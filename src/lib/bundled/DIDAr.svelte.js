function _mergeNamespaces(o, n) {
  for (var a = 0; a < n.length; a++) {
    const u = n[a];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const c in u)
        if (c !== "default" && !(c in o)) {
          const m = Object.getOwnPropertyDescriptor(u, c);
          m && Object.defineProperty(o, c, m.get ? m : { enumerable: !0, get: () => u[c] });
        }
    }
  }
  return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }));
}
function noop$2() {
}
const identity$1 = (o) => o;
function assign(o, n) {
  for (const a in n)
    o[a] = n[a];
  return o;
}
function run(o) {
  return o();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(o) {
  o.forEach(run);
}
function is_function(o) {
  return typeof o == "function";
}
function safe_not_equal(o, n) {
  return o != o ? n == n : o !== n || o && typeof o == "object" || typeof o == "function";
}
function is_empty(o) {
  return Object.keys(o).length === 0;
}
function subscribe(o, ...n) {
  if (o == null)
    return noop$2;
  const a = o.subscribe(...n);
  return a.unsubscribe ? () => a.unsubscribe() : a;
}
function component_subscribe(o, n, a) {
  o.$$.on_destroy.push(subscribe(n, a));
}
function create_slot(o, n, a, u) {
  if (o) {
    const c = get_slot_context(o, n, a, u);
    return o[0](c);
  }
}
function get_slot_context(o, n, a, u) {
  return o[1] && u ? assign(a.ctx.slice(), o[1](u(n))) : a.ctx;
}
function get_slot_changes(o, n, a, u) {
  if (o[2] && u) {
    const c = o[2](u(a));
    if (n.dirty === void 0)
      return c;
    if (typeof c == "object") {
      const m = [], d = Math.max(n.dirty.length, c.length);
      for (let w = 0; w < d; w += 1)
        m[w] = n.dirty[w] | c[w];
      return m;
    }
    return n.dirty | c;
  }
  return n.dirty;
}
function update_slot_base(o, n, a, u, c, m) {
  if (c) {
    const d = get_slot_context(n, a, u, m);
    o.p(d, c);
  }
}
function get_all_dirty_from_scope(o) {
  if (o.ctx.length > 32) {
    const n = [], a = o.ctx.length / 32;
    for (let u = 0; u < a; u++)
      n[u] = -1;
    return n;
  }
  return -1;
}
function null_to_empty(o) {
  return o == null ? "" : o;
}
function set_store_value(o, n, a) {
  return o.set(a), n;
}
const is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (o) => requestAnimationFrame(o) : noop$2;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(o) {
  tasks.forEach((n) => {
    n.c(o) || (tasks.delete(n), n.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop$1(o) {
  let n;
  return tasks.size === 0 && raf(run_tasks), { promise: new Promise((a) => {
    tasks.add(n = { c: o, f: a });
  }), abort() {
    tasks.delete(n);
  } };
}
function append(o, n) {
  o.appendChild(n);
}
function append_styles(o, n, a) {
  const u = get_root_for_style(o);
  if (!u.getElementById(n)) {
    const c = element("style");
    c.id = n, c.textContent = a, append_stylesheet(u, c);
  }
}
function get_root_for_style(o) {
  if (!o)
    return document;
  const n = o.getRootNode ? o.getRootNode() : o.ownerDocument;
  return n && n.host ? n : o.ownerDocument;
}
function append_empty_stylesheet(o) {
  const n = element("style");
  return append_stylesheet(get_root_for_style(o), n), n.sheet;
}
function append_stylesheet(o, n) {
  return append(o.head || o, n), n.sheet;
}
function insert(o, n, a) {
  o.insertBefore(n, a || null);
}
function detach(o) {
  o.parentNode.removeChild(o);
}
function destroy_each(o, n) {
  for (let a = 0; a < o.length; a += 1)
    o[a] && o[a].d(n);
}
function element(o) {
  return document.createElement(o);
}
function text(o) {
  return document.createTextNode(o);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(o, n, a, u) {
  return o.addEventListener(n, a, u), () => o.removeEventListener(n, a, u);
}
function stop_propagation(o) {
  return function(n) {
    return n.stopPropagation(), o.call(this, n);
  };
}
function attr(o, n, a) {
  a == null ? o.removeAttribute(n) : o.getAttribute(n) !== a && o.setAttribute(n, a);
}
function children(o) {
  return Array.from(o.childNodes);
}
function set_data(o, n) {
  n = "" + n, o.wholeText !== n && (o.data = n);
}
function set_style(o, n, a, u) {
  a === null ? o.style.removeProperty(n) : o.style.setProperty(n, a, u ? "important" : "");
}
function toggle_class(o, n, a) {
  o.classList[a ? "add" : "remove"](n);
}
function custom_event(o, n, { bubbles: a = !1, cancelable: u = !1 } = {}) {
  const c = document.createEvent("CustomEvent");
  return c.initCustomEvent(o, a, u, n), c;
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0, current_component;
function hash$3(o) {
  let n = 5381, a = o.length;
  for (; a--; )
    n = (n << 5) - n ^ o.charCodeAt(a);
  return n >>> 0;
}
function create_style_information(o, n) {
  const a = { stylesheet: append_empty_stylesheet(n), rules: {} };
  return managed_styles.set(o, a), a;
}
function create_rule(o, n, a, u, c, m, d, w = 0) {
  const S = 16.666 / u;
  let T = `{
`;
  for (let z = 0; z <= 1; z += S) {
    const W = n + (a - n) * m(z);
    T += 100 * z + `%{${d(W, 1 - W)}}
`;
  }
  const B = T + `100% {${d(a, 1 - a)}}
}`, I = `__svelte_${hash$3(B)}_${w}`, C = get_root_for_style(o), { stylesheet: N, rules: q } = managed_styles.get(C) || create_style_information(C, o);
  q[I] || (q[I] = !0, N.insertRule(`@keyframes ${I} ${B}`, N.cssRules.length));
  const D = o.style.animation || "";
  return o.style.animation = `${D ? `${D}, ` : ""}${I} ${u}ms linear ${c}ms 1 both`, active += 1, I;
}
function delete_rule(o, n) {
  const a = (o.style.animation || "").split(", "), u = a.filter(n ? (m) => m.indexOf(n) < 0 : (m) => m.indexOf("__svelte") === -1), c = a.length - u.length;
  c && (o.style.animation = u.join(", "), active -= c, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((o) => {
      const { ownerNode: n } = o.stylesheet;
      n && detach(n);
    }), managed_styles.clear());
  });
}
function set_current_component(o) {
  current_component = o;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(o) {
  get_current_component().$$.on_mount.push(o);
}
function createEventDispatcher() {
  const o = get_current_component();
  return (n, a, { cancelable: u = !1 } = {}) => {
    const c = o.$$.callbacks[n];
    if (c) {
      const m = custom_event(n, a, { cancelable: u });
      return c.slice().forEach((d) => {
        d.call(o, m);
      }), !m.defaultPrevented;
    }
    return !0;
  };
}
function setContext(o, n) {
  return get_current_component().$$.context.set(o, n), n;
}
function getContext(o) {
  return get_current_component().$$.context.get(o);
}
const dirty_components = [], binding_callbacks = [], render_callbacks = [], flush_callbacks = [], resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(o) {
  render_callbacks.push(o);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0, promise$1;
function flush() {
  const o = current_component;
  do {
    for (; flushidx < dirty_components.length; ) {
      const n = dirty_components[flushidx];
      flushidx++, set_current_component(n), update$1(n.$$);
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let n = 0; n < render_callbacks.length; n += 1) {
      const a = render_callbacks[n];
      seen_callbacks.has(a) || (seen_callbacks.add(a), a());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(o);
}
function update$1(o) {
  if (o.fragment !== null) {
    o.update(), run_all(o.before_update);
    const n = o.dirty;
    o.dirty = [-1], o.fragment && o.fragment.p(o.ctx, n), o.after_update.forEach(add_render_callback);
  }
}
function wait() {
  return promise$1 || (promise$1 = Promise.resolve(), promise$1.then(() => {
    promise$1 = null;
  })), promise$1;
}
function dispatch(o, n, a) {
  o.dispatchEvent(custom_event(`${n ? "intro" : "outro"}${a}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = { r: 0, c: [], p: outros };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(o, n) {
  o && o.i && (outroing.delete(o), o.i(n));
}
function transition_out(o, n, a, u) {
  if (o && o.o) {
    if (outroing.has(o))
      return;
    outroing.add(o), outros.c.push(() => {
      outroing.delete(o), u && (a && o.d(1), u());
    }), o.o(n);
  } else
    u && u();
}
const null_transition = { duration: 0 };
function create_out_transition(o, n, a) {
  let u, c = n(o, a), m = !0;
  const d = outros;
  function w() {
    const { delay: S = 0, duration: T = 300, easing: B = identity$1, tick: I = noop$2, css: C } = c || null_transition;
    C && (u = create_rule(o, 1, 0, T, S, B, C));
    const N = now() + S, q = N + T;
    add_render_callback(() => dispatch(o, !1, "start")), loop$1((D) => {
      if (m) {
        if (D >= q)
          return I(0, 1), dispatch(o, !1, "end"), --d.r || run_all(d.c), !1;
        if (D >= N) {
          const z = B((D - N) / T);
          I(1 - z, z);
        }
      }
      return m;
    });
  }
  return d.r += 1, is_function(c) ? wait().then(() => {
    c = c(), w();
  }) : w(), { end(S) {
    S && c.tick && c.tick(1, 0), m && (u && delete_rule(o, u), m = !1);
  } };
}
function create_bidirectional_transition(o, n, a, u) {
  let c = n(o, a), m = u ? 0 : 1, d = null, w = null, S = null;
  function T() {
    S && delete_rule(o, S);
  }
  function B(C, N) {
    const q = C.b - m;
    return N *= Math.abs(q), { a: m, b: C.b, d: q, duration: N, start: C.start, end: C.start + N, group: C.group };
  }
  function I(C) {
    const { delay: N = 0, duration: q = 300, easing: D = identity$1, tick: z = noop$2, css: W } = c || null_transition, V = { start: now() + N, b: C };
    C || (V.group = outros, outros.r += 1), d || w ? w = V : (W && (T(), S = create_rule(o, m, C, q, N, D, W)), C && z(0, 1), d = B(V, q), add_render_callback(() => dispatch(o, C, "start")), loop$1((ee) => {
      if (w && ee > w.start && (d = B(w, q), w = null, dispatch(o, d.b, "start"), W && (T(), S = create_rule(o, m, d.b, d.duration, 0, D, c.css))), d) {
        if (ee >= d.end)
          z(m = d.b, 1 - m), dispatch(o, d.b, "end"), w || (d.b ? T() : --d.group.r || run_all(d.group.c)), d = null;
        else if (ee >= d.start) {
          const P = ee - d.start;
          m = d.a + d.d * D(P / d.duration), z(m, 1 - m);
        }
      }
      return !(!d && !w);
    }));
  }
  return { run(C) {
    is_function(c) ? wait().then(() => {
      c = c(), I(C);
    }) : I(C);
  }, end() {
    T(), d = w = null;
  } };
}
function get_spread_update(o, n) {
  const a = {}, u = {}, c = { $$scope: 1 };
  let m = o.length;
  for (; m--; ) {
    const d = o[m], w = n[m];
    if (w) {
      for (const S in d)
        S in w || (u[S] = 1);
      for (const S in w)
        c[S] || (a[S] = w[S], c[S] = 1);
      o[m] = w;
    } else
      for (const S in d)
        c[S] = 1;
  }
  for (const d in u)
    d in a || (a[d] = void 0);
  return a;
}
function get_spread_object(o) {
  return typeof o == "object" && o !== null ? o : {};
}
function create_component(o) {
  o && o.c();
}
function mount_component(o, n, a, u) {
  const { fragment: c, on_mount: m, on_destroy: d, after_update: w } = o.$$;
  c && c.m(n, a), u || add_render_callback(() => {
    const S = m.map(run).filter(is_function);
    d ? d.push(...S) : run_all(S), o.$$.on_mount = [];
  }), w.forEach(add_render_callback);
}
function destroy_component(o, n) {
  const a = o.$$;
  a.fragment !== null && (run_all(a.on_destroy), a.fragment && a.fragment.d(n), a.on_destroy = a.fragment = null, a.ctx = []);
}
function make_dirty(o, n) {
  o.$$.dirty[0] === -1 && (dirty_components.push(o), schedule_update(), o.$$.dirty.fill(0)), o.$$.dirty[n / 31 | 0] |= 1 << n % 31;
}
function init$2(o, n, a, u, c, m, d, w = [-1]) {
  const S = current_component;
  set_current_component(o);
  const T = o.$$ = { fragment: null, ctx: null, props: m, update: noop$2, not_equal: c, bound: blank_object(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(n.context || (S ? S.$$.context : [])), callbacks: blank_object(), dirty: w, skip_bound: !1, root: n.target || S.$$.root };
  d && d(T.root);
  let B = !1;
  if (T.ctx = a ? a(o, n.props || {}, (I, C, ...N) => {
    const q = N.length ? N[0] : C;
    return T.ctx && c(T.ctx[I], T.ctx[I] = q) && (!T.skip_bound && T.bound[I] && T.bound[I](q), B && make_dirty(o, I)), C;
  }) : [], T.update(), B = !0, run_all(T.before_update), T.fragment = !!u && u(T.ctx), n.target) {
    if (n.hydrate) {
      const I = children(n.target);
      T.fragment && T.fragment.l(I), I.forEach(detach);
    } else
      T.fragment && T.fragment.c();
    n.intro && transition_in(o.$$.fragment), mount_component(o, n.target, n.anchor, n.customElement), flush();
  }
  set_current_component(S);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$2;
  }
  $on(n, a) {
    const u = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);
    return u.push(a), () => {
      const c = u.indexOf(a);
      c !== -1 && u.splice(c, 1);
    };
  }
  $set(n) {
    this.$$set && !is_empty(n) && (this.$$.skip_bound = !0, this.$$set(n), this.$$.skip_bound = !1);
  }
}
function _catch(o, n) {
  try {
    var a = o();
  } catch (u) {
    return n(u);
  }
  return a && a.then ? a.then(void 0, n) : a;
}
function inMemoryCache() {
  const o = /* @__PURE__ */ new Map();
  return function(n, a) {
    try {
      let c = function(d) {
        if (u)
          return d;
        const w = o.get(n.didUrl);
        return w !== void 0 ? w : Promise.resolve(a()).then(function(S) {
          var T;
          return ((T = S.didResolutionMetadata) == null ? void 0 : T.error) !== "notFound" && o.set(n.didUrl, S), S;
        });
      }, u;
      const m = function() {
        if (n.params && n.params["no-cache"] === "true")
          return Promise.resolve(a()).then(function(d) {
            return u = 1, d;
          });
      }();
      return Promise.resolve(m && m.then ? m.then(c) : c(m));
    } catch (u) {
      return Promise.reject(u);
    }
  };
}
function noCache(o, n) {
  return n();
}
const PCT_ENCODED = "(?:%[0-9a-fA-F]{2})", ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`, METHOD = "([a-z0-9]+)", METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`, PARAM_CHAR = "[a-zA-Z0-9_.:%-]", PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`, PARAMS = `((${PARAM})*)`, PATH = "(/[^#?]*)?", QUERY = "([?][^#]*)?", FRAGMENT = "(#.*)?", DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
function parse$1(o) {
  if (o === "" || !o)
    return null;
  const n = o.match(DID_MATCHER);
  if (n) {
    const a = { did: `did:${n[1]}:${n[2]}`, method: n[1], id: n[2], didUrl: o };
    if (n[4]) {
      const u = n[4].slice(1).split(";");
      a.params = {};
      for (const c of u) {
        const m = c.split("=");
        a.params[m[0]] = m[1];
      }
    }
    return n[6] && (a.path = n[6]), n[7] && (a.query = n[7].slice(1)), n[8] && (a.fragment = n[8].slice(1)), a;
  }
  return null;
}
const EMPTY_RESULT = { didResolutionMetadata: {}, didDocument: null, didDocumentMetadata: {} };
function wrapLegacyResolver(o) {
  return function(n, a, u) {
    try {
      return Promise.resolve(_catch(function() {
        return Promise.resolve(o(n, a, u)).then(function(c) {
          return { ...EMPTY_RESULT, didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: c };
        });
      }, function(c) {
        return { ...EMPTY_RESULT, didResolutionMetadata: { error: "notFound", message: c.toString() } };
      }));
    } catch (c) {
      return Promise.reject(c);
    }
  };
}
class Resolver {
  constructor(n = {}, a = {}) {
    this.registry = void 0, this.cache = void 0, this.registry = n, this.cache = a.cache === !0 ? inMemoryCache() : a.cache || noCache, a.legacyResolvers && Object.keys(a.legacyResolvers).map((u) => {
      this.registry[u] || (this.registry[u] = wrapLegacyResolver(a.legacyResolvers[u]));
    });
  }
  resolve(n, a = {}) {
    try {
      const u = this, c = parse$1(n);
      if (c === null)
        return Promise.resolve({ ...EMPTY_RESULT, didResolutionMetadata: { error: "invalidDid" } });
      const m = u.registry[c.method];
      return m ? Promise.resolve(u.cache(c, () => m(c.did, c, u, a))) : Promise.resolve({ ...EMPTY_RESULT, didResolutionMetadata: { error: "unsupportedDidMethod" } });
    } catch (u) {
      return Promise.reject(u);
    }
  }
}
const subscriber_queue = [];
function readable(o, n) {
  return { subscribe: writable(o, n).subscribe };
}
function writable(o, n = noop$2) {
  let a;
  const u = /* @__PURE__ */ new Set();
  function c(m) {
    if (safe_not_equal(o, m) && (o = m, a)) {
      const d = !subscriber_queue.length;
      for (const w of u)
        w[1](), subscriber_queue.push(w, o);
      if (d) {
        for (let w = 0; w < subscriber_queue.length; w += 2)
          subscriber_queue[w][0](subscriber_queue[w + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  return { set: c, update: function(m) {
    c(m(o));
  }, subscribe: function(m, d = noop$2) {
    const w = [m, d];
    return u.add(w), u.size === 1 && (a = n(c) || noop$2), m(o), () => {
      u.delete(w), u.size === 0 && (a(), a = null);
    };
  } };
}
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (o, n, a) => n in o ? __defProp(o, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : o[n] = a, __spreadValues = (o, n) => {
  for (var a in n || (n = {}))
    __hasOwnProp.call(n, a) && __defNormalProp(o, a, n[a]);
  if (__getOwnPropSymbols)
    for (var a of __getOwnPropSymbols(n))
      __propIsEnum.call(n, a) && __defNormalProp(o, a, n[a]);
  return o;
};
const STATE = {};
function useState(o, n) {
  const a = getContext(STATE), u = typeof o == "function" ? o(a) : o, c = __spreadValues(__spreadValues({}, a), u);
  return n != null && n.expandable && (c.isParentExpanded = c.expanded), setContext(STATE, c), a;
}
function add_css$8(o) {
  append_styles(o, "svelte-1qd6nto", ".container.svelte-1qd6nto{display:inline-block;transform:translate(calc(0px - var(--li-identation)), -50%);position:absolute;top:50%;padding-right:100%}.arrow.svelte-1qd6nto{transform-origin:25% 50%;position:relative;line-height:1.1em;font-size:0.75em;margin-left:0;transition:150ms;color:var(--arrow-color);user-select:none;font-family:'Courier New', Courier, monospace;display:block}.expanded.svelte-1qd6nto{transform:rotateZ(90deg) translateX(-3px)}");
}
function create_if_block$8(o) {
  let n, a, u, c;
  return { c() {
    n = element("span"), a = element("span"), a.textContent = "\u25B6", attr(a, "class", "arrow svelte-1qd6nto"), toggle_class(a, "expanded", o[2]), attr(n, "class", "container svelte-1qd6nto");
  }, m(m, d) {
    insert(m, n, d), append(n, a), u || (c = listen(n, "click", o[4]), u = !0);
  }, p(m, d) {
    4 & d && toggle_class(a, "expanded", m[2]);
  }, d(m) {
    m && detach(n), u = !1, c();
  } };
}
function create_fragment$i(o) {
  let n, a = o[1] && create_if_block$8(o);
  return { c() {
    a && a.c(), n = empty();
  }, m(u, c) {
    a && a.m(u, c), insert(u, n, c);
  }, p(u, [c]) {
    u[1] ? a ? a.p(u, c) : (a = create_if_block$8(u), a.c(), a.m(n.parentNode, n)) : a && (a.d(1), a = null);
  }, i: noop$2, o: noop$2, d(u) {
    a && a.d(u), u && detach(n);
  } };
}
function instance$i(o, n, a) {
  let u, c, m = noop$2, d = () => (m(), m = subscribe(T, (B) => a(2, c = B)), T);
  o.$$.on_destroy.push(() => m());
  const { expanded: w, expandable: S } = useState();
  component_subscribe(o, S, (B) => a(1, u = B));
  let { expanded: T = w } = n;
  return d(), o.$$set = (B) => {
    "expanded" in B && d(a(0, T = B.expanded));
  }, [T, u, c, S, (B) => {
    B.stopPropagation(), set_store_value(T, c = !c, c);
  }];
}
class JSONArrow extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$i, create_fragment$i, safe_not_equal, { expanded: 0 }, add_css$8);
  }
}
function create_fragment$h(o) {
  let n;
  const a = o[1].default, u = create_slot(a, o, o[0], null);
  return { c() {
    u && u.c();
  }, m(c, m) {
    u && u.m(c, m), n = !0;
  }, p(c, [m]) {
    u && u.p && (!n || 1 & m) && update_slot_base(u, a, c, c[0], n ? get_slot_changes(a, c[0], m, null) : get_all_dirty_from_scope(c[0]), null);
  }, i(c) {
    n || (transition_in(u, c), n = !0);
  }, o(c) {
    transition_out(u, c), n = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function instance$h(o, n, a) {
  let { $$slots: u = {}, $$scope: c } = n;
  return useState({ displayMode: "summary" }), o.$$set = (m) => {
    "$$scope" in m && a(0, c = m.$$scope);
  }, [c, u];
}
class Summary extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$h, create_fragment$h, safe_not_equal, {});
  }
}
function create_fragment$g(o) {
  let n;
  const a = o[3].default, u = create_slot(a, o, o[2], null);
  return { c() {
    u && u.c();
  }, m(c, m) {
    u && u.m(c, m), n = !0;
  }, p(c, [m]) {
    u && u.p && (!n || 4 & m) && update_slot_base(u, a, c, c[2], n ? get_slot_changes(a, c[2], m, null) : get_all_dirty_from_scope(c[2]), null);
  }, i(c) {
    n || (transition_in(u, c), n = !0);
  }, o(c) {
    transition_out(u, c), n = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function instance$g(o, n, a) {
  let { $$slots: u = {}, $$scope: c } = n, { expanded: m } = n, { key: d } = n;
  const w = writable(!1);
  return useState(({ keyPath: S, level: T }) => (d !== "[[Entries]]" && (S = [...S, d], T += 1), { keyPath: S, level: T, expanded: m, expandable: w })), o.$$set = (S) => {
    "expanded" in S && a(0, m = S.expanded), "key" in S && a(1, d = S.key), "$$scope" in S && a(2, c = S.$$scope);
  }, [m, d, c, u];
}
class Expandable extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$g, create_fragment$g, safe_not_equal, { expanded: 0, key: 1 });
  }
}
function add_css$7(o) {
  append_styles(o, "svelte-19drypg", ".root.svelte-19drypg{display:inline-block;position:relative}.indent.svelte-19drypg{padding-left:var(--li-identation)}.label.svelte-19drypg{position:relative}");
}
function get_each_context$2(o, n, a) {
  const u = o.slice();
  return u[19] = n[a], u[21] = a, u;
}
const get_item_value_slot_changes = (o) => ({ key: 1 & o }), get_item_value_slot_context = (o) => ({ key: o[19], index: o[21] }), get_item_key_slot_changes = (o) => ({ key: 1 & o }), get_item_key_slot_context = (o) => ({ key: o[19], index: o[21] }), get_preview_slot_changes = (o) => ({}), get_preview_slot_context = (o) => ({}), get_summary_slot_changes = (o) => ({}), get_summary_slot_context = (o) => ({});
function create_else_block$6(o) {
  let n, a, u, c, m, d, w, S, T = o[6] && create_if_block_3$2(o);
  u = new Summary({ props: { $$slots: { default: [create_default_slot_1] }, $$scope: { ctx: o } } });
  let B = o[4] && create_if_block_1$2$1(o);
  return { c() {
    n = element("span"), T && T.c(), a = space(), create_component(u.$$.fragment), c = space(), B && B.c(), m = empty(), attr(n, "class", "root svelte-19drypg");
  }, m(I, C) {
    insert(I, n, C), T && T.m(n, null), append(n, a), mount_component(u, n, null), insert(I, c, C), B && B.m(I, C), insert(I, m, C), d = !0, w || (S = listen(n, "click", o[9]), w = !0);
  }, p(I, C) {
    I[6] && T.p(I, C);
    const N = {};
    8192 & C && (N.$$scope = { dirty: C, ctx: I }), u.$set(N), I[4] ? B ? (B.p(I, C), 16 & C && transition_in(B, 1)) : (B = create_if_block_1$2$1(I), B.c(), transition_in(B, 1), B.m(m.parentNode, m)) : B && (group_outros(), transition_out(B, 1, 1, () => {
      B = null;
    }), check_outros());
  }, i(I) {
    d || (transition_in(T), transition_in(u.$$.fragment, I), transition_in(B), d = !0);
  }, o(I) {
    transition_out(T), transition_out(u.$$.fragment, I), transition_out(B), d = !1;
  }, d(I) {
    I && detach(n), T && T.d(), destroy_component(u), I && detach(c), B && B.d(I), I && detach(m), w = !1, S();
  } };
}
function create_if_block$7(o) {
  let n;
  const a = o[11].summary, u = create_slot(a, o, o[13], get_summary_slot_context);
  return { c() {
    u && u.c();
  }, m(c, m) {
    u && u.m(c, m), n = !0;
  }, p(c, m) {
    u && u.p && (!n || 8192 & m) && update_slot_base(u, a, c, c[13], n ? get_slot_changes(a, c[13], m, get_summary_slot_changes) : get_all_dirty_from_scope(c[13]), get_summary_slot_context);
  }, i(c) {
    n || (transition_in(u, c), n = !0);
  }, o(c) {
    transition_out(u, c), n = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block_3$2(o) {
  let n, a;
  return n = new JSONArrow({ props: { expanded: o[7] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p: noop$2, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_default_slot_1(o) {
  let n;
  const a = o[11].preview, u = create_slot(a, o, o[13], get_preview_slot_context);
  return { c() {
    u && u.c();
  }, m(c, m) {
    u && u.m(c, m), n = !0;
  }, p(c, m) {
    u && u.p && (!n || 8192 & m) && update_slot_base(u, a, c, c[13], n ? get_slot_changes(a, c[13], m, get_preview_slot_changes) : get_all_dirty_from_scope(c[13]), get_preview_slot_context);
  }, i(c) {
    n || (transition_in(u, c), n = !0);
  }, o(c) {
    transition_out(u, c), n = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block_1$2$1(o) {
  let n, a, u, c, m = o[0], d = [];
  for (let S = 0; S < m.length; S += 1)
    d[S] = create_each_block$2(get_each_context$2(o, m, S));
  const w = (S) => transition_out(d[S], 1, 1, () => {
    d[S] = null;
  });
  return { c() {
    n = element("ul");
    for (let S = 0; S < d.length; S += 1)
      d[S].c();
  }, m(S, T) {
    insert(S, n, T);
    for (let B = 0; B < d.length; B += 1)
      d[B].m(n, null);
    a = !0, u || (c = listen(n, "click", stop_propagation(o[9])), u = !0);
  }, p(S, T) {
    if (8223 & T) {
      let B;
      for (m = S[0], B = 0; B < m.length; B += 1) {
        const I = get_each_context$2(S, m, B);
        d[B] ? (d[B].p(I, T), transition_in(d[B], 1)) : (d[B] = create_each_block$2(I), d[B].c(), transition_in(d[B], 1), d[B].m(n, null));
      }
      for (group_outros(), B = m.length; B < d.length; B += 1)
        w(B);
      check_outros();
    }
  }, i(S) {
    if (!a) {
      for (let T = 0; T < m.length; T += 1)
        transition_in(d[T]);
      a = !0;
    }
  }, o(S) {
    d = d.filter(Boolean);
    for (let T = 0; T < d.length; T += 1)
      transition_out(d[T]);
    a = !1;
  }, d(S) {
    S && detach(n), destroy_each(d, S), u = !1, c();
  } };
}
function create_if_block_2$2(o) {
  let n;
  return { c() {
    n = element("span"), n.textContent = ":", attr(n, "class", "operator");
  }, m(a, u) {
    insert(a, n, u);
  }, d(a) {
    a && detach(n);
  } };
}
function create_default_slot$1$1(o) {
  let n, a, u, c, m, d, w = !o[1] || o[1](o[19]);
  a = new JSONArrow({});
  const S = o[11].item_key, T = create_slot(S, o, o[13], get_item_key_slot_context);
  let B = w && create_if_block_2$2();
  function I() {
    return o[12](o[21]);
  }
  const C = o[11].item_value, N = create_slot(C, o, o[13], get_item_value_slot_context);
  return { c() {
    n = element("span"), create_component(a.$$.fragment), T && T.c(), B && B.c(), u = space(), N && N.c(), attr(n, "class", "label svelte-19drypg");
  }, m(q, D) {
    insert(q, n, D), mount_component(a, n, null), T && T.m(n, null), B && B.m(n, null), append(n, u), N && N.m(q, D), c = !0, m || (d = listen(n, "click", I), m = !0);
  }, p(q, D) {
    o = q, T && T.p && (!c || 8193 & D) && update_slot_base(T, S, o, o[13], c ? get_slot_changes(S, o[13], D, get_item_key_slot_changes) : get_all_dirty_from_scope(o[13]), get_item_key_slot_context), 3 & D && (w = !o[1] || o[1](o[19])), w ? B || (B = create_if_block_2$2(), B.c(), B.m(n, u)) : B && (B.d(1), B = null), N && N.p && (!c || 8193 & D) && update_slot_base(N, C, o, o[13], c ? get_slot_changes(C, o[13], D, get_item_value_slot_changes) : get_all_dirty_from_scope(o[13]), get_item_value_slot_context);
  }, i(q) {
    c || (transition_in(a.$$.fragment, q), transition_in(T, q), transition_in(N, q), c = !0);
  }, o(q) {
    transition_out(a.$$.fragment, q), transition_out(T, q), transition_out(N, q), c = !1;
  }, d(q) {
    q && detach(n), destroy_component(a), T && T.d(q), B && B.d(), N && N.d(q), m = !1, d();
  } };
}
function create_each_block$2(o) {
  let n, a, u, c, m, d;
  return a = new Expandable({ props: { key: o[2](o[19]), expanded: o[3][o[21]], $$slots: { default: [create_default_slot$1$1] }, $$scope: { ctx: o } } }), { c() {
    n = element("li"), create_component(a.$$.fragment), u = space(), attr(n, "class", "svelte-19drypg"), toggle_class(n, "indent", o[4]);
  }, m(w, S) {
    insert(w, n, S), mount_component(a, n, null), append(n, u), c = !0, m || (d = listen(n, "click", stop_propagation(click_handler_1)), m = !0);
  }, p(w, S) {
    const T = {};
    5 & S && (T.key = w[2](w[19])), 8 & S && (T.expanded = w[3][w[21]]), 8203 & S && (T.$$scope = { dirty: S, ctx: w }), a.$set(T), 16 & S && toggle_class(n, "indent", w[4]);
  }, i(w) {
    c || (transition_in(a.$$.fragment, w), c = !0);
  }, o(w) {
    transition_out(a.$$.fragment, w), c = !1;
  }, d(w) {
    w && detach(n), destroy_component(a), m = !1, d();
  } };
}
function create_fragment$f(o) {
  let n, a, u, c;
  const m = [create_if_block$7, create_else_block$6], d = [];
  return n = o[5] === "summary" ? 0 : 1, a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(w, S) {
    d[n].m(w, S), insert(w, u, S), c = !0;
  }, p(w, [S]) {
    a.p(w, S);
  }, i(w) {
    c || (transition_in(a), c = !0);
  }, o(w) {
    transition_out(a), c = !1;
  }, d(w) {
    d[n].d(w), w && detach(u);
  } };
}
const click_handler_1 = () => {
};
function instance$f(o, n, a) {
  let u, c, m, { $$slots: d = {}, $$scope: w } = n, { keys: S } = n, { shouldShowColon: T } = n, { expandKey: B = (P) => P } = n, { defaultExpanded: I = !1 } = n;
  const { isParentExpanded: C, displayMode: N, root: q, expanded: D, expandable: z, keyPath: W, level: V, shouldExpandNode: ee } = useState({ root: !1 }, { expandable: !0 });
  if (component_subscribe(o, D, (P) => a(4, c = P)), component_subscribe(o, z, (P) => a(14, m = P)), set_store_value(z, m = !0, m), N !== "summary") {
    if (!I) {
      const P = ee({ keyPath: W, level: V });
      P !== void 0 && (I = P);
    }
    onMount(() => C.subscribe((P) => {
      P ? D.set(I) : D.set(!1);
    }));
  }
  return o.$$set = (P) => {
    "keys" in P && a(0, S = P.keys), "shouldShowColon" in P && a(1, T = P.shouldShowColon), "expandKey" in P && a(2, B = P.expandKey), "defaultExpanded" in P && a(10, I = P.defaultExpanded), "$$scope" in P && a(13, w = P.$$scope);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(3, u = S.map(() => writable(!1)));
  }, [S, T, B, u, c, N, q, D, z, function() {
    set_store_value(D, c = !c, c);
  }, I, d, (P) => u[P].update((F) => !F), w];
}
class JSONNested extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$f, create_fragment$f, safe_not_equal, { keys: 0, shouldShowColon: 1, expandKey: 2, defaultExpanded: 10 }, add_css$7);
  }
}
function add_css$6(o) {
  append_styles(o, "svelte-150ffaa", ".comma.svelte-150ffaa{margin-left:-0.5em;margin-right:0.5em}");
}
function get_each_context$1(o, n, a) {
  const u = o.slice();
  return u[7] = n[a], u[9] = a, u;
}
const get_item_slot_changes = (o) => ({ item: 1 & o }), get_item_slot_context = (o) => ({ item: o[7], index: o[9] });
function create_if_block_3$1(o) {
  let n, a, u = o[2] && create_if_block_4(o);
  return { c() {
    u && u.c(), n = element("span"), a = text(o[3]), attr(n, "class", "operator");
  }, m(c, m) {
    u && u.m(c, m), insert(c, n, m), append(n, a);
  }, p(c, m) {
    c[2] ? u ? u.p(c, m) : (u = create_if_block_4(c), u.c(), u.m(n.parentNode, n)) : u && (u.d(1), u = null), 8 & m && set_data(a, c[3]);
  }, d(c) {
    u && u.d(c), c && detach(n);
  } };
}
function create_if_block_4(o) {
  let n, a;
  return { c() {
    n = element("span"), a = text(o[2]), attr(n, "class", "label");
  }, m(u, c) {
    insert(u, n, c), append(n, a);
  }, p(u, c) {
    4 & c && set_data(a, u[2]);
  }, d(u) {
    u && detach(n);
  } };
}
function create_if_block_2$1$1(o) {
  let n;
  return { c() {
    n = element("span"), n.textContent = ",", attr(n, "class", "comma operator svelte-150ffaa");
  }, m(a, u) {
    insert(a, n, u);
  }, d(a) {
    a && detach(n);
  } };
}
function create_each_block$1(o) {
  let n, a, u;
  const c = o[6].item, m = create_slot(c, o, o[5], get_item_slot_context);
  let d = o[9] < o[0].length - 1 && create_if_block_2$1$1();
  return { c() {
    m && m.c(), n = space(), d && d.c(), a = empty();
  }, m(w, S) {
    m && m.m(w, S), insert(w, n, S), d && d.m(w, S), insert(w, a, S), u = !0;
  }, p(w, S) {
    m && m.p && (!u || 33 & S) && update_slot_base(m, c, w, w[5], u ? get_slot_changes(c, w[5], S, get_item_slot_changes) : get_all_dirty_from_scope(w[5]), get_item_slot_context), w[9] < w[0].length - 1 ? d || (d = create_if_block_2$1$1(), d.c(), d.m(a.parentNode, a)) : d && (d.d(1), d = null);
  }, i(w) {
    u || (transition_in(m, w), u = !0);
  }, o(w) {
    transition_out(m, w), u = !1;
  }, d(w) {
    m && m.d(w), w && detach(n), d && d.d(w), w && detach(a);
  } };
}
function create_if_block_1$1$1(o) {
  let n, a, u;
  return { c() {
    n = element("span"), n.textContent = ",", a = space(), u = element("span"), u.textContent = "\u2026", attr(n, "class", "comma operator svelte-150ffaa"), attr(u, "class", "operator");
  }, m(c, m) {
    insert(c, n, m), insert(c, a, m), insert(c, u, m);
  }, d(c) {
    c && detach(n), c && detach(a), c && detach(u);
  } };
}
function create_if_block$6(o) {
  let n, a;
  return { c() {
    n = element("span"), a = text(o[4]), attr(n, "class", "operator");
  }, m(u, c) {
    insert(u, n, c), append(n, a);
  }, p(u, c) {
    16 & c && set_data(a, u[4]);
  }, d(u) {
    u && detach(n);
  } };
}
function create_fragment$e(o) {
  let n, a, u, c, m, d = o[3] && create_if_block_3$1(o), w = o[0], S = [];
  for (let C = 0; C < w.length; C += 1)
    S[C] = create_each_block$1(get_each_context$1(o, w, C));
  const T = (C) => transition_out(S[C], 1, 1, () => {
    S[C] = null;
  });
  let B = o[1] && create_if_block_1$1$1(), I = o[4] && create_if_block$6(o);
  return { c() {
    d && d.c(), n = space();
    for (let C = 0; C < S.length; C += 1)
      S[C].c();
    a = space(), B && B.c(), u = space(), I && I.c(), c = empty();
  }, m(C, N) {
    d && d.m(C, N), insert(C, n, N);
    for (let q = 0; q < S.length; q += 1)
      S[q].m(C, N);
    insert(C, a, N), B && B.m(C, N), insert(C, u, N), I && I.m(C, N), insert(C, c, N), m = !0;
  }, p(C, [N]) {
    if (C[3] ? d ? d.p(C, N) : (d = create_if_block_3$1(C), d.c(), d.m(n.parentNode, n)) : d && (d.d(1), d = null), 33 & N) {
      let q;
      for (w = C[0], q = 0; q < w.length; q += 1) {
        const D = get_each_context$1(C, w, q);
        S[q] ? (S[q].p(D, N), transition_in(S[q], 1)) : (S[q] = create_each_block$1(D), S[q].c(), transition_in(S[q], 1), S[q].m(a.parentNode, a));
      }
      for (group_outros(), q = w.length; q < S.length; q += 1)
        T(q);
      check_outros();
    }
    C[1] ? B || (B = create_if_block_1$1$1(), B.c(), B.m(u.parentNode, u)) : B && (B.d(1), B = null), C[4] ? I ? I.p(C, N) : (I = create_if_block$6(C), I.c(), I.m(c.parentNode, c)) : I && (I.d(1), I = null);
  }, i(C) {
    if (!m) {
      for (let N = 0; N < w.length; N += 1)
        transition_in(S[N]);
      m = !0;
    }
  }, o(C) {
    S = S.filter(Boolean);
    for (let N = 0; N < S.length; N += 1)
      transition_out(S[N]);
    m = !1;
  }, d(C) {
    d && d.d(C), C && detach(n), destroy_each(S, C), C && detach(a), B && B.d(C), C && detach(u), I && I.d(C), C && detach(c);
  } };
}
function instance$e(o, n, a) {
  let { $$slots: u = {}, $$scope: c } = n, { list: m } = n, { hasMore: d } = n, { label: w } = n, { prefix: S } = n, { postfix: T } = n;
  return o.$$set = (B) => {
    "list" in B && a(0, m = B.list), "hasMore" in B && a(1, d = B.hasMore), "label" in B && a(2, w = B.label), "prefix" in B && a(3, S = B.prefix), "postfix" in B && a(4, T = B.postfix), "$$scope" in B && a(5, c = B.$$scope);
  }, [m, d, w, S, T, c, u];
}
class PreviewList extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$e, create_fragment$e, safe_not_equal, { list: 0, hasMore: 1, label: 2, prefix: 3, postfix: 4 }, add_css$6);
  }
}
function create_summary_slot$8(o) {
  let n;
  return { c() {
    n = element("span"), n.textContent = "{\u2026}", attr(n, "class", "label");
  }, m(a, u) {
    insert(a, n, u);
  }, p: noop$2, d(a) {
    a && detach(n);
  } };
}
function create_item_slot$5(o) {
  let n, a, u, c, m, d = o[4] + "";
  return c = new JSONNode({ props: { value: o[0][o[4]] } }), { c() {
    n = element("span"), a = text(d), u = element("span"), u.textContent = ": ", create_component(c.$$.fragment), attr(n, "class", "property"), attr(u, "class", "operator");
  }, m(w, S) {
    insert(w, n, S), append(n, a), insert(w, u, S), mount_component(c, w, S), m = !0;
  }, p(w, S) {
    (!m || 16 & S) && d !== (d = w[4] + "") && set_data(a, d);
    const T = {};
    17 & S && (T.value = w[0][w[4]]), c.$set(T);
  }, i(w) {
    m || (transition_in(c.$$.fragment, w), m = !0);
  }, o(w) {
    transition_out(c.$$.fragment, w), m = !1;
  }, d(w) {
    w && detach(n), w && detach(u), destroy_component(c, w);
  } };
}
function create_preview_slot$8(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[2], hasMore: o[2].length < o[1].length, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$5, ({ item: u }) => ({ 4: u }), ({ item: u }) => u ? 16 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    4 & c && (m.list = u[2]), 6 & c && (m.hasMore = u[2].length < u[1].length), 49 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot$8(o) {
  let n, a, u = o[3] + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    8 & m && u !== (u = c[3] + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_item_value_slot$8(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[3]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    9 & c && (m.value = u[0][u[3]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$d(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[1], $$slots: { item_value: [create_item_value_slot$8, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot$8, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot$8], summary: [create_summary_slot$8] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    2 & c && (m.keys = u[1]), 47 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function instance$d(o, n, a) {
  let u, c, { value: m } = n;
  return o.$$set = (d) => {
    "value" in d && a(0, m = d.value);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(1, u = Object.getOwnPropertyNames(m)), 2 & o.$$.dirty && a(2, c = u.slice(0, 5));
  }, [m, u, c];
}
class JSONObjectNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$d, create_fragment$d, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$7(o) {
  let n, a, u, c, m = o[0].length + "";
  return { c() {
    n = element("span"), a = text("Array("), u = text(m), c = text(")"), attr(n, "class", "label");
  }, m(d, w) {
    insert(d, n, w), append(n, a), append(n, u), append(n, c);
  }, p(d, w) {
    1 & w && m !== (m = d[0].length + "") && set_data(u, m);
  }, d(d) {
    d && detach(n);
  } };
}
function create_item_slot$4(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[4] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    16 & c && (m.value = u[4]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_preview_slot$7(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[1], hasMore: o[1].length < o[0].length, label: "(" + o[0].length + ") ", prefix: "[", postfix: "]", $$slots: { item: [create_item_slot$4, ({ item: u }) => ({ 4: u }), ({ item: u }) => u ? 16 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    2 & c && (m.list = u[1]), 3 & c && (m.hasMore = u[1].length < u[0].length), 1 & c && (m.label = "(" + u[0].length + ") "), 48 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot$7(o) {
  let n, a, u = String(o[3]) + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    8 & m && u !== (u = String(c[3]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_item_value_slot$7(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[3]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    9 & c && (m.value = u[0][u[3]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$c(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[2], $$slots: { item_value: [create_item_value_slot$7, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot$7, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot$7], summary: [create_summary_slot$7] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    4 & c && (m.keys = u[2]), 43 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function instance$c(o, n, a) {
  let u, c, { value: m } = n;
  return o.$$set = (d) => {
    "value" in d && a(0, m = d.value);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(2, u = Object.getOwnPropertyNames(m)), 1 & o.$$.dirty && a(1, c = m.slice(0, 5));
  }, [m, c, u];
}
class JSONArrayNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$c, create_fragment$c, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$6(o) {
  let n, a, u, c, m, d = o[3].length + "";
  return { c() {
    n = element("span"), a = text(o[1]), u = text("("), c = text(d), m = text(")"), attr(n, "class", "label");
  }, m(w, S) {
    insert(w, n, S), append(n, a), append(n, u), append(n, c), append(n, m);
  }, p(w, S) {
    2 & S && set_data(a, w[1]), 8 & S && d !== (d = w[3].length + "") && set_data(c, d);
  }, d(w) {
    w && detach(n);
  } };
}
function create_item_slot$3(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[8] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    256 & c && (m.value = u[8]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_preview_slot$6(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[4], hasMore: o[4].length < o[2].length, label: `${o[1]}(${o[3].length}) `, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$3, ({ item: u }) => ({ 8: u }), ({ item: u }) => u ? 256 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    16 & c && (m.list = u[4]), 20 & c && (m.hasMore = u[4].length < u[2].length), 10 & c && (m.label = `${u[1]}(${u[3].length}) `), 768 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot_1$1(o) {
  let n, a, u, c = o[6] + "";
  return { c() {
    n = element("span"), a = text(c), attr(n, "class", u = o[6] === ENTRIES$1 ? "internal" : "property");
  }, m(m, d) {
    insert(m, n, d), append(n, a);
  }, p(m, d) {
    64 & d && c !== (c = m[6] + "") && set_data(a, c), 64 & d && u !== (u = m[6] === ENTRIES$1 ? "internal" : "property") && attr(n, "class", u);
  }, d(m) {
    m && detach(n);
  } };
}
function create_else_block$5(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[6]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    65 & c && (m.value = u[0][u[6]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block$5(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[3], defaultExpanded: !0, $$slots: { item_value: [create_item_value_slot_1$1, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot$6, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    8 & c && (m.keys = u[3]), 644 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot$6(o) {
  let n, a, u = o[7] + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    128 & m && u !== (u = c[7] + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_item_value_slot_1$1(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[2][o[7]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    132 & c && (m.value = u[2][u[7]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_value_slot$6(o) {
  let n, a, u, c;
  const m = [create_if_block$5, create_else_block$5], d = [];
  function w(S, T) {
    return S[6] === ENTRIES$1 ? 0 : 1;
  }
  return n = w(o), a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(S, T) {
    d[n].m(S, T), insert(S, u, T), c = !0;
  }, p(S, T) {
    let B = n;
    n = w(S), n === B ? d[n].p(S, T) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[n], a ? a.p(S, T) : (a = d[n] = m[n](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[n].d(S), S && detach(u);
  } };
}
function create_fragment$b(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: [ENTRIES$1, "size"], shouldShowColon: o[5], $$slots: { item_value: [create_item_value_slot$6, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], item_key: [create_item_key_slot_1$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], preview: [create_preview_slot$6], summary: [create_summary_slot$6] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    607 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
const ENTRIES$1 = "[[Entries]]";
function instance$b(o, n, a) {
  let u, { value: c } = n, { nodeType: m } = n, d = [], w = [];
  return o.$$set = (S) => {
    "value" in S && a(0, c = S.value), "nodeType" in S && a(1, m = S.nodeType);
  }, o.$$.update = () => {
    if (1 & o.$$.dirty) {
      let S = [], T = [], B = 0;
      for (const I of c)
        S.push(B++), T.push(I);
      a(3, d = S), a(2, w = T);
    }
    4 & o.$$.dirty && a(4, u = w.slice(0, 5));
  }, [c, m, w, d, u, (S) => S !== ENTRIES$1];
}
class JSONIterableArrayNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$b, create_fragment$b, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function create_summary_slot$5(o) {
  let n, a, u, c, m = o[2].length + "";
  return { c() {
    n = element("span"), a = text("Map("), u = text(m), c = text(")"), attr(n, "color", "label");
  }, m(d, w) {
    insert(d, n, w), append(n, a), append(n, u), append(n, c);
  }, p(d, w) {
    4 & w && m !== (m = d[2].length + "") && set_data(u, m);
  }, d(d) {
    d && detach(n);
  } };
}
function create_item_slot$2(o) {
  let n, a, u, c;
  return n = new JSONNode({ props: { value: o[10] } }), u = new JSONNode({ props: { value: o[0].get(o[10]) } }), { c() {
    create_component(n.$$.fragment), a = element("span"), a.textContent = " => ", create_component(u.$$.fragment), attr(a, "class", "operator");
  }, m(m, d) {
    mount_component(n, m, d), insert(m, a, d), mount_component(u, m, d), c = !0;
  }, p(m, d) {
    const w = {};
    1024 & d && (w.value = m[10]), n.$set(w);
    const S = {};
    1025 & d && (S.value = m[0].get(m[10])), u.$set(S);
  }, i(m) {
    c || (transition_in(n.$$.fragment, m), transition_in(u.$$.fragment, m), c = !0);
  }, o(m) {
    transition_out(n.$$.fragment, m), transition_out(u.$$.fragment, m), c = !1;
  }, d(m) {
    destroy_component(n, m), m && detach(a), destroy_component(u, m);
  } };
}
function create_preview_slot_1(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[4], hasMore: o[4].length < o[0].size, label: `Map(${o[2].length}) `, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$2, ({ item: u }) => ({ 10: u }), ({ item: u }) => u ? 1024 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    16 & c && (m.list = u[4]), 17 & c && (m.hasMore = u[4].length < u[0].size), 4 & c && (m.label = `Map(${u[2].length}) `), 3073 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot_2(o) {
  let n, a, u, c = o[7] + "";
  return { c() {
    n = element("span"), a = text(c), attr(n, "class", u = o[7] === ENTRIES ? "internal" : "property");
  }, m(m, d) {
    insert(m, n, d), append(n, a);
  }, p(m, d) {
    128 & d && c !== (c = m[7] + "") && set_data(a, c), 128 & d && u !== (u = m[7] === ENTRIES ? "internal" : "property") && attr(n, "class", u);
  }, d(m) {
    m && detach(n);
  } };
}
function create_else_block$4(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[7]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    129 & c && (m.value = u[0][u[7]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block$4(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[1], expandKey: o[5], defaultExpanded: !0, $$slots: { item_value: [create_item_value_slot_1, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], item_key: [create_item_key_slot_1, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    2 & c && (m.keys = u[1]), 4 & c && (m.expandKey = u[5]), 2316 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot_1(o) {
  let n, a, u = o[8] + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    256 & m && u !== (u = c[8] + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_preview_slot$5(o) {
  let n, a, u, c, m, d;
  return a = new JSONNode({ props: { value: o[2][o[8]] } }), c = new JSONNode({ props: { value: o[3][o[8]] } }), { c() {
    n = element("span"), n.textContent = "{ ", create_component(a.$$.fragment), u = element("span"), u.textContent = " => ", create_component(c.$$.fragment), m = element("span"), m.textContent = " }", attr(n, "class", "operator"), attr(u, "class", "operator"), attr(m, "class", "operator");
  }, m(w, S) {
    insert(w, n, S), mount_component(a, w, S), insert(w, u, S), mount_component(c, w, S), insert(w, m, S), d = !0;
  }, p(w, S) {
    const T = {};
    260 & S && (T.value = w[2][w[8]]), a.$set(T);
    const B = {};
    264 & S && (B.value = w[3][w[8]]), c.$set(B);
  }, i(w) {
    d || (transition_in(a.$$.fragment, w), transition_in(c.$$.fragment, w), d = !0);
  }, o(w) {
    transition_out(a.$$.fragment, w), transition_out(c.$$.fragment, w), d = !1;
  }, d(w) {
    w && detach(n), destroy_component(a, w), w && detach(u), destroy_component(c, w), w && detach(m);
  } };
}
function create_item_key_slot$5(o) {
  let n, a, u = o[9] + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    512 & m && u !== (u = c[9] + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_item_value_slot_2(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[9] === "key" ? o[2][o[8]] : o[3][o[8]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    780 & c && (m.value = u[9] === "key" ? u[2][u[8]] : u[3][u[8]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_value_slot_1(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: ["key", "value"], $$slots: { item_value: [create_item_value_slot_2, ({ key: u }) => ({ 9: u }), ({ key: u }) => u ? 512 : 0], item_key: [create_item_key_slot$5, ({ key: u }) => ({ 9: u }), ({ key: u }) => u ? 512 : 0], preview: [create_preview_slot$5] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    2828 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_value_slot$5(o) {
  let n, a, u, c;
  const m = [create_if_block$4, create_else_block$4], d = [];
  function w(S, T) {
    return S[7] === ENTRIES ? 0 : 1;
  }
  return n = w(o), a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(S, T) {
    d[n].m(S, T), insert(S, u, T), c = !0;
  }, p(S, T) {
    let B = n;
    n = w(S), n === B ? d[n].p(S, T) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[n], a ? a.p(S, T) : (a = d[n] = m[n](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[n].d(S), S && detach(u);
  } };
}
function create_fragment$a(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: [ENTRIES, "size"], shouldShowColon: o[6], $$slots: { item_value: [create_item_value_slot$5, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot_2, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], preview: [create_preview_slot_1], summary: [create_summary_slot$5] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    2207 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
const ENTRIES = "[[Entries]]";
function instance$a(o, n, a) {
  let u, { value: c } = n;
  useState();
  let m = [], d = [], w = [];
  return o.$$set = (S) => {
    "value" in S && a(0, c = S.value);
  }, o.$$.update = () => {
    if (1 & o.$$.dirty) {
      let S = [], T = [], B = [], I = 0;
      for (const C of c)
        S.push(I++), T.push(C[0]), B.push(C[1]);
      a(1, m = S), a(2, d = T), a(3, w = B);
    }
    1 & o.$$.dirty && a(4, u = Array.from(c.keys()).slice(0, 5));
  }, [c, m, d, w, u, (S) => d[S], (S) => S !== ENTRIES];
}
class JSONIterableMapNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$a, create_fragment$a, safe_not_equal, { value: 0 });
  }
}
function add_css$5(o) {
  append_styles(o, "svelte-l95iub", ".Date.svelte-l95iub{color:var(--date-color)}.BigInt.svelte-l95iub{color:var(--number-color)}.Number.svelte-l95iub{color:var(--number-color)}.Boolean.svelte-l95iub{color:var(--boolean-color)}.Null.svelte-l95iub{color:var(--null-color)}.Undefined.svelte-l95iub{color:var(--undefined-color)}.Symbol.svelte-l95iub{color:var(--symbol-color)}");
}
function create_fragment$9(o) {
  let n, a, u;
  return { c() {
    n = element("span"), a = text(o[0]), attr(n, "class", u = null_to_empty(o[1]) + " svelte-l95iub");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, [m]) {
    1 & m && set_data(a, c[0]), 2 & m && u !== (u = null_to_empty(c[1]) + " svelte-l95iub") && attr(n, "class", u);
  }, i: noop$2, o: noop$2, d(c) {
    c && detach(n);
  } };
}
function instance$9(o, n, a) {
  let { value: u, nodeType: c } = n;
  return o.$$set = (m) => {
    "value" in m && a(0, u = m.value), "nodeType" in m && a(1, c = m.nodeType);
  }, [u, c];
}
class JSONValueNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$9, create_fragment$9, safe_not_equal, { value: 0, nodeType: 1 }, add_css$5);
  }
}
function add_css$4(o) {
  append_styles(o, "svelte-1u08yw6", ".indent.svelte-1u08yw6{padding-left:var(--li-identation)}");
}
function get_each_context$3(o, n, a) {
  const u = o.slice();
  u[6] = n[a], u[9] = a;
  const c = u[9] < u[0].length - 1;
  return u[7] = c, u;
}
function create_else_block$3(o) {
  let n, a, u;
  return a = new JSONNode({ props: { value: o[0][0] + "\u2026" } }), { c() {
    n = element("span"), create_component(a.$$.fragment);
  }, m(c, m) {
    insert(c, n, m), mount_component(a, n, null), u = !0;
  }, p(c, m) {
    const d = {};
    1 & m && (d.value = c[0][0] + "\u2026"), a.$set(d);
  }, i(c) {
    u || (transition_in(a.$$.fragment, c), u = !0);
  }, o(c) {
    transition_out(a.$$.fragment, c), u = !1;
  }, d(c) {
    c && detach(n), destroy_component(a);
  } };
}
function create_if_block$3$1(o) {
  let n, a, u = o[0], c = [];
  for (let d = 0; d < u.length; d += 1)
    c[d] = create_each_block$3(get_each_context$3(o, u, d));
  const m = (d) => transition_out(c[d], 1, 1, () => {
    c[d] = null;
  });
  return { c() {
    for (let d = 0; d < c.length; d += 1)
      c[d].c();
    n = empty();
  }, m(d, w) {
    for (let S = 0; S < c.length; S += 1)
      c[S].m(d, w);
    insert(d, n, w), a = !0;
  }, p(d, w) {
    if (1 & w) {
      let S;
      for (u = d[0], S = 0; S < u.length; S += 1) {
        const T = get_each_context$3(d, u, S);
        c[S] ? (c[S].p(T, w), transition_in(c[S], 1)) : (c[S] = create_each_block$3(T), c[S].c(), transition_in(c[S], 1), c[S].m(n.parentNode, n));
      }
      for (group_outros(), S = u.length; S < c.length; S += 1)
        m(S);
      check_outros();
    }
  }, i(d) {
    if (!a) {
      for (let w = 0; w < u.length; w += 1)
        transition_in(c[w]);
      a = !0;
    }
  }, o(d) {
    c = c.filter(Boolean);
    for (let w = 0; w < c.length; w += 1)
      transition_out(c[w]);
    a = !1;
  }, d(d) {
    destroy_each(c, d), d && detach(n);
  } };
}
function create_each_block$3(o) {
  let n, a, u, c, m, d, w = o[7] ? " +" : "";
  return a = new JSONNode({ props: { value: o[6] + (o[7] ? "\\n" : "") } }), { c() {
    n = element("span"), create_component(a.$$.fragment), u = element("span"), c = text(w), m = element("br"), attr(u, "class", "operator"), attr(n, "class", "svelte-1u08yw6"), toggle_class(n, "indent", o[9] > 0);
  }, m(S, T) {
    insert(S, n, T), mount_component(a, n, null), append(n, u), append(u, c), insert(S, m, T), d = !0;
  }, p(S, T) {
    const B = {};
    1 & T && (B.value = S[6] + (S[7] ? "\\n" : "")), a.$set(B), (!d || 1 & T) && w !== (w = S[7] ? " +" : "") && set_data(c, w);
  }, i(S) {
    d || (transition_in(a.$$.fragment, S), d = !0);
  }, o(S) {
    transition_out(a.$$.fragment, S), d = !1;
  }, d(S) {
    S && detach(n), destroy_component(a), S && detach(m);
  } };
}
function create_fragment$8(o) {
  let n, a, u, c, m, d;
  const w = [create_if_block$3$1, create_else_block$3], S = [];
  function T(B, I) {
    return B[1] ? 0 : 1;
  }
  return a = T(o), u = S[a] = w[a](o), { c() {
    n = element("span"), u.c();
  }, m(B, I) {
    insert(B, n, I), S[a].m(n, null), c = !0, m || (d = listen(n, "click", o[4]), m = !0);
  }, p(B, [I]) {
    let C = a;
    a = T(B), a === C ? S[a].p(B, I) : (group_outros(), transition_out(S[C], 1, 1, () => {
      S[C] = null;
    }), check_outros(), u = S[a], u ? u.p(B, I) : (u = S[a] = w[a](B), u.c()), transition_in(u, 1), u.m(n, null));
  }, i(B) {
    c || (transition_in(u), c = !0);
  }, o(B) {
    transition_out(u), c = !1;
  }, d(B) {
    B && detach(n), S[a].d(), m = !1, d();
  } };
}
function instance$8(o, n, a) {
  let u, c, { stack: m } = n;
  const { expanded: d, expandable: w } = useState();
  return component_subscribe(o, d, (S) => a(1, c = S)), component_subscribe(o, w, (S) => a(5, u = S)), set_store_value(w, u = !0, u), o.$$set = (S) => {
    "stack" in S && a(0, m = S.stack);
  }, [m, c, d, w, () => set_store_value(d, c = !c, c)];
}
class ErrorStack extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$8, create_fragment$8, safe_not_equal, { stack: 0 }, add_css$4);
  }
}
function create_summary_slot$4(o) {
  let n, a, u, c = String(o[0].message) + "";
  return { c() {
    n = element("span"), a = text("Error: "), u = text(c), attr(n, "class", "label");
  }, m(m, d) {
    insert(m, n, d), append(n, a), append(n, u);
  }, p(m, d) {
    1 & d && c !== (c = String(m[0].message) + "") && set_data(u, c);
  }, d(m) {
    m && detach(n);
  } };
}
function create_preview_slot$4(o) {
  let n, a, u, c = String(o[0].message) + "";
  return { c() {
    n = element("span"), a = text("Error: "), u = text(c), attr(n, "class", "label");
  }, m(m, d) {
    insert(m, n, d), append(n, a), append(n, u);
  }, p(m, d) {
    1 & d && c !== (c = String(m[0].message) + "") && set_data(u, c);
  }, d(m) {
    m && detach(n);
  } };
}
function create_item_key_slot$4(o) {
  let n, a, u = o[2] + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "property");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    4 & m && u !== (u = c[2] + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_else_block$2(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[2]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    5 & c && (m.value = u[0][u[2]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block$2$1(o) {
  let n, a;
  return n = new ErrorStack({ props: { stack: o[1] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    2 & c && (m.stack = u[1]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_value_slot$4(o) {
  let n, a, u, c;
  const m = [create_if_block$2$1, create_else_block$2], d = [];
  function w(S, T) {
    return S[2] === "stack" ? 0 : 1;
  }
  return n = w(o), a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(S, T) {
    d[n].m(S, T), insert(S, u, T), c = !0;
  }, p(S, T) {
    let B = n;
    n = w(S), n === B ? d[n].p(S, T) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[n], a ? a.p(S, T) : (a = d[n] = m[n](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[n].d(S), S && detach(u);
  } };
}
function create_fragment$7(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: ["message", "stack"], $$slots: { item_value: [create_item_value_slot$4, ({ key: u }) => ({ 2: u }), ({ key: u }) => u ? 4 : 0], item_key: [create_item_key_slot$4, ({ key: u }) => ({ 2: u }), ({ key: u }) => u ? 4 : 0], preview: [create_preview_slot$4], summary: [create_summary_slot$4] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    15 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function instance$7(o, n, a) {
  let u, { value: c } = n;
  return o.$$set = (m) => {
    "value" in m && a(0, c = m.value);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(1, u = c.stack.split(`
`));
  }, [c, u];
}
class ErrorNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$7, create_fragment$7, safe_not_equal, { value: 0 });
  }
}
function objType(o) {
  const n = Object.prototype.toString.call(o).slice(8, -1);
  return n === "Object" ? typeof o[Symbol.iterator] == "function" ? "Iterable" : o.constructor.name : n;
}
function add_css$3(o) {
  append_styles(o, "svelte-1fvwa9c", "span.svelte-1fvwa9c{color:var(--string-color);word-break:break-all;word-wrap:break-word}");
}
function create_else_block$1$1(o) {
  let n, a, u, c;
  return { c() {
    n = element("span"), a = text('"'), u = text(o[0]), c = text('"'), attr(n, "class", "svelte-1fvwa9c");
  }, m(m, d) {
    insert(m, n, d), append(n, a), append(n, u), append(n, c);
  }, p(m, d) {
    1 & d && set_data(u, m[0]);
  }, d(m) {
    m && detach(n);
  } };
}
function create_if_block$1$1(o) {
  let n, a, u, c, m = o[0].slice(0, 30) + (o[0].length > 30 ? "\u2026" : "");
  return { c() {
    n = element("span"), a = text('"'), u = text(m), c = text('"'), attr(n, "class", "svelte-1fvwa9c");
  }, m(d, w) {
    insert(d, n, w), append(n, a), append(n, u), append(n, c);
  }, p(d, w) {
    1 & w && m !== (m = d[0].slice(0, 30) + (d[0].length > 30 ? "\u2026" : "")) && set_data(u, m);
  }, d(d) {
    d && detach(n);
  } };
}
function create_fragment$6(o) {
  let n, a = (o[1] === "summary" ? create_if_block$1$1 : create_else_block$1$1)(o);
  return { c() {
    a.c(), n = empty();
  }, m(u, c) {
    a.m(u, c), insert(u, n, c);
  }, p(u, [c]) {
    a.p(u, c);
  }, i: noop$2, o: noop$2, d(u) {
    a.d(u), u && detach(n);
  } };
}
function instance$6(o, n, a) {
  let u, { value: c } = n;
  const m = { "\n": "\\n", "	": "\\t", "\r": "\\r" }, { displayMode: d } = useState();
  return o.$$set = (w) => {
    "value" in w && a(2, c = w.value);
  }, o.$$.update = () => {
    4 & o.$$.dirty && a(0, u = c.replace(/[\n\t\r]/g, (w) => m[w]));
  }, [u, d, c];
}
class JSONStringNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$6, create_fragment$6, safe_not_equal, { value: 2 }, add_css$3);
  }
}
function add_css$2(o) {
  append_styles(o, "svelte-1eamqdt", ".i.svelte-1eamqdt{font-style:italic}.fn.svelte-1eamqdt,.i.svelte-1eamqdt{color:var(--function-color)}");
}
function create_summary_slot$3(o) {
  let n;
  return { c() {
    n = element("span"), n.textContent = "\u0192", attr(n, "class", "i svelte-1eamqdt");
  }, m(a, u) {
    insert(a, n, u);
  }, d(a) {
    a && detach(n);
  } };
}
function create_if_block_3$3(o) {
  let n, a, u = getPreview1(o[2]) + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "fn i svelte-1eamqdt");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    4 & m && u !== (u = getPreview1(c[2]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_if_block_2$3(o) {
  let n, a, u = getPreview2(o[2]) + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "i svelte-1eamqdt");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    4 & m && u !== (u = getPreview2(c[2]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_preview_slot$3(o) {
  let n, a, u = !o[2].isArrow && create_if_block_3$3(o), c = !o[2].isClass && create_if_block_2$3(o);
  return { c() {
    u && u.c(), n = empty(), c && c.c(), a = empty();
  }, m(m, d) {
    u && u.m(m, d), insert(m, n, d), c && c.m(m, d), insert(m, a, d);
  }, p(m, d) {
    m[2].isArrow ? u && (u.d(1), u = null) : u ? u.p(m, d) : (u = create_if_block_3$3(m), u.c(), u.m(n.parentNode, n)), m[2].isClass ? c && (c.d(1), c = null) : c ? c.p(m, d) : (c = create_if_block_2$3(m), c.c(), c.m(a.parentNode, a));
  }, d(m) {
    u && u.d(m), m && detach(n), c && c.d(m), m && detach(a);
  } };
}
function create_item_key_slot$3(o) {
  let n, a, u, c = o[7] + "";
  return { c() {
    n = element("span"), a = text(c), attr(n, "class", u = o[7] === FUNCTION || o[7] === PROTO ? "internal" : "property");
  }, m(m, d) {
    insert(m, n, d), append(n, a);
  }, p(m, d) {
    128 & d && c !== (c = m[7] + "") && set_data(a, c), 128 & d && u !== (u = m[7] === FUNCTION || m[7] === PROTO ? "internal" : "property") && attr(n, "class", u);
  }, d(m) {
    m && detach(n);
  } };
}
function create_else_block$7(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[3](o[7]) } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    128 & c && (m.value = u[3](u[7])), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block_1$3(o) {
  let n, a;
  return n = new JSONObjectNode({ props: { value: o[3](o[7]) } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    128 & c && (m.value = u[3](u[7])), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block$9(o) {
  let n, a;
  return { c() {
    n = element("span"), a = text(o[0]), attr(n, "class", "i svelte-1eamqdt");
  }, m(u, c) {
    insert(u, n, c), append(n, a);
  }, p(u, c) {
    1 & c && set_data(a, u[0]);
  }, i: noop$2, o: noop$2, d(u) {
    u && detach(n);
  } };
}
function create_item_value_slot$3(o) {
  let n, a, u, c;
  const m = [create_if_block$9, create_if_block_1$3, create_else_block$7], d = [];
  function w(S, T) {
    return S[7] === FUNCTION ? 0 : S[7] === "prototype" ? 1 : 2;
  }
  return n = w(o), a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(S, T) {
    d[n].m(S, T), insert(S, u, T), c = !0;
  }, p(S, T) {
    let B = n;
    n = w(S), n === B ? d[n].p(S, T) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[n], a ? a.p(S, T) : (a = d[n] = m[n](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[n].d(S), S && detach(u);
  } };
}
function create_fragment$5(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[1], $$slots: { item_value: [create_item_value_slot$3, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot$3, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], preview: [create_preview_slot$3], summary: [create_summary_slot$3] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    2 & c && (m.keys = u[1]), 389 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
const FUNCTION = "[[Function]]", PROTO = "[[Prototype]]";
function getPreview1({ isGenerator: o, isAsync: n, isClass: a }) {
  return a ? `class ${a}` : (n ? "async " : "") + "\u0192" + (o ? "*" : "");
}
function getPreview2({ isAsync: o, isArrow: n, fnName: a, args: u }) {
  return (n && o ? "async" : "") + " " + (a != null ? a : "") + u + (n ? " => \u2026" : "");
}
function toString$2(o) {
  try {
    return o.toString();
  } catch {
    switch (o.constructor.name) {
      case "AsyncFunction":
        return "async function () {}";
      case "AsyncGeneratorFunction":
        return "async function * () {}";
      case "GeneratorFunction:":
        return "function * () {}";
      default:
        return "function () {}";
    }
  }
}
function instance$5(o, n, a) {
  let u, c, m, { value: d } = n;
  function w(S) {
    return S === PROTO ? d.__proto__ : d[S];
  }
  return o.$$set = (S) => {
    "value" in S && a(4, d = S.value);
  }, o.$$.update = () => {
    16 & o.$$.dirty && a(0, u = toString$2(d)), 1 & o.$$.dirty && a(2, c = function(S) {
      const T = S.match(/^(?:(async)\s+)?(?:function)?(\*)?\s*([^(]+)?(\([^)]*\))\s*(=>)?/), B = T == null ? void 0 : T[1], I = T == null ? void 0 : T[2], C = T == null ? void 0 : T[3], N = T == null ? void 0 : T[4], q = T == null ? void 0 : T[5], D = S.match(/^class\s+([^\s]+)/);
      return { args: N, isAsync: B, isGenerator: I, fnName: C, isArrow: q, isClass: D == null ? void 0 : D[1] };
    }(u));
  }, a(1, m = ["length", "name", "prototype", FUNCTION, PROTO].filter(function(S) {
    return S === FUNCTION || w(S);
  })), [u, m, c, w, d];
}
class JSONFunctionNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$5, create_fragment$5, safe_not_equal, { value: 4 }, add_css$2);
  }
}
function create_summary_slot$2(o) {
  let n, a, u, c, m, d = o[3] ? "writable(" : "readable(";
  return u = new JSONNode({ props: { value: o[2] } }), { c() {
    n = element("span"), a = text(d), create_component(u.$$.fragment), c = text(")"), attr(n, "class", "label");
  }, m(w, S) {
    insert(w, n, S), append(n, a), mount_component(u, n, null), append(n, c), m = !0;
  }, p(w, S) {
    (!m || 8 & S) && d !== (d = w[3] ? "writable(" : "readable(") && set_data(a, d);
    const T = {};
    4 & S && (T.value = w[2]), u.$set(T);
  }, i(w) {
    m || (transition_in(u.$$.fragment, w), m = !0);
  }, o(w) {
    transition_out(u.$$.fragment, w), m = !1;
  }, d(w) {
    w && detach(n), destroy_component(u);
  } };
}
function create_item_slot$1(o) {
  let n, a, u, c, m, d = o[9] + "";
  return c = new JSONNode({ props: { value: o[0][o[9]] } }), { c() {
    n = element("span"), a = text(d), u = element("span"), u.textContent = ": ", create_component(c.$$.fragment), attr(n, "class", "property"), attr(u, "class", "operator");
  }, m(w, S) {
    insert(w, n, S), append(n, a), insert(w, u, S), mount_component(c, w, S), m = !0;
  }, p(w, S) {
    (!m || 512 & S) && d !== (d = w[9] + "") && set_data(a, d);
    const T = {};
    513 & S && (T.value = w[0][w[9]]), c.$set(T);
  }, i(w) {
    m || (transition_in(c.$$.fragment, w), m = !0);
  }, o(w) {
    transition_out(c.$$.fragment, w), m = !1;
  }, d(w) {
    w && detach(n), w && detach(u), destroy_component(c, w);
  } };
}
function create_preview_slot$2(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[4], hasMore: o[4].length < o[1].length, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$1, ({ item: u }) => ({ 9: u }), ({ item: u }) => u ? 512 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    16 & c && (m.list = u[4]), 18 & c && (m.hasMore = u[4].length < u[1].length), 1537 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot$2(o) {
  let n, a, u, c = o[8] + "";
  return { c() {
    n = element("span"), a = text(c), attr(n, "class", u = o[8] === STORE_VALUE ? "internal" : "property");
  }, m(m, d) {
    insert(m, n, d), append(n, a);
  }, p(m, d) {
    256 & d && c !== (c = m[8] + "") && set_data(a, c), 256 & d && u !== (u = m[8] === STORE_VALUE ? "internal" : "property") && attr(n, "class", u);
  }, d(m) {
    m && detach(n);
  } };
}
function create_item_value_slot$2(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[6](o[8]) } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    256 & c && (m.value = u[6](u[8])), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$4$1(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[5], $$slots: { item_value: [create_item_value_slot$2, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], item_key: [create_item_key_slot$2, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], preview: [create_preview_slot$2], summary: [create_summary_slot$2] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    32 & c && (m.keys = u[5]), 1311 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
const STORE_VALUE = "$value";
function instance$4$1(o, n, a) {
  let u, c, m, d, w, S, T = noop$2, B = () => (T(), T = subscribe(I, (C) => a(7, S = C)), I);
  o.$$.on_destroy.push(() => T());
  let { value: I } = n;
  return B(), o.$$set = (C) => {
    "value" in C && B(a(0, I = C.value));
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(1, u = Object.getOwnPropertyNames(I)), 2 & o.$$.dirty && a(5, c = [STORE_VALUE, ...u]), 2 & o.$$.dirty && a(4, m = u.slice(0, 5)), 128 & o.$$.dirty && a(2, d = S), 1 & o.$$.dirty && a(3, w = typeof I.set == "function");
  }, [I, u, d, w, m, c, function(C) {
    return C === STORE_VALUE ? d : I[C];
  }, S];
}
class JSONSvelteStoreNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$4$1, create_fragment$4$1, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$1(o) {
  let n, a, u, c, m, d = o[0].length + "";
  return { c() {
    n = element("span"), a = text(o[1]), u = text("("), c = text(d), m = text(")"), attr(n, "class", "label");
  }, m(w, S) {
    insert(w, n, S), append(n, a), append(n, u), append(n, c), append(n, m);
  }, p(w, S) {
    2 & S && set_data(a, w[1]), 1 & S && d !== (d = w[0].length + "") && set_data(c, d);
  }, d(w) {
    w && detach(n);
  } };
}
function create_item_slot(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[7] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    128 & c && (m.value = u[7]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_preview_slot$1(o) {
  let n, a;
  return n = new PreviewList({ props: { list: o[2], hasMore: o[2].length < o[0].length, label: o[1] + "(" + o[0].length + ") ", prefix: "[", postfix: "]", $$slots: { item: [create_item_slot, ({ item: u }) => ({ 7: u }), ({ item: u }) => u ? 128 : 0] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    4 & c && (m.list = u[2]), 5 & c && (m.hasMore = u[2].length < u[0].length), 3 & c && (m.label = u[1] + "(" + u[0].length + ") "), 384 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_item_key_slot$1(o) {
  let n, a, u, c = String(o[6]) + "";
  return { c() {
    n = element("span"), a = text(c), attr(n, "class", u = o[4].includes(o[6]) ? "internal" : "property");
  }, m(m, d) {
    insert(m, n, d), append(n, a);
  }, p(m, d) {
    64 & d && c !== (c = String(m[6]) + "") && set_data(a, c), 64 & d && u !== (u = m[4].includes(m[6]) ? "internal" : "property") && attr(n, "class", u);
  }, d(m) {
    m && detach(n);
  } };
}
function create_item_value_slot$1(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[5](o[6]) } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    64 & c && (m.value = u[5](u[6])), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$3$1(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[3], $$slots: { item_value: [create_item_value_slot$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], item_key: [create_item_key_slot$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], preview: [create_preview_slot$1], summary: [create_summary_slot$1] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    8 & c && (m.keys = u[3]), 327 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
const TO_STRING_TAG = "Symbol(Symbol.toStringTag)";
function instance$3$1(o, n, a) {
  let u, c, { value: m } = n, { nodeType: d } = n;
  const w = ["buffer", "byteLength", "byteOffset", "length", TO_STRING_TAG];
  return o.$$set = (S) => {
    "value" in S && a(0, m = S.value), "nodeType" in S && a(1, d = S.nodeType);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(3, u = [...Object.getOwnPropertyNames(m), ...w]), 1 & o.$$.dirty && a(2, c = m.slice(0, 5));
  }, [m, d, c, u, w, function(S) {
    return S === TO_STRING_TAG ? m[Symbol.toStringTag] : m[S];
  }];
}
class TypedArrayNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$3$1, create_fragment$3$1, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function add_css$1$1(o) {
  append_styles(o, "svelte-17k1wqt", ".regex.svelte-17k1wqt{color:var(--regex-color)}");
}
function create_summary_slot(o) {
  let n, a;
  return { c() {
    n = element("span"), a = text(o[1]), attr(n, "class", "regex svelte-17k1wqt");
  }, m(u, c) {
    insert(u, n, c), append(n, a);
  }, p(u, c) {
    2 & c && set_data(a, u[1]);
  }, d(u) {
    u && detach(n);
  } };
}
function create_preview_slot(o) {
  let n, a;
  return { c() {
    n = element("span"), a = text(o[1]), attr(n, "class", "regex svelte-17k1wqt");
  }, m(u, c) {
    insert(u, n, c), append(n, a);
  }, p(u, c) {
    2 & c && set_data(a, u[1]);
  }, d(u) {
    u && detach(n);
  } };
}
function create_item_key_slot(o) {
  let n, a, u = String(o[3]) + "";
  return { c() {
    n = element("span"), a = text(u), attr(n, "class", "internal");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    8 & m && u !== (u = String(c[3]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_item_value_slot(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0][o[3]] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    9 & c && (m.value = u[0][u[3]]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$2$1(o) {
  let n, a;
  return n = new JSONNested({ props: { keys: o[2], $$slots: { item_value: [create_item_value_slot, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot], summary: [create_summary_slot] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, [c]) {
    const m = {};
    27 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function instance$2$1(o, n, a) {
  let u, { value: c } = n;
  return o.$$set = (m) => {
    "value" in m && a(0, c = m.value);
  }, o.$$.update = () => {
    1 & o.$$.dirty && a(1, u = c.toString());
  }, [c, u, ["lastIndex", "dotAll", "flags", "global", "hasIndices", "ignoreCase", "multiline", "source", "sticky", "unicode"]];
}
class RegExpNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$2$1, create_fragment$2$1, safe_not_equal, { value: 0 }, add_css$1$1);
  }
}
function create_fragment$1$1(o) {
  let n, a, u;
  const c = [{ value: o[0] }, o[1]];
  var m = o[2];
  function d(w) {
    let S = {};
    for (let T = 0; T < c.length; T += 1)
      S = assign(S, c[T]);
    return { props: S };
  }
  return m && (n = new m(d())), { c() {
    n && create_component(n.$$.fragment), a = empty();
  }, m(w, S) {
    n && mount_component(n, w, S), insert(w, a, S), u = !0;
  }, p(w, [S]) {
    const T = 3 & S ? get_spread_update(c, [1 & S && { value: w[0] }, 2 & S && get_spread_object(w[1])]) : {};
    if (m !== (m = w[2])) {
      if (n) {
        group_outros();
        const B = n;
        transition_out(B.$$.fragment, 1, 0, () => {
          destroy_component(B, 1);
        }), check_outros();
      }
      m ? (n = new m(d()), create_component(n.$$.fragment), transition_in(n.$$.fragment, 1), mount_component(n, a.parentNode, a)) : n = null;
    } else
      m && n.$set(T);
  }, i(w) {
    u || (n && transition_in(n.$$.fragment, w), u = !0);
  }, o(w) {
    n && transition_out(n.$$.fragment, w), u = !1;
  }, d(w) {
    w && detach(a), n && destroy_component(n, w);
  } };
}
function instance$1$1(o, n, a) {
  let u, c, m, { value: d } = n;
  const w = writable();
  return component_subscribe(o, w, (S) => a(4, m = S)), o.$$set = (S) => {
    "value" in S && a(0, d = S.value);
  }, o.$$.update = () => {
    1 & o.$$.dirty && set_store_value(w, m = objType(d), m), 17 & o.$$.dirty && a(2, [u, c] = function(S, T) {
      switch (S) {
        case "Object":
          return typeof T.subscribe == "function" ? [JSONSvelteStoreNode] : [JSONObjectNode];
        case "Error":
          return [ErrorNode];
        case "Array":
          return [JSONArrayNode];
        case "Map":
          return [JSONIterableMapNode];
        case "Iterable":
        case "Set":
          return [JSONIterableArrayNode, { nodeType: S }];
        case "Number":
          return [JSONValueNode, { nodeType: S }];
        case "String":
          return [JSONStringNode];
        case "Boolean":
          return [JSONValueNode, { nodeType: S, value: T ? "true" : "false" }];
        case "Date":
          return [JSONValueNode, { nodeType: S, value: T.toISOString() }];
        case "Null":
          return [JSONValueNode, { nodeType: S, value: "null" }];
        case "Undefined":
          return [JSONValueNode, { nodeType: S, value: "undefined" }];
        case "Function":
        case "AsyncFunction":
        case "AsyncGeneratorFunction":
        case "GeneratorFunction":
          return [JSONFunctionNode];
        case "Symbol":
          return [JSONValueNode, { nodeType: S, value: T.toString() }];
        case "BigInt":
          return [JSONValueNode, { nodeType: S, value: String(T) + "n" }];
        case "ArrayBuffer":
          return [JSONValueNode, { nodeType: S, value: `ArrayBuffer(${T.byteLength})` }];
        case "BigInt64Array":
        case "BigUint64Array":
        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Uint16Array":
        case "Uint32Array":
          return [TypedArrayNode, { nodeType: S }];
        case "RegExp":
          return [RegExpNode];
        default:
          return [JSONValueNode, { nodeType: S, value: `<${S}>` }];
      }
    }(m, d), u, (a(1, c), a(4, m), a(0, d)));
  }, [d, c, u, w, m];
}
class JSONNode extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$1$1, create_fragment$1$1, safe_not_equal, { value: 0 });
  }
}
function getShouldExpandNode({ defaultExpandedPaths: o, defaultExpandedLevel: n }) {
  const a = o.map((u) => u.split("."));
  return function({ keyPath: u, level: c }) {
    return c <= n || function(m) {
      e:
        for (const d of a) {
          if (m.length > d.length)
            continue;
          const w = Math.min(m.length, d.length);
          for (let S = 0; S < w; S++)
            if (d[S] !== "*" && d[S] !== String(m[S]))
              continue e;
          return !0;
        }
      return !1;
    }(u);
  };
}
function add_css$9(o) {
  append_styles(o, "svelte-16cw61f", "ul.svelte-16cw61f{--string-color:var(--json-tree-string-color, #cb3f41);--symbol-color:var(--json-tree-symbol-color, #cb3f41);--boolean-color:var(--json-tree-boolean-color, #112aa7);--function-color:var(--json-tree-function-color, #112aa7);--number-color:var(--json-tree-number-color, #3029cf);--label-color:var(--json-tree-label-color, #871d8f);--property-color:var(--json-tree-property-color, #000000);--arrow-color:var(--json-tree-arrow-color, #727272);--operator-color:var(--json-tree-operator-color, #727272);--null-color:var(--json-tree-null-color, #8d8d8d);--undefined-color:var(--json-tree-undefined-color, #8d8d8d);--date-color:var(--json-tree-date-color, #8d8d8d);--internal-color:var(--json-tree-internal-color, grey);--regex-color:var(--json-tree-regex-color, var(--string-color));--li-identation:var(--json-tree-li-indentation, 1em);--li-line-height:var(--json-tree-li-line-height, 1.3);font-size:var(--json-tree-font-size, 12px);font-family:var(--json-tree-font-family, 'Courier New', Courier, monospace)}ul.svelte-16cw61f li{line-height:var(--li-line-height);display:var(--li-display, list-item);list-style:none}ul.svelte-16cw61f,ul.svelte-16cw61f ul{padding:0;margin:0}ul.svelte-16cw61f{margin-left:var(--li-identation)}ul.svelte-16cw61f{cursor:default}ul.svelte-16cw61f .label{color:var(--label-color)}ul.svelte-16cw61f .property{color:var(--property-color)}ul.svelte-16cw61f .internal{color:var(--internal-color)}ul.svelte-16cw61f .operator{color:var(--operator-color)}");
}
function create_default_slot$3(o) {
  let n, a;
  return n = new JSONNode({ props: { value: o[0] } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    1 & c && (m.value = u[0]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$j(o) {
  let n, a, u;
  return a = new Expandable({ props: { key: "$", expanded: o[1], $$slots: { default: [create_default_slot$3] }, $$scope: { ctx: o } } }), { c() {
    n = element("ul"), create_component(a.$$.fragment), attr(n, "class", "svelte-16cw61f");
  }, m(c, m) {
    insert(c, n, m), mount_component(a, n, null), u = !0;
  }, p(c, [m]) {
    const d = {};
    33 & m && (d.$$scope = { dirty: m, ctx: c }), a.$set(d);
  }, i(c) {
    u || (transition_in(a.$$.fragment, c), u = !0);
  }, o(c) {
    transition_out(a.$$.fragment, c), u = !1;
  }, d(c) {
    c && detach(n), destroy_component(a);
  } };
}
function instance$j(o, n, a) {
  let u, { value: c } = n, { defaultExpandedPaths: m = [] } = n, { defaultExpandedLevel: d = 0 } = n;
  const w = writable(!0);
  return useState({ expanded: w, isParentExpanded: readable(!0), root: !0, shouldExpandNode: (S) => u(S), level: 0, keyPath: [] }), o.$$set = (S) => {
    "value" in S && a(0, c = S.value), "defaultExpandedPaths" in S && a(2, m = S.defaultExpandedPaths), "defaultExpandedLevel" in S && a(3, d = S.defaultExpandedLevel);
  }, o.$$.update = () => {
    12 & o.$$.dirty && (u = getShouldExpandNode({ defaultExpandedPaths: m, defaultExpandedLevel: d }));
  }, [c, w, m, d];
}
class Root extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$j, create_fragment$j, safe_not_equal, { value: 0, defaultExpandedPaths: 2, defaultExpandedLevel: 3 }, add_css$9);
  }
}
function cubicOut(o) {
  const n = o - 1;
  return n * n * n + 1;
}
function quintOut(o) {
  return --o * o * o * o * o + 1;
}
function fade(o, { delay: n = 0, duration: a = 400, easing: u = identity$1 } = {}) {
  const c = +getComputedStyle(o).opacity;
  return { delay: n, duration: a, easing: u, css: (m) => "opacity: " + m * c };
}
function fly(o, { delay: n = 0, duration: a = 400, easing: u = cubicOut, x: c = 0, y: m = 0, opacity: d = 0 } = {}) {
  const w = getComputedStyle(o), S = +w.opacity, T = w.transform === "none" ? "" : w.transform, B = S * (1 - d);
  return { delay: n, duration: a, easing: u, css: (I, C) => `
			transform: ${T} translate(${(1 - I) * c}px, ${(1 - I) * m}px);
			opacity: ${S - B * C}` };
}
function add_css$1(o) {
  append_styles(o, "svelte-12ungvz", ".Clipboard.svelte-12ungvz{margin:0 0.5em;word-break:break-all}.Clipboard-Container.svelte-12ungvz{display:flex}.Clipboard-Container.svelte-12ungvz{cursor:pointer}");
}
const get_default_slot_changes = (o) => ({}), get_default_slot_context = (o) => ({ copy: o[2] });
function create_else_block$1(o) {
  let n;
  return { c() {
    n = element("span"), n.textContent = "\u{1F4CB}", attr(n, "class", "text-xl"), attr(n, "title", "Copy to clipboard");
  }, m(a, u) {
    insert(a, n, u);
  }, p: noop$2, i: noop$2, o: noop$2, d(a) {
    a && detach(n);
  } };
}
function create_if_block$3(o) {
  let n, a, u;
  return { c() {
    n = element("div"), n.textContent = "\u2714\uFE0FCopied";
  }, m(c, m) {
    insert(c, n, m), u = !0;
  }, p(c, m) {
  }, i(c) {
    u || (a && a.end(1), u = !0);
  }, o(c) {
    a = create_out_transition(n, fade, { duration }), u = !1;
  }, d(c) {
    c && detach(n), c && a && a.end();
  } };
}
function create_fragment$4(o) {
  let n, a, u, c, m, d, w, S;
  const T = o[5].default, B = create_slot(T, o, o[4], get_default_slot_context), I = [create_if_block$3, create_else_block$1], C = [];
  function N(q, D) {
    return q[1] ? 0 : 1;
  }
  return c = N(o), m = C[c] = I[c](o), { c() {
    n = element("div"), a = element("div"), B && B.c(), u = space(), m.c(), attr(a, "class", "Clipboard svelte-12ungvz"), attr(n, "class", "Clipboard-Container svelte-12ungvz");
  }, m(q, D) {
    insert(q, n, D), append(n, a), B && B.m(a, null), o[6](a), append(n, u), C[c].m(n, null), d = !0, w || (S = [listen(n, "click", o[2]), listen(n, "keypress", o[2])], w = !0);
  }, p(q, [D]) {
    B && B.p && (!d || 16 & D) && update_slot_base(B, T, q, q[4], d ? get_slot_changes(T, q[4], D, get_default_slot_changes) : get_all_dirty_from_scope(q[4]), get_default_slot_context);
    let z = c;
    c = N(q), c === z ? C[c].p(q, D) : (group_outros(), transition_out(C[z], 1, 1, () => {
      C[z] = null;
    }), check_outros(), m = C[c], m ? m.p(q, D) : (m = C[c] = I[c](q), m.c()), transition_in(m, 1), m.m(n, null));
  }, i(q) {
    d || (transition_in(B, q), transition_in(m), d = !0);
  }, o(q) {
    transition_out(B, q), transition_out(m), d = !1;
  }, d(q) {
    q && detach(n), B && B.d(q), o[6](null), C[c].d(), w = !1, run_all(S);
  } };
}
let duration = 2e3;
function instance$4(o, n, a) {
  let u, c, { $$slots: m = {}, $$scope: d } = n, { value: w = null } = n;
  return o.$$set = (S) => {
    "value" in S && a(3, w = S.value), "$$scope" in S && a(4, d = S.$$scope);
  }, [u, c, async function() {
    var S = navigator.clipboard.writeText(u.innerHTML);
    await S, a(3, w = S), a(1, c = !0), setTimeout(() => a(1, c = !1), 1);
  }, w, d, m, function(S) {
    binding_callbacks[S ? "unshift" : "push"](() => {
      u = S, a(0, u);
    });
  }];
}
class Clipboard extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$4, create_fragment$4, safe_not_equal, { value: 3 }, add_css$1);
  }
}
const get_timestamp_slot_changes = (o) => ({}), get_timestamp_slot_context = (o) => ({});
function create_default_slot$2(o) {
  let n;
  const a = o[4].default, u = create_slot(a, o, o[6], null);
  return { c() {
    u && u.c();
  }, m(c, m) {
    u && u.m(c, m), n = !0;
  }, p(c, m) {
    u && u.p && (!n || 64 & m) && update_slot_base(u, a, c, c[6], n ? get_slot_changes(a, c[6], m, null) : get_all_dirty_from_scope(c[6]), null);
  }, i(c) {
    n || (transition_in(u, c), n = !0);
  }, o(c) {
    transition_out(u, c), n = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block$2(o) {
  let n, a, u, c, m, d, w, S = !o[0].startsWith("did:arlocal"), T = S && create_if_block_2$1(o), B = o[2] && create_if_block_1$2(o);
  return { c() {
    n = element("details"), a = element("summary"), u = text(`Full DID Document\r
				`), T && T.c(), c = space(), B && B.c(), attr(n, "class", "cursor-pointer overflow-hidden");
  }, m(I, C) {
    insert(I, n, C), append(n, a), append(a, u), T && T.m(a, null), append(n, c), B && B.m(n, null), n.open = o[2], m = !0, d || (w = listen(n, "toggle", o[5]), d = !0);
  }, p(I, C) {
    1 & C && (S = !I[0].startsWith("did:arlocal")), S ? T ? T.p(I, C) : (T = create_if_block_2$1(I), T.c(), T.m(a, null)) : T && (T.d(1), T = null), I[2] ? B ? (B.p(I, C), 4 & C && transition_in(B, 1)) : (B = create_if_block_1$2(I), B.c(), transition_in(B, 1), B.m(n, null)) : B && (group_outros(), transition_out(B, 1, 1, () => {
      B = null;
    }), check_outros()), 4 & C && (n.open = I[2]);
  }, i(I) {
    m || (transition_in(B), m = !0);
  }, o(I) {
    transition_out(B), m = !1;
  }, d(I) {
    I && detach(n), T && T.d(), B && B.d(), d = !1, w();
  } };
}
function create_if_block_2$1(o) {
  let n, a, u;
  return { c() {
    n = element("a"), a = text("\u{1F517} View Blockchain Explorer"), attr(n, "class", "text-blue-700"), attr(n, "target", "_blank"), attr(n, "rel", "noopener noreferrer"), attr(n, "href", u = "https://sonar.warp.cc/#/app/contract/" + o[0].replace(/.*?:/g, ""));
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    1 & m && u !== (u = "https://sonar.warp.cc/#/app/contract/" + c[0].replace(/.*?:/g, "")) && attr(n, "href", u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_if_block_1$2(o) {
  let n, a, u, c, m;
  return a = new Root({ props: { value: o[1], defaultExpandedLevel: 1 } }), { c() {
    n = element("div"), u = element("div"), create_component(a.$$.fragment), set_style(u, "display", "contents"), set_style(u, "--json-tree-font-size", ".8em"), set_style(u, "--json-tree-string-color", "#42b983"), set_style(u, "--json-tree-label-color", "#cfcfcf");
  }, m(d, w) {
    insert(d, n, w), append(n, u), mount_component(a, u, null), m = !0;
  }, p(d, w) {
    o = d;
    const S = {};
    2 & w && (S.value = o[1]), a.$set(S);
  }, i(d) {
    m || (transition_in(a.$$.fragment, d), add_render_callback(() => {
      c || (c = create_bidirectional_transition(n, fly, { delay: 0, duration: 300, x: 0, y: -100, opacity: 0.25, easing: quintOut }, !0)), c.run(1);
    }), m = !0);
  }, o(d) {
    transition_out(a.$$.fragment, d), c || (c = create_bidirectional_transition(n, fly, { delay: 0, duration: 300, x: 0, y: -100, opacity: 0.25, easing: quintOut }, !1)), c.run(0), m = !1;
  }, d(d) {
    d && detach(n), destroy_component(a), d && c && c.end();
  } };
}
function create_fragment$3(o) {
  var C, N;
  let n, a, u, c, m, d, w, S;
  c = new Clipboard({ props: { $$slots: { default: [create_default_slot$2] }, $$scope: { ctx: o } } });
  const T = o[4].timestamp, B = create_slot(T, o, o[6], get_timestamp_slot_context);
  let I = o[1] && ((N = (C = o[1]) == null ? void 0 : C.verificationMethod) == null ? void 0 : N.length) && create_if_block$2(o);
  return { c() {
    n = element("div"), a = element("div"), u = element("div"), create_component(c.$$.fragment), m = space(), d = element("div"), B && B.c(), w = space(), I && I.c(), attr(u, "class", "flex-1 pr-4"), attr(d, "class", "flex-0 pr-4"), attr(a, "class", "flex flex-row m-4 p-4 bg-[#42b983] text-white font-normal rounded-lg"), attr(n, "class", "m-4 p-4 border rounded-xl shadow-lg font-semibold");
  }, m(q, D) {
    insert(q, n, D), append(n, a), append(a, u), mount_component(c, u, null), append(a, m), append(a, d), B && B.m(d, null), append(n, w), I && I.m(n, null), S = !0;
  }, p(q, [D]) {
    var W, V;
    const z = {};
    64 & D && (z.$$scope = { dirty: D, ctx: q }), c.$set(z), B && B.p && (!S || 64 & D) && update_slot_base(B, T, q, q[6], S ? get_slot_changes(T, q[6], D, get_timestamp_slot_changes) : get_all_dirty_from_scope(q[6]), get_timestamp_slot_context), q[1] && ((V = (W = q[1]) == null ? void 0 : W.verificationMethod) == null ? void 0 : V.length) ? I ? (I.p(q, D), 2 & D && transition_in(I, 1)) : (I = create_if_block$2(q), I.c(), transition_in(I, 1), I.m(n, null)) : I && (group_outros(), transition_out(I, 1, 1, () => {
      I = null;
    }), check_outros());
  }, i(q) {
    S || (transition_in(c.$$.fragment, q), transition_in(B, q), transition_in(I), S = !0);
  }, o(q) {
    transition_out(c.$$.fragment, q), transition_out(B, q), transition_out(I), S = !1;
  }, d(q) {
    q && detach(n), destroy_component(c), B && B.d(q), I && I.d();
  } };
}
function instance$3(o, n, a) {
  let u, c, { $$slots: m = {}, $$scope: d } = n, { did: w } = n, S = !1;
  async function T() {
    return console.log("resolving ", w), a(1, c = (await u.resolve(w)).didDocument), c || setTimeout(() => {
      T();
    }, 5e3), c;
  }
  return onMount(async () => {
    const { didArResolver: B } = await Promise.resolve().then(() => index$4), I = B.getResolver();
    a(3, u = new Resolver(I));
  }), o.$$set = (B) => {
    "did" in B && a(0, w = B.did), "$$scope" in B && a(6, d = B.$$scope);
  }, o.$$.update = () => {
    9 & o.$$.dirty && u && w && T();
  }, [w, c, S, u, m, function() {
    S = this.open, a(2, S);
  }, d];
}
class ResolveDID extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$3, create_fragment$3, safe_not_equal, { did: 0 });
  }
}
function get_each_context(o, n, a) {
  const u = o.slice();
  return u[5] = n[a], u;
}
function create_if_block$1(o) {
  let n, a, u = o[0], c = [];
  for (let d = 0; d < u.length; d += 1)
    c[d] = create_each_block(get_each_context(o, u, d));
  const m = (d) => transition_out(c[d], 1, 1, () => {
    c[d] = null;
  });
  return { c() {
    for (let d = 0; d < c.length; d += 1)
      c[d].c();
    n = empty();
  }, m(d, w) {
    for (let S = 0; S < c.length; S += 1)
      c[S].m(d, w);
    insert(d, n, w), a = !0;
  }, p(d, w) {
    if (3 & w) {
      let S;
      for (u = d[0], S = 0; S < u.length; S += 1) {
        const T = get_each_context(d, u, S);
        c[S] ? (c[S].p(T, w), transition_in(c[S], 1)) : (c[S] = create_each_block(T), c[S].c(), transition_in(c[S], 1), c[S].m(n.parentNode, n));
      }
      for (group_outros(), S = u.length; S < c.length; S += 1)
        m(S);
      check_outros();
    }
  }, i(d) {
    if (!a) {
      for (let w = 0; w < u.length; w += 1)
        transition_in(c[w]);
      a = !0;
    }
  }, o(d) {
    c = c.filter(Boolean);
    for (let w = 0; w < c.length; w += 1)
      transition_out(c[w]);
    a = !1;
  }, d(d) {
    destroy_each(c, d), d && detach(n);
  } };
}
function create_if_block_1$1(o) {
  let n, a;
  return n = new ResolveDID({ props: { did: o[1](o[5].id), $$slots: { timestamp: [create_timestamp_slot], default: [create_default_slot$1] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    3 & c && (m.did = u[1](u[5].id)), 259 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_default_slot$1(o) {
  let n, a, u = o[1](o[5].id) + "";
  return { c() {
    n = text(u), a = space();
  }, m(c, m) {
    insert(c, n, m), insert(c, a, m);
  }, p(c, m) {
    3 & m && u !== (u = c[1](c[5].id) + "") && set_data(n, u);
  }, d(c) {
    c && detach(n), c && detach(a);
  } };
}
function create_timestamp_slot(o) {
  let n, a, u = new Date(1e3 * o[5].timestamp).toLocaleString() + "";
  return { c() {
    n = element("div"), a = text(u), attr(n, "slot", "timestamp");
  }, m(c, m) {
    insert(c, n, m), append(n, a);
  }, p(c, m) {
    1 & m && u !== (u = new Date(1e3 * c[5].timestamp).toLocaleString() + "") && set_data(a, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_each_block(o) {
  let n, a, u = o[1] && o[5].id && create_if_block_1$1(o);
  return { c() {
    u && u.c(), n = empty();
  }, m(c, m) {
    u && u.m(c, m), insert(c, n, m), a = !0;
  }, p(c, m) {
    c[1] && c[5].id ? u ? (u.p(c, m), 3 & m && transition_in(u, 1)) : (u = create_if_block_1$1(c), u.c(), transition_in(u, 1), u.m(n.parentNode, n)) : u && (group_outros(), transition_out(u, 1, 1, () => {
      u = null;
    }), check_outros());
  }, i(c) {
    a || (transition_in(u), a = !0);
  }, o(c) {
    transition_out(u), a = !1;
  }, d(c) {
    u && u.d(c), c && detach(n);
  } };
}
function create_fragment$2(o) {
  let n, a, u = o[0] && create_if_block$1(o);
  return { c() {
    u && u.c(), n = empty();
  }, m(c, m) {
    u && u.m(c, m), insert(c, n, m), a = !0;
  }, p(c, [m]) {
    c[0] ? u ? (u.p(c, m), 1 & m && transition_in(u, 1)) : (u = create_if_block$1(c), u.c(), transition_in(u, 1), u.m(n.parentNode, n)) : u && (group_outros(), transition_out(u, 1, 1, () => {
      u = null;
    }), check_outros());
  }, i(c) {
    a || (transition_in(u), a = !0);
  }, o(c) {
    transition_out(u), a = !1;
  }, d(c) {
    u && u.d(c), c && detach(n);
  } };
}
function instance$2(o, n, a) {
  let { ownerAddress: u } = n, { local: c = !1 } = n;
  const m = createEventDispatcher();
  let d, w;
  return onMount(async () => {
    console.log("Looking for DID contracts...", new Date().toLocaleTimeString()), a(1, w = (B) => c ? `did:arlocal:${B}` : `did:ar:${B}`);
    let S = await Promise.resolve().then(() => index$3);
    S != null && S.default && (S = S.default), S != null && S.default && (S = S.default);
    let T = S.init({ host: "arweave.net", port: 443, protocol: "https", timeout: 2e4, logging: !1 });
    T.arql({ op: "and", expr1: { op: "equals", expr1: "App-Name", expr2: "SmartWeaveContract" }, expr2: { op: "equals", expr1: "Uploader-Contract-Owner", expr2: u }, expr3: { op: "equals", expr1: "Content-Type", expr2: "application/json" }, expr4: { op: "equals", expr1: "DID-AR", expr2: "true" } }).then(async (B) => {
      console.log("txIds", B);
      const I = `query {
								transactions(ids: ["${B.join('","')}"]) {
									edges {
										node {
											block {
												timestamp
											}
											tags {
												name
												value
											}
										}
									}
								}
							}`, C = await T.api.post("graphql", { query: I }, { headers: { "content-type": "application/json" } });
      a(0, d = C.data.data.transactions.edges.map((N) => {
        var q, D;
        return { id: N.node.tags.find((z) => z.name === "Uploader-Tx-Id").value, timestamp: new Date(1e3 * ((D = (q = N.node) == null ? void 0 : q.block) == null ? void 0 : D.timestamp)).toLocaleString() || null };
      })), m("searchComplete", d);
    });
  }), o.$$set = (S) => {
    "ownerAddress" in S && a(2, u = S.ownerAddress), "local" in S && a(3, c = S.local);
  }, [d, w, u, c];
}
class ListDIDs extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$2, create_fragment$2, safe_not_equal, { ownerAddress: 2, local: 3 });
  }
}
function add_css(o) {
  append_styles(o, "svelte-3r23a", ".flex-row.svelte-3r23a{flex-direction:row}.flex.svelte-3r23a{display:flex}.flex-1.svelte-3r23a{flex:1 1 0%}.items-center.svelte-3r23a{align-items:center}.spinner.svelte-3r23a{aspect-ratio:1;height:1em;width:1em;border:0.3em dotted rgba(250, 204, 21);border-radius:9999px;animation:svelte-3r23a-spin 1s linear infinite;background:#fcff23;margin:0.25em}@keyframes svelte-3r23a-spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}");
}
function create_fragment$1(o) {
  let n, a, u, c, m;
  const d = o[1].default, w = create_slot(d, o, o[0], null);
  return { c() {
    n = element("div"), a = element("div"), u = space(), c = element("div"), w && w.c(), attr(a, "class", "spinner svelte-3r23a"), attr(c, "class", "flex-1 svelte-3r23a"), attr(n, "class", "flex flex-row items-center svelte-3r23a");
  }, m(S, T) {
    insert(S, n, T), append(n, a), append(n, u), append(n, c), w && w.m(c, null), m = !0;
  }, p(S, [T]) {
    w && w.p && (!m || 1 & T) && update_slot_base(w, d, S, S[0], m ? get_slot_changes(d, S[0], T, null) : get_all_dirty_from_scope(S[0]), null);
  }, i(S) {
    m || (transition_in(w, S), m = !0);
  }, o(S) {
    transition_out(w, S), m = !1;
  }, d(S) {
    S && detach(n), w && w.d(S);
  } };
}
function instance$1(o, n, a) {
  let { $$slots: u = {}, $$scope: c } = n;
  return o.$$set = (m) => {
    "$$scope" in m && a(0, c = m.$$scope);
  }, [c, u];
}
class Spinner extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance$1, create_fragment$1, safe_not_equal, {}, add_css);
  }
}
function create_else_block_1(o) {
  let n;
  return { c() {
    n = text("Connect with Wallet to create a Decentralized Identity");
  }, m(a, u) {
    insert(a, n, u);
  }, p: noop$2, i: noop$2, o: noop$2, d(a) {
    a && detach(n);
  } };
}
function create_if_block(o) {
  let n, a, u = o[0], c = create_key_block(o);
  return { c() {
    c.c(), n = empty();
  }, m(m, d) {
    c.m(m, d), insert(m, n, d), a = !0;
  }, p(m, d) {
    1 & d && safe_not_equal(u, u = m[0]) ? (group_outros(), transition_out(c, 1, 1, noop$2), check_outros(), c = create_key_block(m), c.c(), transition_in(c, 1), c.m(n.parentNode, n)) : c.p(m, d);
  }, i(m) {
    a || (transition_in(c), a = !0);
  }, o(m) {
    transition_out(c), a = !1;
  }, d(m) {
    m && detach(n), c.d(m);
  } };
}
function create_key_block_1(o) {
  let n, a;
  return n = new ListDIDs({ props: { ownerAddress: o[6] } }), n.$on("searchComplete", o[8]), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    64 & c && (m.ownerAddress = u[6]), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block_3(o) {
  let n, a;
  return n = new Spinner({ props: { $$slots: { default: [create_default_slot] }, $$scope: { ctx: o } } }), { c() {
    create_component(n.$$.fragment);
  }, m(u, c) {
    mount_component(n, u, c), a = !0;
  }, p(u, c) {
    const m = {};
    4096 & c && (m.$$scope = { dirty: c, ctx: u }), n.$set(m);
  }, i(u) {
    a || (transition_in(n.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_if_block_1(o) {
  let n, a, u, c, m;
  function d(T, B) {
    return T[1] ? create_if_block_2 : create_else_block;
  }
  let w = d(o), S = w(o);
  return { c() {
    n = element("div"), S.c(), a = space(), u = element("div"), u.textContent = "Create Decentralized Identity (DID) with Wallet Keys", attr(n, "class", "m-4"), attr(u, "class", "bg-blue-600 hover:bg-blue-500 shadow rounded-lg m-4 p-4 w-fit text-white cursor-pointer");
  }, m(T, B) {
    insert(T, n, B), S.m(n, null), insert(T, a, B), insert(T, u, B), c || (m = [listen(u, "click", function() {
      is_function(o[7]) && o[7].apply(this, arguments);
    }), listen(u, "keypress", function() {
      is_function(o[7]) && o[7].apply(this, arguments);
    })], c = !0);
  }, p(T, B) {
    w === (w = d(o = T)) && S ? S.p(o, B) : (S.d(1), S = w(o), S && (S.c(), S.m(n, null)));
  }, i: noop$2, o: noop$2, d(T) {
    T && detach(n), S.d(), T && detach(a), T && detach(u), c = !1, run_all(m);
  } };
}
function create_default_slot(o) {
  let n;
  return { c() {
    n = text("Creating DID...");
  }, m(a, u) {
    insert(a, n, u);
  }, d(a) {
    a && detach(n);
  } };
}
function create_else_block(o) {
  let n;
  return { c() {
    n = text("We will deploy a new Smart Contract to manage your DID.");
  }, m(a, u) {
    insert(a, n, u);
  }, p: noop$2, d(a) {
    a && detach(n);
  } };
}
function create_if_block_2(o) {
  let n, a, u, c, m, d;
  return { c() {
    n = text("Using existing contract "), a = element("span"), u = element("a"), c = text(o[1]), m = text("\u{1F517}\u2197\uFE0F"), attr(u, "href", d = "https://sonar.warp.cc/#/app/source/" + o[1] + "#code"), attr(u, "target", "_blank"), attr(u, "rel", "noopener noreferrer"), attr(a, "class", "font-mono bg-gray-50 m-2 p-2 rounded");
  }, m(w, S) {
    insert(w, n, S), insert(w, a, S), append(a, u), append(u, c), append(u, m);
  }, p(w, S) {
    2 & S && set_data(c, w[1]), 2 & S && d !== (d = "https://sonar.warp.cc/#/app/source/" + w[1] + "#code") && attr(u, "href", d);
  }, d(w) {
    w && detach(n), w && detach(a);
  } };
}
function create_key_block(o) {
  let n, a, u, c, m, d = o[3], w = create_key_block_1(o);
  const S = [create_if_block_1, create_if_block_3], T = [];
  function B(I, C) {
    return I[5] || I[4] || !I[7] ? I[5] ? 1 : -1 : 0;
  }
  return ~(a = B(o)) && (u = T[a] = S[a](o)), { c() {
    w.c(), n = space(), u && u.c(), c = empty();
  }, m(I, C) {
    w.m(I, C), insert(I, n, C), ~a && T[a].m(I, C), insert(I, c, C), m = !0;
  }, p(I, C) {
    8 & C && safe_not_equal(d, d = I[3]) ? (group_outros(), transition_out(w, 1, 1, noop$2), check_outros(), w = create_key_block_1(I), w.c(), transition_in(w, 1), w.m(n.parentNode, n)) : w.p(I, C);
    let N = a;
    a = B(I), a === N ? ~a && T[a].p(I, C) : (u && (group_outros(), transition_out(T[N], 1, 1, () => {
      T[N] = null;
    }), check_outros()), ~a ? (u = T[a], u ? u.p(I, C) : (u = T[a] = S[a](I), u.c()), transition_in(u, 1), u.m(c.parentNode, c)) : u = null);
  }, i(I) {
    m || (transition_in(w), transition_in(u), m = !0);
  }, o(I) {
    transition_out(w), transition_out(u), m = !1;
  }, d(I) {
    w.d(I), I && detach(n), ~a && T[a].d(I), I && detach(c);
  } };
}
function create_fragment(o) {
  let n, a, u, c;
  const m = [create_if_block, create_else_block_1], d = [];
  function w(S, T) {
    return S[0] && S[2] && S[6] ? 0 : 1;
  }
  return n = w(o), a = d[n] = m[n](o), { c() {
    a.c(), u = empty();
  }, m(S, T) {
    d[n].m(S, T), insert(S, u, T), c = !0;
  }, p(S, [T]) {
    let B = n;
    n = w(S), n === B ? d[n].p(S, T) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[n], a ? a.p(S, T) : (a = d[n] = m[n](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[n].d(S), S && detach(u);
  } };
}
function instance(o, n, a) {
  let u, c, m, d, { RSAPublicKey: w } = n, { Ed25519PublicKey: S } = n, { wallet: T } = n, { srcTx: B = "SoPGF6d-5oLy6-uKpJD2J2tT0ytM9LsXWbP5YQnVT6Q" } = n, I = !1, C = !1, N = !1;
  return onMount(async () => {
    I = new URLSearchParams(window.location.search).get("local") === "true";
    const { init: D } = await Promise.resolve().then(() => didar);
    if (a(2, u = await D({ local: I })), I) {
      const { jwk: z, address: W } = await u.warp.testing.generateWallet();
      a(2, u.wallet = z, u), a(6, m = W), console.log("test address", W);
    }
    a(7, d = async function() {
      a(5, N = !0), a(3, c = await u.create({ RSAPublicKey: w, Ed25519PublicKey: S, srcTx: B }));
      const z = setInterval(async () => {
        a(6, m), a(0, T), C && (clearInterval(z), a(5, N = !1));
      }, 400);
    });
  }), o.$$set = (q) => {
    "RSAPublicKey" in q && a(9, w = q.RSAPublicKey), "Ed25519PublicKey" in q && a(10, S = q.Ed25519PublicKey), "wallet" in q && a(0, T = q.wallet), "srcTx" in q && a(1, B = q.srcTx);
  }, o.$$.update = () => {
    1 & o.$$.dirty && T && (async () => a(6, m = await T.arweaveWalletAPI.getActiveAddress()))();
  }, [T, B, u, c, C, N, m, d, async function(q) {
    console.log("searchComplete", q.detail), a(4, C = q.detail.length);
  }, w, S];
}
class DIDAr extends SvelteComponent {
  constructor(n) {
    super(), init$2(this, n, instance, create_fragment, safe_not_equal, { RSAPublicKey: 9, Ed25519PublicKey: 10, wallet: 0, srcTx: 1 });
  }
}
const id = null, controller = null, verificationMethod = [], authentication = ["#key-0", "#key-1"], assertionMethod = [], keyAgreement = [], capabilityInvocation = [], capabilityDelegation = [], service = [], initialState = { "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2018/v1"], id, controller, verificationMethod, authentication, assertionMethod, keyAgreement, capabilityInvocation, capabilityDelegation, service }, contractSrc = `export async function handle(state, action) {\r
	const input = action.input;\r
	const caller = action.caller;\r
\r
	function setVerificatioMethod() {\r
		if (input.verificationMethod) {\r
			if (!Array.isArray(input.verificationMethod) || input.verificationMethod.length === 0) {\r
				throw new ContractError('verificationMethod must be an array with at least one method');\r
			}\r
			state.verificationMethod = input.verificationMethod;\r
		}\r
	}\r
\r
	async function assertController() {\r
		let flattenedAddresses;\r
		try {\r
			// Need to read the state of each of the controllers' dids and get the Arweave addresses and compare it to the caller value\r
			const promises = state.controller.map(async (did) => await getDidArweaveAddresses(did));\r
			const addresses = await Promise.all(promises);\r
			flattenedAddresses = addresses.flat();\r
		} catch (error) {\r
			throw new ContractError('Invalid controller');\r
		}\r
\r
		// check if caller is listed in the array of state.controllers\r
		if (!flattenedAddresses.includes(caller)) {\r
			throw new ContractError('Caller is not a controller of this DID');\r
		}\r
	}\r
\r
	async function getDidArweaveAddresses(did) {\r
		// remove did:ar*: from the start of the did string\r
		const contractId = did.replace(/^did:ar(.*?):/, '');\r
\r
		// check if contractId match this contract\r
		let didDoc =\r
			contractId == SmartWeave.contract.id\r
				? state\r
				: await SmartWeave.contracts.readContractState(contractId);\r
\r
		// get all publicKeyJwk.kty === "RSA" from verificationMethod\r
		const promises = didDoc.verificationMethod\r
			.filter((method) => method.publicKeyJwk.kty === 'RSA')\r
			.map(\r
				async (method) => await SmartWeave.arweave.wallets.ownerToAddress(method.publicKeyJwk.n)\r
			);\r
\r
		return await Promise.all(promises);\r
	}\r
\r
	if (input.function === 'update') {\r
		// Intialize = 1st update, only if caller is Contract owner\r
		if (!state.id && caller === SmartWeave.contract.owner) {\r
			if (!input?.id?.startsWith('did:ar') || !input.verificationMethod.length) {\r
				throw new ContractError('Invalid ID or missing verificationMethod');\r
			}\r
			state.id = input.id;\r
			state.controller = input?.controller || [input.id];\r
			setVerificatioMethod(); // initialize verificationMethods\r
		}\r
\r
		// after initial update, any controller can make updates\r
		await assertController(state, caller);\r
\r
		setVerificatioMethod();\r
\r
		state.controller = input?.controller || state.controller; // array allows for multiple controllers, see: https://w3c.github.io/did-core/#independent-control\r
		state.authentication = input?.authentication || state.authentication;\r
		state.assertionMethod = input?.assertionMethod || state.assertionMethod;\r
		state.keyAgreement = input?.keyAgreement || state.keyAgreement;\r
		state.capabilityInvocation = input?.capabilityInvocation || state.capabilityInvocation;\r
		state.capabilityDelegation = input?.capabilityDelegation || state.capabilityDelegation;\r
		state.service = input?.service || state.service;\r
	}\r
\r
	return { state };\r
}\r
`;
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
function getAugmentedNamespace(o) {
  var n = o.default;
  if (typeof n == "function") {
    var a = function() {
      return n.apply(this, arguments);
    };
    a.prototype = n.prototype;
  } else
    a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(o).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(o, u);
    Object.defineProperty(a, u, c.get ? c : { enumerable: !0, get: function() {
      return o[u];
    } });
  }), a;
}
var base64 = {}, __extends = commonjsGlobal && commonjsGlobal.__extends || (extendStatics = function(o, n) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, u) {
    a.__proto__ = u;
  } || function(a, u) {
    for (var c in u)
      u.hasOwnProperty(c) && (a[c] = u[c]);
  }, extendStatics(o, n);
}, function(o, n) {
  function a() {
    this.constructor = o;
  }
  extendStatics(o, n), o.prototype = n === null ? Object.create(n) : (a.prototype = n.prototype, new a());
}), extendStatics;
Object.defineProperty(base64, "__esModule", { value: !0 });
var INVALID_BYTE = 256, Coder = function() {
  function o(n) {
    n === void 0 && (n = "="), this._paddingCharacter = n;
  }
  return o.prototype.encodedLength = function(n) {
    return this._paddingCharacter ? (n + 2) / 3 * 4 | 0 : (8 * n + 5) / 6 | 0;
  }, o.prototype.encode = function(n) {
    for (var a = "", u = 0; u < n.length - 2; u += 3) {
      var c = n[u] << 16 | n[u + 1] << 8 | n[u + 2];
      a += this._encodeByte(c >>> 18 & 63), a += this._encodeByte(c >>> 12 & 63), a += this._encodeByte(c >>> 6 & 63), a += this._encodeByte(c >>> 0 & 63);
    }
    var m = n.length - u;
    return m > 0 && (c = n[u] << 16 | (m === 2 ? n[u + 1] << 8 : 0), a += this._encodeByte(c >>> 18 & 63), a += this._encodeByte(c >>> 12 & 63), a += m === 2 ? this._encodeByte(c >>> 6 & 63) : this._paddingCharacter || "", a += this._paddingCharacter || ""), a;
  }, o.prototype.maxDecodedLength = function(n) {
    return this._paddingCharacter ? n / 4 * 3 | 0 : (6 * n + 7) / 8 | 0;
  }, o.prototype.decodedLength = function(n) {
    return this.maxDecodedLength(n.length - this._getPaddingLength(n));
  }, o.prototype.decode = function(n) {
    if (n.length === 0)
      return new Uint8Array(0);
    for (var a = this._getPaddingLength(n), u = n.length - a, c = new Uint8Array(this.maxDecodedLength(u)), m = 0, d = 0, w = 0, S = 0, T = 0, B = 0, I = 0; d < u - 4; d += 4)
      S = this._decodeChar(n.charCodeAt(d + 0)), T = this._decodeChar(n.charCodeAt(d + 1)), B = this._decodeChar(n.charCodeAt(d + 2)), I = this._decodeChar(n.charCodeAt(d + 3)), c[m++] = S << 2 | T >>> 4, c[m++] = T << 4 | B >>> 2, c[m++] = B << 6 | I, w |= S & INVALID_BYTE, w |= T & INVALID_BYTE, w |= B & INVALID_BYTE, w |= I & INVALID_BYTE;
    if (d < u - 1 && (S = this._decodeChar(n.charCodeAt(d)), T = this._decodeChar(n.charCodeAt(d + 1)), c[m++] = S << 2 | T >>> 4, w |= S & INVALID_BYTE, w |= T & INVALID_BYTE), d < u - 2 && (B = this._decodeChar(n.charCodeAt(d + 2)), c[m++] = T << 4 | B >>> 2, w |= B & INVALID_BYTE), d < u - 3 && (I = this._decodeChar(n.charCodeAt(d + 3)), c[m++] = B << 6 | I, w |= I & INVALID_BYTE), w !== 0)
      throw new Error("Base64Coder: incorrect characters for decoding");
    return c;
  }, o.prototype._encodeByte = function(n) {
    var a = n;
    return a += 65, a += 25 - n >>> 8 & 6, a += 51 - n >>> 8 & -75, a += 61 - n >>> 8 & -15, a += 62 - n >>> 8 & 3, String.fromCharCode(a);
  }, o.prototype._decodeChar = function(n) {
    var a = INVALID_BYTE;
    return a += (42 - n & n - 44) >>> 8 & -INVALID_BYTE + n - 43 + 62, a += (46 - n & n - 48) >>> 8 & -INVALID_BYTE + n - 47 + 63, a += (47 - n & n - 58) >>> 8 & -INVALID_BYTE + n - 48 + 52, (a += (64 - n & n - 91) >>> 8 & -INVALID_BYTE + n - 65 + 0) + ((96 - n & n - 123) >>> 8 & -INVALID_BYTE + n - 97 + 26);
  }, o.prototype._getPaddingLength = function(n) {
    var a = 0;
    if (this._paddingCharacter) {
      for (var u = n.length - 1; u >= 0 && n[u] === this._paddingCharacter; u--)
        a++;
      if (n.length < 4 || a > 2)
        throw new Error("Base64Coder: incorrect padding");
    }
    return a;
  }, o;
}();
base64.Coder = Coder;
var stdCoder = new Coder();
function encode$3(o) {
  return stdCoder.encode(o);
}
function decode$2(o) {
  return stdCoder.decode(o);
}
base64.encode = encode$3, base64.decode = decode$2;
var URLSafeCoder = function(o) {
  function n() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return __extends(n, o), n.prototype._encodeByte = function(a) {
    var u = a;
    return u += 65, u += 25 - a >>> 8 & 6, u += 51 - a >>> 8 & -75, u += 61 - a >>> 8 & -13, u += 62 - a >>> 8 & 49, String.fromCharCode(u);
  }, n.prototype._decodeChar = function(a) {
    var u = INVALID_BYTE;
    return u += (44 - a & a - 46) >>> 8 & -INVALID_BYTE + a - 45 + 62, u += (94 - a & a - 96) >>> 8 & -INVALID_BYTE + a - 95 + 63, u += (47 - a & a - 58) >>> 8 & -INVALID_BYTE + a - 48 + 52, (u += (64 - a & a - 91) >>> 8 & -INVALID_BYTE + a - 65 + 0) + ((96 - a & a - 123) >>> 8 & -INVALID_BYTE + a - 97 + 26);
  }, n;
}(Coder);
base64.URLSafeCoder = URLSafeCoder;
var urlSafeCoder = new URLSafeCoder();
function encodeURLSafe(o) {
  return urlSafeCoder.encode(o);
}
var encodeURLSafe_1 = base64.encodeURLSafe = encodeURLSafe;
function decodeURLSafe(o) {
  return urlSafeCoder.decode(o);
}
base64.decodeURLSafe = decodeURLSafe, base64.encodedLength = function(o) {
  return stdCoder.encodedLength(o);
}, base64.maxDecodedLength = function(o) {
  return stdCoder.maxDecodedLength(o);
}, base64.decodedLength = function(o) {
  return stdCoder.decodedLength(o);
};
const SRC_TX = "SoPGF6d-5oLy6-uKpJD2J2tT0ytM9LsXWbP5YQnVT6Q";
function DidArFactory({ warp: o, wallet: n }) {
  return { warp: o, wallet: n, create, read: read$2, update };
}
async function init$1({ local: o = !1, wallet: n = "use_wallet", warp: a = null } = { local: !1, wallet: "use_wallet", warp: null }) {
  const { WarpFactory: u } = await Promise.resolve().then(() => index$1);
  return DidArFactory({ warp: a = a || (o ? u.forLocal() : u.forMainnet()), wallet: n });
}
async function create({ RSAPublicKey: o, Ed25519PublicKey: n, srcTx: a = SRC_TX } = {}) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const u = [{ name: "DID-AR", value: "true" }], { contractTxId: c, srcTxId: m } = a ? await this.warp.createContract.deployFromSourceTx({ wallet: this.wallet, initState: JSON.stringify(initialState), srcTxId: a, tags: u }) : await this.warp.createContract.deploy({ wallet: this.wallet, initState: JSON.stringify(initialState), src: contractSrc, tags: u }), d = this.warp.environment == "mainnet" ? `did:ar:${c}` : `did:arlocal:${c}`, w = await generateVerificationMethods({ did: d, publicKeys: [o, n] });
  return await this.update({ id: d, controller: [d], verificationMethod: w }), d;
}
async function update({ id: o, ...n }) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const a = o.replace(/^did:ar(.*?):/, ""), u = this.warp.contract(a);
  u.connect(this.wallet);
  try {
    await u.writeInteraction({ ...n, id: o, function: "update" });
  } catch (c) {
    console.error(c);
  }
}
async function read$2(o) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const n = o.replace(/^did:ar(.*?):/, "");
  return (await this.warp.contract(n).readState()).cachedValue.state;
}
async function generateVerificationMethods({ did: o, publicKeys: n }) {
  const a = [];
  for (let u = 0; u < n.length; u++) {
    const c = n[u], m = `${o}#key-${u}`, d = isRSAKey(c) ? generateRSAVerificationMethod({ did: o, id: m, key: c }) : generateEd25519VerificationMethod({ did: o, id: m, key: c });
    a.push(d);
  }
  return a;
}
function generateRSAVerificationMethod({ did: o, id: n, key: a }) {
  return { id: n, type: "JsonWebKey2020", controller: o, publicKeyJwk: { kty: "RSA", e: "AQAB", n: a.n, kid: (a == null ? void 0 : a.kid) || n } };
}
function generateEd25519VerificationMethod({ did: o, id: n, key: a }) {
  return { id: n, type: "JsonWebKey2020", controller: o, publicKeyJwk: { kty: "OKP", crv: "Ed25519", x: encodeURLSafe_1(new Uint8Array(a)) } };
}
function isRSAKey(o) {
  return o.kty === "RSA";
}
const didar = Object.freeze(Object.defineProperty({ __proto__: null, DidArFactory, init: init$1, create, update, read: read$2, generateVerificationMethods, generateEd25519VerificationMethod }, Symbol.toStringTag, { value: "Module" })), REGISTRY = "bLAgYxAdX2Ry-nt6aH2ixgvJXbpsEYm28NgJgyqfs-U";
async function arnsResolver(o, { CacheOptions: n } = {}) {
  const a = await init({ CacheOptions: n }), u = await a.resolveARNS(o), c = await a.resolveANT(u);
  return await a.resolveDID(c);
}
async function init({ local: o, CacheOptions: n } = { local: !1, CacheOptions: void 0 }) {
  const { WarpFactory: a } = await Promise.resolve().then(() => index$1);
  return { warp: o ? a.forLocal(void 0, void 0, n) : a.forMainnet(n), resolveARNS, resolveANT, resolveDID };
}
async function resolveARNS(o) {
  return (await this.warp.contract(REGISTRY).readState()).cachedValue.state.records[o];
}
async function resolveANT(o) {
  return `did:ar:${(await this.warp.contract(o).readState()).cachedValue.state.records["did-ar"].transactionId}`;
}
async function resolveDID(o) {
  const n = o.replace("did:ar:", "");
  return (await this.warp.contract(n).readState()).cachedValue.state;
}
const arnsResolver$1 = Object.freeze(Object.defineProperty({ __proto__: null, arnsResolver, init, resolveARNS, resolveANT, resolveDID }, Symbol.toStringTag, { value: "Module" }));
function getResolver() {
  return { ar: async function(o, n, a, u) {
    const { WarpFactory: c } = await Promise.resolve().then(() => index$1);
    let m = c.forMainnet();
    return { didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: (await m.contract(n.id).readState()).cachedValue.state, didDocumentMetadata: {} };
  }, arlocal: async function(o, n, a, u) {
    const { WarpFactory: c } = await Promise.resolve().then(() => index$1);
    let m = c.forLocal();
    return { didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: (await m.contract(n.id).readState()).cachedValue.state, didDocumentMetadata: {} };
  } };
}
const resolver = Object.freeze(Object.defineProperty({ __proto__: null, getResolver }, Symbol.toStringTag, { value: "Module" })), index$4 = Object.freeze(Object.defineProperty({ __proto__: null, DIDAr, init: init$1, create, update, arns: arnsResolver$1, arnsResolver, didArResolver: resolver }, Symbol.toStringTag, { value: "Module" }));
var web = {}, common$8 = {}, ar$1 = {}, bignumber = { exports: {} }, t;
t = bignumber, function(o) {
  var n, a = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, u = Math.ceil, c = Math.floor, m = "[BigNumber Error] ", d = m + "Number primitive has more than 15 significant digits: ", w = 1e14, S = 14, T = 9007199254740991, B = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], I = 1e7, C = 1e9;
  function N(P) {
    var F = 0 | P;
    return P > 0 || P === F ? F : F - 1;
  }
  function q(P) {
    for (var F, H, te = 1, p = P.length, $ = P[0] + ""; te < p; ) {
      for (F = P[te++] + "", H = S - F.length; H--; F = "0" + F)
        ;
      $ += F;
    }
    for (p = $.length; $.charCodeAt(--p) === 48; )
      ;
    return $.slice(0, p + 1 || 1);
  }
  function D(P, F) {
    var H, te, p = P.c, $ = F.c, _ = P.s, y = F.s, g = P.e, v = F.e;
    if (!_ || !y)
      return null;
    if (H = p && !p[0], te = $ && !$[0], H || te)
      return H ? te ? 0 : -y : _;
    if (_ != y)
      return _;
    if (H = _ < 0, te = g == v, !p || !$)
      return te ? 0 : !p ^ H ? 1 : -1;
    if (!te)
      return g > v ^ H ? 1 : -1;
    for (y = (g = p.length) < (v = $.length) ? g : v, _ = 0; _ < y; _++)
      if (p[_] != $[_])
        return p[_] > $[_] ^ H ? 1 : -1;
    return g == v ? 0 : g > v ^ H ? 1 : -1;
  }
  function z(P, F, H, te) {
    if (P < F || P > H || P !== c(P))
      throw Error(m + (te || "Argument") + (typeof P == "number" ? P < F || P > H ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(P));
  }
  function W(P) {
    var F = P.c.length - 1;
    return N(P.e / S) == F && P.c[F] % 2 != 0;
  }
  function V(P, F) {
    return (P.length > 1 ? P.charAt(0) + "." + P.slice(1) : P) + (F < 0 ? "e" : "e+") + F;
  }
  function ee(P, F, H) {
    var te, p;
    if (F < 0) {
      for (p = H + "."; ++F; p += H)
        ;
      P = p + P;
    } else if (++F > (te = P.length)) {
      for (p = H, F -= te; --F; p += H)
        ;
      P += p;
    } else
      F < te && (P = P.slice(0, F) + "." + P.slice(F));
    return P;
  }
  n = function P(F) {
    var H, te, p, $, _, y, g, v, E, A, L = fe.prototype = { constructor: fe, toString: null, valueOf: null }, j = new fe(1), J = 20, X = 4, re = -7, Z = 21, ie = -1e7, oe = 1e7, ue = !1, se = 1, ce = 0, Se = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, he = "0123456789abcdefghijklmnopqrstuvwxyz", $e = !0;
    function fe(l, h) {
      var b, M, k, x, O, G, Q, ne, Y = this;
      if (!(Y instanceof fe))
        return new fe(l, h);
      if (h == null) {
        if (l && l._isBigNumber === !0)
          return Y.s = l.s, void (!l.c || l.e > oe ? Y.c = Y.e = null : l.e < ie ? Y.c = [Y.e = 0] : (Y.e = l.e, Y.c = l.c.slice()));
        if ((G = typeof l == "number") && 0 * l == 0) {
          if (Y.s = 1 / l < 0 ? (l = -l, -1) : 1, l === ~~l) {
            for (x = 0, O = l; O >= 10; O /= 10, x++)
              ;
            return void (x > oe ? Y.c = Y.e = null : (Y.e = x, Y.c = [l]));
          }
          ne = String(l);
        } else {
          if (!a.test(ne = String(l)))
            return p(Y, ne, G);
          Y.s = ne.charCodeAt(0) == 45 ? (ne = ne.slice(1), -1) : 1;
        }
        (x = ne.indexOf(".")) > -1 && (ne = ne.replace(".", "")), (O = ne.search(/e/i)) > 0 ? (x < 0 && (x = O), x += +ne.slice(O + 1), ne = ne.substring(0, O)) : x < 0 && (x = ne.length);
      } else {
        if (z(h, 2, he.length, "Base"), h == 10 && $e)
          return de(Y = new fe(l), J + Y.e + 1, X);
        if (ne = String(l), G = typeof l == "number") {
          if (0 * l != 0)
            return p(Y, ne, G, h);
          if (Y.s = 1 / l < 0 ? (ne = ne.slice(1), -1) : 1, fe.DEBUG && ne.replace(/^0\.0*|\./, "").length > 15)
            throw Error(d + l);
        } else
          Y.s = ne.charCodeAt(0) === 45 ? (ne = ne.slice(1), -1) : 1;
        for (b = he.slice(0, h), x = O = 0, Q = ne.length; O < Q; O++)
          if (b.indexOf(M = ne.charAt(O)) < 0) {
            if (M == ".") {
              if (O > x) {
                x = Q;
                continue;
              }
            } else if (!k && (ne == ne.toUpperCase() && (ne = ne.toLowerCase()) || ne == ne.toLowerCase() && (ne = ne.toUpperCase()))) {
              k = !0, O = -1, x = 0;
              continue;
            }
            return p(Y, String(l), G, h);
          }
        G = !1, (x = (ne = te(ne, h, 10, Y.s)).indexOf(".")) > -1 ? ne = ne.replace(".", "") : x = ne.length;
      }
      for (O = 0; ne.charCodeAt(O) === 48; O++)
        ;
      for (Q = ne.length; ne.charCodeAt(--Q) === 48; )
        ;
      if (ne = ne.slice(O, ++Q)) {
        if (Q -= O, G && fe.DEBUG && Q > 15 && (l > T || l !== c(l)))
          throw Error(d + Y.s * l);
        if ((x = x - O - 1) > oe)
          Y.c = Y.e = null;
        else if (x < ie)
          Y.c = [Y.e = 0];
        else {
          if (Y.e = x, Y.c = [], O = (x + 1) % S, x < 0 && (O += S), O < Q) {
            for (O && Y.c.push(+ne.slice(0, O)), Q -= S; O < Q; )
              Y.c.push(+ne.slice(O, O += S));
            O = S - (ne = ne.slice(O)).length;
          } else
            O -= Q;
          for (; O--; ne += "0")
            ;
          Y.c.push(+ne);
        }
      } else
        Y.c = [Y.e = 0];
    }
    function le(l, h, b, M) {
      var k, x, O, G, Q;
      if (b == null ? b = X : z(b, 0, 8), !l.c)
        return l.toString();
      if (k = l.c[0], O = l.e, h == null)
        Q = q(l.c), Q = M == 1 || M == 2 && (O <= re || O >= Z) ? V(Q, O) : ee(Q, O, "0");
      else if (x = (l = de(new fe(l), h, b)).e, G = (Q = q(l.c)).length, M == 1 || M == 2 && (h <= x || x <= re)) {
        for (; G < h; Q += "0", G++)
          ;
        Q = V(Q, x);
      } else if (h -= O, Q = ee(Q, x, "0"), x + 1 > G) {
        if (--h > 0)
          for (Q += "."; h--; Q += "0")
            ;
      } else if ((h += x - G) > 0)
        for (x + 1 == G && (Q += "."); h--; Q += "0")
          ;
      return l.s < 0 && k ? "-" + Q : Q;
    }
    function we(l, h) {
      for (var b, M = 1, k = new fe(l[0]); M < l.length; M++) {
        if (!(b = new fe(l[M])).s) {
          k = b;
          break;
        }
        h.call(k, b) && (k = b);
      }
      return k;
    }
    function We(l, h, b) {
      for (var M = 1, k = h.length; !h[--k]; h.pop())
        ;
      for (k = h[0]; k >= 10; k /= 10, M++)
        ;
      return (b = M + b * S - 1) > oe ? l.c = l.e = null : b < ie ? l.c = [l.e = 0] : (l.e = b, l.c = h), l;
    }
    function de(l, h, b, M) {
      var k, x, O, G, Q, ne, Y, ae = l.c, Ee = B;
      if (ae) {
        e: {
          for (k = 1, G = ae[0]; G >= 10; G /= 10, k++)
            ;
          if ((x = h - k) < 0)
            x += S, O = h, Y = (Q = ae[ne = 0]) / Ee[k - O - 1] % 10 | 0;
          else if ((ne = u((x + 1) / S)) >= ae.length) {
            if (!M)
              break e;
            for (; ae.length <= ne; ae.push(0))
              ;
            Q = Y = 0, k = 1, O = (x %= S) - S + 1;
          } else {
            for (Q = G = ae[ne], k = 1; G >= 10; G /= 10, k++)
              ;
            Y = (O = (x %= S) - S + k) < 0 ? 0 : Q / Ee[k - O - 1] % 10 | 0;
          }
          if (M = M || h < 0 || ae[ne + 1] != null || (O < 0 ? Q : Q % Ee[k - O - 1]), M = b < 4 ? (Y || M) && (b == 0 || b == (l.s < 0 ? 3 : 2)) : Y > 5 || Y == 5 && (b == 4 || M || b == 6 && (x > 0 ? O > 0 ? Q / Ee[k - O] : 0 : ae[ne - 1]) % 10 & 1 || b == (l.s < 0 ? 8 : 7)), h < 1 || !ae[0])
            return ae.length = 0, M ? (h -= l.e + 1, ae[0] = Ee[(S - h % S) % S], l.e = -h || 0) : ae[0] = l.e = 0, l;
          if (x == 0 ? (ae.length = ne, G = 1, ne--) : (ae.length = ne + 1, G = Ee[S - x], ae[ne] = O > 0 ? c(Q / Ee[k - O] % Ee[O]) * G : 0), M)
            for (; ; ) {
              if (ne == 0) {
                for (x = 1, O = ae[0]; O >= 10; O /= 10, x++)
                  ;
                for (O = ae[0] += G, G = 1; O >= 10; O /= 10, G++)
                  ;
                x != G && (l.e++, ae[0] == w && (ae[0] = 1));
                break;
              }
              if (ae[ne] += G, ae[ne] != w)
                break;
              ae[ne--] = 0, G = 1;
            }
          for (x = ae.length; ae[--x] === 0; ae.pop())
            ;
        }
        l.e > oe ? l.c = l.e = null : l.e < ie && (l.c = [l.e = 0]);
      }
      return l;
    }
    function ke(l) {
      var h, b = l.e;
      return b === null ? l.toString() : (h = q(l.c), h = b <= re || b >= Z ? V(h, b) : ee(h, b, "0"), l.s < 0 ? "-" + h : h);
    }
    return fe.clone = P, fe.ROUND_UP = 0, fe.ROUND_DOWN = 1, fe.ROUND_CEIL = 2, fe.ROUND_FLOOR = 3, fe.ROUND_HALF_UP = 4, fe.ROUND_HALF_DOWN = 5, fe.ROUND_HALF_EVEN = 6, fe.ROUND_HALF_CEIL = 7, fe.ROUND_HALF_FLOOR = 8, fe.EUCLID = 9, fe.config = fe.set = function(l) {
      var h, b;
      if (l != null) {
        if (typeof l != "object")
          throw Error(m + "Object expected: " + l);
        if (l.hasOwnProperty(h = "DECIMAL_PLACES") && (z(b = l[h], 0, C, h), J = b), l.hasOwnProperty(h = "ROUNDING_MODE") && (z(b = l[h], 0, 8, h), X = b), l.hasOwnProperty(h = "EXPONENTIAL_AT") && ((b = l[h]) && b.pop ? (z(b[0], -C, 0, h), z(b[1], 0, C, h), re = b[0], Z = b[1]) : (z(b, -C, C, h), re = -(Z = b < 0 ? -b : b))), l.hasOwnProperty(h = "RANGE"))
          if ((b = l[h]) && b.pop)
            z(b[0], -C, -1, h), z(b[1], 1, C, h), ie = b[0], oe = b[1];
          else {
            if (z(b, -C, C, h), !b)
              throw Error(m + h + " cannot be zero: " + b);
            ie = -(oe = b < 0 ? -b : b);
          }
        if (l.hasOwnProperty(h = "CRYPTO")) {
          if ((b = l[h]) !== !!b)
            throw Error(m + h + " not true or false: " + b);
          if (b) {
            if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
              throw ue = !b, Error(m + "crypto unavailable");
            ue = b;
          } else
            ue = b;
        }
        if (l.hasOwnProperty(h = "MODULO_MODE") && (z(b = l[h], 0, 9, h), se = b), l.hasOwnProperty(h = "POW_PRECISION") && (z(b = l[h], 0, C, h), ce = b), l.hasOwnProperty(h = "FORMAT")) {
          if (typeof (b = l[h]) != "object")
            throw Error(m + h + " not an object: " + b);
          Se = b;
        }
        if (l.hasOwnProperty(h = "ALPHABET")) {
          if (typeof (b = l[h]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(b))
            throw Error(m + h + " invalid: " + b);
          $e = b.slice(0, 10) == "0123456789", he = b;
        }
      }
      return { DECIMAL_PLACES: J, ROUNDING_MODE: X, EXPONENTIAL_AT: [re, Z], RANGE: [ie, oe], CRYPTO: ue, MODULO_MODE: se, POW_PRECISION: ce, FORMAT: Se, ALPHABET: he };
    }, fe.isBigNumber = function(l) {
      if (!l || l._isBigNumber !== !0)
        return !1;
      if (!fe.DEBUG)
        return !0;
      var h, b, M = l.c, k = l.e, x = l.s;
      e:
        if ({}.toString.call(M) == "[object Array]") {
          if ((x === 1 || x === -1) && k >= -C && k <= C && k === c(k)) {
            if (M[0] === 0) {
              if (k === 0 && M.length === 1)
                return !0;
              break e;
            }
            if ((h = (k + 1) % S) < 1 && (h += S), String(M[0]).length == h) {
              for (h = 0; h < M.length; h++)
                if ((b = M[h]) < 0 || b >= w || b !== c(b))
                  break e;
              if (b !== 0)
                return !0;
            }
          }
        } else if (M === null && k === null && (x === null || x === 1 || x === -1))
          return !0;
      throw Error(m + "Invalid BigNumber: " + l);
    }, fe.maximum = fe.max = function() {
      return we(arguments, L.lt);
    }, fe.minimum = fe.min = function() {
      return we(arguments, L.gt);
    }, fe.random = ($ = 9007199254740992, _ = Math.random() * $ & 2097151 ? function() {
      return c(Math.random() * $);
    } : function() {
      return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
    }, function(l) {
      var h, b, M, k, x, O = 0, G = [], Q = new fe(j);
      if (l == null ? l = J : z(l, 0, C), k = u(l / S), ue)
        if (crypto.getRandomValues) {
          for (h = crypto.getRandomValues(new Uint32Array(k *= 2)); O < k; )
            (x = 131072 * h[O] + (h[O + 1] >>> 11)) >= 9e15 ? (b = crypto.getRandomValues(new Uint32Array(2)), h[O] = b[0], h[O + 1] = b[1]) : (G.push(x % 1e14), O += 2);
          O = k / 2;
        } else {
          if (!crypto.randomBytes)
            throw ue = !1, Error(m + "crypto unavailable");
          for (h = crypto.randomBytes(k *= 7); O < k; )
            (x = 281474976710656 * (31 & h[O]) + 1099511627776 * h[O + 1] + 4294967296 * h[O + 2] + 16777216 * h[O + 3] + (h[O + 4] << 16) + (h[O + 5] << 8) + h[O + 6]) >= 9e15 ? crypto.randomBytes(7).copy(h, O) : (G.push(x % 1e14), O += 7);
          O = k / 7;
        }
      if (!ue)
        for (; O < k; )
          (x = _()) < 9e15 && (G[O++] = x % 1e14);
      for (k = G[--O], l %= S, k && l && (x = B[S - l], G[O] = c(k / x) * x); G[O] === 0; G.pop(), O--)
        ;
      if (O < 0)
        G = [M = 0];
      else {
        for (M = -1; G[0] === 0; G.splice(0, 1), M -= S)
          ;
        for (O = 1, x = G[0]; x >= 10; x /= 10, O++)
          ;
        O < S && (M -= S - O);
      }
      return Q.e = M, Q.c = G, Q;
    }), fe.sum = function() {
      for (var l = 1, h = arguments, b = new fe(h[0]); l < h.length; )
        b = b.plus(h[l++]);
      return b;
    }, te = function() {
      var l = "0123456789";
      function h(b, M, k, x) {
        for (var O, G, Q = [0], ne = 0, Y = b.length; ne < Y; ) {
          for (G = Q.length; G--; Q[G] *= M)
            ;
          for (Q[0] += x.indexOf(b.charAt(ne++)), O = 0; O < Q.length; O++)
            Q[O] > k - 1 && (Q[O + 1] == null && (Q[O + 1] = 0), Q[O + 1] += Q[O] / k | 0, Q[O] %= k);
        }
        return Q.reverse();
      }
      return function(b, M, k, x, O) {
        var G, Q, ne, Y, ae, Ee, pe, ye, Le = b.indexOf("."), ge = J, be = X;
        for (Le >= 0 && (Y = ce, ce = 0, b = b.replace(".", ""), Ee = (ye = new fe(M)).pow(b.length - Le), ce = Y, ye.c = h(ee(q(Ee.c), Ee.e, "0"), 10, k, l), ye.e = ye.c.length), ne = Y = (pe = h(b, M, k, O ? (G = he, l) : (G = l, he))).length; pe[--Y] == 0; pe.pop())
          ;
        if (!pe[0])
          return G.charAt(0);
        if (Le < 0 ? --ne : (Ee.c = pe, Ee.e = ne, Ee.s = x, pe = (Ee = H(Ee, ye, ge, be, k)).c, ae = Ee.r, ne = Ee.e), Le = pe[Q = ne + ge + 1], Y = k / 2, ae = ae || Q < 0 || pe[Q + 1] != null, ae = be < 4 ? (Le != null || ae) && (be == 0 || be == (Ee.s < 0 ? 3 : 2)) : Le > Y || Le == Y && (be == 4 || ae || be == 6 && 1 & pe[Q - 1] || be == (Ee.s < 0 ? 8 : 7)), Q < 1 || !pe[0])
          b = ae ? ee(G.charAt(1), -ge, G.charAt(0)) : G.charAt(0);
        else {
          if (pe.length = Q, ae)
            for (--k; ++pe[--Q] > k; )
              pe[Q] = 0, Q || (++ne, pe = [1].concat(pe));
          for (Y = pe.length; !pe[--Y]; )
            ;
          for (Le = 0, b = ""; Le <= Y; b += G.charAt(pe[Le++]))
            ;
          b = ee(b, ne, G.charAt(0));
        }
        return b;
      };
    }(), H = function() {
      function l(M, k, x) {
        var O, G, Q, ne, Y = 0, ae = M.length, Ee = k % I, pe = k / I | 0;
        for (M = M.slice(); ae--; )
          Y = ((G = Ee * (Q = M[ae] % I) + (O = pe * Q + (ne = M[ae] / I | 0) * Ee) % I * I + Y) / x | 0) + (O / I | 0) + pe * ne, M[ae] = G % x;
        return Y && (M = [Y].concat(M)), M;
      }
      function h(M, k, x, O) {
        var G, Q;
        if (x != O)
          Q = x > O ? 1 : -1;
        else
          for (G = Q = 0; G < x; G++)
            if (M[G] != k[G]) {
              Q = M[G] > k[G] ? 1 : -1;
              break;
            }
        return Q;
      }
      function b(M, k, x, O) {
        for (var G = 0; x--; )
          M[x] -= G, G = M[x] < k[x] ? 1 : 0, M[x] = G * O + M[x] - k[x];
        for (; !M[0] && M.length > 1; M.splice(0, 1))
          ;
      }
      return function(M, k, x, O, G) {
        var Q, ne, Y, ae, Ee, pe, ye, Le, ge, be, Re, me, Ae, He, ve, Me, Fe, _e = M.s == k.s ? 1 : -1, Oe = M.c, qe = k.c;
        if (!(Oe && Oe[0] && qe && qe[0]))
          return new fe(M.s && k.s && (Oe ? !qe || Oe[0] != qe[0] : qe) ? Oe && Oe[0] == 0 || !qe ? 0 * _e : _e / 0 : NaN);
        for (ge = (Le = new fe(_e)).c = [], _e = x + (ne = M.e - k.e) + 1, G || (G = w, ne = N(M.e / S) - N(k.e / S), _e = _e / S | 0), Y = 0; qe[Y] == (Oe[Y] || 0); Y++)
          ;
        if (qe[Y] > (Oe[Y] || 0) && ne--, _e < 0)
          ge.push(1), ae = !0;
        else {
          for (He = Oe.length, Me = qe.length, Y = 0, _e += 2, (Ee = c(G / (qe[0] + 1))) > 1 && (qe = l(qe, Ee, G), Oe = l(Oe, Ee, G), Me = qe.length, He = Oe.length), Ae = Me, Re = (be = Oe.slice(0, Me)).length; Re < Me; be[Re++] = 0)
            ;
          Fe = qe.slice(), Fe = [0].concat(Fe), ve = qe[0], qe[1] >= G / 2 && ve++;
          do {
            if (Ee = 0, (Q = h(qe, be, Me, Re)) < 0) {
              if (me = be[0], Me != Re && (me = me * G + (be[1] || 0)), (Ee = c(me / ve)) > 1)
                for (Ee >= G && (Ee = G - 1), ye = (pe = l(qe, Ee, G)).length, Re = be.length; h(pe, be, ye, Re) == 1; )
                  Ee--, b(pe, Me < ye ? Fe : qe, ye, G), ye = pe.length, Q = 1;
              else
                Ee == 0 && (Q = Ee = 1), ye = (pe = qe.slice()).length;
              if (ye < Re && (pe = [0].concat(pe)), b(be, pe, Re, G), Re = be.length, Q == -1)
                for (; h(qe, be, Me, Re) < 1; )
                  Ee++, b(be, Me < Re ? Fe : qe, Re, G), Re = be.length;
            } else
              Q === 0 && (Ee++, be = [0]);
            ge[Y++] = Ee, be[0] ? be[Re++] = Oe[Ae] || 0 : (be = [Oe[Ae]], Re = 1);
          } while ((Ae++ < He || be[0] != null) && _e--);
          ae = be[0] != null, ge[0] || ge.splice(0, 1);
        }
        if (G == w) {
          for (Y = 1, _e = ge[0]; _e >= 10; _e /= 10, Y++)
            ;
          de(Le, x + (Le.e = Y + ne * S - 1) + 1, O, ae);
        } else
          Le.e = ne, Le.r = +ae;
        return Le;
      };
    }(), y = /^(-?)0([xbo])(?=\w[\w.]*$)/i, g = /^([^.]+)\.$/, v = /^\.([^.]+)$/, E = /^-?(Infinity|NaN)$/, A = /^\s*\+(?=[\w.])|^\s+|\s+$/g, p = function(l, h, b, M) {
      var k, x = b ? h : h.replace(A, "");
      if (E.test(x))
        l.s = isNaN(x) ? null : x < 0 ? -1 : 1;
      else {
        if (!b && (x = x.replace(y, function(O, G, Q) {
          return k = (Q = Q.toLowerCase()) == "x" ? 16 : Q == "b" ? 2 : 8, M && M != k ? O : G;
        }), M && (k = M, x = x.replace(g, "$1").replace(v, "0.$1")), h != x))
          return new fe(x, k);
        if (fe.DEBUG)
          throw Error(m + "Not a" + (M ? " base " + M : "") + " number: " + h);
        l.s = null;
      }
      l.c = l.e = null;
    }, L.absoluteValue = L.abs = function() {
      var l = new fe(this);
      return l.s < 0 && (l.s = 1), l;
    }, L.comparedTo = function(l, h) {
      return D(this, new fe(l, h));
    }, L.decimalPlaces = L.dp = function(l, h) {
      var b, M, k, x = this;
      if (l != null)
        return z(l, 0, C), h == null ? h = X : z(h, 0, 8), de(new fe(x), l + x.e + 1, h);
      if (!(b = x.c))
        return null;
      if (M = ((k = b.length - 1) - N(this.e / S)) * S, k = b[k])
        for (; k % 10 == 0; k /= 10, M--)
          ;
      return M < 0 && (M = 0), M;
    }, L.dividedBy = L.div = function(l, h) {
      return H(this, new fe(l, h), J, X);
    }, L.dividedToIntegerBy = L.idiv = function(l, h) {
      return H(this, new fe(l, h), 0, 1);
    }, L.exponentiatedBy = L.pow = function(l, h) {
      var b, M, k, x, O, G, Q, ne, Y = this;
      if ((l = new fe(l)).c && !l.isInteger())
        throw Error(m + "Exponent not an integer: " + ke(l));
      if (h != null && (h = new fe(h)), O = l.e > 14, !Y.c || !Y.c[0] || Y.c[0] == 1 && !Y.e && Y.c.length == 1 || !l.c || !l.c[0])
        return ne = new fe(Math.pow(+ke(Y), O ? 2 - W(l) : +ke(l))), h ? ne.mod(h) : ne;
      if (G = l.s < 0, h) {
        if (h.c ? !h.c[0] : !h.s)
          return new fe(NaN);
        (M = !G && Y.isInteger() && h.isInteger()) && (Y = Y.mod(h));
      } else {
        if (l.e > 9 && (Y.e > 0 || Y.e < -1 || (Y.e == 0 ? Y.c[0] > 1 || O && Y.c[1] >= 24e7 : Y.c[0] < 8e13 || O && Y.c[0] <= 9999975e7)))
          return x = Y.s < 0 && W(l) ? -0 : 0, Y.e > -1 && (x = 1 / x), new fe(G ? 1 / x : x);
        ce && (x = u(ce / S + 2));
      }
      for (O ? (b = new fe(0.5), G && (l.s = 1), Q = W(l)) : Q = (k = Math.abs(+ke(l))) % 2, ne = new fe(j); ; ) {
        if (Q) {
          if (!(ne = ne.times(Y)).c)
            break;
          x ? ne.c.length > x && (ne.c.length = x) : M && (ne = ne.mod(h));
        }
        if (k) {
          if ((k = c(k / 2)) === 0)
            break;
          Q = k % 2;
        } else if (de(l = l.times(b), l.e + 1, 1), l.e > 14)
          Q = W(l);
        else {
          if ((k = +ke(l)) == 0)
            break;
          Q = k % 2;
        }
        Y = Y.times(Y), x ? Y.c && Y.c.length > x && (Y.c.length = x) : M && (Y = Y.mod(h));
      }
      return M ? ne : (G && (ne = j.div(ne)), h ? ne.mod(h) : x ? de(ne, ce, X, void 0) : ne);
    }, L.integerValue = function(l) {
      var h = new fe(this);
      return l == null ? l = X : z(l, 0, 8), de(h, h.e + 1, l);
    }, L.isEqualTo = L.eq = function(l, h) {
      return D(this, new fe(l, h)) === 0;
    }, L.isFinite = function() {
      return !!this.c;
    }, L.isGreaterThan = L.gt = function(l, h) {
      return D(this, new fe(l, h)) > 0;
    }, L.isGreaterThanOrEqualTo = L.gte = function(l, h) {
      return (h = D(this, new fe(l, h))) === 1 || h === 0;
    }, L.isInteger = function() {
      return !!this.c && N(this.e / S) > this.c.length - 2;
    }, L.isLessThan = L.lt = function(l, h) {
      return D(this, new fe(l, h)) < 0;
    }, L.isLessThanOrEqualTo = L.lte = function(l, h) {
      return (h = D(this, new fe(l, h))) === -1 || h === 0;
    }, L.isNaN = function() {
      return !this.s;
    }, L.isNegative = function() {
      return this.s < 0;
    }, L.isPositive = function() {
      return this.s > 0;
    }, L.isZero = function() {
      return !!this.c && this.c[0] == 0;
    }, L.minus = function(l, h) {
      var b, M, k, x, O = this, G = O.s;
      if (h = (l = new fe(l, h)).s, !G || !h)
        return new fe(NaN);
      if (G != h)
        return l.s = -h, O.plus(l);
      var Q = O.e / S, ne = l.e / S, Y = O.c, ae = l.c;
      if (!Q || !ne) {
        if (!Y || !ae)
          return Y ? (l.s = -h, l) : new fe(ae ? O : NaN);
        if (!Y[0] || !ae[0])
          return ae[0] ? (l.s = -h, l) : new fe(Y[0] ? O : X == 3 ? -0 : 0);
      }
      if (Q = N(Q), ne = N(ne), Y = Y.slice(), G = Q - ne) {
        for ((x = G < 0) ? (G = -G, k = Y) : (ne = Q, k = ae), k.reverse(), h = G; h--; k.push(0))
          ;
        k.reverse();
      } else
        for (M = (x = (G = Y.length) < (h = ae.length)) ? G : h, G = h = 0; h < M; h++)
          if (Y[h] != ae[h]) {
            x = Y[h] < ae[h];
            break;
          }
      if (x && (k = Y, Y = ae, ae = k, l.s = -l.s), (h = (M = ae.length) - (b = Y.length)) > 0)
        for (; h--; Y[b++] = 0)
          ;
      for (h = w - 1; M > G; ) {
        if (Y[--M] < ae[M]) {
          for (b = M; b && !Y[--b]; Y[b] = h)
            ;
          --Y[b], Y[M] += w;
        }
        Y[M] -= ae[M];
      }
      for (; Y[0] == 0; Y.splice(0, 1), --ne)
        ;
      return Y[0] ? We(l, Y, ne) : (l.s = X == 3 ? -1 : 1, l.c = [l.e = 0], l);
    }, L.modulo = L.mod = function(l, h) {
      var b, M, k = this;
      return l = new fe(l, h), !k.c || !l.s || l.c && !l.c[0] ? new fe(NaN) : !l.c || k.c && !k.c[0] ? new fe(k) : (se == 9 ? (M = l.s, l.s = 1, b = H(k, l, 0, 3), l.s = M, b.s *= M) : b = H(k, l, 0, se), (l = k.minus(b.times(l))).c[0] || se != 1 || (l.s = k.s), l);
    }, L.multipliedBy = L.times = function(l, h) {
      var b, M, k, x, O, G, Q, ne, Y, ae, Ee, pe, ye, Le, ge, be = this, Re = be.c, me = (l = new fe(l, h)).c;
      if (!(Re && me && Re[0] && me[0]))
        return !be.s || !l.s || Re && !Re[0] && !me || me && !me[0] && !Re ? l.c = l.e = l.s = null : (l.s *= be.s, Re && me ? (l.c = [0], l.e = 0) : l.c = l.e = null), l;
      for (M = N(be.e / S) + N(l.e / S), l.s *= be.s, (Q = Re.length) < (ae = me.length) && (ye = Re, Re = me, me = ye, k = Q, Q = ae, ae = k), k = Q + ae, ye = []; k--; ye.push(0))
        ;
      for (Le = w, ge = I, k = ae; --k >= 0; ) {
        for (b = 0, Ee = me[k] % ge, pe = me[k] / ge | 0, x = k + (O = Q); x > k; )
          b = ((ne = Ee * (ne = Re[--O] % ge) + (G = pe * ne + (Y = Re[O] / ge | 0) * Ee) % ge * ge + ye[x] + b) / Le | 0) + (G / ge | 0) + pe * Y, ye[x--] = ne % Le;
        ye[x] = b;
      }
      return b ? ++M : ye.splice(0, 1), We(l, ye, M);
    }, L.negated = function() {
      var l = new fe(this);
      return l.s = -l.s || null, l;
    }, L.plus = function(l, h) {
      var b, M = this, k = M.s;
      if (h = (l = new fe(l, h)).s, !k || !h)
        return new fe(NaN);
      if (k != h)
        return l.s = -h, M.minus(l);
      var x = M.e / S, O = l.e / S, G = M.c, Q = l.c;
      if (!x || !O) {
        if (!G || !Q)
          return new fe(k / 0);
        if (!G[0] || !Q[0])
          return Q[0] ? l : new fe(G[0] ? M : 0 * k);
      }
      if (x = N(x), O = N(O), G = G.slice(), k = x - O) {
        for (k > 0 ? (O = x, b = Q) : (k = -k, b = G), b.reverse(); k--; b.push(0))
          ;
        b.reverse();
      }
      for ((k = G.length) - (h = Q.length) < 0 && (b = Q, Q = G, G = b, h = k), k = 0; h; )
        k = (G[--h] = G[h] + Q[h] + k) / w | 0, G[h] = w === G[h] ? 0 : G[h] % w;
      return k && (G = [k].concat(G), ++O), We(l, G, O);
    }, L.precision = L.sd = function(l, h) {
      var b, M, k, x = this;
      if (l != null && l !== !!l)
        return z(l, 1, C), h == null ? h = X : z(h, 0, 8), de(new fe(x), l, h);
      if (!(b = x.c))
        return null;
      if (M = (k = b.length - 1) * S + 1, k = b[k]) {
        for (; k % 10 == 0; k /= 10, M--)
          ;
        for (k = b[0]; k >= 10; k /= 10, M++)
          ;
      }
      return l && x.e + 1 > M && (M = x.e + 1), M;
    }, L.shiftedBy = function(l) {
      return z(l, -9007199254740991, T), this.times("1e" + l);
    }, L.squareRoot = L.sqrt = function() {
      var l, h, b, M, k, x = this, O = x.c, G = x.s, Q = x.e, ne = J + 4, Y = new fe("0.5");
      if (G !== 1 || !O || !O[0])
        return new fe(!G || G < 0 && (!O || O[0]) ? NaN : O ? x : 1 / 0);
      if ((G = Math.sqrt(+ke(x))) == 0 || G == 1 / 0 ? (((h = q(O)).length + Q) % 2 == 0 && (h += "0"), G = Math.sqrt(+h), Q = N((Q + 1) / 2) - (Q < 0 || Q % 2), b = new fe(h = G == 1 / 0 ? "5e" + Q : (h = G.toExponential()).slice(0, h.indexOf("e") + 1) + Q)) : b = new fe(G + ""), b.c[0]) {
        for ((G = (Q = b.e) + ne) < 3 && (G = 0); ; )
          if (k = b, b = Y.times(k.plus(H(x, k, ne, 1))), q(k.c).slice(0, G) === (h = q(b.c)).slice(0, G)) {
            if (b.e < Q && --G, (h = h.slice(G - 3, G + 1)) != "9999" && (M || h != "4999")) {
              +h && (+h.slice(1) || h.charAt(0) != "5") || (de(b, b.e + J + 2, 1), l = !b.times(b).eq(x));
              break;
            }
            if (!M && (de(k, k.e + J + 2, 0), k.times(k).eq(x))) {
              b = k;
              break;
            }
            ne += 4, G += 4, M = 1;
          }
      }
      return de(b, b.e + J + 1, X, l);
    }, L.toExponential = function(l, h) {
      return l != null && (z(l, 0, C), l++), le(this, l, h, 1);
    }, L.toFixed = function(l, h) {
      return l != null && (z(l, 0, C), l = l + this.e + 1), le(this, l, h);
    }, L.toFormat = function(l, h, b) {
      var M, k = this;
      if (b == null)
        l != null && h && typeof h == "object" ? (b = h, h = null) : l && typeof l == "object" ? (b = l, l = h = null) : b = Se;
      else if (typeof b != "object")
        throw Error(m + "Argument not an object: " + b);
      if (M = k.toFixed(l, h), k.c) {
        var x, O = M.split("."), G = +b.groupSize, Q = +b.secondaryGroupSize, ne = b.groupSeparator || "", Y = O[0], ae = O[1], Ee = k.s < 0, pe = Ee ? Y.slice(1) : Y, ye = pe.length;
        if (Q && (x = G, G = Q, Q = x, ye -= x), G > 0 && ye > 0) {
          for (x = ye % G || G, Y = pe.substr(0, x); x < ye; x += G)
            Y += ne + pe.substr(x, G);
          Q > 0 && (Y += ne + pe.slice(x)), Ee && (Y = "-" + Y);
        }
        M = ae ? Y + (b.decimalSeparator || "") + ((Q = +b.fractionGroupSize) ? ae.replace(new RegExp("\\d{" + Q + "}\\B", "g"), "$&" + (b.fractionGroupSeparator || "")) : ae) : Y;
      }
      return (b.prefix || "") + M + (b.suffix || "");
    }, L.toFraction = function(l) {
      var h, b, M, k, x, O, G, Q, ne, Y, ae, Ee, pe = this, ye = pe.c;
      if (l != null && (!(G = new fe(l)).isInteger() && (G.c || G.s !== 1) || G.lt(j)))
        throw Error(m + "Argument " + (G.isInteger() ? "out of range: " : "not an integer: ") + ke(G));
      if (!ye)
        return new fe(pe);
      for (h = new fe(j), ne = b = new fe(j), M = Q = new fe(j), Ee = q(ye), x = h.e = Ee.length - pe.e - 1, h.c[0] = B[(O = x % S) < 0 ? S + O : O], l = !l || G.comparedTo(h) > 0 ? x > 0 ? h : ne : G, O = oe, oe = 1 / 0, G = new fe(Ee), Q.c[0] = 0; Y = H(G, h, 0, 1), (k = b.plus(Y.times(M))).comparedTo(l) != 1; )
        b = M, M = k, ne = Q.plus(Y.times(k = ne)), Q = k, h = G.minus(Y.times(k = h)), G = k;
      return k = H(l.minus(b), M, 0, 1), Q = Q.plus(k.times(ne)), b = b.plus(k.times(M)), Q.s = ne.s = pe.s, ae = H(ne, M, x *= 2, X).minus(pe).abs().comparedTo(H(Q, b, x, X).minus(pe).abs()) < 1 ? [ne, M] : [Q, b], oe = O, ae;
    }, L.toNumber = function() {
      return +ke(this);
    }, L.toPrecision = function(l, h) {
      return l != null && z(l, 1, C), le(this, l, h, 2);
    }, L.toString = function(l) {
      var h, b = this, M = b.s, k = b.e;
      return k === null ? M ? (h = "Infinity", M < 0 && (h = "-" + h)) : h = "NaN" : (l == null ? h = k <= re || k >= Z ? V(q(b.c), k) : ee(q(b.c), k, "0") : l === 10 && $e ? h = ee(q((b = de(new fe(b), J + k + 1, X)).c), b.e, "0") : (z(l, 2, he.length, "Base"), h = te(ee(q(b.c), k, "0"), 10, l, M, !0)), M < 0 && b.c[0] && (h = "-" + h)), h;
    }, L.valueOf = L.toJSON = function() {
      return ke(this);
    }, L._isBigNumber = !0, F != null && fe.set(F), fe;
  }(), n.default = n.BigNumber = n, t.exports ? t.exports = n : (o || (o = typeof self < "u" && self ? self : window), o.BigNumber = n);
}(commonjsGlobal), Object.defineProperty(ar$1, "__esModule", { value: !0 });
const bignumber_js_1$2 = bignumber.exports;
class Ar$1 {
  constructor() {
    this.BigNum = (n, a) => new (bignumber_js_1$2.BigNumber.clone({ DECIMAL_PLACES: a }))(n);
  }
  winstonToAr(n, { formatted: a = !1, decimals: u = 12, trim: c = !0 } = {}) {
    let m = this.stringToBigNum(n, u).shiftedBy(-12);
    return a ? m.toFormat(u) : m.toFixed(u);
  }
  arToWinston(n, { formatted: a = !1 } = {}) {
    let u = this.stringToBigNum(n).shiftedBy(12);
    return a ? u.toFormat() : u.toFixed(0);
  }
  compare(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.comparedTo(c);
  }
  isEqual(n, a) {
    return this.compare(n, a) === 0;
  }
  isLessThan(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.isLessThan(c);
  }
  isGreaterThan(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.isGreaterThan(c);
  }
  add(n, a) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(a), u.plus(a).toFixed(0);
  }
  sub(n, a) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(a), u.minus(a).toFixed(0);
  }
  stringToBigNum(n, a = 12) {
    return this.BigNum(n, a);
  }
}
ar$1.default = Ar$1;
var api$2 = {}, axios$2 = { exports: {} }, axios$1 = { exports: {} }, bind$2 = function(o, n) {
  return function() {
    for (var a = new Array(arguments.length), u = 0; u < a.length; u++)
      a[u] = arguments[u];
    return o.apply(n, a);
  };
}, bind$1 = bind$2, toString$1 = Object.prototype.toString, kindOf = (cache = /* @__PURE__ */ Object.create(null), function(o) {
  var n = toString$1.call(o);
  return cache[n] || (cache[n] = n.slice(8, -1).toLowerCase());
}), cache;
function kindOfTest(o) {
  return o = o.toLowerCase(), function(n) {
    return kindOf(n) === o;
  };
}
function isArray$4(o) {
  return Array.isArray(o);
}
function isUndefined(o) {
  return o === void 0;
}
function isBuffer$3(o) {
  return o !== null && !isUndefined(o) && o.constructor !== null && !isUndefined(o.constructor) && typeof o.constructor.isBuffer == "function" && o.constructor.isBuffer(o);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(o) {
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(o) : o && o.buffer && isArrayBuffer(o.buffer);
}
function isString(o) {
  return typeof o == "string";
}
function isNumber(o) {
  return typeof o == "number";
}
function isObject$7(o) {
  return o !== null && typeof o == "object";
}
function isPlainObject(o) {
  if (kindOf(o) !== "object")
    return !1;
  var n = Object.getPrototypeOf(o);
  return n === null || n === Object.prototype;
}
var isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob$1 = kindOfTest("Blob"), isFileList = kindOfTest("FileList");
function isFunction$3(o) {
  return toString$1.call(o) === "[object Function]";
}
function isStream(o) {
  return isObject$7(o) && isFunction$3(o.pipe);
}
function isFormData(o) {
  var n = "[object FormData]";
  return o && (typeof FormData == "function" && o instanceof FormData || toString$1.call(o) === n || isFunction$3(o.toString) && o.toString() === n);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(o) {
  return o.trim ? o.trim() : o.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return (typeof navigator > "u" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window < "u" && typeof document < "u";
}
function forEach(o, n) {
  if (o != null)
    if (typeof o != "object" && (o = [o]), isArray$4(o))
      for (var a = 0, u = o.length; a < u; a++)
        n.call(null, o[a], a, o);
    else
      for (var c in o)
        Object.prototype.hasOwnProperty.call(o, c) && n.call(null, o[c], c, o);
}
function merge() {
  var o = {};
  function n(c, m) {
    isPlainObject(o[m]) && isPlainObject(c) ? o[m] = merge(o[m], c) : isPlainObject(c) ? o[m] = merge({}, c) : isArray$4(c) ? o[m] = c.slice() : o[m] = c;
  }
  for (var a = 0, u = arguments.length; a < u; a++)
    forEach(arguments[a], n);
  return o;
}
function extend(o, n, a) {
  return forEach(n, function(u, c) {
    o[c] = a && typeof u == "function" ? bind$1(u, a) : u;
  }), o;
}
function stripBOM(o) {
  return o.charCodeAt(0) === 65279 && (o = o.slice(1)), o;
}
function inherits$a(o, n, a, u) {
  o.prototype = Object.create(n.prototype, u), o.prototype.constructor = o, a && Object.assign(o.prototype, a);
}
function toFlatObject(o, n, a) {
  var u, c, m, d = {};
  n = n || {};
  do {
    for (c = (u = Object.getOwnPropertyNames(o)).length; c-- > 0; )
      d[m = u[c]] || (n[m] = o[m], d[m] = !0);
    o = Object.getPrototypeOf(o);
  } while (o && (!a || a(o, n)) && o !== Object.prototype);
  return n;
}
function endsWith(o, n, a) {
  o = String(o), (a === void 0 || a > o.length) && (a = o.length), a -= n.length;
  var u = o.indexOf(n, a);
  return u !== -1 && u === a;
}
function toArray$1(o) {
  if (!o)
    return null;
  var n = o.length;
  if (isUndefined(n))
    return null;
  for (var a = new Array(n); n-- > 0; )
    a[n] = o[n];
  return a;
}
var isTypedArray$3 = (TypedArray = typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array), function(o) {
  return TypedArray && o instanceof TypedArray;
}), TypedArray, utils$C = { isArray: isArray$4, isArrayBuffer, isBuffer: isBuffer$3, isFormData, isArrayBufferView, isString, isNumber, isObject: isObject$7, isPlainObject, isUndefined, isDate, isFile, isBlob: isBlob$1, isFunction: isFunction$3, isStream, isURLSearchParams, isStandardBrowserEnv, forEach, merge, extend, trim, stripBOM, inherits: inherits$a, toFlatObject, kindOf, kindOfTest, endsWith, toArray: toArray$1, isTypedArray: isTypedArray$3, isFileList }, utils$B = utils$C;
function encode$2(o) {
  return encodeURIComponent(o).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function(o, n, a) {
  if (!n)
    return o;
  var u;
  if (a)
    u = a(n);
  else if (utils$B.isURLSearchParams(n))
    u = n.toString();
  else {
    var c = [];
    utils$B.forEach(n, function(d, w) {
      d != null && (utils$B.isArray(d) ? w += "[]" : d = [d], utils$B.forEach(d, function(S) {
        utils$B.isDate(S) ? S = S.toISOString() : utils$B.isObject(S) && (S = JSON.stringify(S)), c.push(encode$2(w) + "=" + encode$2(S));
      }));
    }), u = c.join("&");
  }
  if (u) {
    var m = o.indexOf("#");
    m !== -1 && (o = o.slice(0, m)), o += (o.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return o;
}, utils$A = utils$C;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function(o, n, a) {
  return this.handlers.push({ fulfilled: o, rejected: n, synchronous: !!a && a.synchronous, runWhen: a ? a.runWhen : null }), this.handlers.length - 1;
}, InterceptorManager$1.prototype.eject = function(o) {
  this.handlers[o] && (this.handlers[o] = null);
}, InterceptorManager$1.prototype.forEach = function(o) {
  utils$A.forEach(this.handlers, function(n) {
    n !== null && o(n);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$z = utils$C, normalizeHeaderName$1 = function(o, n) {
  utils$z.forEach(o, function(a, u) {
    u !== n && u.toUpperCase() === n.toUpperCase() && (o[n] = a, delete o[u]);
  });
}, utils$y = utils$C;
function AxiosError$2(o, n, a, u, c) {
  Error.call(this), this.message = o, this.name = "AxiosError", n && (this.code = n), a && (this.config = a), u && (this.request = u), c && (this.response = c);
}
utils$y.inherits(AxiosError$2, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
} });
var prototype = AxiosError$2.prototype, descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(o) {
  descriptors[o] = { value: o };
}), Object.defineProperties(AxiosError$2, descriptors), Object.defineProperty(prototype, "isAxiosError", { value: !0 }), AxiosError$2.from = function(o, n, a, u, c, m) {
  var d = Object.create(prototype);
  return utils$y.toFlatObject(o, d, function(w) {
    return w !== Error.prototype;
  }), AxiosError$2.call(d, o.message, n, a, u, c), d.name = o.name, m && Object.assign(d, m), d;
};
var AxiosError_1 = AxiosError$2, transitional = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, utils$x = utils$C;
function toFormData$1(o, n) {
  n = n || new FormData();
  var a = [];
  function u(c) {
    return c === null ? "" : utils$x.isDate(c) ? c.toISOString() : utils$x.isArrayBuffer(c) || utils$x.isTypedArray(c) ? typeof Blob == "function" ? new Blob([c]) : Buffer.from(c) : c;
  }
  return function c(m, d) {
    if (utils$x.isPlainObject(m) || utils$x.isArray(m)) {
      if (a.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + d);
      a.push(m), utils$x.forEach(m, function(w, S) {
        if (!utils$x.isUndefined(w)) {
          var T, B = d ? d + "." + S : S;
          if (w && !d && typeof w == "object") {
            if (utils$x.endsWith(S, "{}"))
              w = JSON.stringify(w);
            else if (utils$x.endsWith(S, "[]") && (T = utils$x.toArray(w)))
              return void T.forEach(function(I) {
                !utils$x.isUndefined(I) && n.append(B, u(I));
              });
          }
          c(w, B);
        }
      }), a.pop();
    } else
      n.append(d, u(m));
  }(o), n;
}
var toFormData_1 = toFormData$1, settle, hasRequiredSettle, cookies, hasRequiredCookies;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var o = AxiosError_1;
  return settle = function(n, a, u) {
    var c = u.config.validateStatus;
    u.status && c && !c(u.status) ? a(new o("Request failed with status code " + u.status, [o.ERR_BAD_REQUEST, o.ERR_BAD_RESPONSE][Math.floor(u.status / 100) - 4], u.config, u.request, u)) : n(u);
  };
}
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var o = utils$C;
  return cookies = o.isStandardBrowserEnv() ? { write: function(n, a, u, c, m, d) {
    var w = [];
    w.push(n + "=" + encodeURIComponent(a)), o.isNumber(u) && w.push("expires=" + new Date(u).toGMTString()), o.isString(c) && w.push("path=" + c), o.isString(m) && w.push("domain=" + m), d === !0 && w.push("secure"), document.cookie = w.join("; ");
  }, read: function(n) {
    var a = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
    return a ? decodeURIComponent(a[3]) : null;
  }, remove: function(n) {
    this.write(n, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } }, cookies;
}
var isAbsoluteURL$1 = function(o) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(o);
}, combineURLs$1 = function(o, n) {
  return n ? o.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : o;
}, isAbsoluteURL = isAbsoluteURL$1, combineURLs = combineURLs$1, buildFullPath$1 = function(o, n) {
  return o && !isAbsoluteURL(n) ? combineURLs(o, n) : n;
}, parseHeaders, hasRequiredParseHeaders, isURLSameOrigin, hasRequiredIsURLSameOrigin, CanceledError_1, hasRequiredCanceledError, parseProtocol, hasRequiredParseProtocol, xhr, hasRequiredXhr, _null, hasRequired_null;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var o = utils$C, n = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
  return parseHeaders = function(a) {
    var u, c, m, d = {};
    return a && o.forEach(a.split(`
`), function(w) {
      if (m = w.indexOf(":"), u = o.trim(w.substr(0, m)).toLowerCase(), c = o.trim(w.substr(m + 1)), u) {
        if (d[u] && n.indexOf(u) >= 0)
          return;
        d[u] = u === "set-cookie" ? (d[u] ? d[u] : []).concat([c]) : d[u] ? d[u] + ", " + c : c;
      }
    }), d;
  }, parseHeaders;
}
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var o = utils$C;
  return isURLSameOrigin = o.isStandardBrowserEnv() ? function() {
    var n, a = /(msie|trident)/i.test(navigator.userAgent), u = document.createElement("a");
    function c(m) {
      var d = m;
      return a && (u.setAttribute("href", d), d = u.href), u.setAttribute("href", d), { href: u.href, protocol: u.protocol ? u.protocol.replace(/:$/, "") : "", host: u.host, search: u.search ? u.search.replace(/^\?/, "") : "", hash: u.hash ? u.hash.replace(/^#/, "") : "", hostname: u.hostname, port: u.port, pathname: u.pathname.charAt(0) === "/" ? u.pathname : "/" + u.pathname };
    }
    return n = c(window.location.href), function(m) {
      var d = o.isString(m) ? c(m) : m;
      return d.protocol === n.protocol && d.host === n.host;
    };
  }() : function() {
    return !0;
  };
}
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var o = AxiosError_1;
  function n(a) {
    o.call(this, a == null ? "canceled" : a, o.ERR_CANCELED), this.name = "CanceledError";
  }
  return utils$C.inherits(n, o, { __CANCEL__: !0 }), CanceledError_1 = n;
}
function requireParseProtocol() {
  return hasRequiredParseProtocol ? parseProtocol : (hasRequiredParseProtocol = 1, parseProtocol = function(o) {
    var n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(o);
    return n && n[1] || "";
  });
}
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var o = utils$C, n = requireSettle(), a = requireCookies(), u = buildURL$1, c = buildFullPath$1, m = requireParseHeaders(), d = requireIsURLSameOrigin(), w = transitional, S = AxiosError_1, T = requireCanceledError(), B = requireParseProtocol();
  return xhr = function(I) {
    return new Promise(function(C, N) {
      var q, D = I.data, z = I.headers, W = I.responseType;
      function V() {
        I.cancelToken && I.cancelToken.unsubscribe(q), I.signal && I.signal.removeEventListener("abort", q);
      }
      o.isFormData(D) && o.isStandardBrowserEnv() && delete z["Content-Type"];
      var ee = new XMLHttpRequest();
      if (I.auth) {
        var P = I.auth.username || "", F = I.auth.password ? unescape(encodeURIComponent(I.auth.password)) : "";
        z.Authorization = "Basic " + btoa(P + ":" + F);
      }
      var H = c(I.baseURL, I.url);
      function te() {
        if (ee) {
          var _ = "getAllResponseHeaders" in ee ? m(ee.getAllResponseHeaders()) : null, y = { data: W && W !== "text" && W !== "json" ? ee.response : ee.responseText, status: ee.status, statusText: ee.statusText, headers: _, config: I, request: ee };
          n(function(g) {
            C(g), V();
          }, function(g) {
            N(g), V();
          }, y), ee = null;
        }
      }
      if (ee.open(I.method.toUpperCase(), u(H, I.params, I.paramsSerializer), !0), ee.timeout = I.timeout, "onloadend" in ee ? ee.onloadend = te : ee.onreadystatechange = function() {
        ee && ee.readyState === 4 && (ee.status !== 0 || ee.responseURL && ee.responseURL.indexOf("file:") === 0) && setTimeout(te);
      }, ee.onabort = function() {
        ee && (N(new S("Request aborted", S.ECONNABORTED, I, ee)), ee = null);
      }, ee.onerror = function() {
        N(new S("Network Error", S.ERR_NETWORK, I, ee, ee)), ee = null;
      }, ee.ontimeout = function() {
        var _ = I.timeout ? "timeout of " + I.timeout + "ms exceeded" : "timeout exceeded", y = I.transitional || w;
        I.timeoutErrorMessage && (_ = I.timeoutErrorMessage), N(new S(_, y.clarifyTimeoutError ? S.ETIMEDOUT : S.ECONNABORTED, I, ee)), ee = null;
      }, o.isStandardBrowserEnv()) {
        var p = (I.withCredentials || d(H)) && I.xsrfCookieName ? a.read(I.xsrfCookieName) : void 0;
        p && (z[I.xsrfHeaderName] = p);
      }
      "setRequestHeader" in ee && o.forEach(z, function(_, y) {
        D === void 0 && y.toLowerCase() === "content-type" ? delete z[y] : ee.setRequestHeader(y, _);
      }), o.isUndefined(I.withCredentials) || (ee.withCredentials = !!I.withCredentials), W && W !== "json" && (ee.responseType = I.responseType), typeof I.onDownloadProgress == "function" && ee.addEventListener("progress", I.onDownloadProgress), typeof I.onUploadProgress == "function" && ee.upload && ee.upload.addEventListener("progress", I.onUploadProgress), (I.cancelToken || I.signal) && (q = function(_) {
        ee && (N(!_ || _ && _.type ? new T() : _), ee.abort(), ee = null);
      }, I.cancelToken && I.cancelToken.subscribe(q), I.signal && (I.signal.aborted ? q() : I.signal.addEventListener("abort", q))), D || (D = null);
      var $ = B(H);
      $ && ["http", "https", "file"].indexOf($) === -1 ? N(new S("Unsupported protocol " + $ + ":", S.ERR_BAD_REQUEST, I)) : ee.send(D);
    });
  }, xhr;
}
function require_null() {
  return hasRequired_null ? _null : (hasRequired_null = 1, _null = null);
}
var utils$w = utils$C, normalizeHeaderName = normalizeHeaderName$1, AxiosError$1 = AxiosError_1, transitionalDefaults = transitional, toFormData = toFormData_1, DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset(o, n) {
  !utils$w.isUndefined(o) && utils$w.isUndefined(o["Content-Type"]) && (o["Content-Type"] = n);
}
function getDefaultAdapter() {
  var o;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (o = requireXhr()), o;
}
function stringifySafely(o, n, a) {
  if (utils$w.isString(o))
    try {
      return (n || JSON.parse)(o), utils$w.trim(o);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (a || JSON.stringify)(o);
}
var defaults$3 = { transitional: transitionalDefaults, adapter: getDefaultAdapter(), transformRequest: [function(o, n) {
  if (normalizeHeaderName(n, "Accept"), normalizeHeaderName(n, "Content-Type"), utils$w.isFormData(o) || utils$w.isArrayBuffer(o) || utils$w.isBuffer(o) || utils$w.isStream(o) || utils$w.isFile(o) || utils$w.isBlob(o))
    return o;
  if (utils$w.isArrayBufferView(o))
    return o.buffer;
  if (utils$w.isURLSearchParams(o))
    return setContentTypeIfUnset(n, "application/x-www-form-urlencoded;charset=utf-8"), o.toString();
  var a, u = utils$w.isObject(o), c = n && n["Content-Type"];
  if ((a = utils$w.isFileList(o)) || u && c === "multipart/form-data") {
    var m = this.env && this.env.FormData;
    return toFormData(a ? { "files[]": o } : o, m && new m());
  }
  return u || c === "application/json" ? (setContentTypeIfUnset(n, "application/json"), stringifySafely(o)) : o;
}], transformResponse: [function(o) {
  var n = this.transitional || defaults$3.transitional, a = n && n.silentJSONParsing, u = n && n.forcedJSONParsing, c = !a && this.responseType === "json";
  if (c || u && utils$w.isString(o) && o.length)
    try {
      return JSON.parse(o);
    } catch (m) {
      if (c)
        throw m.name === "SyntaxError" ? AxiosError$1.from(m, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : m;
    }
  return o;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: require_null() }, validateStatus: function(o) {
  return o >= 200 && o < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*" } } };
utils$w.forEach(["delete", "get", "head"], function(o) {
  defaults$3.headers[o] = {};
}), utils$w.forEach(["post", "put", "patch"], function(o) {
  defaults$3.headers[o] = utils$w.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$v = utils$C, defaults$2 = defaults_1, transformData$1 = function(o, n, a) {
  var u = this || defaults$2;
  return utils$v.forEach(a, function(c) {
    o = c.call(u, o, n);
  }), o;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel ? isCancel$1 : (hasRequiredIsCancel = 1, isCancel$1 = function(o) {
    return !(!o || !o.__CANCEL__);
  });
}
var utils$u = utils$C, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1, CanceledError = requireCanceledError();
function throwIfCancellationRequested(o) {
  if (o.cancelToken && o.cancelToken.throwIfRequested(), o.signal && o.signal.aborted)
    throw new CanceledError();
}
var dispatchRequest$1 = function(o) {
  return throwIfCancellationRequested(o), o.headers = o.headers || {}, o.data = transformData.call(o, o.data, o.headers, o.transformRequest), o.headers = utils$u.merge(o.headers.common || {}, o.headers[o.method] || {}, o.headers), utils$u.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(n) {
    delete o.headers[n];
  }), (o.adapter || defaults$1.adapter)(o).then(function(n) {
    return throwIfCancellationRequested(o), n.data = transformData.call(o, n.data, n.headers, o.transformResponse), n;
  }, function(n) {
    return isCancel(n) || (throwIfCancellationRequested(o), n && n.response && (n.response.data = transformData.call(o, n.response.data, n.response.headers, o.transformResponse))), Promise.reject(n);
  });
}, utils$t = utils$C, mergeConfig$2 = function(o, n) {
  n = n || {};
  var a = {};
  function u(T, B) {
    return utils$t.isPlainObject(T) && utils$t.isPlainObject(B) ? utils$t.merge(T, B) : utils$t.isPlainObject(B) ? utils$t.merge({}, B) : utils$t.isArray(B) ? B.slice() : B;
  }
  function c(T) {
    return utils$t.isUndefined(n[T]) ? utils$t.isUndefined(o[T]) ? void 0 : u(void 0, o[T]) : u(o[T], n[T]);
  }
  function m(T) {
    if (!utils$t.isUndefined(n[T]))
      return u(void 0, n[T]);
  }
  function d(T) {
    return utils$t.isUndefined(n[T]) ? utils$t.isUndefined(o[T]) ? void 0 : u(void 0, o[T]) : u(void 0, n[T]);
  }
  function w(T) {
    return T in n ? u(o[T], n[T]) : T in o ? u(void 0, o[T]) : void 0;
  }
  var S = { url: m, method: m, data: m, baseURL: d, transformRequest: d, transformResponse: d, paramsSerializer: d, timeout: d, timeoutMessage: d, withCredentials: d, adapter: d, responseType: d, xsrfCookieName: d, xsrfHeaderName: d, onUploadProgress: d, onDownloadProgress: d, decompress: d, maxContentLength: d, maxBodyLength: d, beforeRedirect: d, transport: d, httpAgent: d, httpsAgent: d, cancelToken: d, socketPath: d, responseEncoding: d, validateStatus: w };
  return utils$t.forEach(Object.keys(o).concat(Object.keys(n)), function(T) {
    var B = S[T] || c, I = B(T);
    utils$t.isUndefined(I) && B !== w || (a[T] = I);
  }), a;
}, data$1, hasRequiredData;
function requireData() {
  return hasRequiredData ? data$1 : (hasRequiredData = 1, data$1 = { version: "0.27.2" });
}
var VERSION = requireData().version, AxiosError = AxiosError_1, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(o, n) {
  validators$1[o] = function(a) {
    return typeof a === o || "a" + (n < 1 ? "n " : " ") + o;
  };
});
var deprecatedWarnings = {};
function assertOptions(o, n, a) {
  if (typeof o != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  for (var u = Object.keys(o), c = u.length; c-- > 0; ) {
    var m = u[c], d = n[m];
    if (d) {
      var w = o[m], S = w === void 0 || d(w, m, o);
      if (S !== !0)
        throw new AxiosError("option " + m + " must be " + S, AxiosError.ERR_BAD_OPTION_VALUE);
    } else if (a !== !0)
      throw new AxiosError("Unknown option " + m, AxiosError.ERR_BAD_OPTION);
  }
}
validators$1.transitional = function(o, n, a) {
  function u(c, m) {
    return "[Axios v" + VERSION + "] Transitional option '" + c + "'" + m + (a ? ". " + a : "");
  }
  return function(c, m, d) {
    if (o === !1)
      throw new AxiosError(u(m, " has been removed" + (n ? " in " + n : "")), AxiosError.ERR_DEPRECATED);
    return n && !deprecatedWarnings[m] && (deprecatedWarnings[m] = !0, console.warn(u(m, " has been deprecated since v" + n + " and will be removed in the near future"))), !o || o(c, m, d);
  };
};
var validator$1 = { assertOptions, validators: validators$1 }, utils$s = utils$C, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, buildFullPath = buildFullPath$1, validator = validator$1, validators = validator.validators;
function Axios$1(o) {
  this.defaults = o, this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };
}
Axios$1.prototype.request = function(o, n) {
  typeof o == "string" ? (n = n || {}).url = o : n = o || {}, (n = mergeConfig$1(this.defaults, n)).method ? n.method = n.method.toLowerCase() : this.defaults.method ? n.method = this.defaults.method.toLowerCase() : n.method = "get";
  var a = n.transitional;
  a !== void 0 && validator.assertOptions(a, { silentJSONParsing: validators.transitional(validators.boolean), forcedJSONParsing: validators.transitional(validators.boolean), clarifyTimeoutError: validators.transitional(validators.boolean) }, !1);
  var u = [], c = !0;
  this.interceptors.request.forEach(function(I) {
    typeof I.runWhen == "function" && I.runWhen(n) === !1 || (c = c && I.synchronous, u.unshift(I.fulfilled, I.rejected));
  });
  var m, d = [];
  if (this.interceptors.response.forEach(function(I) {
    d.push(I.fulfilled, I.rejected);
  }), !c) {
    var w = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(w, u), w = w.concat(d), m = Promise.resolve(n); w.length; )
      m = m.then(w.shift(), w.shift());
    return m;
  }
  for (var S = n; u.length; ) {
    var T = u.shift(), B = u.shift();
    try {
      S = T(S);
    } catch (I) {
      B(I);
      break;
    }
  }
  try {
    m = dispatchRequest(S);
  } catch (I) {
    return Promise.reject(I);
  }
  for (; d.length; )
    m = m.then(d.shift(), d.shift());
  return m;
}, Axios$1.prototype.getUri = function(o) {
  o = mergeConfig$1(this.defaults, o);
  var n = buildFullPath(o.baseURL, o.url);
  return buildURL(n, o.params, o.paramsSerializer);
}, utils$s.forEach(["delete", "get", "head", "options"], function(o) {
  Axios$1.prototype[o] = function(n, a) {
    return this.request(mergeConfig$1(a || {}, { method: o, url: n, data: (a || {}).data }));
  };
}), utils$s.forEach(["post", "put", "patch"], function(o) {
  function n(a) {
    return function(u, c, m) {
      return this.request(mergeConfig$1(m || {}, { method: o, headers: a ? { "Content-Type": "multipart/form-data" } : {}, url: u, data: c }));
    };
  }
  Axios$1.prototype[o] = n(), Axios$1.prototype[o + "Form"] = n(!0);
});
var Axios_1 = Axios$1, CancelToken_1, hasRequiredCancelToken, spread, hasRequiredSpread, isAxiosError, hasRequiredIsAxiosError;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var o = requireCanceledError();
  function n(a) {
    if (typeof a != "function")
      throw new TypeError("executor must be a function.");
    var u;
    this.promise = new Promise(function(m) {
      u = m;
    });
    var c = this;
    this.promise.then(function(m) {
      if (c._listeners) {
        var d, w = c._listeners.length;
        for (d = 0; d < w; d++)
          c._listeners[d](m);
        c._listeners = null;
      }
    }), this.promise.then = function(m) {
      var d, w = new Promise(function(S) {
        c.subscribe(S), d = S;
      }).then(m);
      return w.cancel = function() {
        c.unsubscribe(d);
      }, w;
    }, a(function(m) {
      c.reason || (c.reason = new o(m), u(c.reason));
    });
  }
  return n.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, n.prototype.subscribe = function(a) {
    this.reason ? a(this.reason) : this._listeners ? this._listeners.push(a) : this._listeners = [a];
  }, n.prototype.unsubscribe = function(a) {
    if (this._listeners) {
      var u = this._listeners.indexOf(a);
      u !== -1 && this._listeners.splice(u, 1);
    }
  }, n.source = function() {
    var a;
    return { token: new n(function(u) {
      a = u;
    }), cancel: a };
  }, CancelToken_1 = n;
}
function requireSpread() {
  return hasRequiredSpread ? spread : (hasRequiredSpread = 1, spread = function(o) {
    return function(n) {
      return o.apply(null, n);
    };
  });
}
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var o = utils$C;
  return isAxiosError = function(n) {
    return o.isObject(n) && n.isAxiosError === !0;
  };
}
var utils$r = utils$C, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(o) {
  var n = new Axios(o), a = bind(Axios.prototype.request, n);
  return utils$r.extend(a, Axios.prototype, n), utils$r.extend(a, n), a.create = function(u) {
    return createInstance(mergeConfig(o, u));
  }, a;
}
var axios = createInstance(defaults);
axios.Axios = Axios, axios.CanceledError = requireCanceledError(), axios.CancelToken = requireCancelToken(), axios.isCancel = requireIsCancel(), axios.VERSION = requireData().version, axios.toFormData = toFormData_1, axios.AxiosError = AxiosError_1, axios.Cancel = axios.CanceledError, axios.all = function(o) {
  return Promise.all(o);
}, axios.spread = requireSpread(), axios.isAxiosError = requireIsAxiosError(), axios$1.exports = axios, axios$1.exports.default = axios, axios$2.exports = axios$1.exports, Object.defineProperty(api$2, "__esModule", { value: !0 });
const axios_1$1 = axios$2.exports;
class Api$1 {
  constructor(n) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(n);
  }
  applyConfig(n) {
    this.config = this.mergeDefaults(n);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(n) {
    const a = n.protocol || "http", u = n.port || (a === "https" ? 443 : 80);
    return { host: n.host || "127.0.0.1", protocol: a, port: u, timeout: n.timeout || 2e4, logging: n.logging || !1, logger: n.logger || console.log, network: n.network };
  }
  async get(n, a) {
    try {
      return await this.request().get(n, a);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(n, a, u) {
    try {
      return await this.request().post(n, a, u);
    } catch (c) {
      if (c.response && c.response.status)
        return c.response;
      throw c;
    }
  }
  request() {
    const n = {};
    this.config.network && (n["x-network"] = this.config.network);
    let a = axios_1$1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: n });
    return this.config.logging && (a.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), a.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), a;
  }
}
api$2.default = Api$1;
var webcryptoDriver = {}, utils$q = {}, base64Js = {};
base64Js.byteLength = byteLength, base64Js.toByteArray = toByteArray, base64Js.fromByteArray = fromByteArray;
for (var lookup$1 = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code$1.length; i < len; ++i)
  lookup$1[i] = code$1[i], revLookup[code$1.charCodeAt(i)] = i;
function getLens(o) {
  var n = o.length;
  if (n % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var a = o.indexOf("=");
  return a === -1 && (a = n), [a, a === n ? 0 : 4 - a % 4];
}
function byteLength(o) {
  var n = getLens(o), a = n[0], u = n[1];
  return 3 * (a + u) / 4 - u;
}
function _byteLength(o, n, a) {
  return 3 * (n + a) / 4 - a;
}
function toByteArray(o) {
  var n, a, u = getLens(o), c = u[0], m = u[1], d = new Arr(_byteLength(o, c, m)), w = 0, S = m > 0 ? c - 4 : c;
  for (a = 0; a < S; a += 4)
    n = revLookup[o.charCodeAt(a)] << 18 | revLookup[o.charCodeAt(a + 1)] << 12 | revLookup[o.charCodeAt(a + 2)] << 6 | revLookup[o.charCodeAt(a + 3)], d[w++] = n >> 16 & 255, d[w++] = n >> 8 & 255, d[w++] = 255 & n;
  return m === 2 && (n = revLookup[o.charCodeAt(a)] << 2 | revLookup[o.charCodeAt(a + 1)] >> 4, d[w++] = 255 & n), m === 1 && (n = revLookup[o.charCodeAt(a)] << 10 | revLookup[o.charCodeAt(a + 1)] << 4 | revLookup[o.charCodeAt(a + 2)] >> 2, d[w++] = n >> 8 & 255, d[w++] = 255 & n), d;
}
function tripletToBase64(o) {
  return lookup$1[o >> 18 & 63] + lookup$1[o >> 12 & 63] + lookup$1[o >> 6 & 63] + lookup$1[63 & o];
}
function encodeChunk(o, n, a) {
  for (var u, c = [], m = n; m < a; m += 3)
    u = (o[m] << 16 & 16711680) + (o[m + 1] << 8 & 65280) + (255 & o[m + 2]), c.push(tripletToBase64(u));
  return c.join("");
}
function fromByteArray(o) {
  for (var n, a = o.length, u = a % 3, c = [], m = 16383, d = 0, w = a - u; d < w; d += m)
    c.push(encodeChunk(o, d, d + m > w ? w : d + m));
  return u === 1 ? (n = o[a - 1], c.push(lookup$1[n >> 2] + lookup$1[n << 4 & 63] + "==")) : u === 2 && (n = (o[a - 2] << 8) + o[a - 1], c.push(lookup$1[n >> 10] + lookup$1[n >> 4 & 63] + lookup$1[n << 2 & 63] + "=")), c.join("");
}
revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
var util = {}, types = {}, shams$1, hasRequiredShams$1, shams, hasRequiredShams, hasSymbols, hasRequiredHasSymbols, implementation, hasRequiredImplementation, functionBind, hasRequiredFunctionBind, src, hasRequiredSrc, getIntrinsic, hasRequiredGetIntrinsic;
function requireShams$1() {
  return hasRequiredShams$1 ? shams$1 : (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var o = {}, n = Symbol("test"), a = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
      return !1;
    for (n in o[n] = 42, o)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0)
      return !1;
    var u = Object.getOwnPropertySymbols(o);
    if (u.length !== 1 || u[0] !== n || !Object.prototype.propertyIsEnumerable.call(o, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = Object.getOwnPropertyDescriptor(o, n);
      if (c.value !== 42 || c.enumerable !== !0)
        return !1;
    }
    return !0;
  });
}
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var o = requireShams$1();
  return shams = function() {
    return o() && !!Symbol.toStringTag;
  };
}
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var o = typeof Symbol < "u" && Symbol, n = requireShams$1();
  return hasSymbols = function() {
    return typeof o == "function" && typeof Symbol == "function" && typeof o("foo") == "symbol" && typeof Symbol("bar") == "symbol" && n();
  };
}
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var o = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, a = Object.prototype.toString, u = "[object Function]";
  return implementation = function(c) {
    var m = this;
    if (typeof m != "function" || a.call(m) !== u)
      throw new TypeError(o + m);
    for (var d, w = n.call(arguments, 1), S = function() {
      if (this instanceof d) {
        var N = m.apply(this, w.concat(n.call(arguments)));
        return Object(N) === N ? N : this;
      }
      return m.apply(c, w.concat(n.call(arguments)));
    }, T = Math.max(0, m.length - w.length), B = [], I = 0; I < T; I++)
      B.push("$" + I);
    if (d = Function("binder", "return function (" + B.join(",") + "){ return binder.apply(this,arguments); }")(S), m.prototype) {
      var C = function() {
      };
      C.prototype = m.prototype, d.prototype = new C(), C.prototype = null;
    }
    return d;
  }, implementation;
}
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var o = requireImplementation();
  return functionBind = Function.prototype.bind || o;
}
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var o = requireFunctionBind();
  return src = o.call(Function.call, Object.prototype.hasOwnProperty);
}
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  var o;
  hasRequiredGetIntrinsic = 1;
  var n = SyntaxError, a = Function, u = TypeError, c = function(_) {
    try {
      return a('"use strict"; return (' + _ + ").constructor;")();
    } catch {
    }
  }, m = Object.getOwnPropertyDescriptor;
  if (m)
    try {
      m({}, "");
    } catch {
      m = null;
    }
  var d = function() {
    throw new u();
  }, w = m ? function() {
    try {
      return d;
    } catch {
      try {
        return m(arguments, "callee").get;
      } catch {
        return d;
      }
    }
  }() : d, S = requireHasSymbols()(), T = Object.getPrototypeOf || function(_) {
    return _.__proto__;
  }, B = {}, I = typeof Uint8Array > "u" ? o : T(Uint8Array), C = { "%AggregateError%": typeof AggregateError > "u" ? o : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? o : ArrayBuffer, "%ArrayIteratorPrototype%": S ? T([][Symbol.iterator]()) : o, "%AsyncFromSyncIteratorPrototype%": o, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? o : Atomics, "%BigInt%": typeof BigInt > "u" ? o : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? o : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? o : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? o : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? o : FinalizationRegistry, "%Function%": a, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? o : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? o : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? o : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": S ? T(T([][Symbol.iterator]())) : o, "%JSON%": typeof JSON == "object" ? JSON : o, "%Map%": typeof Map > "u" ? o : Map, "%MapIteratorPrototype%": typeof Map < "u" && S ? T((/* @__PURE__ */ new Map())[Symbol.iterator]()) : o, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? o : Promise, "%Proxy%": typeof Proxy > "u" ? o : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? o : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? o : Set, "%SetIteratorPrototype%": typeof Set < "u" && S ? T((/* @__PURE__ */ new Set())[Symbol.iterator]()) : o, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? o : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": S ? T(""[Symbol.iterator]()) : o, "%Symbol%": S ? Symbol : o, "%SyntaxError%": n, "%ThrowTypeError%": w, "%TypedArray%": I, "%TypeError%": u, "%Uint8Array%": typeof Uint8Array > "u" ? o : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? o : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? o : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? o : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? o : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? o : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? o : WeakSet }, N = function _(y) {
    var g;
    if (y === "%AsyncFunction%")
      g = c("async function () {}");
    else if (y === "%GeneratorFunction%")
      g = c("function* () {}");
    else if (y === "%AsyncGeneratorFunction%")
      g = c("async function* () {}");
    else if (y === "%AsyncGenerator%") {
      var v = _("%AsyncGeneratorFunction%");
      v && (g = v.prototype);
    } else if (y === "%AsyncIteratorPrototype%") {
      var E = _("%AsyncGenerator%");
      E && (g = T(E.prototype));
    }
    return C[y] = g, g;
  }, q = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, D = requireFunctionBind(), z = requireSrc(), W = D.call(Function.call, Array.prototype.concat), V = D.call(Function.apply, Array.prototype.splice), ee = D.call(Function.call, String.prototype.replace), P = D.call(Function.call, String.prototype.slice), F = D.call(Function.call, RegExp.prototype.exec), H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, te = /\\(\\)?/g, p = function(_) {
    var y = P(_, 0, 1), g = P(_, -1);
    if (y === "%" && g !== "%")
      throw new n("invalid intrinsic syntax, expected closing `%`");
    if (g === "%" && y !== "%")
      throw new n("invalid intrinsic syntax, expected opening `%`");
    var v = [];
    return ee(_, H, function(E, A, L, j) {
      v[v.length] = L ? ee(j, te, "$1") : A || E;
    }), v;
  }, $ = function(_, y) {
    var g, v = _;
    if (z(q, v) && (v = "%" + (g = q[v])[0] + "%"), z(C, v)) {
      var E = C[v];
      if (E === B && (E = N(v)), E === void 0 && !y)
        throw new u("intrinsic " + _ + " exists, but is not available. Please file an issue!");
      return { alias: g, name: v, value: E };
    }
    throw new n("intrinsic " + _ + " does not exist!");
  };
  return getIntrinsic = function(_, y) {
    if (typeof _ != "string" || _.length === 0)
      throw new u("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof y != "boolean")
      throw new u('"allowMissing" argument must be a boolean');
    if (F(/^%?[^%]*%?$/, _) === null)
      throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var g = p(_), v = g.length > 0 ? g[0] : "", E = $("%" + v + "%", y), A = E.name, L = E.value, j = !1, J = E.alias;
    J && (v = J[0], V(g, W([0, 1], J)));
    for (var X = 1, re = !0; X < g.length; X += 1) {
      var Z = g[X], ie = P(Z, 0, 1), oe = P(Z, -1);
      if ((ie === '"' || ie === "'" || ie === "`" || oe === '"' || oe === "'" || oe === "`") && ie !== oe)
        throw new n("property names with quotes must have matching quotes");
      if (Z !== "constructor" && re || (j = !0), z(C, A = "%" + (v += "." + Z) + "%"))
        L = C[A];
      else if (L != null) {
        if (!(Z in L)) {
          if (!y)
            throw new u("base intrinsic for " + _ + " exists, but the property is not available.");
          return;
        }
        if (m && X + 1 >= g.length) {
          var ue = m(L, Z);
          L = (re = !!ue) && "get" in ue && !("originalValue" in ue.get) ? ue.get : L[Z];
        } else
          re = z(L, Z), L = L[Z];
        re && !j && (C[A] = L);
      }
    }
    return L;
  }, getIntrinsic;
}
var callBind = { exports: {} }, hasRequiredCallBind, callBound, hasRequiredCallBound, isArguments$2, hasRequiredIsArguments, isGeneratorFunction, hasRequiredIsGeneratorFunction, isCallable, hasRequiredIsCallable, forEach_1, hasRequiredForEach, availableTypedArrays, hasRequiredAvailableTypedArrays, getOwnPropertyDescriptor, hasRequiredGetOwnPropertyDescriptor, isTypedArray$2, hasRequiredIsTypedArray, whichTypedArray, hasRequiredWhichTypedArray, hasRequiredTypes, isBufferBrowser, hasRequiredIsBufferBrowser;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(o) {
    var n = requireFunctionBind(), a = requireGetIntrinsic(), u = a("%Function.prototype.apply%"), c = a("%Function.prototype.call%"), m = a("%Reflect.apply%", !0) || n.call(c, u), d = a("%Object.getOwnPropertyDescriptor%", !0), w = a("%Object.defineProperty%", !0), S = a("%Math.max%");
    if (w)
      try {
        w({}, "a", { value: 1 });
      } catch {
        w = null;
      }
    o.exports = function(B) {
      var I = m(n, c, arguments);
      if (d && w) {
        var C = d(I, "length");
        C.configurable && w(I, "length", { value: 1 + S(0, B.length - (arguments.length - 1)) });
      }
      return I;
    };
    var T = function() {
      return m(n, u, arguments);
    };
    w ? w(o.exports, "apply", { value: T }) : o.exports.apply = T;
  }(callBind)), callBind.exports;
}
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var o = requireGetIntrinsic(), n = requireCallBind(), a = n(o("String.prototype.indexOf"));
  return callBound = function(u, c) {
    var m = o(u, !!c);
    return typeof m == "function" && a(u, ".prototype.") > -1 ? n(m) : m;
  }, callBound;
}
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments$2;
  hasRequiredIsArguments = 1;
  var o = requireShams()(), n = requireCallBound()("Object.prototype.toString"), a = function(m) {
    return !(o && m && typeof m == "object" && Symbol.toStringTag in m) && n(m) === "[object Arguments]";
  }, u = function(m) {
    return !!a(m) || m !== null && typeof m == "object" && typeof m.length == "number" && m.length >= 0 && n(m) !== "[object Array]" && n(m.callee) === "[object Function]";
  }, c = function() {
    return a(arguments);
  }();
  return a.isLegacyArguments = u, isArguments$2 = c ? a : u;
}
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var o, n = Object.prototype.toString, a = Function.prototype.toString, u = /^\s*(?:function)?\*/, c = requireShams()(), m = Object.getPrototypeOf;
  return isGeneratorFunction = function(d) {
    if (typeof d != "function")
      return !1;
    if (u.test(a.call(d)))
      return !0;
    if (!c)
      return n.call(d) === "[object GeneratorFunction]";
    if (!m)
      return !1;
    if (o === void 0) {
      var w = function() {
        if (!c)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }();
      o = !!w && m(w);
    }
    return m(d) === o;
  };
}
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var o, n, a = Function.prototype.toString, u = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
  if (typeof u == "function" && typeof Object.defineProperty == "function")
    try {
      o = Object.defineProperty({}, "length", { get: function() {
        throw n;
      } }), n = {}, u(function() {
        throw 42;
      }, null, o);
    } catch (C) {
      C !== n && (u = null);
    }
  else
    u = null;
  var c = /^\s*class\b/, m = function(C) {
    try {
      var N = a.call(C);
      return c.test(N);
    } catch {
      return !1;
    }
  }, d = function(C) {
    try {
      return !m(C) && (a.call(C), !0);
    } catch {
      return !1;
    }
  }, w = Object.prototype.toString, S = typeof Symbol == "function" && !!Symbol.toStringTag, T = !(0 in [,]), B = function() {
    return !1;
  };
  if (typeof document == "object") {
    var I = document.all;
    w.call(I) === w.call(document.all) && (B = function(C) {
      if ((T || !C) && (C === void 0 || typeof C == "object"))
        try {
          var N = w.call(C);
          return (N === "[object HTMLAllCollection]" || N === "[object HTML document.all class]" || N === "[object HTMLCollection]" || N === "[object Object]") && C("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = u ? function(C) {
    if (B(C))
      return !0;
    if (!C || typeof C != "function" && typeof C != "object")
      return !1;
    try {
      u(C, null, o);
    } catch (N) {
      if (N !== n)
        return !1;
    }
    return !m(C) && d(C);
  } : function(C) {
    if (B(C))
      return !0;
    if (!C || typeof C != "function" && typeof C != "object")
      return !1;
    if (S)
      return d(C);
    if (m(C))
      return !1;
    var N = w.call(C);
    return !(N !== "[object Function]" && N !== "[object GeneratorFunction]" && !/^\[object HTML/.test(N)) && d(C);
  };
}
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var o = requireIsCallable(), n = Object.prototype.toString, a = Object.prototype.hasOwnProperty, u = function(d, w, S) {
    for (var T = 0, B = d.length; T < B; T++)
      a.call(d, T) && (S == null ? w(d[T], T, d) : w.call(S, d[T], T, d));
  }, c = function(d, w, S) {
    for (var T = 0, B = d.length; T < B; T++)
      S == null ? w(d.charAt(T), T, d) : w.call(S, d.charAt(T), T, d);
  }, m = function(d, w, S) {
    for (var T in d)
      a.call(d, T) && (S == null ? w(d[T], T, d) : w.call(S, d[T], T, d));
  };
  return forEach_1 = function(d, w, S) {
    if (!o(w))
      throw new TypeError("iterator must be a function");
    var T;
    arguments.length >= 3 && (T = S), n.call(d) === "[object Array]" ? u(d, w, T) : typeof d == "string" ? c(d, w, T) : m(d, w, T);
  }, forEach_1;
}
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var o = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], n = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var a = [], u = 0; u < o.length; u++)
      typeof n[o[u]] == "function" && (a[a.length] = o[u]);
    return a;
  }, availableTypedArrays;
}
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var o = requireGetIntrinsic()("%Object.getOwnPropertyDescriptor%", !0);
  if (o)
    try {
      o([], "length");
    } catch {
      o = null;
    }
  return getOwnPropertyDescriptor = o;
}
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$2;
  hasRequiredIsTypedArray = 1;
  var o = requireForEach(), n = requireAvailableTypedArrays(), a = requireCallBound(), u = a("Object.prototype.toString"), c = requireShams()(), m = typeof globalThis > "u" ? commonjsGlobal : globalThis, d = n(), w = a("Array.prototype.indexOf", !0) || function(C, N) {
    for (var q = 0; q < C.length; q += 1)
      if (C[q] === N)
        return q;
    return -1;
  }, S = a("String.prototype.slice"), T = {}, B = requireGetOwnPropertyDescriptor(), I = Object.getPrototypeOf;
  return c && B && I && o(d, function(C) {
    var N = new m[C]();
    if (Symbol.toStringTag in N) {
      var q = I(N), D = B(q, Symbol.toStringTag);
      if (!D) {
        var z = I(q);
        D = B(z, Symbol.toStringTag);
      }
      T[C] = D.get;
    }
  }), isTypedArray$2 = function(C) {
    if (!C || typeof C != "object")
      return !1;
    if (!c || !(Symbol.toStringTag in C)) {
      var N = S(u(C), 8, -1);
      return w(d, N) > -1;
    }
    return !!B && function(q) {
      var D = !1;
      return o(T, function(z, W) {
        if (!D)
          try {
            D = z.call(q) === W;
          } catch {
          }
      }), D;
    }(C);
  };
}
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var o = requireForEach(), n = requireAvailableTypedArrays(), a = requireCallBound(), u = a("Object.prototype.toString"), c = requireShams()(), m = typeof globalThis > "u" ? commonjsGlobal : globalThis, d = n(), w = a("String.prototype.slice"), S = {}, T = requireGetOwnPropertyDescriptor(), B = Object.getPrototypeOf;
  c && T && B && o(d, function(C) {
    if (typeof m[C] == "function") {
      var N = new m[C]();
      if (Symbol.toStringTag in N) {
        var q = B(N), D = T(q, Symbol.toStringTag);
        if (!D) {
          var z = B(q);
          D = T(z, Symbol.toStringTag);
        }
        S[C] = D.get;
      }
    }
  });
  var I = requireIsTypedArray();
  return whichTypedArray = function(C) {
    return !!I(C) && (c && Symbol.toStringTag in C ? function(N) {
      var q = !1;
      return o(S, function(D, z) {
        if (!q)
          try {
            var W = D.call(N);
            W === z && (q = W);
          } catch {
          }
      }), q;
    }(C) : w(u(C), 8, -1));
  }, whichTypedArray;
}
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(o) {
    var n = requireIsArguments(), a = requireIsGeneratorFunction(), u = requireWhichTypedArray(), c = requireIsTypedArray();
    function m(A) {
      return A.call.bind(A);
    }
    var d = typeof BigInt < "u", w = typeof Symbol < "u", S = m(Object.prototype.toString), T = m(Number.prototype.valueOf), B = m(String.prototype.valueOf), I = m(Boolean.prototype.valueOf);
    if (d)
      var C = m(BigInt.prototype.valueOf);
    if (w)
      var N = m(Symbol.prototype.valueOf);
    function q(A, L) {
      if (typeof A != "object")
        return !1;
      try {
        return L(A), !0;
      } catch {
        return !1;
      }
    }
    function D(A) {
      return S(A) === "[object Map]";
    }
    function z(A) {
      return S(A) === "[object Set]";
    }
    function W(A) {
      return S(A) === "[object WeakMap]";
    }
    function V(A) {
      return S(A) === "[object WeakSet]";
    }
    function ee(A) {
      return S(A) === "[object ArrayBuffer]";
    }
    function P(A) {
      return typeof ArrayBuffer < "u" && (ee.working ? ee(A) : A instanceof ArrayBuffer);
    }
    function F(A) {
      return S(A) === "[object DataView]";
    }
    function H(A) {
      return typeof DataView < "u" && (F.working ? F(A) : A instanceof DataView);
    }
    o.isArgumentsObject = n, o.isGeneratorFunction = a, o.isTypedArray = c, o.isPromise = function(A) {
      return typeof Promise < "u" && A instanceof Promise || A !== null && typeof A == "object" && typeof A.then == "function" && typeof A.catch == "function";
    }, o.isArrayBufferView = function(A) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(A) : c(A) || H(A);
    }, o.isUint8Array = function(A) {
      return u(A) === "Uint8Array";
    }, o.isUint8ClampedArray = function(A) {
      return u(A) === "Uint8ClampedArray";
    }, o.isUint16Array = function(A) {
      return u(A) === "Uint16Array";
    }, o.isUint32Array = function(A) {
      return u(A) === "Uint32Array";
    }, o.isInt8Array = function(A) {
      return u(A) === "Int8Array";
    }, o.isInt16Array = function(A) {
      return u(A) === "Int16Array";
    }, o.isInt32Array = function(A) {
      return u(A) === "Int32Array";
    }, o.isFloat32Array = function(A) {
      return u(A) === "Float32Array";
    }, o.isFloat64Array = function(A) {
      return u(A) === "Float64Array";
    }, o.isBigInt64Array = function(A) {
      return u(A) === "BigInt64Array";
    }, o.isBigUint64Array = function(A) {
      return u(A) === "BigUint64Array";
    }, D.working = typeof Map < "u" && D(/* @__PURE__ */ new Map()), o.isMap = function(A) {
      return typeof Map < "u" && (D.working ? D(A) : A instanceof Map);
    }, z.working = typeof Set < "u" && z(/* @__PURE__ */ new Set()), o.isSet = function(A) {
      return typeof Set < "u" && (z.working ? z(A) : A instanceof Set);
    }, W.working = typeof WeakMap < "u" && W(/* @__PURE__ */ new WeakMap()), o.isWeakMap = function(A) {
      return typeof WeakMap < "u" && (W.working ? W(A) : A instanceof WeakMap);
    }, V.working = typeof WeakSet < "u" && V(/* @__PURE__ */ new WeakSet()), o.isWeakSet = function(A) {
      return V(A);
    }, ee.working = typeof ArrayBuffer < "u" && ee(new ArrayBuffer()), o.isArrayBuffer = P, F.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && F(new DataView(new ArrayBuffer(1), 0, 1)), o.isDataView = H;
    var te = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function p(A) {
      return S(A) === "[object SharedArrayBuffer]";
    }
    function $(A) {
      return te !== void 0 && (p.working === void 0 && (p.working = p(new te())), p.working ? p(A) : A instanceof te);
    }
    function _(A) {
      return q(A, T);
    }
    function y(A) {
      return q(A, B);
    }
    function g(A) {
      return q(A, I);
    }
    function v(A) {
      return d && q(A, C);
    }
    function E(A) {
      return w && q(A, N);
    }
    o.isSharedArrayBuffer = $, o.isAsyncFunction = function(A) {
      return S(A) === "[object AsyncFunction]";
    }, o.isMapIterator = function(A) {
      return S(A) === "[object Map Iterator]";
    }, o.isSetIterator = function(A) {
      return S(A) === "[object Set Iterator]";
    }, o.isGeneratorObject = function(A) {
      return S(A) === "[object Generator]";
    }, o.isWebAssemblyCompiledModule = function(A) {
      return S(A) === "[object WebAssembly.Module]";
    }, o.isNumberObject = _, o.isStringObject = y, o.isBooleanObject = g, o.isBigIntObject = v, o.isSymbolObject = E, o.isBoxedPrimitive = function(A) {
      return _(A) || y(A) || g(A) || v(A) || E(A);
    }, o.isAnyArrayBuffer = function(A) {
      return typeof Uint8Array < "u" && (P(A) || $(A));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(A) {
      Object.defineProperty(o, A, { enumerable: !1, value: function() {
        throw new Error(A + " is not supported in userland");
      } });
    });
  }(types)), types;
}
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser ? isBufferBrowser : (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(o) {
    return o && typeof o == "object" && typeof o.copy == "function" && typeof o.fill == "function" && typeof o.readUInt8 == "function";
  });
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser, hasRequiredUtil;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(o, n) {
    n && (o.super_ = n, o.prototype = Object.create(n.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }));
  } : inherits_browser.exports = function(o, n) {
    if (n) {
      o.super_ = n;
      var a = function() {
      };
      a.prototype = n.prototype, o.prototype = new a(), o.prototype.constructor = o;
    }
  }), inherits_browser.exports;
}
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, function(o) {
    var n = Object.getOwnPropertyDescriptors || function(E) {
      for (var A = Object.keys(E), L = {}, j = 0; j < A.length; j++)
        L[A[j]] = Object.getOwnPropertyDescriptor(E, A[j]);
      return L;
    }, a = /%[sdj%]/g;
    o.format = function(E) {
      if (!z(E)) {
        for (var A = [], L = 0; L < arguments.length; L++)
          A.push(d(arguments[L]));
        return A.join(" ");
      }
      L = 1;
      for (var j = arguments, J = j.length, X = String(E).replace(a, function(Z) {
        if (Z === "%%")
          return "%";
        if (L >= J)
          return Z;
        switch (Z) {
          case "%s":
            return String(j[L++]);
          case "%d":
            return Number(j[L++]);
          case "%j":
            try {
              return JSON.stringify(j[L++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Z;
        }
      }), re = j[L]; L < J; re = j[++L])
        q(re) || !ee(re) ? X += " " + re : X += " " + d(re);
      return X;
    }, o.deprecate = function(E, A) {
      if (typeof process < "u" && process.noDeprecation === !0)
        return E;
      if (typeof process > "u")
        return function() {
          return o.deprecate(E, A).apply(this, arguments);
        };
      var L = !1;
      return function() {
        if (!L) {
          if (process.throwDeprecation)
            throw new Error(A);
          process.traceDeprecation ? console.trace(A) : console.error(A), L = !0;
        }
        return E.apply(this, arguments);
      };
    };
    var u = {}, c = /^$/;
    if (process.env.NODE_DEBUG) {
      var m = process.env.NODE_DEBUG;
      m = m.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), c = new RegExp("^" + m + "$", "i");
    }
    function d(E, A) {
      var L = { seen: [], stylize: S };
      return arguments.length >= 3 && (L.depth = arguments[2]), arguments.length >= 4 && (L.colors = arguments[3]), N(A) ? L.showHidden = A : A && o._extend(L, A), W(L.showHidden) && (L.showHidden = !1), W(L.depth) && (L.depth = 2), W(L.colors) && (L.colors = !1), W(L.customInspect) && (L.customInspect = !0), L.colors && (L.stylize = w), T(L, E, L.depth);
    }
    function w(E, A) {
      var L = d.styles[A];
      return L ? "\x1B[" + d.colors[L][0] + "m" + E + "\x1B[" + d.colors[L][1] + "m" : E;
    }
    function S(E, A) {
      return E;
    }
    function T(E, A, L) {
      if (E.customInspect && A && H(A.inspect) && A.inspect !== o.inspect && (!A.constructor || A.constructor.prototype !== A)) {
        var j = A.inspect(L, E);
        return z(j) || (j = T(E, j, L)), j;
      }
      var J = function(ce, Se) {
        if (W(Se))
          return ce.stylize("undefined", "undefined");
        if (z(Se)) {
          var he = "'" + JSON.stringify(Se).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ce.stylize(he, "string");
        }
        return D(Se) ? ce.stylize("" + Se, "number") : N(Se) ? ce.stylize("" + Se, "boolean") : q(Se) ? ce.stylize("null", "null") : void 0;
      }(E, A);
      if (J)
        return J;
      var X = Object.keys(A), re = function(ce) {
        var Se = {};
        return ce.forEach(function(he, $e) {
          Se[he] = !0;
        }), Se;
      }(X);
      if (E.showHidden && (X = Object.getOwnPropertyNames(A)), F(A) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
        return B(A);
      if (X.length === 0) {
        if (H(A)) {
          var Z = A.name ? ": " + A.name : "";
          return E.stylize("[Function" + Z + "]", "special");
        }
        if (V(A))
          return E.stylize(RegExp.prototype.toString.call(A), "regexp");
        if (P(A))
          return E.stylize(Date.prototype.toString.call(A), "date");
        if (F(A))
          return B(A);
      }
      var ie, oe = "", ue = !1, se = ["{", "}"];
      return C(A) && (ue = !0, se = ["[", "]"]), H(A) && (oe = " [Function" + (A.name ? ": " + A.name : "") + "]"), V(A) && (oe = " " + RegExp.prototype.toString.call(A)), P(A) && (oe = " " + Date.prototype.toUTCString.call(A)), F(A) && (oe = " " + B(A)), X.length !== 0 || ue && A.length != 0 ? L < 0 ? V(A) ? E.stylize(RegExp.prototype.toString.call(A), "regexp") : E.stylize("[Object]", "special") : (E.seen.push(A), ie = ue ? function(ce, Se, he, $e, fe) {
        for (var le = [], we = 0, We = Se.length; we < We; ++we)
          y(Se, String(we)) ? le.push(I(ce, Se, he, $e, String(we), !0)) : le.push("");
        return fe.forEach(function(de) {
          de.match(/^\d+$/) || le.push(I(ce, Se, he, $e, de, !0));
        }), le;
      }(E, A, L, re, X) : X.map(function(ce) {
        return I(E, A, L, re, ce, ue);
      }), E.seen.pop(), function(ce, Se, he) {
        return ce.reduce(function($e, fe) {
          return fe.indexOf(`
`), $e + fe.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? he[0] + (Se === "" ? "" : Se + `
 `) + " " + ce.join(`,
  `) + " " + he[1] : he[0] + Se + " " + ce.join(", ") + " " + he[1];
      }(ie, oe, se)) : se[0] + oe + se[1];
    }
    function B(E) {
      return "[" + Error.prototype.toString.call(E) + "]";
    }
    function I(E, A, L, j, J, X) {
      var re, Z, ie;
      if ((ie = Object.getOwnPropertyDescriptor(A, J) || { value: A[J] }).get ? Z = ie.set ? E.stylize("[Getter/Setter]", "special") : E.stylize("[Getter]", "special") : ie.set && (Z = E.stylize("[Setter]", "special")), y(j, J) || (re = "[" + J + "]"), Z || (E.seen.indexOf(ie.value) < 0 ? (Z = q(L) ? T(E, ie.value, null) : T(E, ie.value, L - 1)).indexOf(`
`) > -1 && (Z = X ? Z.split(`
`).map(function(oe) {
        return "  " + oe;
      }).join(`
`).substr(2) : `
` + Z.split(`
`).map(function(oe) {
        return "   " + oe;
      }).join(`
`)) : Z = E.stylize("[Circular]", "special")), W(re)) {
        if (X && J.match(/^\d+$/))
          return Z;
        (re = JSON.stringify("" + J)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (re = re.substr(1, re.length - 2), re = E.stylize(re, "name")) : (re = re.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), re = E.stylize(re, "string"));
      }
      return re + ": " + Z;
    }
    function C(E) {
      return Array.isArray(E);
    }
    function N(E) {
      return typeof E == "boolean";
    }
    function q(E) {
      return E === null;
    }
    function D(E) {
      return typeof E == "number";
    }
    function z(E) {
      return typeof E == "string";
    }
    function W(E) {
      return E === void 0;
    }
    function V(E) {
      return ee(E) && te(E) === "[object RegExp]";
    }
    function ee(E) {
      return typeof E == "object" && E !== null;
    }
    function P(E) {
      return ee(E) && te(E) === "[object Date]";
    }
    function F(E) {
      return ee(E) && (te(E) === "[object Error]" || E instanceof Error);
    }
    function H(E) {
      return typeof E == "function";
    }
    function te(E) {
      return Object.prototype.toString.call(E);
    }
    function p(E) {
      return E < 10 ? "0" + E.toString(10) : E.toString(10);
    }
    o.debuglog = function(E) {
      if (E = E.toUpperCase(), !u[E])
        if (c.test(E)) {
          var A = process.pid;
          u[E] = function() {
            var L = o.format.apply(o, arguments);
            console.error("%s %d: %s", E, A, L);
          };
        } else
          u[E] = function() {
          };
      return u[E];
    }, o.inspect = d, d.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, d.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, o.types = requireTypes(), o.isArray = C, o.isBoolean = N, o.isNull = q, o.isNullOrUndefined = function(E) {
      return E == null;
    }, o.isNumber = D, o.isString = z, o.isSymbol = function(E) {
      return typeof E == "symbol";
    }, o.isUndefined = W, o.isRegExp = V, o.types.isRegExp = V, o.isObject = ee, o.isDate = P, o.types.isDate = P, o.isError = F, o.types.isNativeError = F, o.isFunction = H, o.isPrimitive = function(E) {
      return E === null || typeof E == "boolean" || typeof E == "number" || typeof E == "string" || typeof E == "symbol" || E === void 0;
    }, o.isBuffer = requireIsBufferBrowser();
    var $ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function _() {
      var E = new Date(), A = [p(E.getHours()), p(E.getMinutes()), p(E.getSeconds())].join(":");
      return [E.getDate(), $[E.getMonth()], A].join(" ");
    }
    function y(E, A) {
      return Object.prototype.hasOwnProperty.call(E, A);
    }
    o.log = function() {
      console.log("%s - %s", _(), o.format.apply(o, arguments));
    }, o.inherits = requireInherits_browser(), o._extend = function(E, A) {
      if (!A || !ee(A))
        return E;
      for (var L = Object.keys(A), j = L.length; j--; )
        E[L[j]] = A[L[j]];
      return E;
    };
    var g = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    function v(E, A) {
      if (!E) {
        var L = new Error("Promise was rejected with a falsy value");
        L.reason = E, E = L;
      }
      return A(E);
    }
    o.promisify = function(E) {
      if (typeof E != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (g && E[g]) {
        var A;
        if (typeof (A = E[g]) != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(A, g, { value: A, enumerable: !1, writable: !1, configurable: !0 }), A;
      }
      function A() {
        for (var L, j, J = new Promise(function(Z, ie) {
          L = Z, j = ie;
        }), X = [], re = 0; re < arguments.length; re++)
          X.push(arguments[re]);
        X.push(function(Z, ie) {
          Z ? j(Z) : L(ie);
        });
        try {
          E.apply(this, X);
        } catch (Z) {
          j(Z);
        }
        return J;
      }
      return Object.setPrototypeOf(A, Object.getPrototypeOf(E)), g && Object.defineProperty(A, g, { value: A, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(A, n(E));
    }, o.promisify.custom = g, o.callbackify = function(E) {
      if (typeof E != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function A() {
        for (var L = [], j = 0; j < arguments.length; j++)
          L.push(arguments[j]);
        var J = L.pop();
        if (typeof J != "function")
          throw new TypeError("The last argument must be of type Function");
        var X = this, re = function() {
          return J.apply(X, arguments);
        };
        E.apply(this, L).then(function(Z) {
          process.nextTick(re.bind(null, null, Z));
        }, function(Z) {
          process.nextTick(v.bind(null, Z, re));
        });
      }
      return Object.setPrototypeOf(A, Object.getPrototypeOf(E)), Object.defineProperties(A, n(E)), A;
    };
  }(util)), util;
}
Object.defineProperty(utils$q, "__esModule", { value: !0 }), utils$q.b64UrlDecode = utils$q.b64UrlEncode = utils$q.bufferTob64Url = utils$q.bufferTob64 = utils$q.b64UrlToBuffer = utils$q.stringToB64Url = utils$q.stringToBuffer = utils$q.bufferToString = utils$q.b64UrlToString = utils$q.concatBuffers = void 0;
const B64js$1 = base64Js;
function concatBuffers$1(o) {
  let n = 0;
  for (let c = 0; c < o.length; c++)
    n += o[c].byteLength;
  let a = new Uint8Array(n), u = 0;
  a.set(new Uint8Array(o[0]), u), u += o[0].byteLength;
  for (let c = 1; c < o.length; c++)
    a.set(new Uint8Array(o[c]), u), u += o[c].byteLength;
  return a;
}
function b64UrlToString$1(o) {
  return bufferToString$1(b64UrlToBuffer$1(o));
}
function bufferToString$1(o) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(o) : new TextDecoder("utf-8", { fatal: !0 }).decode(o);
}
function stringToBuffer$1(o) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(o) : new TextEncoder().encode(o);
}
function stringToB64Url$1(o) {
  return bufferTob64Url$1(stringToBuffer$1(o));
}
function b64UrlToBuffer$1(o) {
  return new Uint8Array(B64js$1.toByteArray(b64UrlDecode$1(o)));
}
function bufferTob64$1(o) {
  return B64js$1.fromByteArray(new Uint8Array(o));
}
function bufferTob64Url$1(o) {
  return b64UrlEncode$1(bufferTob64$1(o));
}
function b64UrlEncode$1(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode$1(o) {
  let n;
  return n = (o = o.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - o.length % 4, o.concat("=".repeat(n));
}
utils$q.concatBuffers = concatBuffers$1, utils$q.b64UrlToString = b64UrlToString$1, utils$q.bufferToString = bufferToString$1, utils$q.stringToBuffer = stringToBuffer$1, utils$q.stringToB64Url = stringToB64Url$1, utils$q.b64UrlToBuffer = b64UrlToBuffer$1, utils$q.bufferTob64 = bufferTob64$1, utils$q.bufferTob64Url = bufferTob64Url$1, utils$q.b64UrlEncode = b64UrlEncode$1, utils$q.b64UrlDecode = b64UrlDecode$1, Object.defineProperty(webcryptoDriver, "__esModule", { value: !0 });
const ArweaveUtils$6 = utils$q;
class WebCryptoDriver {
  constructor() {
    if (this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", !this.detectWebCrypto())
      throw new Error("SubtleCrypto not available!");
    this.driver = crypto.subtle;
  }
  async generateJWK() {
    let n = await this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, !0, ["sign"]), a = await this.driver.exportKey("jwk", n.privateKey);
    return { kty: a.kty, e: a.e, n: a.n, d: a.d, p: a.p, q: a.q, dp: a.dp, dq: a.dq, qi: a.qi };
  }
  async sign(n, a, { saltLength: u } = {}) {
    let c = await this.driver.sign({ name: "RSA-PSS", saltLength: 32 }, await this.jwkToCryptoKey(n), a);
    return new Uint8Array(c);
  }
  async hash(n, a = "SHA-256") {
    let u = await this.driver.digest(a, n);
    return new Uint8Array(u);
  }
  async verify(n, a, u) {
    const c = { kty: "RSA", e: "AQAB", n }, m = await this.jwkToPublicCryptoKey(c), d = this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, m, u, a), w = this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, m, u, a);
    return d || w;
  }
  async jwkToCryptoKey(n) {
    return this.driver.importKey("jwk", n, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["sign"]);
  }
  async jwkToPublicCryptoKey(n) {
    return this.driver.importKey("jwk", n, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["verify"]);
  }
  detectWebCrypto() {
    if (typeof crypto > "u")
      return !1;
    const n = crypto == null ? void 0 : crypto.subtle;
    return n !== void 0 && ["generateKey", "importKey", "exportKey", "digest", "sign"].every((a) => typeof n[a] == "function");
  }
  async encrypt(n, a, u) {
    const c = await this.driver.importKey("raw", typeof a == "string" ? ArweaveUtils$6.stringToBuffer(a) : a, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), m = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, c, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), d = new Uint8Array(16);
    crypto.getRandomValues(d);
    const w = await this.driver.encrypt({ name: "AES-CBC", iv: d }, m, n);
    return ArweaveUtils$6.concatBuffers([d, w]);
  }
  async decrypt(n, a, u) {
    const c = await this.driver.importKey("raw", typeof a == "string" ? ArweaveUtils$6.stringToBuffer(a) : a, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), m = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, c, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), d = n.slice(0, 16), w = await this.driver.decrypt({ name: "AES-CBC", iv: d }, m, n.slice(16));
    return ArweaveUtils$6.concatBuffers([w]);
  }
}
webcryptoDriver.default = WebCryptoDriver;
var network$1 = {};
Object.defineProperty(network$1, "__esModule", { value: !0 });
class Network$1 {
  constructor(n) {
    this.api = n;
  }
  getInfo() {
    return this.api.get("info").then((n) => n.data);
  }
  getPeers() {
    return this.api.get("peers").then((n) => n.data);
  }
}
network$1.default = Network$1;
var transactions$1 = {}, error$1 = {};
Object.defineProperty(error$1, "__esModule", { value: !0 }), error$1.getError = void 0;
class ArweaveError$1 extends Error {
  constructor(n, a = {}) {
    a.message ? super(a.message) : super(), this.type = n, this.response = a.response;
  }
  getType() {
    return this.type;
  }
}
function getError$1(o) {
  let n = o.data;
  if (typeof o.data == "string")
    try {
      n = JSON.parse(o.data);
    } catch {
    }
  if (o.data instanceof ArrayBuffer || o.data instanceof Uint8Array)
    try {
      n = JSON.parse(n.toString());
    } catch {
    }
  return n ? n.error || n : o.statusText || "unknown";
}
error$1.default = ArweaveError$1, error$1.getError = getError$1;
var transaction$1 = {}, deepHash$1 = {}, hasRequiredDeepHash$1;
function requireDeepHash$1() {
  if (hasRequiredDeepHash$1)
    return deepHash$1;
  hasRequiredDeepHash$1 = 1, Object.defineProperty(deepHash$1, "__esModule", { value: !0 });
  const o = requireCommon$1();
  async function n(u) {
    if (Array.isArray(u)) {
      const d = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("list"), o.default.utils.stringToBuffer(u.length.toString())]);
      return await a(u, await o.default.crypto.hash(d, "SHA-384"));
    }
    const c = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("blob"), o.default.utils.stringToBuffer(u.byteLength.toString())]), m = o.default.utils.concatBuffers([await o.default.crypto.hash(c, "SHA-384"), await o.default.crypto.hash(u, "SHA-384")]);
    return await o.default.crypto.hash(m, "SHA-384");
  }
  async function a(u, c) {
    if (u.length < 1)
      return c;
    const m = o.default.utils.concatBuffers([c, await n(u[0])]), d = await o.default.crypto.hash(m, "SHA-384");
    return await a(u.slice(1), d);
  }
  return deepHash$1.default = n, deepHash$1;
}
var merkle$1 = {}, hasRequiredMerkle$1, hasRequiredTransaction$1;
function requireMerkle$1() {
  return hasRequiredMerkle$1 || (hasRequiredMerkle$1 = 1, function(o) {
    Object.defineProperty(o, "__esModule", { value: !0 }), o.debug = o.validatePath = o.arrayCompare = o.bufferToInt = o.intToBuffer = o.arrayFlatten = o.generateProofs = o.buildLayers = o.generateTransactionChunks = o.generateTree = o.computeRootHash = o.generateLeaves = o.chunkData = o.MIN_CHUNK_SIZE = o.MAX_CHUNK_SIZE = void 0;
    const n = requireCommon$1(), a = utils$q;
    o.MAX_CHUNK_SIZE = 262144, o.MIN_CHUNK_SIZE = 32768;
    async function u(q) {
      let D = [], z = q, W = 0;
      for (; z.byteLength >= o.MAX_CHUNK_SIZE; ) {
        let V = o.MAX_CHUNK_SIZE, ee = z.byteLength - o.MAX_CHUNK_SIZE;
        ee > 0 && ee < o.MIN_CHUNK_SIZE && (V = Math.ceil(z.byteLength / 2));
        const P = z.slice(0, V), F = await n.default.crypto.hash(P);
        W += P.byteLength, D.push({ dataHash: F, minByteRange: W - P.byteLength, maxByteRange: W }), z = z.slice(V);
      }
      return D.push({ dataHash: await n.default.crypto.hash(z), minByteRange: W, maxByteRange: W + z.byteLength }), D;
    }
    async function c(q) {
      return Promise.all(q.map(async ({ dataHash: D, minByteRange: z, maxByteRange: W }) => ({ type: "leaf", id: await I(await Promise.all([I(D), I(C(W))])), dataHash: D, minByteRange: z, maxByteRange: W })));
    }
    async function m(q) {
      return await d(await c(await u(q)));
    }
    async function d(q, D = 0) {
      if (q.length < 2)
        return q[0];
      const z = [];
      for (let W = 0; W < q.length; W += 2)
        z.push(await B(q[W], q[W + 1]));
      return d(z, D + 1);
    }
    function w(q) {
      const D = S(q);
      return Array.isArray(D) ? T(D) : [D];
    }
    function S(q, D = new Uint8Array(), z = 0) {
      if (q.type == "leaf")
        return { offset: q.maxByteRange - 1, proof: (0, a.concatBuffers)([D, q.dataHash, C(q.maxByteRange)]) };
      if (q.type == "branch") {
        const W = (0, a.concatBuffers)([D, q.leftChild.id, q.rightChild.id, C(q.byteRange)]);
        return [S(q.leftChild, W, z + 1), S(q.rightChild, W, z + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function T(q) {
      const D = [];
      return q.forEach((z) => {
        Array.isArray(z) ? D.push(...T(z)) : D.push(z);
      }), D;
    }
    async function B(q, D) {
      return D ? { type: "branch", id: await I([await I(q.id), await I(D.id), await I(C(q.maxByteRange))]), byteRange: q.maxByteRange, maxByteRange: D.maxByteRange, leftChild: q, rightChild: D } : q;
    }
    async function I(q) {
      return Array.isArray(q) && (q = n.default.utils.concatBuffers(q)), new Uint8Array(await n.default.crypto.hash(q));
    }
    function C(q) {
      const D = new Uint8Array(32);
      for (var z = D.length - 1; z >= 0; z--) {
        var W = q % 256;
        D[z] = W, q = (q - W) / 256;
      }
      return D;
    }
    function N(q) {
      let D = 0;
      for (var z = 0; z < q.length; z++)
        D *= 256, D += q[z];
      return D;
    }
    o.chunkData = u, o.generateLeaves = c, o.computeRootHash = async function(q) {
      return (await m(q)).id;
    }, o.generateTree = m, o.generateTransactionChunks = async function(q) {
      const D = await u(q), z = await c(D), W = await d(z), V = await w(W), ee = D.slice(-1)[0];
      return ee.maxByteRange - ee.minByteRange == 0 && (D.splice(D.length - 1, 1), V.splice(V.length - 1, 1)), { data_root: W.id, chunks: D, proofs: V };
    }, o.buildLayers = d, o.generateProofs = w, o.arrayFlatten = T, o.intToBuffer = C, o.bufferToInt = N, o.arrayCompare = (q, D) => q.every((z, W) => D[W] === z), o.validatePath = async function q(D, z, W, V, ee) {
      if (V <= 0)
        return !1;
      if (z >= V)
        return q(D, 0, V - 1, V, ee);
      if (z < 0)
        return q(D, 0, 0, V, ee);
      if (ee.length == 64) {
        const _ = ee.slice(0, 32), y = ee.slice(_.length, _.length + 32), g = await I([await I(_), await I(y)]);
        return !!(0, o.arrayCompare)(D, g) && { offset: V - 1, leftBound: W, rightBound: V, chunkSize: V - W };
      }
      const P = ee.slice(0, 32), F = ee.slice(P.length, P.length + 32), H = ee.slice(P.length + F.length, P.length + F.length + 32), te = N(H), p = ee.slice(P.length + F.length + H.length), $ = await I([await I(P), await I(F), await I(H)]);
      return !!(0, o.arrayCompare)(D, $) && (z < te ? await q(P, z, W, Math.min(V, te), p) : await q(F, z, Math.max(W, te), V, p));
    }, o.debug = async function q(D, z = "") {
      if (D.byteLength < 1)
        return z;
      const W = D.slice(0, 32), V = D.slice(W.length, W.length + 32), ee = D.slice(W.length + V.length, W.length + V.length + 32), P = N(ee), F = D.slice(W.length + V.length + ee.length), H = await I([await I(W), await I(V), await I(ee)]);
      return q(F, `${z}
${JSON.stringify(Buffer.from(W))},${JSON.stringify(Buffer.from(V))},${P} => ${JSON.stringify(H)}`);
    };
  }(merkle$1)), merkle$1;
}
function requireTransaction$1() {
  if (hasRequiredTransaction$1)
    return transaction$1;
  hasRequiredTransaction$1 = 1, Object.defineProperty(transaction$1, "__esModule", { value: !0 }), transaction$1.Tag = void 0;
  const o = utils$q, n = requireDeepHash$1(), a = requireMerkle$1();
  class u {
    get(d, w) {
      if (!Object.getOwnPropertyNames(this).includes(d))
        throw new Error(`Field "${d}" is not a property of the Arweave Transaction class.`);
      return this[d] instanceof Uint8Array ? w && w.decode && w.string ? o.bufferToString(this[d]) : w && w.decode && !w.string ? this[d] : o.bufferTob64Url(this[d]) : w && w.decode == 1 ? w && w.string ? o.b64UrlToString(this[d]) : o.b64UrlToBuffer(this[d]) : this[d];
    }
  }
  class c extends u {
    constructor(d, w, S = !1) {
      super(), this.name = d, this.value = w;
    }
  }
  return transaction$1.Tag = c, transaction$1.default = class extends u {
    constructor(m = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, m), typeof this.data == "string" && (this.data = o.b64UrlToBuffer(this.data)), m.tags && (this.tags = m.tags.map((d) => new c(d.name, d.value)));
    }
    addTag(m, d) {
      this.tags.push(new c(o.stringToB64Url(m), o.stringToB64Url(d)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: o.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(m) {
      this.owner = m;
    }
    setSignature({ id: m, owner: d, reward: w, tags: S, signature: T }) {
      this.id = m, this.owner = d, w && (this.reward = w), S && (this.tags = S), this.signature = T;
    }
    async prepareChunks(m) {
      !this.chunks && m.byteLength > 0 && (this.chunks = await (0, a.generateTransactionChunks)(m), this.data_root = o.bufferTob64Url(this.chunks.data_root)), this.chunks || m.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(m, d) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const w = this.chunks.proofs[m], S = this.chunks.chunks[m];
      return { data_root: this.data_root, data_size: this.data_size, data_path: o.bufferTob64Url(w.proof), offset: w.offset.toString(), chunk: o.bufferTob64Url(d.slice(S.minByteRange, S.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let m = this.tags.reduce((w, S) => o.concatBuffers([w, S.get("name", { decode: !0, string: !1 }), S.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return o.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), o.stringToBuffer(this.quantity), o.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), m]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const d = this.tags.map((w) => [w.get("name", { decode: !0, string: !1 }), w.get("value", { decode: !0, string: !1 })]);
          return await (0, n.default)([o.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), o.stringToBuffer(this.quantity), o.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), d, o.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction$1;
}
var transactionUploader$1 = {}, hasRequiredTransactionUploader$1, hasRequiredTransactions$1;
function requireTransactionUploader$1() {
  if (hasRequiredTransactionUploader$1)
    return transactionUploader$1;
  hasRequiredTransactionUploader$1 = 1, Object.defineProperty(transactionUploader$1, "__esModule", { value: !0 }), transactionUploader$1.TransactionUploader = void 0;
  const o = requireTransaction$1(), n = utils$q, a = error$1, u = requireMerkle$1(), c = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class m {
    constructor(w, S) {
      if (this.api = w, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !S.id)
        throw new Error("Transaction is not signed");
      if (!S.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = S.data, this.transaction = new o.default(Object.assign({}, S, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(w) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let S = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (S > 0 && (S -= S * Math.random() * 0.3, await new Promise((I) => setTimeout(I, S))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      w && (this.chunkIndex = w);
      const T = this.transaction.getChunk(w || this.chunkIndex, this.data);
      if (!await (0, u.validatePath)(this.transaction.chunks.data_root, parseInt(T.offset), 0, parseInt(T.data_size), n.b64UrlToBuffer(T.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const B = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((I) => (console.error(I.message), { status: -1, data: { error: I.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = B.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, a.getError)(B), c.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized(w, S, T) {
      if (!S || typeof S.chunkIndex != "number" || typeof S.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var B = new o.default(S.transaction);
      B.chunks || await B.prepareChunks(T);
      const I = new m(w, B);
      if (I.chunkIndex = S.chunkIndex, I.lastRequestTimeEnd = S.lastRequestTimeEnd, I.lastResponseError = S.lastResponseError, I.lastResponseStatus = S.lastResponseStatus, I.txPosted = S.txPosted, I.data = T, I.transaction.data_root !== S.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return I;
    }
    static async fromTransactionId(w, S) {
      const T = await w.get(`tx/${S}`);
      if (T.status !== 200)
        throw new Error(`Tx ${S} not found: ${T.status}`);
      const B = T.data;
      return B.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: B };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const S = await this.api.post("tx", this.transaction).catch((T) => (console.error(T), { status: -1, data: { error: T.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = S.status, this.transaction.data = new Uint8Array(0), S.status >= 200 && S.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, a.getError)(S), new Error(`Unable to upload transaction: ${S.status}, ${this.lastResponseError}`);
      }
      const w = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = w.status, !(w.status >= 200 && w.status < 300))
        throw this.lastResponseError = (0, a.getError)(w), new Error(`Unable to upload transaction: ${w.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader$1.TransactionUploader = m, transactionUploader$1;
}
function requireTransactions$1() {
  if (hasRequiredTransactions$1)
    return transactions$1;
  hasRequiredTransactions$1 = 1;
  var o = commonjsGlobal && commonjsGlobal.__await || function(d) {
    return this instanceof o ? (this.v = d, this) : new o(d);
  }, n = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(d, w, S) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var T, B = S.apply(d, w || []), I = [];
    return T = {}, C("next"), C("throw"), C("return"), T[Symbol.asyncIterator] = function() {
      return this;
    }, T;
    function C(W) {
      B[W] && (T[W] = function(V) {
        return new Promise(function(ee, P) {
          I.push([W, V, ee, P]) > 1 || N(W, V);
        });
      });
    }
    function N(W, V) {
      try {
        (function(ee) {
          ee.value instanceof o ? Promise.resolve(ee.value.v).then(q, D) : z(I[0][2], ee);
        })(B[W](V));
      } catch (ee) {
        z(I[0][3], ee);
      }
    }
    function q(W) {
      N("next", W);
    }
    function D(W) {
      N("throw", W);
    }
    function z(W, V) {
      W(V), I.shift(), I.length && N(I[0][0], I[0][1]);
    }
  };
  Object.defineProperty(transactions$1, "__esModule", { value: !0 });
  const a = error$1, u = requireTransaction$1(), c = utils$q, m = requireTransactionUploader$1();
  return transactions$1.default = class {
    constructor(d, w, S) {
      this.api = d, this.crypto = w, this.chunks = S;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((d) => d.data);
    }
    getPrice(d, w) {
      let S = w ? `price/${d}/${w}` : `price/${d}`;
      return this.api.get(S, { transformResponse: [function(T) {
        return T;
      }] }).then((T) => T.data);
    }
    async get(d) {
      const w = await this.api.get(`tx/${d}`);
      if (w.status == 200) {
        const S = parseInt(w.data.data_size);
        if (w.data.format >= 2 && S > 0 && S <= 12582912) {
          const T = await this.getData(d);
          return new u.default(Object.assign(Object.assign({}, w.data), { data: T }));
        }
        return new u.default(Object.assign(Object.assign({}, w.data), { format: w.data.format || 1 }));
      }
      throw w.status == 404 ? new a.default("TX_NOT_FOUND") : w.status == 410 ? new a.default("TX_FAILED") : new a.default("TX_INVALID");
    }
    fromRaw(d) {
      return new u.default(d);
    }
    async search(d, w) {
      return this.api.post("arql", { op: "equals", expr1: d, expr2: w }).then((S) => S.data ? S.data : []);
    }
    getStatus(d) {
      return this.api.get(`tx/${d}/status`).then((w) => w.status == 200 ? { status: 200, confirmed: w.data } : { status: w.status, confirmed: null });
    }
    async getData(d, w) {
      let S;
      try {
        S = await this.chunks.downloadChunkedData(d);
      } catch (T) {
        console.error(`Error while trying to download chunked data for ${d}`), console.error(T);
      }
      if (!S) {
        console.warn(`Falling back to gateway cache for ${d}`);
        try {
          S = (await this.api.get(`/${d}`)).data;
        } catch (T) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${d}`), console.error(T);
        }
      }
      if (!S)
        throw new Error(`${d} was not found!`);
      return w && w.decode && !w.string ? S : w && w.decode && w.string ? c.bufferToString(S) : c.bufferTob64Url(S);
    }
    async sign(d, w, S) {
      if (!(w || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if (w && w !== "use_wallet") {
        d.setOwner(w.n);
        let T = await d.getSignatureData(), B = await this.crypto.sign(w, T, S), I = await this.crypto.hash(B);
        d.setSignature({ id: c.bufferTob64Url(I), owner: w.n, signature: c.bufferTob64Url(B) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const T = await window.arweaveWallet.sign(d, S);
        d.setSignature({ id: T.id, owner: T.owner, reward: T.reward, tags: T.tags, signature: T.signature });
      }
    }
    async verify(d) {
      const w = await d.getSignatureData(), S = d.get("signature", { decode: !0, string: !1 }), T = c.bufferTob64Url(await this.crypto.hash(S));
      if (d.id !== T)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(d.owner, w, S);
    }
    async post(d) {
      if (typeof d == "string" ? d = new u.default(JSON.parse(d)) : typeof d.readInt32BE == "function" ? d = new u.default(JSON.parse(d.toString())) : typeof d != "object" || d instanceof u.default || (d = new u.default(d)), !(d instanceof u.default))
        throw new Error("Must be Transaction object");
      d.chunks || await d.prepareChunks(d.data);
      const w = await this.getUploader(d, d.data);
      try {
        for (; !w.isComplete; )
          await w.uploadChunk();
      } catch (S) {
        if (w.lastResponseStatus > 0)
          return { status: w.lastResponseStatus, statusText: w.lastResponseError, data: { error: w.lastResponseError } };
        throw S;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(d, w) {
      let S;
      if (w instanceof ArrayBuffer && (w = new Uint8Array(w)), d instanceof u.default) {
        if (w || (w = d.data), !(w instanceof Uint8Array))
          throw new Error("Data format is invalid");
        d.chunks || await d.prepareChunks(w), S = new m.TransactionUploader(this.api, d), S.data && S.data.length !== 0 || (S.data = w);
      } else {
        if (typeof d == "string" && (d = await m.TransactionUploader.fromTransactionId(this.api, d)), !(w && w instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        S = await m.TransactionUploader.fromSerialized(this.api, d, w);
      }
      return S;
    }
    upload(d, w) {
      return n(this, arguments, function* () {
        const S = yield o(this.getUploader(d, w));
        for (; !S.isComplete; )
          yield o(S.uploadChunk()), yield yield o(S);
        return yield o(S);
      });
    }
  }, transactions$1;
}
var wallets$1 = {};
Object.defineProperty(wallets$1, "__esModule", { value: !0 });
const ArweaveUtils$5 = utils$q;
class Wallets$1 {
  constructor(n, a) {
    this.api = n, this.crypto = a;
  }
  getBalance(n) {
    return this.api.get(`wallet/${n}/balance`, { transformResponse: [function(a) {
      return a;
    }] }).then((a) => a.data);
  }
  getLastTransactionID(n) {
    return this.api.get(`wallet/${n}/last_tx`).then((a) => a.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(n) {
    return n && n !== "use_wallet" ? this.getAddress(n) : this.getAddress();
  }
  async getAddress(n) {
    if (n && n !== "use_wallet")
      return this.ownerToAddress(n.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(n) {
    return ArweaveUtils$5.bufferTob64Url(await this.crypto.hash(ArweaveUtils$5.b64UrlToBuffer(n)));
  }
}
wallets$1.default = Wallets$1;
var silo$1 = {};
Object.defineProperty(silo$1, "__esModule", { value: !0 }), silo$1.SiloResource = void 0;
const ArweaveUtils$4 = utils$q;
class Silo$1 {
  constructor(n, a, u) {
    this.api = n, this.crypto = a, this.transactions = u;
  }
  async get(n) {
    if (!n)
      throw new Error("No Silo URI specified");
    const a = await this.parseUri(n), u = await this.transactions.search("Silo-Name", a.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const c = await this.transactions.get(u[0]);
    if (!c)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const m = c.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(m, a.getEncryptionKey());
  }
  async readTransactionData(n, a) {
    if (!a)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(a), c = n.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(c, u.getEncryptionKey());
  }
  async parseUri(n) {
    const a = n.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!a)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = a[1], c = Math.pow(2, parseInt(a[2])), m = await this.hash(ArweaveUtils$4.stringToBuffer(u), c), d = ArweaveUtils$4.bufferTob64(m.slice(0, 15)), w = await this.hash(m.slice(16, 31), 1);
    return new SiloResource$1(n, d, w);
  }
  async hash(n, a) {
    let u = await this.crypto.hash(n);
    for (let c = 0; c < a - 1; c++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo$1.default = Silo$1;
class SiloResource$1 {
  constructor(n, a, u) {
    this.uri = n, this.accessKey = a, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo$1.SiloResource = SiloResource$1;
var chunks$1 = {};
Object.defineProperty(chunks$1, "__esModule", { value: !0 });
const error_1$3 = error$1, ArweaveUtils$3 = utils$q;
class Chunks$1 {
  constructor(n) {
    this.api = n;
  }
  async getTransactionOffset(n) {
    const a = await this.api.get(`tx/${n}/offset`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$3.getError)(a)}`);
  }
  async getChunk(n) {
    const a = await this.api.get(`chunk/${n}`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$3.getError)(a)}`);
  }
  async getChunkData(n) {
    const a = await this.getChunk(n);
    return ArweaveUtils$3.b64UrlToBuffer(a.chunk);
  }
  firstChunkOffset(n) {
    return parseInt(n.offset) - parseInt(n.size) + 1;
  }
  async downloadChunkedData(n) {
    const a = await this.getTransactionOffset(n), u = parseInt(a.size), c = parseInt(a.offset) - u + 1, m = new Uint8Array(u);
    let d = 0;
    for (; d < u; ) {
      let w;
      this.api.config.logging && console.log(`[chunk] ${d}/${u}`);
      try {
        w = await this.getChunkData(c + d);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${c + d}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!w)
        throw new Error(`Couldn't complete data download at ${d}/${u}`);
      m.set(w, d), d += w.length;
    }
    return m;
  }
}
chunks$1.default = Chunks$1;
var blocks$1 = {};
Object.defineProperty(blocks$1, "__esModule", { value: !0 });
const error_1$2 = error$1;
class Blocks$1 {
  constructor(n, a) {
    this.api = n, this.network = a;
  }
  async get(n) {
    const a = await this.api.get(`${Blocks$1.ENDPOINT}${n}`);
    if (a.status === 200)
      return a.data;
    throw a.status === 404 ? new error_1$2.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${a}`);
  }
  async getCurrent() {
    const { current: n } = await this.network.getInfo();
    return await this.get(n);
  }
}
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$8;
  hasRequiredCommon$1 = 1, Object.defineProperty(common$8, "__esModule", { value: !0 });
  const o = ar$1, n = api$2, a = webcryptoDriver, u = network$1, c = requireTransactions$1(), m = wallets$1, d = requireTransaction$1(), w = utils$q, S = silo$1, T = chunks$1, B = blocks$1;
  class I {
    constructor(N) {
      this.api = new n.default(N), this.wallets = new m.default(this.api, I.crypto), this.chunks = new T.default(this.api), this.transactions = new c.default(this.api, I.crypto, this.chunks), this.silo = new S.default(this.api, this.crypto, this.transactions), this.network = new u.default(this.api), this.blocks = new B.default(this.api, this.network), this.ar = new o.default();
    }
    get crypto() {
      return I.crypto;
    }
    get utils() {
      return I.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(N, q) {
      const D = {};
      if (Object.assign(D, N), !(N.data || N.target && N.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (N.owner == null && q && q !== "use_wallet" && (D.owner = q.n), N.last_tx == null && (D.last_tx = await this.transactions.getTransactionAnchor()), typeof N.data == "string" && (N.data = w.stringToBuffer(N.data)), N.data instanceof ArrayBuffer && (N.data = new Uint8Array(N.data)), N.data && !(N.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (N.reward == null) {
        const W = N.data ? N.data.byteLength : 0;
        D.reward = await this.transactions.getPrice(W, D.target);
      }
      D.data_root = "", D.data_size = N.data ? N.data.byteLength.toString() : "0", D.data = N.data || new Uint8Array(0);
      const z = new d.default(D);
      return await z.getSignatureData(), z;
    }
    async createSiloTransaction(N, q, D) {
      const z = {};
      if (Object.assign(z, N), !N.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!D)
        throw new Error("No Silo URI specified.");
      if (N.target || N.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (N.owner == null) {
        if (!q || !q.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        z.owner = q.n;
      }
      N.last_tx == null && (z.last_tx = await this.transactions.getTransactionAnchor());
      const W = await this.silo.parseUri(D);
      if (typeof N.data == "string") {
        const ee = await this.crypto.encrypt(w.stringToBuffer(N.data), W.getEncryptionKey());
        z.reward = await this.transactions.getPrice(ee.byteLength), z.data = w.bufferTob64Url(ee);
      }
      if (N.data instanceof Uint8Array) {
        const ee = await this.crypto.encrypt(N.data, W.getEncryptionKey());
        z.reward = await this.transactions.getPrice(ee.byteLength), z.data = w.bufferTob64Url(ee);
      }
      const V = new d.default(z);
      return V.addTag("Silo-Name", W.getAccessKey()), V.addTag("Silo-Version", "0.1.0"), V;
    }
    arql(N) {
      return this.api.post("/arql", N).then((q) => q.data || []);
    }
  }
  return common$8.default = I, I.crypto = new a.default(), I.utils = w, common$8;
}
blocks$1.default = Blocks$1, Blocks$1.ENDPOINT = "block/hash/", function(o) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(c, m, d, w) {
    w === void 0 && (w = d);
    var S = Object.getOwnPropertyDescriptor(m, d);
    S && !("get" in S ? !m.__esModule : S.writable || S.configurable) || (S = { enumerable: !0, get: function() {
      return m[d];
    } }), Object.defineProperty(c, w, S);
  } : function(c, m, d, w) {
    w === void 0 && (w = d), c[w] = m[d];
  }), a = commonjsGlobal && commonjsGlobal.__exportStar || function(c, m) {
    for (var d in c)
      d === "default" || Object.prototype.hasOwnProperty.call(m, d) || n(m, c, d);
  };
  Object.defineProperty(o, "__esModule", { value: !0 });
  const u = requireCommon$1();
  u.default.init = function(c = {}) {
    const m = function() {
      const T = { host: "arweave.net", port: 443, protocol: "https" };
      if (!(window && window.location && window.location.protocol && window.location.hostname))
        return T;
      const B = window.location.protocol.replace(":", ""), I = window.location.hostname, C = window.location.port ? parseInt(window.location.port) : B == "https" ? 443 : 80;
      return ["localhost", "127.0.0.1"].includes(I) || B == "file" ? T : { host: I, port: C, protocol: B };
    }(), d = c.protocol || m.protocol, w = c.host || m.host, S = c.port || m.port;
    return new u.default(Object.assign(Object.assign({}, c), { host: w, protocol: d, port: S }));
  }, window.Arweave = u.default, a(requireCommon$1(), o), o.default = u.default;
}(web);
const index$2 = getDefaultExportFromCjs(web), index$3 = _mergeNamespaces({ __proto__: null, default: index$2 }, [web]);
var cjs = {}, ConsoleLogger$1 = {}, LoggerSettings = {}, exports;
exports = LoggerSettings, Object.defineProperty(exports, "__esModule", { value: !0 }), exports.lvlToOrder = exports.LogLevelOrder = void 0, exports.LogLevelOrder = { silly: 0, trace: 1, debug: 2, info: 3, warn: 4, error: 5, fatal: 6, none: 7 }, exports.lvlToOrder = function(o) {
  return exports.LogLevelOrder[o];
}, Object.defineProperty(ConsoleLogger$1, "__esModule", { value: !0 }), ConsoleLogger$1.ConsoleLogger = void 0;
const LoggerSettings_1 = LoggerSettings;
class ConsoleLogger {
  constructor(n, a) {
    this.moduleName = n, this.settings = a;
  }
  trace(n, ...a) {
    this.shouldLog("trace") && console.debug(this.message("trace", n), a);
  }
  error(n, ...a) {
    this.shouldLog("error") && console.error(this.message("error", n), a);
  }
  info(n, ...a) {
    this.shouldLog("info") && console.info(this.message("info", n), a);
  }
  silly(n, ...a) {
    this.shouldLog("silly") && console.debug(this.message("silly", n), a);
  }
  debug(n, ...a) {
    this.shouldLog("debug") && console.debug(this.message("debug", n), a);
  }
  warn(n, ...a) {
    this.shouldLog("warn") && console.warn(this.message("warn", n), a);
  }
  log(n, ...a) {
    this.shouldLog("info") && console.info(this.message("info", n), a);
  }
  fatal(n, ...a) {
    this.shouldLog("fatal") && console.error(this.message("fatal", n), a);
  }
  shouldLog(n) {
    return (0, LoggerSettings_1.lvlToOrder)(n) >= (0, LoggerSettings_1.lvlToOrder)(this.settings.minLevel);
  }
  setSettings(n) {
    this.settings = n;
  }
  message(n, a) {
    return `${new Date().toISOString()} ${n.toUpperCase()} [${this.moduleName}] ${a}`;
  }
}
ConsoleLogger$1.ConsoleLogger = ConsoleLogger;
var ConsoleLoggerFactory$1 = {};
Object.defineProperty(ConsoleLoggerFactory$1, "__esModule", { value: !0 }), ConsoleLoggerFactory$1.ConsoleLoggerFactory = void 0;
const ConsoleLogger_1 = ConsoleLogger$1;
class ConsoleLoggerFactory {
  constructor() {
    this.registeredLoggers = {}, this.registeredOptions = {}, this.defOptions = { minLevel: "info" }, this.setOptions = this.setOptions.bind(this), this.getOptions = this.getOptions.bind(this), this.create = this.create.bind(this), this.logLevel = this.logLevel.bind(this);
  }
  setOptions(n, a) {
    a ? this.registeredLoggers[a] ? this.registeredLoggers[a].setSettings({ ...this.registeredLoggers[a].settings, ...n }) : this.registeredOptions[a] = { ...this.defOptions, ...n } : (this.defOptions = n, Object.keys(this.registeredLoggers).forEach((u) => {
      this.registeredLoggers[u].setSettings({ ...this.registeredLoggers[u].settings, ...n });
    }));
  }
  getOptions(n) {
    return n ? this.registeredLoggers[n] ? this.registeredLoggers[n].settings : this.registeredOptions[n] ? this.registeredOptions[n] : this.defOptions : this.defOptions;
  }
  logLevel(n, a) {
    this.setOptions({ minLevel: n }, a);
  }
  create(n = "SWC") {
    return Object.prototype.hasOwnProperty.call(this.registeredLoggers, n) || (this.registeredLoggers[n] = new ConsoleLogger_1.ConsoleLogger(n, this.getOptions(n))), this.registeredLoggers[n];
  }
}
ConsoleLoggerFactory$1.ConsoleLoggerFactory = ConsoleLoggerFactory;
var WarpLogger = {};
Object.defineProperty(WarpLogger, "__esModule", { value: !0 });
var LoggerFactory$1 = {};
Object.defineProperty(LoggerFactory$1, "__esModule", { value: !0 }), LoggerFactory$1.LoggerFactory = void 0;
const ConsoleLoggerFactory_1 = ConsoleLoggerFactory$1;
class LoggerFactory {
  constructor() {
  }
  setOptions(n, a) {
    LoggerFactory.INST.setOptions(n, a);
  }
  getOptions(n) {
    return LoggerFactory.INST.getOptions(n);
  }
  logLevel(n, a) {
    LoggerFactory.INST.logLevel(n, a);
  }
  create(n) {
    return LoggerFactory.INST.create(n);
  }
  static use(n) {
    LoggerFactory.INST = n;
  }
}
LoggerFactory$1.LoggerFactory = LoggerFactory, LoggerFactory.INST = new ConsoleLoggerFactory_1.ConsoleLoggerFactory();
var Benchmark$1 = {};
Object.defineProperty(Benchmark$1, "__esModule", { value: !0 }), Benchmark$1.Benchmark = void 0;
class Benchmark {
  constructor() {
    this.start = Date.now(), this.end = null;
  }
  static measure() {
    return new Benchmark();
  }
  reset() {
    this.start = Date.now(), this.end = null;
  }
  stop() {
    this.end = Date.now();
  }
  elapsed(n = !1) {
    this.end === null && (this.end = Date.now());
    const a = this.end - this.start;
    return n ? a : `${(this.end - this.start).toFixed(0)}ms`;
  }
}
Benchmark$1.Benchmark = Benchmark;
var DefinitionLoader = {};
Object.defineProperty(DefinitionLoader, "__esModule", { value: !0 });
var ExecutorFactory = {};
Object.defineProperty(ExecutorFactory, "__esModule", { value: !0 });
var InteractionsLoader = {};
Object.defineProperty(InteractionsLoader, "__esModule", { value: !0 });
var InteractionsSorter = {};
Object.defineProperty(InteractionsSorter, "__esModule", { value: !0 });
var StateEvaluator = {};
Object.defineProperty(StateEvaluator, "__esModule", { value: !0 }), StateEvaluator.DefaultEvaluationOptions = StateEvaluator.EvalStateResult = void 0;
class EvalStateResult {
  constructor(n, a, u) {
    this.state = n, this.validity = a, this.errorMessages = u;
  }
}
StateEvaluator.EvalStateResult = EvalStateResult;
class DefaultEvaluationOptions {
  constructor() {
    this.ignoreExceptions = !0, this.waitForConfirmation = !1, this.updateCacheForEachInteraction = !1, this.internalWrites = !1, this.maxCallDepth = 7, this.maxInteractionEvaluationTimeSeconds = 60, this.stackTrace = { saveState: !1 }, this.bundlerUrl = "https://d1o5nlqr4okus2.cloudfront.net/", this.gasLimit = Number.MAX_SAFE_INTEGER, this.useFastCopy = !0, this.useVM2 = !1, this.allowUnsafeClient = !1, this.allowBigInt = !1, this.walletBalanceUrl = "http://nyc-1.dev.arweave.net:1984/", this.mineArLocalBlocks = !0, this.throwOnInternalWriteError = !0;
  }
}
StateEvaluator.DefaultEvaluationOptions = DefaultEvaluationOptions;
var ContractDefinitionLoader = {}, SmartWeaveTags = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.SmartWeaveTags = void 0, function(n) {
    n.APP_NAME = "App-Name", n.APP_VERSION = "App-Version", n.CONTRACT_TX_ID = "Contract", n.INPUT = "Input", n.CONTENT_TYPE = "Content-Type", n.CONTRACT_SRC_TX_ID = "Contract-Src", n.SDK = "SDK", n.MIN_FEE = "Min-Fee", n.INIT_STATE = "Init-State", n.INIT_STATE_TX = "Init-State-TX", n.INTERACT_WRITE = "Interact-Write", n.WASM_LANG = "Wasm-Lang", n.WASM_LANG_VERSION = "Wasm-Lang-Version", n.WASM_META = "Wasm-Meta", n.REQUEST_VRF = "Request-Vrf";
  }(o.SmartWeaveTags || (o.SmartWeaveTags = {}));
})(SmartWeaveTags);
var utils$p = {};
function getTag$4(o, n) {
  const a = o.get("tags");
  for (const u of a)
    try {
      if (u.get("name", { decode: !0, string: !0 }) === n)
        return u.get("value", { decode: !0, string: !0 });
    } catch {
    }
  return !1;
}
function arrayToHex(o) {
  let n = "";
  for (const a of o)
    n += ("0" + a.toString(16)).slice(-2);
  return n;
}
Object.defineProperty(utils$p, "__esModule", { value: !0 }), utils$p.arrayToHex = utils$p.getTag = void 0, utils$p.getTag = getTag$4, utils$p.arrayToHex = arrayToHex;
var ArweaveWrapper = {}, transaction = {}, utils$o = {}, __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$6(n, o, a);
  return __setModuleDefault$6(n, o), n;
};
Object.defineProperty(utils$o, "__esModule", { value: !0 }), utils$o.b64UrlDecode = utils$o.b64UrlEncode = utils$o.bufferTob64Url = utils$o.bufferTob64 = utils$o.b64UrlToBuffer = utils$o.stringToB64Url = utils$o.stringToBuffer = utils$o.bufferToString = utils$o.b64UrlToString = utils$o.concatBuffers = void 0;
const B64js = __importStar$6(base64Js);
function concatBuffers(o) {
  let n = 0;
  for (let c = 0; c < o.length; c++)
    n += o[c].byteLength;
  let a = new Uint8Array(n), u = 0;
  a.set(new Uint8Array(o[0]), u), u += o[0].byteLength;
  for (let c = 1; c < o.length; c++)
    a.set(new Uint8Array(o[c]), u), u += o[c].byteLength;
  return a;
}
function b64UrlToString(o) {
  return bufferToString(b64UrlToBuffer(o));
}
function bufferToString(o) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(o) : new TextDecoder("utf-8", { fatal: !0 }).decode(o);
}
function stringToBuffer(o) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(o) : new TextEncoder().encode(o);
}
function stringToB64Url(o) {
  return bufferTob64Url(stringToBuffer(o));
}
function b64UrlToBuffer(o) {
  return new Uint8Array(B64js.toByteArray(b64UrlDecode(o)));
}
function bufferTob64(o) {
  return B64js.fromByteArray(new Uint8Array(o));
}
function bufferTob64Url(o) {
  return b64UrlEncode(bufferTob64(o));
}
function b64UrlEncode(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(o) {
  let n;
  return n = (o = o.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - o.length % 4, o.concat("=".repeat(n));
}
utils$o.concatBuffers = concatBuffers, utils$o.b64UrlToString = b64UrlToString, utils$o.bufferToString = bufferToString, utils$o.stringToBuffer = stringToBuffer, utils$o.stringToB64Url = stringToB64Url, utils$o.b64UrlToBuffer = b64UrlToBuffer, utils$o.bufferTob64 = bufferTob64, utils$o.bufferTob64Url = bufferTob64Url, utils$o.b64UrlEncode = b64UrlEncode, utils$o.b64UrlDecode = b64UrlDecode;
var deepHash = {}, common$7 = {}, ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
const bignumber_js_1$1 = bignumber.exports;
class Ar {
  constructor() {
    this.BigNum = (n, a) => new (bignumber_js_1$1.BigNumber.clone({ DECIMAL_PLACES: a }))(n);
  }
  winstonToAr(n, { formatted: a = !1, decimals: u = 12, trim: c = !0 } = {}) {
    let m = this.stringToBigNum(n, u).shiftedBy(-12);
    return a ? m.toFormat(u) : m.toFixed(u);
  }
  arToWinston(n, { formatted: a = !1 } = {}) {
    let u = this.stringToBigNum(n).shiftedBy(12);
    return a ? u.toFormat() : u.toFixed(0);
  }
  compare(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.comparedTo(c);
  }
  isEqual(n, a) {
    return this.compare(n, a) === 0;
  }
  isLessThan(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.isLessThan(c);
  }
  isGreaterThan(n, a) {
    let u = this.stringToBigNum(n), c = this.stringToBigNum(a);
    return u.isGreaterThan(c);
  }
  add(n, a) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(a), u.plus(a).toFixed(0);
  }
  sub(n, a) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(a), u.minus(a).toFixed(0);
  }
  stringToBigNum(n, a = 12) {
    return this.BigNum(n, a);
  }
}
ar.default = Ar;
var api$1 = {}, __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(api$1, "__esModule", { value: !0 });
const axios_1 = __importDefault$8(axios$2.exports);
class Api {
  constructor(n) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(n);
  }
  applyConfig(n) {
    this.config = this.mergeDefaults(n);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(n) {
    const a = n.protocol || "http", u = n.port || (a === "https" ? 443 : 80);
    return { host: n.host || "127.0.0.1", protocol: a, port: u, timeout: n.timeout || 2e4, logging: n.logging || !1, logger: n.logger || console.log, network: n.network };
  }
  async get(n, a) {
    try {
      return await this.request().get(n, a);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(n, a, u) {
    try {
      return await this.request().post(n, a, u);
    } catch (c) {
      if (c.response && c.response.status)
        return c.response;
      throw c;
    }
  }
  request() {
    const n = {};
    this.config.network && (n["x-network"] = this.config.network);
    let a = axios_1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: n });
    return this.config.logging && (a.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), a.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), a;
  }
}
api$1.default = Api;
var nodeDriver = {}, pem$2 = {}, asn1 = {}, bn$3 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" })), require$$2$1 = getAugmentedNamespace(__viteBrowserExternal$1);
(function(o, n) {
  function a(p, $) {
    if (!p)
      throw new Error($ || "Assertion failed");
  }
  function u(p, $) {
    p.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, p.prototype = new _(), p.prototype.constructor = p;
  }
  function c(p, $, _) {
    if (c.isBN(p))
      return p;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(p || 0, $ || 10, _ || "be"));
  }
  var m;
  typeof bn$3 == "object" ? bn$3.exports = c : n.BN = c, c.BN = c, c.wordSize = 26;
  try {
    m = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(p, $) {
    var _ = p.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(p, $, _) {
    var y = d(p, _);
    return _ - 1 >= $ && (y |= d(p, _ - 1) << 4), y;
  }
  function S(p, $, _, y) {
    for (var g = 0, v = Math.min(p.length, _), E = $; E < v; E++) {
      var A = p.charCodeAt(E) - 48;
      g *= y, g += A >= 49 ? A - 49 + 10 : A >= 17 ? A - 17 + 10 : A;
    }
    return g;
  }
  c.isBN = function(p) {
    return p instanceof c || p !== null && typeof p == "object" && p.constructor.wordSize === c.wordSize && Array.isArray(p.words);
  }, c.max = function(p, $) {
    return p.cmp($) > 0 ? p : $;
  }, c.min = function(p, $) {
    return p.cmp($) < 0 ? p : $;
  }, c.prototype._init = function(p, $, _) {
    if (typeof p == "number")
      return this._initNumber(p, $, _);
    if (typeof p == "object")
      return this._initArray(p, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var y = 0;
    (p = p.toString().replace(/\s+/g, ""))[0] === "-" && (y++, this.negative = 1), y < p.length && ($ === 16 ? this._parseHex(p, y, _) : (this._parseBase(p, $, y), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(p, $, _) {
    p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [67108863 & p], this.length = 1) : p < 4503599627370496 ? (this.words = [67108863 & p, p / 67108864 & 67108863], this.length = 2) : (a(p < 9007199254740992), this.words = [67108863 & p, p / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(p, $, _) {
    if (a(typeof p.length == "number"), p.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v, E = 0;
    if (_ === "be")
      for (y = p.length - 1, g = 0; y >= 0; y -= 3)
        v = p[y] | p[y - 1] << 8 | p[y - 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    else if (_ === "le")
      for (y = 0, g = 0; y < p.length; y += 3)
        v = p[y] | p[y + 1] << 8 | p[y + 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    return this.strip();
  }, c.prototype._parseHex = function(p, $, _) {
    this.length = Math.ceil((p.length - $) / 6), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v = 0, E = 0;
    if (_ === "be")
      for (y = p.length - 1; y >= $; y -= 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    else
      for (y = (p.length - $) % 2 == 0 ? $ + 1 : $; y < p.length; y += 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(p, $, _) {
    this.words = [0], this.length = 1;
    for (var y = 0, g = 1; g <= 67108863; g *= $)
      y++;
    y--, g = g / $ | 0;
    for (var v = p.length - _, E = v % y, A = Math.min(v, v - E) + _, L = 0, j = _; j < A; j += y)
      L = S(p, j, j + y, $), this.imuln(g), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    if (E !== 0) {
      var J = 1;
      for (L = S(p, j, p.length, $), j = 0; j < E; j++)
        J *= $;
      this.imuln(J), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    }
    this.strip();
  }, c.prototype.copy = function(p) {
    p.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      p.words[$] = this.words[$];
    p.length = this.length, p.negative = this.negative, p.red = this.red;
  }, c.prototype.clone = function() {
    var p = new c(null);
    return this.copy(p), p;
  }, c.prototype._expand = function(p) {
    for (; this.length < p; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var T = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(p, $, _) {
    _.negative = $.negative ^ p.negative;
    var y = p.length + $.length | 0;
    _.length = y, y = y - 1 | 0;
    var g = 0 | p.words[0], v = 0 | $.words[0], E = g * v, A = 67108863 & E, L = E / 67108864 | 0;
    _.words[0] = A;
    for (var j = 1; j < y; j++) {
      for (var J = L >>> 26, X = 67108863 & L, re = Math.min(j, $.length - 1), Z = Math.max(0, j - p.length + 1); Z <= re; Z++) {
        var ie = j - Z | 0;
        J += (E = (g = 0 | p.words[ie]) * (v = 0 | $.words[Z]) + X) / 67108864 | 0, X = 67108863 & E;
      }
      _.words[j] = 0 | X, L = 0 | J;
    }
    return L !== 0 ? _.words[j] = 0 | L : _.length--, _.strip();
  }
  c.prototype.toString = function(p, $) {
    var _;
    if ($ = 0 | $ || 1, (p = p || 10) === 16 || p === "hex") {
      _ = "";
      for (var y = 0, g = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], A = (16777215 & (E << y | g)).toString(16);
        _ = (g = E >>> 24 - y & 16777215) != 0 || v !== this.length - 1 ? T[6 - A.length] + A + _ : A + _, (y += 2) >= 26 && (y -= 26, v--);
      }
      for (g !== 0 && (_ = g.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (p === (0 | p) && p >= 2 && p <= 36) {
      var L = B[p], j = I[p];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var X = J.modn(j).toString(p);
        _ = (J = J.idivn(j)).isZero() ? X + _ : T[L - X.length] + X + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var p = this.words[0];
    return this.length === 2 ? p += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(p, $) {
    return a(m !== void 0), this.toArrayLike(m, p, $);
  }, c.prototype.toArray = function(p, $) {
    return this.toArrayLike(Array, p, $);
  }, c.prototype.toArrayLike = function(p, $, _) {
    var y = this.byteLength(), g = _ || Math.max(1, y);
    a(y <= g, "byte array longer than desired length"), a(g > 0, "Requested array length <= 0"), this.strip();
    var v, E, A = $ === "le", L = new p(g), j = this.clone();
    if (A) {
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[E] = v;
      for (; E < g; E++)
        L[E] = 0;
    } else {
      for (E = 0; E < g - y; E++)
        L[E] = 0;
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[g - E - 1] = v;
    }
    return L;
  }, Math.clz32 ? c.prototype._countBits = function(p) {
    return 32 - Math.clz32(p);
  } : c.prototype._countBits = function(p) {
    var $ = p, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(p) {
    if (p === 0)
      return 26;
    var $ = p, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var p = this.words[this.length - 1], $ = this._countBits(p);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var p = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (p += _, _ !== 26)
        break;
    }
    return p;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(p) {
    return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(p) {
    return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(p) {
    for (; this.length < p.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < p.length; $++)
      this.words[$] = this.words[$] | p.words[$];
    return this.strip();
  }, c.prototype.ior = function(p) {
    return a((this.negative | p.negative) == 0), this.iuor(p);
  }, c.prototype.or = function(p) {
    return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
  }, c.prototype.uor = function(p) {
    return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
  }, c.prototype.iuand = function(p) {
    var $;
    $ = this.length > p.length ? p : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & p.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(p) {
    return a((this.negative | p.negative) == 0), this.iuand(p);
  }, c.prototype.and = function(p) {
    return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
  }, c.prototype.uand = function(p) {
    return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
  }, c.prototype.iuxor = function(p) {
    var $, _;
    this.length > p.length ? ($ = this, _ = p) : ($ = p, _ = this);
    for (var y = 0; y < _.length; y++)
      this.words[y] = $.words[y] ^ _.words[y];
    if (this !== $)
      for (; y < $.length; y++)
        this.words[y] = $.words[y];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(p) {
    return a((this.negative | p.negative) == 0), this.iuxor(p);
  }, c.prototype.xor = function(p) {
    return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
  }, c.prototype.uxor = function(p) {
    return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
  }, c.prototype.inotn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = 0 | Math.ceil(p / 26), _ = p % 26;
    this._expand($), _ > 0 && $--;
    for (var y = 0; y < $; y++)
      this.words[y] = 67108863 & ~this.words[y];
    return _ > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(p) {
    return this.clone().inotn(p);
  }, c.prototype.setn = function(p, $) {
    a(typeof p == "number" && p >= 0);
    var _ = p / 26 | 0, y = p % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << y : this.words[_] & ~(1 << y), this.strip();
  }, c.prototype.iadd = function(p) {
    var $, _, y;
    if (this.negative !== 0 && p.negative === 0)
      return this.negative = 0, $ = this.isub(p), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && p.negative !== 0)
      return p.negative = 0, $ = this.isub(p), p.negative = 1, $._normSign();
    this.length > p.length ? (_ = this, y = p) : (_ = p, y = this);
    for (var g = 0, v = 0; v < y.length; v++)
      $ = (0 | _.words[v]) + (0 | y.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    for (; g !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    if (this.length = _.length, g !== 0)
      this.words[this.length] = g, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(p) {
    var $;
    return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, $ = this.sub(p), p.negative ^= 1, $) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = p.sub(this), this.negative = 1, $) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
  }, c.prototype.isub = function(p) {
    if (p.negative !== 0) {
      p.negative = 0;
      var $ = this.iadd(p);
      return p.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
    var _, y, g = this.cmp(p);
    if (g === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    g > 0 ? (_ = this, y = p) : (_ = p, y = this);
    for (var v = 0, E = 0; E < y.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | y.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(p) {
    return this.clone().isub(p);
  };
  var N = function(p, $, _) {
    var y, g, v, E = p.words, A = $.words, L = _.words, j = 0, J = 0 | E[0], X = 8191 & J, re = J >>> 13, Z = 0 | E[1], ie = 8191 & Z, oe = Z >>> 13, ue = 0 | E[2], se = 8191 & ue, ce = ue >>> 13, Se = 0 | E[3], he = 8191 & Se, $e = Se >>> 13, fe = 0 | E[4], le = 8191 & fe, we = fe >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, b = l >>> 13, M = 0 | E[7], k = 8191 & M, x = M >>> 13, O = 0 | E[8], G = 8191 & O, Q = O >>> 13, ne = 0 | E[9], Y = 8191 & ne, ae = ne >>> 13, Ee = 0 | A[0], pe = 8191 & Ee, ye = Ee >>> 13, Le = 0 | A[1], ge = 8191 & Le, be = Le >>> 13, Re = 0 | A[2], me = 8191 & Re, Ae = Re >>> 13, He = 0 | A[3], ve = 8191 & He, Me = He >>> 13, Fe = 0 | A[4], _e = 8191 & Fe, Oe = Fe >>> 13, qe = 0 | A[5], Te = 8191 & qe, Pe = qe >>> 13, ze = 0 | A[6], xe = 8191 & ze, Ne = ze >>> 13, Ve = 0 | A[7], Be = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | A[8], Ie = 8191 & Je, je = Je >>> 13, Xe = 0 | A[9], Ce = 8191 & Xe, De = Xe >>> 13;
    _.negative = p.negative ^ $.negative, _.length = 19;
    var Ge = (j + (y = Math.imul(X, pe)) | 0) + ((8191 & (g = (g = Math.imul(X, ye)) + Math.imul(re, pe) | 0)) << 13) | 0;
    j = ((v = Math.imul(re, ye)) + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, y = Math.imul(ie, pe), g = (g = Math.imul(ie, ye)) + Math.imul(oe, pe) | 0, v = Math.imul(oe, ye);
    var Ke = (j + (y = y + Math.imul(X, ge) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, be) | 0) + Math.imul(re, ge) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, be) | 0) + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, y = Math.imul(se, pe), g = (g = Math.imul(se, ye)) + Math.imul(ce, pe) | 0, v = Math.imul(ce, ye), y = y + Math.imul(ie, ge) | 0, g = (g = g + Math.imul(ie, be) | 0) + Math.imul(oe, ge) | 0, v = v + Math.imul(oe, be) | 0;
    var Ye = (j + (y = y + Math.imul(X, me) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ae) | 0) + Math.imul(re, me) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ae) | 0) + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, y = Math.imul(he, pe), g = (g = Math.imul(he, ye)) + Math.imul($e, pe) | 0, v = Math.imul($e, ye), y = y + Math.imul(se, ge) | 0, g = (g = g + Math.imul(se, be) | 0) + Math.imul(ce, ge) | 0, v = v + Math.imul(ce, be) | 0, y = y + Math.imul(ie, me) | 0, g = (g = g + Math.imul(ie, Ae) | 0) + Math.imul(oe, me) | 0, v = v + Math.imul(oe, Ae) | 0;
    var Ze = (j + (y = y + Math.imul(X, ve) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Me) | 0) + Math.imul(re, ve) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Me) | 0) + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, y = Math.imul(le, pe), g = (g = Math.imul(le, ye)) + Math.imul(we, pe) | 0, v = Math.imul(we, ye), y = y + Math.imul(he, ge) | 0, g = (g = g + Math.imul(he, be) | 0) + Math.imul($e, ge) | 0, v = v + Math.imul($e, be) | 0, y = y + Math.imul(se, me) | 0, g = (g = g + Math.imul(se, Ae) | 0) + Math.imul(ce, me) | 0, v = v + Math.imul(ce, Ae) | 0, y = y + Math.imul(ie, ve) | 0, g = (g = g + Math.imul(ie, Me) | 0) + Math.imul(oe, ve) | 0, v = v + Math.imul(oe, Me) | 0;
    var Qe = (j + (y = y + Math.imul(X, _e) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Oe) | 0) + Math.imul(re, _e) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Oe) | 0) + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, y = Math.imul(de, pe), g = (g = Math.imul(de, ye)) + Math.imul(ke, pe) | 0, v = Math.imul(ke, ye), y = y + Math.imul(le, ge) | 0, g = (g = g + Math.imul(le, be) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, be) | 0, y = y + Math.imul(he, me) | 0, g = (g = g + Math.imul(he, Ae) | 0) + Math.imul($e, me) | 0, v = v + Math.imul($e, Ae) | 0, y = y + Math.imul(se, ve) | 0, g = (g = g + Math.imul(se, Me) | 0) + Math.imul(ce, ve) | 0, v = v + Math.imul(ce, Me) | 0, y = y + Math.imul(ie, _e) | 0, g = (g = g + Math.imul(ie, Oe) | 0) + Math.imul(oe, _e) | 0, v = v + Math.imul(oe, Oe) | 0;
    var et = (j + (y = y + Math.imul(X, Te) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Pe) | 0) + Math.imul(re, Te) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Pe) | 0) + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, y = Math.imul(h, pe), g = (g = Math.imul(h, ye)) + Math.imul(b, pe) | 0, v = Math.imul(b, ye), y = y + Math.imul(de, ge) | 0, g = (g = g + Math.imul(de, be) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, be) | 0, y = y + Math.imul(le, me) | 0, g = (g = g + Math.imul(le, Ae) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ae) | 0, y = y + Math.imul(he, ve) | 0, g = (g = g + Math.imul(he, Me) | 0) + Math.imul($e, ve) | 0, v = v + Math.imul($e, Me) | 0, y = y + Math.imul(se, _e) | 0, g = (g = g + Math.imul(se, Oe) | 0) + Math.imul(ce, _e) | 0, v = v + Math.imul(ce, Oe) | 0, y = y + Math.imul(ie, Te) | 0, g = (g = g + Math.imul(ie, Pe) | 0) + Math.imul(oe, Te) | 0, v = v + Math.imul(oe, Pe) | 0;
    var tt = (j + (y = y + Math.imul(X, xe) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ne) | 0) + Math.imul(re, xe) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ne) | 0) + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, y = Math.imul(k, pe), g = (g = Math.imul(k, ye)) + Math.imul(x, pe) | 0, v = Math.imul(x, ye), y = y + Math.imul(h, ge) | 0, g = (g = g + Math.imul(h, be) | 0) + Math.imul(b, ge) | 0, v = v + Math.imul(b, be) | 0, y = y + Math.imul(de, me) | 0, g = (g = g + Math.imul(de, Ae) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ae) | 0, y = y + Math.imul(le, ve) | 0, g = (g = g + Math.imul(le, Me) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Me) | 0, y = y + Math.imul(he, _e) | 0, g = (g = g + Math.imul(he, Oe) | 0) + Math.imul($e, _e) | 0, v = v + Math.imul($e, Oe) | 0, y = y + Math.imul(se, Te) | 0, g = (g = g + Math.imul(se, Pe) | 0) + Math.imul(ce, Te) | 0, v = v + Math.imul(ce, Pe) | 0, y = y + Math.imul(ie, xe) | 0, g = (g = g + Math.imul(ie, Ne) | 0) + Math.imul(oe, xe) | 0, v = v + Math.imul(oe, Ne) | 0;
    var rt = (j + (y = y + Math.imul(X, Be) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ue) | 0) + Math.imul(re, Be) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ue) | 0) + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, y = Math.imul(G, pe), g = (g = Math.imul(G, ye)) + Math.imul(Q, pe) | 0, v = Math.imul(Q, ye), y = y + Math.imul(k, ge) | 0, g = (g = g + Math.imul(k, be) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, be) | 0, y = y + Math.imul(h, me) | 0, g = (g = g + Math.imul(h, Ae) | 0) + Math.imul(b, me) | 0, v = v + Math.imul(b, Ae) | 0, y = y + Math.imul(de, ve) | 0, g = (g = g + Math.imul(de, Me) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Me) | 0, y = y + Math.imul(le, _e) | 0, g = (g = g + Math.imul(le, Oe) | 0) + Math.imul(we, _e) | 0, v = v + Math.imul(we, Oe) | 0, y = y + Math.imul(he, Te) | 0, g = (g = g + Math.imul(he, Pe) | 0) + Math.imul($e, Te) | 0, v = v + Math.imul($e, Pe) | 0, y = y + Math.imul(se, xe) | 0, g = (g = g + Math.imul(se, Ne) | 0) + Math.imul(ce, xe) | 0, v = v + Math.imul(ce, Ne) | 0, y = y + Math.imul(ie, Be) | 0, g = (g = g + Math.imul(ie, Ue) | 0) + Math.imul(oe, Be) | 0, v = v + Math.imul(oe, Ue) | 0;
    var nt = (j + (y = y + Math.imul(X, Ie) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, je) | 0) + Math.imul(re, Ie) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, je) | 0) + (g >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, y = Math.imul(Y, pe), g = (g = Math.imul(Y, ye)) + Math.imul(ae, pe) | 0, v = Math.imul(ae, ye), y = y + Math.imul(G, ge) | 0, g = (g = g + Math.imul(G, be) | 0) + Math.imul(Q, ge) | 0, v = v + Math.imul(Q, be) | 0, y = y + Math.imul(k, me) | 0, g = (g = g + Math.imul(k, Ae) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ae) | 0, y = y + Math.imul(h, ve) | 0, g = (g = g + Math.imul(h, Me) | 0) + Math.imul(b, ve) | 0, v = v + Math.imul(b, Me) | 0, y = y + Math.imul(de, _e) | 0, g = (g = g + Math.imul(de, Oe) | 0) + Math.imul(ke, _e) | 0, v = v + Math.imul(ke, Oe) | 0, y = y + Math.imul(le, Te) | 0, g = (g = g + Math.imul(le, Pe) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Pe) | 0, y = y + Math.imul(he, xe) | 0, g = (g = g + Math.imul(he, Ne) | 0) + Math.imul($e, xe) | 0, v = v + Math.imul($e, Ne) | 0, y = y + Math.imul(se, Be) | 0, g = (g = g + Math.imul(se, Ue) | 0) + Math.imul(ce, Be) | 0, v = v + Math.imul(ce, Ue) | 0, y = y + Math.imul(ie, Ie) | 0, g = (g = g + Math.imul(ie, je) | 0) + Math.imul(oe, Ie) | 0, v = v + Math.imul(oe, je) | 0;
    var it = (j + (y = y + Math.imul(X, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, De) | 0) + Math.imul(re, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, De) | 0) + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, y = Math.imul(Y, ge), g = (g = Math.imul(Y, be)) + Math.imul(ae, ge) | 0, v = Math.imul(ae, be), y = y + Math.imul(G, me) | 0, g = (g = g + Math.imul(G, Ae) | 0) + Math.imul(Q, me) | 0, v = v + Math.imul(Q, Ae) | 0, y = y + Math.imul(k, ve) | 0, g = (g = g + Math.imul(k, Me) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Me) | 0, y = y + Math.imul(h, _e) | 0, g = (g = g + Math.imul(h, Oe) | 0) + Math.imul(b, _e) | 0, v = v + Math.imul(b, Oe) | 0, y = y + Math.imul(de, Te) | 0, g = (g = g + Math.imul(de, Pe) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Pe) | 0, y = y + Math.imul(le, xe) | 0, g = (g = g + Math.imul(le, Ne) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ne) | 0, y = y + Math.imul(he, Be) | 0, g = (g = g + Math.imul(he, Ue) | 0) + Math.imul($e, Be) | 0, v = v + Math.imul($e, Ue) | 0, y = y + Math.imul(se, Ie) | 0, g = (g = g + Math.imul(se, je) | 0) + Math.imul(ce, Ie) | 0, v = v + Math.imul(ce, je) | 0;
    var ot = (j + (y = y + Math.imul(ie, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(ie, De) | 0) + Math.imul(oe, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(oe, De) | 0) + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, y = Math.imul(Y, me), g = (g = Math.imul(Y, Ae)) + Math.imul(ae, me) | 0, v = Math.imul(ae, Ae), y = y + Math.imul(G, ve) | 0, g = (g = g + Math.imul(G, Me) | 0) + Math.imul(Q, ve) | 0, v = v + Math.imul(Q, Me) | 0, y = y + Math.imul(k, _e) | 0, g = (g = g + Math.imul(k, Oe) | 0) + Math.imul(x, _e) | 0, v = v + Math.imul(x, Oe) | 0, y = y + Math.imul(h, Te) | 0, g = (g = g + Math.imul(h, Pe) | 0) + Math.imul(b, Te) | 0, v = v + Math.imul(b, Pe) | 0, y = y + Math.imul(de, xe) | 0, g = (g = g + Math.imul(de, Ne) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ne) | 0, y = y + Math.imul(le, Be) | 0, g = (g = g + Math.imul(le, Ue) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, Ue) | 0, y = y + Math.imul(he, Ie) | 0, g = (g = g + Math.imul(he, je) | 0) + Math.imul($e, Ie) | 0, v = v + Math.imul($e, je) | 0;
    var at = (j + (y = y + Math.imul(se, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(se, De) | 0) + Math.imul(ce, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ce, De) | 0) + (g >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, y = Math.imul(Y, ve), g = (g = Math.imul(Y, Me)) + Math.imul(ae, ve) | 0, v = Math.imul(ae, Me), y = y + Math.imul(G, _e) | 0, g = (g = g + Math.imul(G, Oe) | 0) + Math.imul(Q, _e) | 0, v = v + Math.imul(Q, Oe) | 0, y = y + Math.imul(k, Te) | 0, g = (g = g + Math.imul(k, Pe) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Pe) | 0, y = y + Math.imul(h, xe) | 0, g = (g = g + Math.imul(h, Ne) | 0) + Math.imul(b, xe) | 0, v = v + Math.imul(b, Ne) | 0, y = y + Math.imul(de, Be) | 0, g = (g = g + Math.imul(de, Ue) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, Ue) | 0, y = y + Math.imul(le, Ie) | 0, g = (g = g + Math.imul(le, je) | 0) + Math.imul(we, Ie) | 0, v = v + Math.imul(we, je) | 0;
    var st = (j + (y = y + Math.imul(he, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(he, De) | 0) + Math.imul($e, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul($e, De) | 0) + (g >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, y = Math.imul(Y, _e), g = (g = Math.imul(Y, Oe)) + Math.imul(ae, _e) | 0, v = Math.imul(ae, Oe), y = y + Math.imul(G, Te) | 0, g = (g = g + Math.imul(G, Pe) | 0) + Math.imul(Q, Te) | 0, v = v + Math.imul(Q, Pe) | 0, y = y + Math.imul(k, xe) | 0, g = (g = g + Math.imul(k, Ne) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ne) | 0, y = y + Math.imul(h, Be) | 0, g = (g = g + Math.imul(h, Ue) | 0) + Math.imul(b, Be) | 0, v = v + Math.imul(b, Ue) | 0, y = y + Math.imul(de, Ie) | 0, g = (g = g + Math.imul(de, je) | 0) + Math.imul(ke, Ie) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (j + (y = y + Math.imul(le, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(le, De) | 0) + Math.imul(we, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(we, De) | 0) + (g >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, y = Math.imul(Y, Te), g = (g = Math.imul(Y, Pe)) + Math.imul(ae, Te) | 0, v = Math.imul(ae, Pe), y = y + Math.imul(G, xe) | 0, g = (g = g + Math.imul(G, Ne) | 0) + Math.imul(Q, xe) | 0, v = v + Math.imul(Q, Ne) | 0, y = y + Math.imul(k, Be) | 0, g = (g = g + Math.imul(k, Ue) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, Ue) | 0, y = y + Math.imul(h, Ie) | 0, g = (g = g + Math.imul(h, je) | 0) + Math.imul(b, Ie) | 0, v = v + Math.imul(b, je) | 0;
    var ct = (j + (y = y + Math.imul(de, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(de, De) | 0) + Math.imul(ke, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ke, De) | 0) + (g >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, y = Math.imul(Y, xe), g = (g = Math.imul(Y, Ne)) + Math.imul(ae, xe) | 0, v = Math.imul(ae, Ne), y = y + Math.imul(G, Be) | 0, g = (g = g + Math.imul(G, Ue) | 0) + Math.imul(Q, Be) | 0, v = v + Math.imul(Q, Ue) | 0, y = y + Math.imul(k, Ie) | 0, g = (g = g + Math.imul(k, je) | 0) + Math.imul(x, Ie) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (j + (y = y + Math.imul(h, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(h, De) | 0) + Math.imul(b, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(b, De) | 0) + (g >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, y = Math.imul(Y, Be), g = (g = Math.imul(Y, Ue)) + Math.imul(ae, Be) | 0, v = Math.imul(ae, Ue), y = y + Math.imul(G, Ie) | 0, g = (g = g + Math.imul(G, je) | 0) + Math.imul(Q, Ie) | 0, v = v + Math.imul(Q, je) | 0;
    var ht = (j + (y = y + Math.imul(k, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(k, De) | 0) + Math.imul(x, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(x, De) | 0) + (g >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, y = Math.imul(Y, Ie), g = (g = Math.imul(Y, je)) + Math.imul(ae, Ie) | 0, v = Math.imul(ae, je);
    var dt = (j + (y = y + Math.imul(G, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(G, De) | 0) + Math.imul(Q, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(Q, De) | 0) + (g >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (j + (y = Math.imul(Y, Ce)) | 0) + ((8191 & (g = (g = Math.imul(Y, De)) + Math.imul(ae, Ce) | 0)) << 13) | 0;
    return j = ((v = Math.imul(ae, De)) + (g >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L[0] = Ge, L[1] = Ke, L[2] = Ye, L[3] = Ze, L[4] = Qe, L[5] = et, L[6] = tt, L[7] = rt, L[8] = nt, L[9] = it, L[10] = ot, L[11] = at, L[12] = st, L[13] = ut, L[14] = ct, L[15] = ft, L[16] = ht, L[17] = dt, L[18] = pt, j !== 0 && (L[19] = j, _.length++), _;
  };
  function q(p, $, _) {
    return new D().mulp(p, $, _);
  }
  function D(p, $) {
    this.x = p, this.y = $;
  }
  Math.imul || (N = C), c.prototype.mulTo = function(p, $) {
    var _, y = this.length + p.length;
    return _ = this.length === 10 && p.length === 10 ? N(this, p, $) : y < 63 ? C(this, p, $) : y < 1024 ? function(g, v, E) {
      E.negative = v.negative ^ g.negative, E.length = g.length + v.length;
      for (var A = 0, L = 0, j = 0; j < E.length - 1; j++) {
        var J = L;
        L = 0;
        for (var X = 67108863 & A, re = Math.min(j, v.length - 1), Z = Math.max(0, j - g.length + 1); Z <= re; Z++) {
          var ie = j - Z, oe = (0 | g.words[ie]) * (0 | v.words[Z]), ue = 67108863 & oe;
          X = 67108863 & (ue = ue + X | 0), L += (J = (J = J + (oe / 67108864 | 0) | 0) + (ue >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[j] = X, A = J, J = L;
      }
      return A !== 0 ? E.words[j] = A : E.length--, E.strip();
    }(this, p, $) : q(this, p, $), _;
  }, D.prototype.makeRBT = function(p) {
    for (var $ = new Array(p), _ = c.prototype._countBits(p) - 1, y = 0; y < p; y++)
      $[y] = this.revBin(y, _, p);
    return $;
  }, D.prototype.revBin = function(p, $, _) {
    if (p === 0 || p === _ - 1)
      return p;
    for (var y = 0, g = 0; g < $; g++)
      y |= (1 & p) << $ - g - 1, p >>= 1;
    return y;
  }, D.prototype.permute = function(p, $, _, y, g, v) {
    for (var E = 0; E < v; E++)
      y[E] = $[p[E]], g[E] = _[p[E]];
  }, D.prototype.transform = function(p, $, _, y, g, v) {
    this.permute(v, p, $, _, y, g);
    for (var E = 1; E < g; E <<= 1)
      for (var A = E << 1, L = Math.cos(2 * Math.PI / A), j = Math.sin(2 * Math.PI / A), J = 0; J < g; J += A)
        for (var X = L, re = j, Z = 0; Z < E; Z++) {
          var ie = _[J + Z], oe = y[J + Z], ue = _[J + Z + E], se = y[J + Z + E], ce = X * ue - re * se;
          se = X * se + re * ue, ue = ce, _[J + Z] = ie + ue, y[J + Z] = oe + se, _[J + Z + E] = ie - ue, y[J + Z + E] = oe - se, Z !== A && (ce = L * X - j * re, re = L * re + j * X, X = ce);
        }
  }, D.prototype.guessLen13b = function(p, $) {
    var _ = 1 | Math.max($, p), y = 1 & _, g = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      g++;
    return 1 << g + 1 + y;
  }, D.prototype.conjugate = function(p, $, _) {
    if (!(_ <= 1))
      for (var y = 0; y < _ / 2; y++) {
        var g = p[y];
        p[y] = p[_ - y - 1], p[_ - y - 1] = g, g = $[y], $[y] = -$[_ - y - 1], $[_ - y - 1] = -g;
      }
  }, D.prototype.normalize13b = function(p, $) {
    for (var _ = 0, y = 0; y < $ / 2; y++) {
      var g = 8192 * Math.round(p[2 * y + 1] / $) + Math.round(p[2 * y] / $) + _;
      p[y] = 67108863 & g, _ = g < 67108864 ? 0 : g / 67108864 | 0;
    }
    return p;
  }, D.prototype.convert13b = function(p, $, _, y) {
    for (var g = 0, v = 0; v < $; v++)
      g += 0 | p[v], _[2 * v] = 8191 & g, g >>>= 13, _[2 * v + 1] = 8191 & g, g >>>= 13;
    for (v = 2 * $; v < y; ++v)
      _[v] = 0;
    a(g === 0), a((-8192 & g) == 0);
  }, D.prototype.stub = function(p) {
    for (var $ = new Array(p), _ = 0; _ < p; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(p, $, _) {
    var y = 2 * this.guessLen13b(p.length, $.length), g = this.makeRBT(y), v = this.stub(y), E = new Array(y), A = new Array(y), L = new Array(y), j = new Array(y), J = new Array(y), X = new Array(y), re = _.words;
    re.length = y, this.convert13b(p.words, p.length, E, y), this.convert13b($.words, $.length, j, y), this.transform(E, v, A, L, y, g), this.transform(j, v, J, X, y, g);
    for (var Z = 0; Z < y; Z++) {
      var ie = A[Z] * J[Z] - L[Z] * X[Z];
      L[Z] = A[Z] * X[Z] + L[Z] * J[Z], A[Z] = ie;
    }
    return this.conjugate(A, L, y), this.transform(A, L, re, v, y, g), this.conjugate(re, v, y), this.normalize13b(re, y), _.negative = p.negative ^ $.negative, _.length = p.length + $.length, _.strip();
  }, c.prototype.mul = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), this.mulTo(p, $);
  }, c.prototype.mulf = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), q(this, p, $);
  }, c.prototype.imul = function(p) {
    return this.clone().mulTo(p, this);
  }, c.prototype.imuln = function(p) {
    a(typeof p == "number"), a(p < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var y = (0 | this.words[_]) * p, g = (67108863 & y) + (67108863 & $);
      $ >>= 26, $ += y / 67108864 | 0, $ += g >>> 26, this.words[_] = 67108863 & g;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(p) {
    return this.clone().imuln(p);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(p) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), A = 0; A < E.length; A++) {
        var L = A / 26 | 0, j = A % 26;
        E[A] = (v.words[L] & 1 << j) >>> j;
      }
      return E;
    }(p);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, y = 0; y < $.length && $[y] === 0; y++, _ = _.sqr())
      ;
    if (++y < $.length)
      for (var g = _.sqr(); y < $.length; y++, g = g.sqr())
        $[y] !== 0 && (_ = _.mul(g));
    return _;
  }, c.prototype.iushln = function(p) {
    a(typeof p == "number" && p >= 0);
    var $, _ = p % 26, y = (p - _) / 26, g = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & g, A = (0 | this.words[$]) - E << _;
        this.words[$] = A | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (y !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + y] = this.words[$];
      for ($ = 0; $ < y; $++)
        this.words[$] = 0;
      this.length += y;
    }
    return this.strip();
  }, c.prototype.ishln = function(p) {
    return a(this.negative === 0), this.iushln(p);
  }, c.prototype.iushrn = function(p, $, _) {
    var y;
    a(typeof p == "number" && p >= 0), y = $ ? ($ - $ % 26) / 26 : 0;
    var g = p % 26, v = Math.min((p - g) / 26, this.length), E = 67108863 ^ 67108863 >>> g << g, A = _;
    if (y -= v, y = Math.max(0, y), A) {
      for (var L = 0; L < v; L++)
        A.words[L] = this.words[L];
      A.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, L = 0; L < this.length; L++)
          this.words[L] = this.words[L + v];
      else
        this.words[0] = 0, this.length = 1;
    var j = 0;
    for (L = this.length - 1; L >= 0 && (j !== 0 || L >= y); L--) {
      var J = 0 | this.words[L];
      this.words[L] = j << 26 - g | J >>> g, j = J & E;
    }
    return A && j !== 0 && (A.words[A.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(p, $, _) {
    return a(this.negative === 0), this.iushrn(p, $, _);
  }, c.prototype.shln = function(p) {
    return this.clone().ishln(p);
  }, c.prototype.ushln = function(p) {
    return this.clone().iushln(p);
  }, c.prototype.shrn = function(p) {
    return this.clone().ishrn(p);
  }, c.prototype.ushrn = function(p) {
    return this.clone().iushrn(p);
  }, c.prototype.testn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    return !(this.length <= _ || !(this.words[_] & y));
  }, c.prototype.imaskn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var y = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= y;
    }
    return this.strip();
  }, c.prototype.maskn = function(p) {
    return this.clone().imaskn(p);
  }, c.prototype.iaddn = function(p) {
    return a(typeof p == "number"), a(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < p ? (this.words[0] = p - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
  }, c.prototype._iaddn = function(p) {
    this.words[0] += p;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(p) {
    if (a(typeof p == "number"), a(p < 67108864), p < 0)
      return this.iaddn(-p);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(p), this.negative = 1, this;
    if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(p) {
    return this.clone().iaddn(p);
  }, c.prototype.subn = function(p) {
    return this.clone().isubn(p);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(p, $, _) {
    var y, g, v = p.length + _;
    this._expand(v);
    var E = 0;
    for (y = 0; y < p.length; y++) {
      g = (0 | this.words[y + _]) + E;
      var A = (0 | p.words[y]) * $;
      E = ((g -= 67108863 & A) >> 26) - (A / 67108864 | 0), this.words[y + _] = 67108863 & g;
    }
    for (; y < this.length - _; y++)
      E = (g = (0 | this.words[y + _]) + E) >> 26, this.words[y + _] = 67108863 & g;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, y = 0; y < this.length; y++)
      E = (g = -(0 | this.words[y]) + E) >> 26, this.words[y] = 67108863 & g;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(p, $) {
    var _ = (this.length, p.length), y = this.clone(), g = p, v = 0 | g.words[g.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (g = g.ushln(_), y.iushln(_), v = 0 | g.words[g.length - 1]);
    var E, A = y.length - g.length;
    if ($ !== "mod") {
      (E = new c(null)).length = A + 1, E.words = new Array(E.length);
      for (var L = 0; L < E.length; L++)
        E.words[L] = 0;
    }
    var j = y.clone()._ishlnsubmul(g, 1, A);
    j.negative === 0 && (y = j, E && (E.words[A] = 1));
    for (var J = A - 1; J >= 0; J--) {
      var X = 67108864 * (0 | y.words[g.length + J]) + (0 | y.words[g.length + J - 1]);
      for (X = Math.min(X / v | 0, 67108863), y._ishlnsubmul(g, X, J); y.negative !== 0; )
        X--, y.negative = 0, y._ishlnsubmul(g, 1, J), y.isZero() || (y.negative ^= 1);
      E && (E.words[J] = X);
    }
    return E && E.strip(), y.strip(), $ !== "div" && _ !== 0 && y.iushrn(_), { div: E || null, mod: y };
  }, c.prototype.divmod = function(p, $, _) {
    return a(!p.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && p.negative === 0 ? (v = this.neg().divmod(p, $), $ !== "mod" && (y = v.div.neg()), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.iadd(p)), { div: y, mod: g }) : this.negative === 0 && p.negative !== 0 ? (v = this.divmod(p.neg(), $), $ !== "mod" && (y = v.div.neg()), { div: y, mod: v.mod }) : (this.negative & p.negative) != 0 ? (v = this.neg().divmod(p.neg(), $), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.isub(p)), { div: v.div, mod: g }) : p.length > this.length || this.cmp(p) < 0 ? { div: new c(0), mod: this } : p.length === 1 ? $ === "div" ? { div: this.divn(p.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(p.words[0])) } : { div: this.divn(p.words[0]), mod: new c(this.modn(p.words[0])) } : this._wordDiv(p, $);
    var y, g, v;
  }, c.prototype.div = function(p) {
    return this.divmod(p, "div", !1).div;
  }, c.prototype.mod = function(p) {
    return this.divmod(p, "mod", !1).mod;
  }, c.prototype.umod = function(p) {
    return this.divmod(p, "mod", !0).mod;
  }, c.prototype.divRound = function(p) {
    var $ = this.divmod(p);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(p) : $.mod, y = p.ushrn(1), g = p.andln(1), v = _.cmp(y);
    return v < 0 || g === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(p) {
    a(p <= 67108863);
    for (var $ = (1 << 26) % p, _ = 0, y = this.length - 1; y >= 0; y--)
      _ = ($ * _ + (0 | this.words[y])) % p;
    return _;
  }, c.prototype.idivn = function(p) {
    a(p <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = y / p | 0, $ = y % p;
    }
    return this.strip();
  }, c.prototype.divn = function(p) {
    return this.clone().idivn(p);
  }, c.prototype.egcd = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y = new c(1), g = new c(0), v = new c(0), E = new c(1), A = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++A;
    for (var L = _.clone(), j = $.clone(); !$.isZero(); ) {
      for (var J = 0, X = 1; ($.words[0] & X) == 0 && J < 26; ++J, X <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (y.isOdd() || g.isOdd()) && (y.iadd(L), g.isub(j)), y.iushrn(1), g.iushrn(1);
      for (var re = 0, Z = 1; (_.words[0] & Z) == 0 && re < 26; ++re, Z <<= 1)
        ;
      if (re > 0)
        for (_.iushrn(re); re-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(L), E.isub(j)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), y.isub(v), g.isub(E)) : (_.isub($), v.isub(y), E.isub(g));
    }
    return { a: v, b: E, gcd: _.iushln(A) };
  }, c.prototype._invmp = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y, g = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var A = 0, L = 1; ($.words[0] & L) == 0 && A < 26; ++A, L <<= 1)
        ;
      if (A > 0)
        for ($.iushrn(A); A-- > 0; )
          g.isOdd() && g.iadd(E), g.iushrn(1);
      for (var j = 0, J = 1; (_.words[0] & J) == 0 && j < 26; ++j, J <<= 1)
        ;
      if (j > 0)
        for (_.iushrn(j); j-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), g.isub(v)) : (_.isub($), v.isub(g));
    }
    return (y = $.cmpn(1) === 0 ? g : v).cmpn(0) < 0 && y.iadd(p), y;
  }, c.prototype.gcd = function(p) {
    if (this.isZero())
      return p.abs();
    if (p.isZero())
      return this.abs();
    var $ = this.clone(), _ = p.clone();
    $.negative = 0, _.negative = 0;
    for (var y = 0; $.isEven() && _.isEven(); y++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var g = $.cmp(_);
      if (g < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (g === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(y);
  }, c.prototype.invm = function(p) {
    return this.egcd(p).a.umod(p);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(p) {
    return this.words[0] & p;
  }, c.prototype.bincn = function(p) {
    a(typeof p == "number");
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= y, this;
    for (var g = y, v = _; g !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      g = (E += g) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return g !== 0 && (this.words[v] = g, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(p) {
    var $, _ = p < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (p = -p), a(p <= 67108863, "Number is too big");
      var y = 0 | this.words[0];
      $ = y === p ? 0 : y < p ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(p) {
    if (this.negative !== 0 && p.negative === 0)
      return -1;
    if (this.negative === 0 && p.negative !== 0)
      return 1;
    var $ = this.ucmp(p);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(p) {
    if (this.length > p.length)
      return 1;
    if (this.length < p.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = 0 | this.words[_], g = 0 | p.words[_];
      if (y !== g) {
        y < g ? $ = -1 : y > g && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(p) {
    return this.cmpn(p) === 1;
  }, c.prototype.gt = function(p) {
    return this.cmp(p) === 1;
  }, c.prototype.gten = function(p) {
    return this.cmpn(p) >= 0;
  }, c.prototype.gte = function(p) {
    return this.cmp(p) >= 0;
  }, c.prototype.ltn = function(p) {
    return this.cmpn(p) === -1;
  }, c.prototype.lt = function(p) {
    return this.cmp(p) === -1;
  }, c.prototype.lten = function(p) {
    return this.cmpn(p) <= 0;
  }, c.prototype.lte = function(p) {
    return this.cmp(p) <= 0;
  }, c.prototype.eqn = function(p) {
    return this.cmpn(p) === 0;
  }, c.prototype.eq = function(p) {
    return this.cmp(p) === 0;
  }, c.red = function(p) {
    return new H(p);
  }, c.prototype.toRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(p) {
    return this.red = p, this;
  }, c.prototype.forceRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(p);
  }, c.prototype.redAdd = function(p) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
  }, c.prototype.redIAdd = function(p) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
  }, c.prototype.redSub = function(p) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
  }, c.prototype.redISub = function(p) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
  }, c.prototype.redShl = function(p) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
  }, c.prototype.redMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
  }, c.prototype.redIMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(p) {
    return a(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function W(p, $) {
    this.name = p, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    W.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function ee() {
    W.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function P() {
    W.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function F() {
    W.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(p) {
    if (typeof p == "string") {
      var $ = c._prime(p);
      this.m = $.p, this.prime = $;
    } else
      a(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
  }
  function te(p) {
    H.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  W.prototype._tmp = function() {
    var p = new c(null);
    return p.words = new Array(Math.ceil(this.n / 13)), p;
  }, W.prototype.ireduce = function(p) {
    var $, _ = p;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var y = $ < this.n ? -1 : _.ucmp(this.p);
    return y === 0 ? (_.words[0] = 0, _.length = 1) : y > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, W.prototype.split = function(p, $) {
    p.iushrn(this.n, 0, $);
  }, W.prototype.imulK = function(p) {
    return p.imul(this.k);
  }, u(V, W), V.prototype.split = function(p, $) {
    for (var _ = 4194303, y = Math.min(p.length, 9), g = 0; g < y; g++)
      $.words[g] = p.words[g];
    if ($.length = y, p.length <= 9)
      return p.words[0] = 0, void (p.length = 1);
    var v = p.words[9];
    for ($.words[$.length++] = v & _, g = 10; g < p.length; g++) {
      var E = 0 | p.words[g];
      p.words[g - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, p.words[g - 10] = v, v === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
  }, V.prototype.imulK = function(p) {
    p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 0 | p.words[_];
      $ += 977 * y, p.words[_] = 67108863 & $, $ = 64 * y + ($ / 67108864 | 0);
    }
    return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
  }, u(ee, W), u(P, W), u(F, W), F.prototype.imulK = function(p) {
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 19 * (0 | p.words[_]) + $, g = 67108863 & y;
      y >>>= 26, p.words[_] = g, $ = y;
    }
    return $ !== 0 && (p.words[p.length++] = $), p;
  }, c._prime = function(p) {
    if (z[p])
      return z[p];
    var $;
    if (p === "k256")
      $ = new V();
    else if (p === "p224")
      $ = new ee();
    else if (p === "p192")
      $ = new P();
    else {
      if (p !== "p25519")
        throw new Error("Unknown prime " + p);
      $ = new F();
    }
    return z[p] = $, $;
  }, H.prototype._verify1 = function(p) {
    a(p.negative === 0, "red works only with positives"), a(p.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(p, $) {
    a((p.negative | $.negative) == 0, "red works only with positives"), a(p.red && p.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(p) {
    return this.prime ? this.prime.ireduce(p)._forceRed(this) : p.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(p) {
    return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
  }, H.prototype.add = function(p, $) {
    this._verify2(p, $);
    var _ = p.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(p, $) {
    this._verify2(p, $);
    var _ = p.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(p, $) {
    this._verify2(p, $);
    var _ = p.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(p, $) {
    this._verify2(p, $);
    var _ = p.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(p, $) {
    return this._verify1(p), this.imod(p.ushln($));
  }, H.prototype.imul = function(p, $) {
    return this._verify2(p, $), this.imod(p.imul($));
  }, H.prototype.mul = function(p, $) {
    return this._verify2(p, $), this.imod(p.mul($));
  }, H.prototype.isqr = function(p) {
    return this.imul(p, p.clone());
  }, H.prototype.sqr = function(p) {
    return this.mul(p, p);
  }, H.prototype.sqrt = function(p) {
    if (p.isZero())
      return p.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(p, _);
    }
    for (var y = this.m.subn(1), g = 0; !y.isZero() && y.andln(1) === 0; )
      g++, y.iushrn(1);
    a(!y.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), A = this.m.subn(1).iushrn(1), L = this.m.bitLength();
    for (L = new c(2 * L * L).toRed(this); this.pow(L, A).cmp(E) !== 0; )
      L.redIAdd(E);
    for (var j = this.pow(L, y), J = this.pow(p, y.addn(1).iushrn(1)), X = this.pow(p, y), re = g; X.cmp(v) !== 0; ) {
      for (var Z = X, ie = 0; Z.cmp(v) !== 0; ie++)
        Z = Z.redSqr();
      a(ie < re);
      var oe = this.pow(j, new c(1).iushln(re - ie - 1));
      J = J.redMul(oe), j = oe.redSqr(), X = X.redMul(j), re = ie;
    }
    return J;
  }, H.prototype.invm = function(p) {
    var $ = p._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(p, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return p.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = p;
    for (var y = 2; y < _.length; y++)
      _[y] = this.mul(_[y - 1], p);
    var g = _[0], v = 0, E = 0, A = $.bitLength() % 26;
    for (A === 0 && (A = 26), y = $.length - 1; y >= 0; y--) {
      for (var L = $.words[y], j = A - 1; j >= 0; j--) {
        var J = L >> j & 1;
        g !== _[0] && (g = this.sqr(g)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || y === 0 && j === 0) && (g = this.mul(g, _[v]), E = 0, v = 0)) : E = 0;
      }
      A = 26;
    }
    return g;
  }, H.prototype.convertTo = function(p) {
    var $ = p.umod(this.m);
    return $ === p ? $.clone() : $;
  }, H.prototype.convertFrom = function(p) {
    var $ = p.clone();
    return $.red = null, $;
  }, c.mont = function(p) {
    return new te(p);
  }, u(te, H), te.prototype.convertTo = function(p) {
    return this.imod(p.ushln(this.shift));
  }, te.prototype.convertFrom = function(p) {
    var $ = this.imod(p.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(p, $) {
    if (p.isZero() || $.isZero())
      return p.words[0] = 0, p.length = 1, p;
    var _ = p.imul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(p, $) {
    if (p.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = p.mul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(p) {
    return this.imod(p._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var api = {}, encoders = {}, buffer$6 = {}, ieee754 = {
  read: function(o, n, a, u, c) {
    var m, d, w = 8 * c - u - 1, S = (1 << w) - 1, T = S >> 1, B = -7, I = a ? c - 1 : 0, C = a ? -1 : 1, N = o[n + I];
    for (I += C, m = N & (1 << -B) - 1, N >>= -B, B += w; B > 0; m = 256 * m + o[n + I], I += C, B -= 8)
      ;
    for (d = m & (1 << -B) - 1, m >>= -B, B += u; B > 0; d = 256 * d + o[n + I], I += C, B -= 8)
      ;
    if (m === 0)
      m = 1 - T;
    else {
      if (m === S)
        return d ? NaN : 1 / 0 * (N ? -1 : 1);
      d += Math.pow(2, u), m -= T;
    }
    return (N ? -1 : 1) * d * Math.pow(2, m - u);
  },
  write: function(o, n, a, u, c, m) {
    var d, w, S, T = 8 * m - c - 1, B = (1 << T) - 1, I = B >> 1, C = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = u ? 0 : m - 1, q = u ? 1 : -1, D = n < 0 || n === 0 && 1 / n < 0 ? 1 : 0;
    for (n = Math.abs(n), isNaN(n) || n === 1 / 0 ? (w = isNaN(n) ? 1 : 0, d = B) : (d = Math.floor(Math.log(n) / Math.LN2), n * (S = Math.pow(2, -d)) < 1 && (d--, S *= 2), (n += d + I >= 1 ? C / S : C * Math.pow(2, 1 - I)) * S >= 2 && (d++, S /= 2), d + I >= B ? (w = 0, d = B) : d + I >= 1 ? (w = (n * S - 1) * Math.pow(2, c), d += I) : (w = n * Math.pow(2, I - 1) * Math.pow(2, c), d = 0)); c >= 8; o[a + N] = 255 & w, N += q, w /= 256, c -= 8)
      ;
    for (d = d << c | w, T += c; T > 0; o[a + N] = 255 & d, N += q, d /= 256, T -= 8)
      ;
    o[a + N - q] |= 128 * D;
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(o) {
  const n = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = d, o.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, o.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function m(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, b) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return T(l);
    }
    return w(l, h, b);
  }
  function w(l, h, b) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | N(x, O);
        let Q = m(G);
        const ne = Q.write(x, O);
        return ne !== G && (Q = Q.slice(0, ne)), Q;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (le(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (le(l, ArrayBuffer) || l && le(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (le(l, SharedArrayBuffer) || l && le(l.buffer, SharedArrayBuffer)))
      return I(l, h, b);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const M = l.valueOf && l.valueOf();
    if (M != null && M !== l)
      return d.from(M, h, b);
    const k = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = m(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? m(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (k)
      return k;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, b);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function T(l) {
    return S(l), m(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), b = m(h);
    for (let M = 0; M < h; M += 1)
      b[M] = 255 & l[M];
    return b;
  }
  function I(l, h, b) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (b || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let M;
    return M = h === void 0 && b === void 0 ? new Uint8Array(l) : b === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, b), Object.setPrototypeOf(M, d.prototype), M;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function N(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || le(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const b = l.length, M = arguments.length > 2 && arguments[2] === !0;
    if (!M && b === 0)
      return 0;
    let k = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return b;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * b;
        case "hex":
          return b >>> 1;
        case "base64":
          return $e(l).length;
        default:
          if (k)
            return M ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), k = !0;
      }
  }
  function q(l, h, b) {
    let M = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return g(this, h, b);
        case "utf8":
        case "utf-8":
          return p(this, h, b);
        case "ascii":
          return _(this, h, b);
        case "latin1":
        case "binary":
          return y(this, h, b);
        case "base64":
          return te(this, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, b);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), M = !0;
      }
  }
  function D(l, h, b) {
    const M = l[h];
    l[h] = l[b], l[b] = M;
  }
  function z(l, h, b, M, k) {
    if (l.length === 0)
      return -1;
    if (typeof b == "string" ? (M = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), we(b = +b) && (b = k ? 0 : l.length - 1), b < 0 && (b = l.length + b), b >= l.length) {
      if (k)
        return -1;
      b = l.length - 1;
    } else if (b < 0) {
      if (!k)
        return -1;
      b = 0;
    }
    if (typeof h == "string" && (h = d.from(h, M)), d.isBuffer(h))
      return h.length === 0 ? -1 : W(l, h, b, M, k);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(l, h, b) : Uint8Array.prototype.lastIndexOf.call(l, h, b) : W(l, [h], b, M, k);
    throw new TypeError("val must be string, number or Buffer");
  }
  function W(l, h, b, M, k) {
    let x, O = 1, G = l.length, Q = h.length;
    if (M !== void 0 && ((M = String(M).toLowerCase()) === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, Q /= 2, b /= 2;
    }
    function ne(Y, ae) {
      return O === 1 ? Y[ae] : Y.readUInt16BE(ae * O);
    }
    if (k) {
      let Y = -1;
      for (x = b; x < G; x++)
        if (ne(l, x) === ne(h, Y === -1 ? 0 : x - Y)) {
          if (Y === -1 && (Y = x), x - Y + 1 === Q)
            return Y * O;
        } else
          Y !== -1 && (x -= x - Y), Y = -1;
    } else
      for (b + Q > G && (b = G - Q), x = b; x >= 0; x--) {
        let Y = !0;
        for (let ae = 0; ae < Q; ae++)
          if (ne(l, x + ae) !== ne(h, ae)) {
            Y = !1;
            break;
          }
        if (Y)
          return x;
      }
    return -1;
  }
  function V(l, h, b, M) {
    b = Number(b) || 0;
    const k = l.length - b;
    M ? (M = Number(M)) > k && (M = k) : M = k;
    const x = h.length;
    let O;
    for (M > x / 2 && (M = x / 2), O = 0; O < M; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[b + O] = G;
    }
    return O;
  }
  function ee(l, h, b, M) {
    return fe(he(h, l.length - b), l, b, M);
  }
  function P(l, h, b, M) {
    return fe(function(k) {
      const x = [];
      for (let O = 0; O < k.length; ++O)
        x.push(255 & k.charCodeAt(O));
      return x;
    }(h), l, b, M);
  }
  function F(l, h, b, M) {
    return fe($e(h), l, b, M);
  }
  function H(l, h, b, M) {
    return fe(function(k, x) {
      let O, G, Q;
      const ne = [];
      for (let Y = 0; Y < k.length && !((x -= 2) < 0); ++Y)
        O = k.charCodeAt(Y), G = O >> 8, Q = O % 256, ne.push(Q), ne.push(G);
      return ne;
    }(h, l.length - b), l, b, M);
  }
  function te(l, h, b) {
    return h === 0 && b === l.length ? n.fromByteArray(l) : n.fromByteArray(l.slice(h, b));
  }
  function p(l, h, b) {
    b = Math.min(l.length, b);
    const M = [];
    let k = h;
    for (; k < b; ) {
      const x = l[k];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (k + G <= b) {
        let Q, ne, Y, ae;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            Q = l[k + 1], (192 & Q) == 128 && (ae = (31 & x) << 6 | 63 & Q, ae > 127 && (O = ae));
            break;
          case 3:
            Q = l[k + 1], ne = l[k + 2], (192 & Q) == 128 && (192 & ne) == 128 && (ae = (15 & x) << 12 | (63 & Q) << 6 | 63 & ne, ae > 2047 && (ae < 55296 || ae > 57343) && (O = ae));
            break;
          case 4:
            Q = l[k + 1], ne = l[k + 2], Y = l[k + 3], (192 & Q) == 128 && (192 & ne) == 128 && (192 & Y) == 128 && (ae = (15 & x) << 18 | (63 & Q) << 12 | (63 & ne) << 6 | 63 & Y, ae > 65535 && ae < 1114112 && (O = ae));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, M.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), M.push(O), k += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", Q = 0;
      for (; Q < O; )
        G += String.fromCharCode.apply(String, x.slice(Q, Q += $));
      return G;
    }(M);
  }
  o.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, b) {
    return w(l, h, b);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, b) {
    return function(M, k, x) {
      return S(M), M <= 0 ? m(M) : k !== void 0 ? typeof x == "string" ? m(M).fill(k, x) : m(M).fill(k) : m(M);
    }(l, h, b);
  }, d.allocUnsafe = function(l) {
    return T(l);
  }, d.allocUnsafeSlow = function(l) {
    return T(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), le(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let b = l.length, M = h.length;
    for (let k = 0, x = Math.min(b, M); k < x; ++k)
      if (l[k] !== h[k]) {
        b = l[k], M = h[k];
        break;
      }
    return b < M ? -1 : M < b ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let b;
    if (h === void 0)
      for (h = 0, b = 0; b < l.length; ++b)
        h += l[b].length;
    const M = d.allocUnsafe(h);
    let k = 0;
    for (b = 0; b < l.length; ++b) {
      let x = l[b];
      if (le(x, Uint8Array))
        k + x.length > M.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(M, k)) : Uint8Array.prototype.set.call(M, x, k);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(M, k);
      }
      k += x.length;
    }
    return M;
  }, d.byteLength = N, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? p(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = o.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, b, M, k) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), b === void 0 && (b = l ? l.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), h < 0 || b > l.length || M < 0 || k > this.length)
      throw new RangeError("out of range index");
    if (M >= k && h >= b)
      return 0;
    if (M >= k)
      return -1;
    if (h >= b)
      return 1;
    if (this === l)
      return 0;
    let x = (k >>>= 0) - (M >>>= 0), O = (b >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), Q = this.slice(M, k), ne = l.slice(h, b);
    for (let Y = 0; Y < G; ++Y)
      if (Q[Y] !== ne[Y]) {
        x = Q[Y], O = ne[Y];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, b) {
    return this.indexOf(l, h, b) !== -1;
  }, d.prototype.indexOf = function(l, h, b) {
    return z(this, l, h, b, !0);
  }, d.prototype.lastIndexOf = function(l, h, b) {
    return z(this, l, h, b, !1);
  }, d.prototype.write = function(l, h, b, M) {
    if (h === void 0)
      M = "utf8", b = this.length, h = 0;
    else if (b === void 0 && typeof h == "string")
      M = h, b = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(b) ? (b >>>= 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
    }
    const k = this.length - h;
    if ((b === void 0 || b > k) && (b = k), l.length > 0 && (b < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    M || (M = "utf8");
    let x = !1;
    for (; ; )
      switch (M) {
        case "hex":
          return V(this, l, h, b);
        case "utf8":
        case "utf-8":
          return ee(this, l, h, b);
        case "ascii":
        case "latin1":
        case "binary":
          return P(this, l, h, b);
        case "base64":
          return F(this, l, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, b);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + M);
          M = ("" + M).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(127 & l[k]);
    return M;
  }
  function y(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(l[k]);
    return M;
  }
  function g(l, h, b) {
    const M = l.length;
    (!h || h < 0) && (h = 0), (!b || b < 0 || b > M) && (b = M);
    let k = "";
    for (let x = h; x < b; ++x)
      k += We[l[x]];
    return k;
  }
  function v(l, h, b) {
    const M = l.slice(h, b);
    let k = "";
    for (let x = 0; x < M.length - 1; x += 2)
      k += String.fromCharCode(M[x] + 256 * M[x + 1]);
    return k;
  }
  function E(l, h, b) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > b)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function A(l, h, b, M, k, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > k || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (b + M > l.length)
      throw new RangeError("Index out of range");
  }
  function L(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, b;
  }
  function j(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b + 7] = x, x >>= 8, l[b + 6] = x, x >>= 8, l[b + 5] = x, x >>= 8, l[b + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b + 3] = O, O >>= 8, l[b + 2] = O, O >>= 8, l[b + 1] = O, O >>= 8, l[b] = O, b + 8;
  }
  function J(l, h, b, M, k, x) {
    if (b + M > l.length)
      throw new RangeError("Index out of range");
    if (b < 0)
      throw new RangeError("Index out of range");
  }
  function X(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 4), a.write(l, h, b, M, 23, 4), b + 4;
  }
  function re(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 8), a.write(l, h, b, M, 52, 8), b + 8;
  }
  d.prototype.slice = function(l, h) {
    const b = this.length;
    (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (h = h === void 0 ? b : ~~h) < 0 ? (h += b) < 0 && (h = 0) : h > b && (h = b), h < l && (h = l);
    const M = this.subarray(l, h);
    return Object.setPrototypeOf(M, d.prototype), M;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return M;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l + --h], k = 1;
    for (; h > 0 && (k *= 256); )
      M += this[l + --h] * k;
    return M;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, k = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
    return BigInt(M) + (BigInt(k) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], k = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
    return (BigInt(M) << BigInt(32)) + BigInt(k);
  }), d.prototype.readIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return k *= 128, M >= k && (M -= Math.pow(2, 8 * h)), M;
  }, d.prototype.readIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = h, k = 1, x = this[l + --M];
    for (; M > 0 && (k *= 256); )
      x += this[l + --M] * k;
    return k *= 128, x >= k && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l] | this[l + 1] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l + 1] | this[l] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
    return (BigInt(M) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(M) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = 1, x = 0;
    for (this[h] = 255 & l; ++x < b && (k *= 256); )
      this[h + x] = l / k & 255;
    return h + b;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = b - 1, x = 1;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      this[h + k] = l / x & 255;
    return h + b;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++k < b && (x *= 256); )
      l < 0 && O === 0 && this[h + k - 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeIntBE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = b - 1, x = 1, O = 0;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + k + 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, b) {
    return X(this, l, h, !0, b);
  }, d.prototype.writeFloatBE = function(l, h, b) {
    return X(this, l, h, !1, b);
  }, d.prototype.writeDoubleLE = function(l, h, b) {
    return re(this, l, h, !0, b);
  }, d.prototype.writeDoubleBE = function(l, h, b) {
    return re(this, l, h, !1, b);
  }, d.prototype.copy = function(l, h, b, M) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (b || (b = 0), M || M === 0 || (M = this.length), h >= l.length && (h = l.length), h || (h = 0), M > 0 && M < b && (M = b), M === b || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (b < 0 || b >= this.length)
      throw new RangeError("Index out of range");
    if (M < 0)
      throw new RangeError("sourceEnd out of bounds");
    M > this.length && (M = this.length), l.length - h < M - b && (M = l.length - h + b);
    const k = M - b;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, b, M) : Uint8Array.prototype.set.call(l, this.subarray(b, M), h), k;
  }, d.prototype.fill = function(l, h, b, M) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (M = h, h = 0, b = this.length) : typeof b == "string" && (M = b, b = this.length), M !== void 0 && typeof M != "string")
        throw new TypeError("encoding must be a string");
      if (typeof M == "string" && !d.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (M === "utf8" && x < 128 || M === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < b)
      throw new RangeError("Out of range index");
    if (b <= h)
      return this;
    let k;
    if (h >>>= 0, b = b === void 0 ? this.length : b >>> 0, l || (l = 0), typeof l == "number")
      for (k = h; k < b; ++k)
        this[k] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, M), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (k = 0; k < b - h; ++k)
        this[k + h] = x[k % O];
    }
    return this;
  };
  const Z = {};
  function ie(l, h, b) {
    Z[l] = class extends b {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(M) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: M, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function oe(l) {
    let h = "", b = l.length;
    const M = l[0] === "-" ? 1 : 0;
    for (; b >= M + 4; b -= 3)
      h = `_${l.slice(b - 3, b)}${h}`;
    return `${l.slice(0, b)}${h}`;
  }
  function ue(l, h, b, M, k, x) {
    if (l > b || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${b}${O}`, new Z.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, Q) {
      se(G, "offset"), O[G] !== void 0 && O[G + Q] !== void 0 || ce(G, O.length - (Q + 1));
    })(M, k, x);
  }
  function se(l, h) {
    if (typeof l != "number")
      throw new Z.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function ce(l, h, b) {
    throw Math.floor(l) !== l ? (se(l, b), new Z.ERR_OUT_OF_RANGE(b || "offset", "an integer", l)) : h < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(b || "offset", `>= ${b ? 1 : 0} and <= ${h}`, l);
  }
  ie("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), ie("ERR_OUT_OF_RANGE", function(l, h, b) {
    let M = `The value of "${l}" is out of range.`, k = b;
    return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? k = oe(String(b)) : typeof b == "bigint" && (k = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (k = oe(k)), k += "n"), M += ` It must be ${h}. Received ${k}`, M;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let b;
    h = h || 1 / 0;
    const M = l.length;
    let k = null;
    const x = [];
    for (let O = 0; O < M; ++O) {
      if (b = l.charCodeAt(O), b > 55295 && b < 57344) {
        if (!k) {
          if (b > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === M) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          k = b;
          continue;
        }
        if (b < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), k = b;
          continue;
        }
        b = 65536 + (k - 55296 << 10 | b - 56320);
      } else
        k && (h -= 3) > -1 && x.push(239, 191, 189);
      if (k = null, b < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(b);
      } else if (b < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(b >> 6 | 192, 63 & b | 128);
      } else if (b < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(b >> 12 | 224, b >> 6 & 63 | 128, 63 & b | 128);
      } else {
        if (!(b < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, 63 & b | 128);
      }
    }
    return x;
  }
  function $e(l) {
    return n.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function fe(l, h, b, M) {
    let k;
    for (k = 0; k < M && !(k + b >= h.length || k >= l.length); ++k)
      h[k + b] = l[k];
    return k;
  }
  function le(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let b = 0; b < 16; ++b) {
      const M = 16 * b;
      for (let k = 0; k < 16; ++k)
        h[M + k] = l[b] + l[k];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$6);
var buffer$5 = buffer$6, Buffer$a = buffer$5.Buffer, safer = {}, key$3;
for (key$3 in buffer$5)
  buffer$5.hasOwnProperty(key$3) && key$3 !== "SlowBuffer" && key$3 !== "Buffer" && (safer[key$3] = buffer$5[key$3]);
var Safer = safer.Buffer = {};
for (key$3 in Buffer$a)
  Buffer$a.hasOwnProperty(key$3) && key$3 !== "allocUnsafe" && key$3 !== "allocUnsafeSlow" && (Safer[key$3] = Buffer$a[key$3]);
if (safer.Buffer.prototype = Buffer$a.prototype, Safer.from && Safer.from !== Uint8Array.from || (Safer.from = function(o, n, a) {
  if (typeof o == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof o);
  if (o && o.length === void 0)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof o);
  return Buffer$a(o, n, a);
}), Safer.alloc || (Safer.alloc = function(o, n, a) {
  if (typeof o != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof o);
  if (o < 0 || o >= 2 * (1 << 30))
    throw new RangeError('The value "' + o + '" is invalid for option "size"');
  var u = Buffer$a(o);
  return n && n.length !== 0 ? typeof a == "string" ? u.fill(n, a) : u.fill(n) : u.fill(0), u;
}), !safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = { MAX_LENGTH: safer.kMaxLength }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$9 = requireInherits_browser();
function Reporter$2(o) {
  this._reporterState = { obj: null, path: [], options: o || {}, errors: [] };
}
function ReporterError(o, n) {
  this.path = o, this.rethrow(n);
}
reporter.Reporter = Reporter$2, Reporter$2.prototype.isError = function(o) {
  return o instanceof ReporterError;
}, Reporter$2.prototype.save = function() {
  const o = this._reporterState;
  return { obj: o.obj, pathLen: o.path.length };
}, Reporter$2.prototype.restore = function(o) {
  const n = this._reporterState;
  n.obj = o.obj, n.path = n.path.slice(0, o.pathLen);
}, Reporter$2.prototype.enterKey = function(o) {
  return this._reporterState.path.push(o);
}, Reporter$2.prototype.exitKey = function(o) {
  const n = this._reporterState;
  n.path = n.path.slice(0, o - 1);
}, Reporter$2.prototype.leaveKey = function(o, n, a) {
  const u = this._reporterState;
  this.exitKey(o), u.obj !== null && (u.obj[n] = a);
}, Reporter$2.prototype.path = function() {
  return this._reporterState.path.join("/");
}, Reporter$2.prototype.enterObject = function() {
  const o = this._reporterState, n = o.obj;
  return o.obj = {}, n;
}, Reporter$2.prototype.leaveObject = function(o) {
  const n = this._reporterState, a = n.obj;
  return n.obj = o, a;
}, Reporter$2.prototype.error = function(o) {
  let n;
  const a = this._reporterState, u = o instanceof ReporterError;
  if (n = u ? o : new ReporterError(a.path.map(function(c) {
    return "[" + JSON.stringify(c) + "]";
  }).join(""), o.message || o, o.stack), !a.options.partial)
    throw n;
  return u || a.errors.push(n), n;
}, Reporter$2.prototype.wrapResult = function(o) {
  const n = this._reporterState;
  return n.options.partial ? { result: this.isError(o) ? null : o, errors: n.errors } : o;
}, inherits$9(ReporterError, Error), ReporterError.prototype.rethrow = function(o) {
  if (this.message = o + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (n) {
      this.stack = n.stack;
    }
  return this;
};
var buffer$4 = {};
const inherits$8 = requireInherits_browser(), Reporter$1 = reporter.Reporter, Buffer$9 = safer_1.Buffer;
function DecoderBuffer$2(o, n) {
  Reporter$1.call(this, n), Buffer$9.isBuffer(o) ? (this.base = o, this.offset = 0, this.length = o.length) : this.error("Input not Buffer");
}
function EncoderBuffer$1(o, n) {
  if (Array.isArray(o))
    this.length = 0, this.value = o.map(function(a) {
      return EncoderBuffer$1.isEncoderBuffer(a) || (a = new EncoderBuffer$1(a, n)), this.length += a.length, a;
    }, this);
  else if (typeof o == "number") {
    if (!(0 <= o && o <= 255))
      return n.error("non-byte EncoderBuffer value");
    this.value = o, this.length = 1;
  } else if (typeof o == "string")
    this.value = o, this.length = Buffer$9.byteLength(o);
  else {
    if (!Buffer$9.isBuffer(o))
      return n.error("Unsupported type: " + typeof o);
    this.value = o, this.length = o.length;
  }
}
inherits$8(DecoderBuffer$2, Reporter$1), buffer$4.DecoderBuffer = DecoderBuffer$2, DecoderBuffer$2.isDecoderBuffer = function(o) {
  return o instanceof DecoderBuffer$2 || typeof o == "object" && Buffer$9.isBuffer(o.base) && o.constructor.name === "DecoderBuffer" && typeof o.offset == "number" && typeof o.length == "number" && typeof o.save == "function" && typeof o.restore == "function" && typeof o.isEmpty == "function" && typeof o.readUInt8 == "function" && typeof o.skip == "function" && typeof o.raw == "function";
}, DecoderBuffer$2.prototype.save = function() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
}, DecoderBuffer$2.prototype.restore = function(o) {
  const n = new DecoderBuffer$2(this.base);
  return n.offset = o.offset, n.length = this.offset, this.offset = o.offset, Reporter$1.prototype.restore.call(this, o.reporter), n;
}, DecoderBuffer$2.prototype.isEmpty = function() {
  return this.offset === this.length;
}, DecoderBuffer$2.prototype.readUInt8 = function(o) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
}, DecoderBuffer$2.prototype.skip = function(o, n) {
  if (!(this.offset + o <= this.length))
    return this.error(n || "DecoderBuffer overrun");
  const a = new DecoderBuffer$2(this.base);
  return a._reporterState = this._reporterState, a.offset = this.offset, a.length = this.offset + o, this.offset += o, a;
}, DecoderBuffer$2.prototype.raw = function(o) {
  return this.base.slice(o ? o.offset : this.offset, this.length);
}, buffer$4.EncoderBuffer = EncoderBuffer$1, EncoderBuffer$1.isEncoderBuffer = function(o) {
  return o instanceof EncoderBuffer$1 || typeof o == "object" && o.constructor.name === "EncoderBuffer" && typeof o.length == "number" && typeof o.join == "function";
}, EncoderBuffer$1.prototype.join = function(o, n) {
  return o || (o = Buffer$9.alloc(this.length)), n || (n = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(a) {
    a.join(o, n), n += a.length;
  }) : (typeof this.value == "number" ? o[n] = this.value : typeof this.value == "string" ? o.write(this.value, n) : Buffer$9.isBuffer(this.value) && this.value.copy(o, n), n += this.length)), o;
};
var minimalisticAssert = assert$g;
function assert$g(o, n) {
  if (!o)
    throw new Error(n || "Assertion failed");
}
assert$g.equal = function(o, n, a) {
  if (o != n)
    throw new Error(a || "Assertion failed: " + o + " != " + n);
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer$4.EncoderBuffer, DecoderBuffer$1 = buffer$4.DecoderBuffer, assert$f = minimalisticAssert, tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
function Node$2(o, n, a) {
  const u = {};
  this._baseState = u, u.name = a, u.enc = o, u.parent = n || null, u.children = null, u.tag = null, u.args = null, u.reverseArgs = null, u.choice = null, u.optional = !1, u.any = !1, u.obj = !1, u.use = null, u.useDecoder = null, u.key = null, u.default = null, u.explicit = null, u.implicit = null, u.contains = null, u.parent || (u.children = [], this._wrap());
}
var node = Node$2;
const stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
Node$2.prototype.clone = function() {
  const o = this._baseState, n = {};
  stateProps.forEach(function(u) {
    n[u] = o[u];
  });
  const a = new this.constructor(n.parent);
  return a._baseState = n, a;
}, Node$2.prototype._wrap = function() {
  const o = this._baseState;
  methods.forEach(function(n) {
    this[n] = function() {
      const a = new this.constructor(this);
      return o.children.push(a), a[n].apply(a, arguments);
    };
  }, this);
}, Node$2.prototype._init = function(o) {
  const n = this._baseState;
  assert$f(n.parent === null), o.call(this), n.children = n.children.filter(function(a) {
    return a._baseState.parent === this;
  }, this), assert$f.equal(n.children.length, 1, "Root node can have only one child");
}, Node$2.prototype._useArgs = function(o) {
  const n = this._baseState, a = o.filter(function(u) {
    return u instanceof this.constructor;
  }, this);
  o = o.filter(function(u) {
    return !(u instanceof this.constructor);
  }, this), a.length !== 0 && (assert$f(n.children === null), n.children = a, a.forEach(function(u) {
    u._baseState.parent = this;
  }, this)), o.length !== 0 && (assert$f(n.args === null), n.args = o, n.reverseArgs = o.map(function(u) {
    if (typeof u != "object" || u.constructor !== Object)
      return u;
    const c = {};
    return Object.keys(u).forEach(function(m) {
      m == (0 | m) && (m |= 0);
      const d = u[m];
      c[d] = m;
    }), c;
  }));
}, overrided.forEach(function(o) {
  Node$2.prototype[o] = function() {
    const n = this._baseState;
    throw new Error(o + " not implemented for encoding: " + n.enc);
  };
}), tags.forEach(function(o) {
  Node$2.prototype[o] = function() {
    const n = this._baseState, a = Array.prototype.slice.call(arguments);
    return assert$f(n.tag === null), n.tag = o, this._useArgs(a), this;
  };
}), Node$2.prototype.use = function(o) {
  assert$f(o);
  const n = this._baseState;
  return assert$f(n.use === null), n.use = o, this;
}, Node$2.prototype.optional = function() {
  return this._baseState.optional = !0, this;
}, Node$2.prototype.def = function(o) {
  const n = this._baseState;
  return assert$f(n.default === null), n.default = o, n.optional = !0, this;
}, Node$2.prototype.explicit = function(o) {
  const n = this._baseState;
  return assert$f(n.explicit === null && n.implicit === null), n.explicit = o, this;
}, Node$2.prototype.implicit = function(o) {
  const n = this._baseState;
  return assert$f(n.explicit === null && n.implicit === null), n.implicit = o, this;
}, Node$2.prototype.obj = function() {
  const o = this._baseState, n = Array.prototype.slice.call(arguments);
  return o.obj = !0, n.length !== 0 && this._useArgs(n), this;
}, Node$2.prototype.key = function(o) {
  const n = this._baseState;
  return assert$f(n.key === null), n.key = o, this;
}, Node$2.prototype.any = function() {
  return this._baseState.any = !0, this;
}, Node$2.prototype.choice = function(o) {
  const n = this._baseState;
  return assert$f(n.choice === null), n.choice = o, this._useArgs(Object.keys(o).map(function(a) {
    return o[a];
  })), this;
}, Node$2.prototype.contains = function(o) {
  const n = this._baseState;
  return assert$f(n.use === null), n.contains = o, this;
}, Node$2.prototype._decode = function(o, n) {
  const a = this._baseState;
  if (a.parent === null)
    return o.wrapResult(a.children[0]._decode(o, n));
  let u, c = a.default, m = !0, d = null;
  if (a.key !== null && (d = o.enterKey(a.key)), a.optional) {
    let w = null;
    if (a.explicit !== null ? w = a.explicit : a.implicit !== null ? w = a.implicit : a.tag !== null && (w = a.tag), w !== null || a.any) {
      if (m = this._peekTag(o, w, a.any), o.isError(m))
        return m;
    } else {
      const S = o.save();
      try {
        a.choice === null ? this._decodeGeneric(a.tag, o, n) : this._decodeChoice(o, n), m = !0;
      } catch {
        m = !1;
      }
      o.restore(S);
    }
  }
  if (a.obj && m && (u = o.enterObject()), m) {
    if (a.explicit !== null) {
      const S = this._decodeTag(o, a.explicit);
      if (o.isError(S))
        return S;
      o = S;
    }
    const w = o.offset;
    if (a.use === null && a.choice === null) {
      let S;
      a.any && (S = o.save());
      const T = this._decodeTag(o, a.implicit !== null ? a.implicit : a.tag, a.any);
      if (o.isError(T))
        return T;
      a.any ? c = o.raw(S) : o = T;
    }
    if (n && n.track && a.tag !== null && n.track(o.path(), w, o.length, "tagged"), n && n.track && a.tag !== null && n.track(o.path(), o.offset, o.length, "content"), a.any || (c = a.choice === null ? this._decodeGeneric(a.tag, o, n) : this._decodeChoice(o, n)), o.isError(c))
      return c;
    if (a.any || a.choice !== null || a.children === null || a.children.forEach(function(S) {
      S._decode(o, n);
    }), a.contains && (a.tag === "octstr" || a.tag === "bitstr")) {
      const S = new DecoderBuffer$1(c);
      c = this._getUse(a.contains, o._reporterState.obj)._decode(S, n);
    }
  }
  return a.obj && m && (c = o.leaveObject(u)), a.key === null || c === null && m !== !0 ? d !== null && o.exitKey(d) : o.leaveKey(d, a.key, c), c;
}, Node$2.prototype._decodeGeneric = function(o, n, a) {
  const u = this._baseState;
  return o === "seq" || o === "set" ? null : o === "seqof" || o === "setof" ? this._decodeList(n, o, u.args[0], a) : /str$/.test(o) ? this._decodeStr(n, o, a) : o === "objid" && u.args ? this._decodeObjid(n, u.args[0], u.args[1], a) : o === "objid" ? this._decodeObjid(n, null, null, a) : o === "gentime" || o === "utctime" ? this._decodeTime(n, o, a) : o === "null_" ? this._decodeNull(n, a) : o === "bool" ? this._decodeBool(n, a) : o === "objDesc" ? this._decodeStr(n, o, a) : o === "int" || o === "enum" ? this._decodeInt(n, u.args && u.args[0], a) : u.use !== null ? this._getUse(u.use, n._reporterState.obj)._decode(n, a) : n.error("unknown tag: " + o);
}, Node$2.prototype._getUse = function(o, n) {
  const a = this._baseState;
  return a.useDecoder = this._use(o, n), assert$f(a.useDecoder._baseState.parent === null), a.useDecoder = a.useDecoder._baseState.children[0], a.implicit !== a.useDecoder._baseState.implicit && (a.useDecoder = a.useDecoder.clone(), a.useDecoder._baseState.implicit = a.implicit), a.useDecoder;
}, Node$2.prototype._decodeChoice = function(o, n) {
  const a = this._baseState;
  let u = null, c = !1;
  return Object.keys(a.choice).some(function(m) {
    const d = o.save(), w = a.choice[m];
    try {
      const S = w._decode(o, n);
      if (o.isError(S))
        return !1;
      u = { type: m, value: S }, c = !0;
    } catch {
      return o.restore(d), !1;
    }
    return !0;
  }, this), c ? u : o.error("Choice not matched");
}, Node$2.prototype._createEncoderBuffer = function(o) {
  return new EncoderBuffer(o, this.reporter);
}, Node$2.prototype._encode = function(o, n, a) {
  const u = this._baseState;
  if (u.default !== null && u.default === o)
    return;
  const c = this._encodeValue(o, n, a);
  return c === void 0 || this._skipDefault(c, n, a) ? void 0 : c;
}, Node$2.prototype._encodeValue = function(o, n, a) {
  const u = this._baseState;
  if (u.parent === null)
    return u.children[0]._encode(o, n || new Reporter());
  let c = null;
  if (this.reporter = n, u.optional && o === void 0) {
    if (u.default === null)
      return;
    o = u.default;
  }
  let m = null, d = !1;
  if (u.any)
    c = this._createEncoderBuffer(o);
  else if (u.choice)
    c = this._encodeChoice(o, n);
  else if (u.contains)
    m = this._getUse(u.contains, a)._encode(o, n), d = !0;
  else if (u.children)
    m = u.children.map(function(w) {
      if (w._baseState.tag === "null_")
        return w._encode(null, n, o);
      if (w._baseState.key === null)
        return n.error("Child should have a key");
      const S = n.enterKey(w._baseState.key);
      if (typeof o != "object")
        return n.error("Child expected, but input is not object");
      const T = w._encode(o[w._baseState.key], n, o);
      return n.leaveKey(S), T;
    }, this).filter(function(w) {
      return w;
    }), m = this._createEncoderBuffer(m);
  else if (u.tag === "seqof" || u.tag === "setof") {
    if (!u.args || u.args.length !== 1)
      return n.error("Too many args for : " + u.tag);
    if (!Array.isArray(o))
      return n.error("seqof/setof, but data is not Array");
    const w = this.clone();
    w._baseState.implicit = null, m = this._createEncoderBuffer(o.map(function(S) {
      const T = this._baseState;
      return this._getUse(T.args[0], o)._encode(S, n);
    }, w));
  } else
    u.use !== null ? c = this._getUse(u.use, a)._encode(o, n) : (m = this._encodePrimitive(u.tag, o), d = !0);
  if (!u.any && u.choice === null) {
    const w = u.implicit !== null ? u.implicit : u.tag, S = u.implicit === null ? "universal" : "context";
    w === null ? u.use === null && n.error("Tag could be omitted only for .use()") : u.use === null && (c = this._encodeComposite(w, d, S, m));
  }
  return u.explicit !== null && (c = this._encodeComposite(u.explicit, !1, "context", c)), c;
}, Node$2.prototype._encodeChoice = function(o, n) {
  const a = this._baseState, u = a.choice[o.type];
  return u || assert$f(!1, o.type + " not found in " + JSON.stringify(Object.keys(a.choice))), u._encode(o.value, n);
}, Node$2.prototype._encodePrimitive = function(o, n) {
  const a = this._baseState;
  if (/str$/.test(o))
    return this._encodeStr(n, o);
  if (o === "objid" && a.args)
    return this._encodeObjid(n, a.reverseArgs[0], a.args[1]);
  if (o === "objid")
    return this._encodeObjid(n, null, null);
  if (o === "gentime" || o === "utctime")
    return this._encodeTime(n, o);
  if (o === "null_")
    return this._encodeNull();
  if (o === "int" || o === "enum")
    return this._encodeInt(n, a.args && a.reverseArgs[0]);
  if (o === "bool")
    return this._encodeBool(n);
  if (o === "objDesc")
    return this._encodeStr(n, o);
  throw new Error("Unsupported tag: " + o);
}, Node$2.prototype._isNumstr = function(o) {
  return /^[0-9 ]*$/.test(o);
}, Node$2.prototype._isPrintstr = function(o) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(o);
};
var der$2 = {};
(function(o) {
  function n(a) {
    const u = {};
    return Object.keys(a).forEach(function(c) {
      (0 | c) == c && (c |= 0);
      const m = a[c];
      u[m] = c;
    }), u;
  }
  o.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, o.tagClassByName = n(o.tagClass), o.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, o.tagByName = n(o.tag);
})(der$2);
const inherits$7 = requireInherits_browser(), Buffer$8 = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(o) {
  this.enc = "der", this.name = o.name, this.entity = o, this.tree = new DERNode$1(), this.tree._init(o.body);
}
var der_1$1 = DEREncoder$1;
function DERNode$1(o) {
  Node$1.call(this, "der", o);
}
function two(o) {
  return o < 10 ? "0" + o : o;
}
function encodeTag(o, n, a, u) {
  let c;
  if (o === "seqof" ? o = "seq" : o === "setof" && (o = "set"), der$1.tagByName.hasOwnProperty(o))
    c = der$1.tagByName[o];
  else {
    if (typeof o != "number" || (0 | o) !== o)
      return u.error("Unknown tag: " + o);
    c = o;
  }
  return c >= 31 ? u.error("Multi-octet tag encoding unsupported") : (n || (c |= 32), c |= der$1.tagClassByName[a || "universal"] << 6, c);
}
DEREncoder$1.prototype.encode = function(o, n) {
  return this.tree._encode(o, n).join();
}, inherits$7(DERNode$1, Node$1), DERNode$1.prototype._encodeComposite = function(o, n, a, u) {
  const c = encodeTag(o, n, a, this.reporter);
  if (u.length < 128) {
    const w = Buffer$8.alloc(2);
    return w[0] = c, w[1] = u.length, this._createEncoderBuffer([w, u]);
  }
  let m = 1;
  for (let w = u.length; w >= 256; w >>= 8)
    m++;
  const d = Buffer$8.alloc(2 + m);
  d[0] = c, d[1] = 128 | m;
  for (let w = 1 + m, S = u.length; S > 0; w--, S >>= 8)
    d[w] = 255 & S;
  return this._createEncoderBuffer([d, u]);
}, DERNode$1.prototype._encodeStr = function(o, n) {
  if (n === "bitstr")
    return this._createEncoderBuffer([0 | o.unused, o.data]);
  if (n === "bmpstr") {
    const a = Buffer$8.alloc(2 * o.length);
    for (let u = 0; u < o.length; u++)
      a.writeUInt16BE(o.charCodeAt(u), 2 * u);
    return this._createEncoderBuffer(a);
  }
  return n === "numstr" ? this._isNumstr(o) ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : n === "printstr" ? this._isPrintstr(o) ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(n) || n === "objDesc" ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: " + n + " unsupported");
}, DERNode$1.prototype._encodeObjid = function(o, n, a) {
  if (typeof o == "string") {
    if (!n)
      return this.reporter.error("string objid given, but no values map found");
    if (!n.hasOwnProperty(o))
      return this.reporter.error("objid not found in values map");
    o = n[o].split(/[\s.]+/g);
    for (let d = 0; d < o.length; d++)
      o[d] |= 0;
  } else if (Array.isArray(o)) {
    o = o.slice();
    for (let d = 0; d < o.length; d++)
      o[d] |= 0;
  }
  if (!Array.isArray(o))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(o));
  if (!a) {
    if (o[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    o.splice(0, 2, 40 * o[0] + o[1]);
  }
  let u = 0;
  for (let d = 0; d < o.length; d++) {
    let w = o[d];
    for (u++; w >= 128; w >>= 7)
      u++;
  }
  const c = Buffer$8.alloc(u);
  let m = c.length - 1;
  for (let d = o.length - 1; d >= 0; d--) {
    let w = o[d];
    for (c[m--] = 127 & w; (w >>= 7) > 0; )
      c[m--] = 128 | 127 & w;
  }
  return this._createEncoderBuffer(c);
}, DERNode$1.prototype._encodeTime = function(o, n) {
  let a;
  const u = new Date(o);
  return n === "gentime" ? a = [two(u.getUTCFullYear()), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : n === "utctime" ? a = [two(u.getUTCFullYear() % 100), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + n + " time is not supported yet"), this._encodeStr(a, "octstr");
}, DERNode$1.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
}, DERNode$1.prototype._encodeInt = function(o, n) {
  if (typeof o == "string") {
    if (!n)
      return this.reporter.error("String int or enum given, but no values map");
    if (!n.hasOwnProperty(o))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(o));
    o = n[o];
  }
  if (typeof o != "number" && !Buffer$8.isBuffer(o)) {
    const c = o.toArray();
    !o.sign && 128 & c[0] && c.unshift(0), o = Buffer$8.from(c);
  }
  if (Buffer$8.isBuffer(o)) {
    let c = o.length;
    o.length === 0 && c++;
    const m = Buffer$8.alloc(c);
    return o.copy(m), o.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
  }
  if (o < 128)
    return this._createEncoderBuffer(o);
  if (o < 256)
    return this._createEncoderBuffer([0, o]);
  let a = 1;
  for (let c = o; c >= 256; c >>= 8)
    a++;
  const u = new Array(a);
  for (let c = u.length - 1; c >= 0; c--)
    u[c] = 255 & o, o >>= 8;
  return 128 & u[0] && u.unshift(0), this._createEncoderBuffer(Buffer$8.from(u));
}, DERNode$1.prototype._encodeBool = function(o) {
  return this._createEncoderBuffer(o ? 255 : 0);
}, DERNode$1.prototype._use = function(o, n) {
  return typeof o == "function" && (o = o(n)), o._getEncoder("der").tree;
}, DERNode$1.prototype._skipDefault = function(o, n, a) {
  const u = this._baseState;
  let c;
  if (u.default === null)
    return !1;
  const m = o.join();
  if (u.defaultBuffer === void 0 && (u.defaultBuffer = this._encodeValue(u.default, n, a).join()), m.length !== u.defaultBuffer.length)
    return !1;
  for (c = 0; c < m.length; c++)
    if (m[c] !== u.defaultBuffer[c])
      return !1;
  return !0;
};
const inherits$6 = requireInherits_browser(), DEREncoder = der_1$1;
function PEMEncoder(o) {
  DEREncoder.call(this, o), this.enc = "pem";
}
inherits$6(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function(o, n) {
  const a = DEREncoder.prototype.encode.call(this, o).toString("base64"), u = ["-----BEGIN " + n.label + "-----"];
  for (let c = 0; c < a.length; c += 64)
    u.push(a.slice(c, c + 64));
  return u.push("-----END " + n.label + "-----"), u.join(`
`);
}, function(o) {
  const n = encoders;
  n.der = der_1$1, n.pem = pem$1;
}();
var decoders = {};
const inherits$5 = requireInherits_browser(), bignum = bn$3.exports, DecoderBuffer = buffer$4.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(o) {
  this.enc = "der", this.name = o.name, this.entity = o, this.tree = new DERNode(), this.tree._init(o.body);
}
var der_1 = DERDecoder$1;
function DERNode(o) {
  Node.call(this, "der", o);
}
function derDecodeTag(o, n) {
  let a = o.readUInt8(n);
  if (o.isError(a))
    return a;
  const u = der.tagClass[a >> 6], c = (32 & a) == 0;
  if ((31 & a) == 31) {
    let m = a;
    for (a = 0; (128 & m) == 128; ) {
      if (m = o.readUInt8(n), o.isError(m))
        return m;
      a <<= 7, a |= 127 & m;
    }
  } else
    a &= 31;
  return { cls: u, primitive: c, tag: a, tagStr: der.tag[a] };
}
function derDecodeLen(o, n, a) {
  let u = o.readUInt8(a);
  if (o.isError(u))
    return u;
  if (!n && u === 128)
    return null;
  if ((128 & u) == 0)
    return u;
  const c = 127 & u;
  if (c > 4)
    return o.error("length octect is too long");
  u = 0;
  for (let m = 0; m < c; m++) {
    u <<= 8;
    const d = o.readUInt8(a);
    if (o.isError(d))
      return d;
    u |= d;
  }
  return u;
}
DERDecoder$1.prototype.decode = function(o, n) {
  return DecoderBuffer.isDecoderBuffer(o) || (o = new DecoderBuffer(o, n)), this.tree._decode(o, n);
}, inherits$5(DERNode, Node), DERNode.prototype._peekTag = function(o, n, a) {
  if (o.isEmpty())
    return !1;
  const u = o.save(), c = derDecodeTag(o, 'Failed to peek tag: "' + n + '"');
  return o.isError(c) ? c : (o.restore(u), c.tag === n || c.tagStr === n || c.tagStr + "of" === n || a);
}, DERNode.prototype._decodeTag = function(o, n, a) {
  const u = derDecodeTag(o, 'Failed to decode tag of "' + n + '"');
  if (o.isError(u))
    return u;
  let c = derDecodeLen(o, u.primitive, 'Failed to get length of "' + n + '"');
  if (o.isError(c))
    return c;
  if (!a && u.tag !== n && u.tagStr !== n && u.tagStr + "of" !== n)
    return o.error('Failed to match tag: "' + n + '"');
  if (u.primitive || c !== null)
    return o.skip(c, 'Failed to match body of: "' + n + '"');
  const m = o.save(), d = this._skipUntilEnd(o, 'Failed to skip indefinite length body: "' + this.tag + '"');
  return o.isError(d) ? d : (c = o.offset - m.offset, o.restore(m), o.skip(c, 'Failed to match body of: "' + n + '"'));
}, DERNode.prototype._skipUntilEnd = function(o, n) {
  for (; ; ) {
    const a = derDecodeTag(o, n);
    if (o.isError(a))
      return a;
    const u = derDecodeLen(o, a.primitive, n);
    if (o.isError(u))
      return u;
    let c;
    if (c = a.primitive || u !== null ? o.skip(u) : this._skipUntilEnd(o, n), o.isError(c))
      return c;
    if (a.tagStr === "end")
      break;
  }
}, DERNode.prototype._decodeList = function(o, n, a, u) {
  const c = [];
  for (; !o.isEmpty(); ) {
    const m = this._peekTag(o, "end");
    if (o.isError(m))
      return m;
    const d = a.decode(o, "der", u);
    if (o.isError(d) && m)
      break;
    c.push(d);
  }
  return c;
}, DERNode.prototype._decodeStr = function(o, n) {
  if (n === "bitstr") {
    const a = o.readUInt8();
    return o.isError(a) ? a : { unused: a, data: o.raw() };
  }
  if (n === "bmpstr") {
    const a = o.raw();
    if (a.length % 2 == 1)
      return o.error("Decoding of string type: bmpstr length mismatch");
    let u = "";
    for (let c = 0; c < a.length / 2; c++)
      u += String.fromCharCode(a.readUInt16BE(2 * c));
    return u;
  }
  if (n === "numstr") {
    const a = o.raw().toString("ascii");
    return this._isNumstr(a) ? a : o.error("Decoding of string type: numstr unsupported characters");
  }
  if (n === "octstr" || n === "objDesc")
    return o.raw();
  if (n === "printstr") {
    const a = o.raw().toString("ascii");
    return this._isPrintstr(a) ? a : o.error("Decoding of string type: printstr unsupported characters");
  }
  return /str$/.test(n) ? o.raw().toString() : o.error("Decoding of string type: " + n + " unsupported");
}, DERNode.prototype._decodeObjid = function(o, n, a) {
  let u;
  const c = [];
  let m = 0, d = 0;
  for (; !o.isEmpty(); )
    d = o.readUInt8(), m <<= 7, m |= 127 & d, (128 & d) == 0 && (c.push(m), m = 0);
  128 & d && c.push(m);
  const w = c[0] / 40 | 0, S = c[0] % 40;
  if (u = a ? c : [w, S].concat(c.slice(1)), n) {
    let T = n[u.join(" ")];
    T === void 0 && (T = n[u.join(".")]), T !== void 0 && (u = T);
  }
  return u;
}, DERNode.prototype._decodeTime = function(o, n) {
  const a = o.raw().toString();
  let u, c, m, d, w, S;
  if (n === "gentime")
    u = 0 | a.slice(0, 4), c = 0 | a.slice(4, 6), m = 0 | a.slice(6, 8), d = 0 | a.slice(8, 10), w = 0 | a.slice(10, 12), S = 0 | a.slice(12, 14);
  else {
    if (n !== "utctime")
      return o.error("Decoding " + n + " time is not supported yet");
    u = 0 | a.slice(0, 2), c = 0 | a.slice(2, 4), m = 0 | a.slice(4, 6), d = 0 | a.slice(6, 8), w = 0 | a.slice(8, 10), S = 0 | a.slice(10, 12), u = u < 70 ? 2e3 + u : 1900 + u;
  }
  return Date.UTC(u, c - 1, m, d, w, S, 0);
}, DERNode.prototype._decodeNull = function() {
  return null;
}, DERNode.prototype._decodeBool = function(o) {
  const n = o.readUInt8();
  return o.isError(n) ? n : n !== 0;
}, DERNode.prototype._decodeInt = function(o, n) {
  const a = o.raw();
  let u = new bignum(a);
  return n && (u = n[u.toString(10)] || u), u;
}, DERNode.prototype._use = function(o, n) {
  return typeof o == "function" && (o = o(n)), o._getDecoder("der").tree;
};
const inherits$4 = requireInherits_browser(), Buffer$7 = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(o) {
  DERDecoder.call(this, o), this.enc = "pem";
}
inherits$4(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function(o, n) {
  const a = o.toString().split(/[\r\n]+/g), u = n.label.toUpperCase(), c = /^-----(BEGIN|END) ([^-]+)-----$/;
  let m = -1, d = -1;
  for (let T = 0; T < a.length; T++) {
    const B = a[T].match(c);
    if (B !== null && B[2] === u) {
      if (m !== -1) {
        if (B[1] !== "END")
          break;
        d = T;
        break;
      }
      if (B[1] !== "BEGIN")
        break;
      m = T;
    }
  }
  if (m === -1 || d === -1)
    throw new Error("PEM section not found for: " + u);
  const w = a.slice(m + 1, d).join("");
  w.replace(/[^a-z0-9+/=]+/gi, "");
  const S = Buffer$7.from(w, "base64");
  return DERDecoder.prototype.decode.call(this, S, n);
}, function(o) {
  const n = decoders;
  n.der = der_1, n.pem = pem;
}(), function(o) {
  const n = encoders, a = decoders, u = requireInherits_browser();
  function c(m, d) {
    this.name = m, this.body = d, this.decoders = {}, this.encoders = {};
  }
  o.define = function(m, d) {
    return new c(m, d);
  }, c.prototype._createNamed = function(m) {
    const d = this.name;
    function w(S) {
      this._initNamed(S, d);
    }
    return u(w, m), w.prototype._initNamed = function(S, T) {
      m.call(this, S, T);
    }, new w(this);
  }, c.prototype._getDecoder = function(m) {
    return m = m || "der", this.decoders.hasOwnProperty(m) || (this.decoders[m] = this._createNamed(a[m])), this.decoders[m];
  }, c.prototype.decode = function(m, d, w) {
    return this._getDecoder(d).decode(m, w);
  }, c.prototype._getEncoder = function(m) {
    return m = m || "der", this.encoders.hasOwnProperty(m) || (this.encoders[m] = this._createNamed(n[m])), this.encoders[m];
  }, c.prototype.encode = function(m, d, w) {
    return this._getEncoder(d).encode(m, w);
  };
}(api);
var base$1 = {};
(function(o) {
  const n = base$1;
  n.Reporter = reporter.Reporter, n.DecoderBuffer = buffer$4.DecoderBuffer, n.EncoderBuffer = buffer$4.EncoderBuffer, n.Node = node;
})();
var constants$1 = {};
(function(o) {
  const n = constants$1;
  n._reverse = function(a) {
    const u = {};
    return Object.keys(a).forEach(function(c) {
      (0 | c) == c && (c |= 0);
      const m = a[c];
      u[m] = c;
    }), u;
  }, n.der = der$2;
})(), function(o) {
  const n = asn1;
  n.bignum = bn$3.exports, n.define = api.define, n.base = base$1, n.constants = constants$1, n.decoders = decoders, n.encoders = encoders;
}();
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$5(n, o, a);
  return __setModuleDefault$5(n, o), n;
};
Object.defineProperty(pem$2, "__esModule", { value: !0 }), pem$2.jwkTopem = pem$2.pemTojwk = void 0;
const asn = __importStar$5(asn1);
function urlize(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hex2b64url(o) {
  return urlize(Buffer.from(o, "hex").toString("base64"));
}
var RSAPublicKey = asn.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
}), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
}), PublicKeyInfo = asn.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
}), Version = asn.define("Version", function() {
  this.int({ 0: "two-prime", 1: "multi" });
}), OtherPrimeInfos = asn.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
}), RSAPrivateKey = asn.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
}), PrivateKeyInfo = asn.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
function addExtras(o, n) {
  return n = n || {}, Object.keys(n).forEach(function(a) {
    o[a] = n[a];
  }), o;
}
function pad(o) {
  return o.length % 2 == 1 ? "0" + o : o;
}
function decodeRsaPublic(o, n) {
  var a = RSAPublicKey.decode(o, "der"), u = pad(a.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(a.n), e: hex2b64url(u) }, n);
}
function decodeRsaPrivate(o, n) {
  var a = RSAPrivateKey.decode(o, "der"), u = pad(a.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(a.n), e: hex2b64url(u), d: bn2base64url(a.d), p: bn2base64url(a.p), q: bn2base64url(a.q), dp: bn2base64url(a.dp), dq: bn2base64url(a.dq), qi: bn2base64url(a.qi) }, n);
}
function decodePublic(o, n) {
  return decodeRsaPublic(PublicKeyInfo.decode(o, "der").publicKey.data, n);
}
function decodePrivate(o, n) {
  return decodeRsaPrivate(PrivateKeyInfo.decode(o, "der").privateKey.data, n);
}
function getDecoder(o) {
  var n = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(o);
  if (!n)
    return null;
  var a = !!n[1];
  return n[2] === "PRIVATE" ? a ? decodeRsaPrivate : decodePrivate : a ? decodeRsaPublic : decodePublic;
}
function parse(o) {
  return { n: string2bn(o.n), e: string2bn(o.e), d: o.d && string2bn(o.d), p: o.p && string2bn(o.p), q: o.q && string2bn(o.q), dp: o.dp && string2bn(o.dp), dq: o.dq && string2bn(o.dq), qi: o.qi && string2bn(o.qi) };
}
function bn2base64url(o) {
  return hex2b64url(pad(o.toString(16)));
}
function base64url2bn(o) {
  return new asn.bignum(Buffer.from(o, "base64"));
}
function string2bn(o) {
  return /^[0-9]+$/.test(o) ? new asn.bignum(o, 10) : base64url2bn(o);
}
function pemTojwk(o, n) {
  var a = o.toString().split(/(\r\n|\r|\n)+/g), u = getDecoder((a = a.filter(function(c) {
    return c.trim().length !== 0;
  }))[0]);
  return a = a.slice(1, -1).join(""), u(Buffer.from(a.replace(/[^\w\d\+\/=]+/g, ""), "base64"), n);
}
function jwkTopem(o) {
  var n = parse(o), a = !!n.d, u = a ? "PRIVATE" : "PUBLIC", c = "-----BEGIN RSA " + u + ` KEY-----
`, m = `
-----END RSA ` + u + ` KEY-----
`, d = Buffer.alloc(0);
  return a ? (n.version = "two-prime", d = RSAPrivateKey.encode(n, "der")) : d = RSAPublicKey.encode(n, "der"), c + d.toString("base64").match(/.{1,64}/g).join(`
`) + m;
}
pem$2.pemTojwk = pemTojwk, pem$2.jwkTopem = jwkTopem;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$4(n, o, a);
  return __setModuleDefault$4(n, o), n;
};
Object.defineProperty(nodeDriver, "__esModule", { value: !0 });
const pem_1 = pem$2, crypto$2 = __importStar$4(require$$2$1), constants = __importStar$4(require$$2$1);
class NodeCryptoDriver {
  constructor() {
    this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", this.encryptionAlgorithm = "aes-256-cbc";
  }
  generateJWK() {
    if (typeof crypto$2.generateKeyPair != "function")
      throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
    return new Promise((n, a) => {
      crypto$2.generateKeyPair("rsa", { modulusLength: this.keyLength, publicExponent: this.publicExponent, privateKeyEncoding: { type: "pkcs1", format: "pem" }, publicKeyEncoding: { type: "pkcs1", format: "pem" } }, (u, c, m) => {
        u && a(u), n(this.pemToJWK(m));
      });
    });
  }
  sign(n, a, { saltLength: u } = {}) {
    return new Promise((c, m) => {
      c(crypto$2.createSign(this.hashAlgorithm).update(a).sign({ key: this.jwkToPem(n), padding: constants.RSA_PKCS1_PSS_PADDING, saltLength: u }));
    });
  }
  verify(n, a, u) {
    return new Promise((c, m) => {
      const d = { kty: "RSA", e: "AQAB", n }, w = this.jwkToPem(d);
      c(crypto$2.createVerify(this.hashAlgorithm).update(a).verify({ key: w, padding: constants.RSA_PKCS1_PSS_PADDING }, u));
    });
  }
  hash(n, a = "SHA-256") {
    return new Promise((u, c) => {
      u(crypto$2.createHash(this.parseHashAlgorithm(a)).update(n).digest());
    });
  }
  async encrypt(n, a, u) {
    const c = crypto$2.pbkdf2Sync(a, u = u || "salt", 1e5, 32, this.hashAlgorithm), m = crypto$2.randomBytes(16), d = crypto$2.createCipheriv(this.encryptionAlgorithm, c, m);
    return Buffer.concat([m, d.update(n), d.final()]);
  }
  async decrypt(n, a, u) {
    try {
      const c = crypto$2.pbkdf2Sync(a, u = u || "salt", 1e5, 32, this.hashAlgorithm), m = n.slice(0, 16), d = n.slice(16), w = crypto$2.createDecipheriv(this.encryptionAlgorithm, c, m);
      return Buffer.concat([w.update(d), w.final()]);
    } catch {
      throw new Error("Failed to decrypt");
    }
  }
  jwkToPem(n) {
    return (0, pem_1.jwkTopem)(n);
  }
  pemToJWK(n) {
    return (0, pem_1.pemTojwk)(n);
  }
  parseHashAlgorithm(n) {
    switch (n) {
      case "SHA-256":
        return "sha256";
      case "SHA-384":
        return "sha384";
      default:
        throw new Error(`Algorithm not supported: ${n}`);
    }
  }
}
nodeDriver.default = NodeCryptoDriver;
var network = {};
Object.defineProperty(network, "__esModule", { value: !0 });
class Network {
  constructor(n) {
    this.api = n;
  }
  getInfo() {
    return this.api.get("info").then((n) => n.data);
  }
  getPeers() {
    return this.api.get("peers").then((n) => n.data);
  }
}
network.default = Network;
var transactions = {}, error = {};
Object.defineProperty(error, "__esModule", { value: !0 }), error.getError = void 0;
class ArweaveError extends Error {
  constructor(n, a = {}) {
    a.message ? super(a.message) : super(), this.type = n, this.response = a.response;
  }
  getType() {
    return this.type;
  }
}
function getError(o) {
  let n = o.data;
  if (typeof o.data == "string")
    try {
      n = JSON.parse(o.data);
    } catch {
    }
  if (o.data instanceof ArrayBuffer || o.data instanceof Uint8Array)
    try {
      n = JSON.parse(n.toString());
    } catch {
    }
  return n ? n.error || n : o.statusText || "unknown";
}
error.default = ArweaveError, error.getError = getError;
var transactionUploader = {}, merkle = {}, hasRequiredMerkle, hasRequiredTransactionUploader, hasRequiredTransactions;
function requireMerkle() {
  return hasRequiredMerkle || (hasRequiredMerkle = 1, function(o) {
    var n = commonjsGlobal && commonjsGlobal.__importDefault || function(D) {
      return D && D.__esModule ? D : { default: D };
    };
    Object.defineProperty(o, "__esModule", { value: !0 }), o.debug = o.validatePath = o.arrayCompare = o.bufferToInt = o.intToBuffer = o.arrayFlatten = o.generateProofs = o.buildLayers = o.generateTransactionChunks = o.generateTree = o.computeRootHash = o.generateLeaves = o.chunkData = o.MIN_CHUNK_SIZE = o.MAX_CHUNK_SIZE = void 0;
    const a = n(requireCommon()), u = utils$o;
    o.MAX_CHUNK_SIZE = 262144, o.MIN_CHUNK_SIZE = 32768;
    async function c(D) {
      let z = [], W = D, V = 0;
      for (; W.byteLength >= o.MAX_CHUNK_SIZE; ) {
        let ee = o.MAX_CHUNK_SIZE, P = W.byteLength - o.MAX_CHUNK_SIZE;
        P > 0 && P < o.MIN_CHUNK_SIZE && (ee = Math.ceil(W.byteLength / 2));
        const F = W.slice(0, ee), H = await a.default.crypto.hash(F);
        V += F.byteLength, z.push({ dataHash: H, minByteRange: V - F.byteLength, maxByteRange: V }), W = W.slice(ee);
      }
      return z.push({ dataHash: await a.default.crypto.hash(W), minByteRange: V, maxByteRange: V + W.byteLength }), z;
    }
    async function m(D) {
      return Promise.all(D.map(async ({ dataHash: z, minByteRange: W, maxByteRange: V }) => ({ type: "leaf", id: await C(await Promise.all([C(z), C(N(V))])), dataHash: z, minByteRange: W, maxByteRange: V })));
    }
    async function d(D) {
      return await w(await m(await c(D)));
    }
    async function w(D, z = 0) {
      if (D.length < 2)
        return D[0];
      const W = [];
      for (let V = 0; V < D.length; V += 2)
        W.push(await I(D[V], D[V + 1]));
      return w(W, z + 1);
    }
    function S(D) {
      const z = T(D);
      return Array.isArray(z) ? B(z) : [z];
    }
    function T(D, z = new Uint8Array(), W = 0) {
      if (D.type == "leaf")
        return { offset: D.maxByteRange - 1, proof: (0, u.concatBuffers)([z, D.dataHash, N(D.maxByteRange)]) };
      if (D.type == "branch") {
        const V = (0, u.concatBuffers)([z, D.leftChild.id, D.rightChild.id, N(D.byteRange)]);
        return [T(D.leftChild, V, W + 1), T(D.rightChild, V, W + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function B(D) {
      const z = [];
      return D.forEach((W) => {
        Array.isArray(W) ? z.push(...B(W)) : z.push(W);
      }), z;
    }
    async function I(D, z) {
      return z ? { type: "branch", id: await C([await C(D.id), await C(z.id), await C(N(D.maxByteRange))]), byteRange: D.maxByteRange, maxByteRange: z.maxByteRange, leftChild: D, rightChild: z } : D;
    }
    async function C(D) {
      return Array.isArray(D) && (D = a.default.utils.concatBuffers(D)), new Uint8Array(await a.default.crypto.hash(D));
    }
    function N(D) {
      const z = new Uint8Array(32);
      for (var W = z.length - 1; W >= 0; W--) {
        var V = D % 256;
        z[W] = V, D = (D - V) / 256;
      }
      return z;
    }
    function q(D) {
      let z = 0;
      for (var W = 0; W < D.length; W++)
        z *= 256, z += D[W];
      return z;
    }
    o.chunkData = c, o.generateLeaves = m, o.computeRootHash = async function(D) {
      return (await d(D)).id;
    }, o.generateTree = d, o.generateTransactionChunks = async function(D) {
      const z = await c(D), W = await m(z), V = await w(W), ee = await S(V), P = z.slice(-1)[0];
      return P.maxByteRange - P.minByteRange == 0 && (z.splice(z.length - 1, 1), ee.splice(ee.length - 1, 1)), { data_root: V.id, chunks: z, proofs: ee };
    }, o.buildLayers = w, o.generateProofs = S, o.arrayFlatten = B, o.intToBuffer = N, o.bufferToInt = q, o.arrayCompare = (D, z) => D.every((W, V) => z[V] === W), o.validatePath = async function D(z, W, V, ee, P) {
      if (ee <= 0)
        return !1;
      if (W >= ee)
        return D(z, 0, ee - 1, ee, P);
      if (W < 0)
        return D(z, 0, 0, ee, P);
      if (P.length == 64) {
        const y = P.slice(0, 32), g = P.slice(y.length, y.length + 32), v = await C([await C(y), await C(g)]);
        return !!(0, o.arrayCompare)(z, v) && { offset: ee - 1, leftBound: V, rightBound: ee, chunkSize: ee - V };
      }
      const F = P.slice(0, 32), H = P.slice(F.length, F.length + 32), te = P.slice(F.length + H.length, F.length + H.length + 32), p = q(te), $ = P.slice(F.length + H.length + te.length), _ = await C([await C(F), await C(H), await C(te)]);
      return !!(0, o.arrayCompare)(z, _) && (W < p ? await D(F, W, V, Math.min(ee, p), $) : await D(H, W, Math.max(V, p), ee, $));
    }, o.debug = async function D(z, W = "") {
      if (z.byteLength < 1)
        return W;
      const V = z.slice(0, 32), ee = z.slice(V.length, V.length + 32), P = z.slice(V.length + ee.length, V.length + ee.length + 32), F = q(P), H = z.slice(V.length + ee.length + P.length), te = await C([await C(V), await C(ee), await C(P)]);
      return D(H, `${W}
${JSON.stringify(Buffer.from(V))},${JSON.stringify(Buffer.from(ee))},${F} => ${JSON.stringify(te)}`);
    };
  }(merkle)), merkle;
}
function requireTransactionUploader() {
  if (hasRequiredTransactionUploader)
    return transactionUploader;
  hasRequiredTransactionUploader = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(B, I, C, N) {
    N === void 0 && (N = C);
    var q = Object.getOwnPropertyDescriptor(I, C);
    q && !("get" in q ? !I.__esModule : q.writable || q.configurable) || (q = { enumerable: !0, get: function() {
      return I[C];
    } }), Object.defineProperty(B, N, q);
  } : function(B, I, C, N) {
    N === void 0 && (N = C), B[N] = I[C];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(B, I) {
    Object.defineProperty(B, "default", { enumerable: !0, value: I });
  } : function(B, I) {
    B.default = I;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var I = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && o(I, B, C);
    return n(I, B), I;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(transactionUploader, "__esModule", { value: !0 }), transactionUploader.TransactionUploader = void 0;
  const c = u(requireTransaction()), m = a(utils$o), d = error, w = requireMerkle(), S = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class T {
    constructor(I, C) {
      if (this.api = I, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !C.id)
        throw new Error("Transaction is not signed");
      if (!C.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = C.data, this.transaction = new c.default(Object.assign({}, C, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(I) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let C = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (C > 0 && (C -= C * Math.random() * 0.3, await new Promise((D) => setTimeout(D, C))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      I && (this.chunkIndex = I);
      const N = this.transaction.getChunk(I || this.chunkIndex, this.data);
      if (!await (0, w.validatePath)(this.transaction.chunks.data_root, parseInt(N.offset), 0, parseInt(N.data_size), m.b64UrlToBuffer(N.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const q = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((D) => (console.error(D.message), { status: -1, data: { error: D.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = q.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, d.getError)(q), S.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized(I, C, N) {
      if (!C || typeof C.chunkIndex != "number" || typeof C.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var q = new c.default(C.transaction);
      q.chunks || await q.prepareChunks(N);
      const D = new T(I, q);
      if (D.chunkIndex = C.chunkIndex, D.lastRequestTimeEnd = C.lastRequestTimeEnd, D.lastResponseError = C.lastResponseError, D.lastResponseStatus = C.lastResponseStatus, D.txPosted = C.txPosted, D.data = N, D.transaction.data_root !== C.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return D;
    }
    static async fromTransactionId(I, C) {
      const N = await I.get(`tx/${C}`);
      if (N.status !== 200)
        throw new Error(`Tx ${C} not found: ${N.status}`);
      const q = N.data;
      return q.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: q };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const C = await this.api.post("tx", this.transaction).catch((N) => (console.error(N), { status: -1, data: { error: N.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = C.status, this.transaction.data = new Uint8Array(0), C.status >= 200 && C.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, d.getError)(C), new Error(`Unable to upload transaction: ${C.status}, ${this.lastResponseError}`);
      }
      const I = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = I.status, !(I.status >= 200 && I.status < 300))
        throw this.lastResponseError = (0, d.getError)(I), new Error(`Unable to upload transaction: ${I.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader.TransactionUploader = T, transactionUploader;
}
function requireTransactions() {
  if (hasRequiredTransactions)
    return transactions;
  hasRequiredTransactions = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(B, I, C, N) {
    N === void 0 && (N = C);
    var q = Object.getOwnPropertyDescriptor(I, C);
    q && !("get" in q ? !I.__esModule : q.writable || q.configurable) || (q = { enumerable: !0, get: function() {
      return I[C];
    } }), Object.defineProperty(B, N, q);
  } : function(B, I, C, N) {
    N === void 0 && (N = C), B[N] = I[C];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(B, I) {
    Object.defineProperty(B, "default", { enumerable: !0, value: I });
  } : function(B, I) {
    B.default = I;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var I = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && o(I, B, C);
    return n(I, B), I;
  }, u = commonjsGlobal && commonjsGlobal.__await || function(B) {
    return this instanceof u ? (this.v = B, this) : new u(B);
  }, c = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(B, I, C) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var N, q = C.apply(B, I || []), D = [];
    return N = {}, z("next"), z("throw"), z("return"), N[Symbol.asyncIterator] = function() {
      return this;
    }, N;
    function z(F) {
      q[F] && (N[F] = function(H) {
        return new Promise(function(te, p) {
          D.push([F, H, te, p]) > 1 || W(F, H);
        });
      });
    }
    function W(F, H) {
      try {
        (function(te) {
          te.value instanceof u ? Promise.resolve(te.value.v).then(V, ee) : P(D[0][2], te);
        })(q[F](H));
      } catch (te) {
        P(D[0][3], te);
      }
    }
    function V(F) {
      W("next", F);
    }
    function ee(F) {
      W("throw", F);
    }
    function P(F, H) {
      F(H), D.shift(), D.length && W(D[0][0], D[0][1]);
    }
  }, m = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(transactions, "__esModule", { value: !0 });
  const d = m(error), w = m(requireTransaction()), S = a(utils$o), T = requireTransactionUploader();
  return transactions.default = class {
    constructor(B, I, C) {
      this.api = B, this.crypto = I, this.chunks = C;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((B) => B.data);
    }
    getPrice(B, I) {
      let C = I ? `price/${B}/${I}` : `price/${B}`;
      return this.api.get(C, { transformResponse: [function(N) {
        return N;
      }] }).then((N) => N.data);
    }
    async get(B) {
      const I = await this.api.get(`tx/${B}`);
      if (I.status == 200) {
        const C = parseInt(I.data.data_size);
        if (I.data.format >= 2 && C > 0 && C <= 12582912) {
          const N = await this.getData(B);
          return new w.default(Object.assign(Object.assign({}, I.data), { data: N }));
        }
        return new w.default(Object.assign(Object.assign({}, I.data), { format: I.data.format || 1 }));
      }
      throw I.status == 404 ? new d.default("TX_NOT_FOUND") : I.status == 410 ? new d.default("TX_FAILED") : new d.default("TX_INVALID");
    }
    fromRaw(B) {
      return new w.default(B);
    }
    async search(B, I) {
      return this.api.post("arql", { op: "equals", expr1: B, expr2: I }).then((C) => C.data ? C.data : []);
    }
    getStatus(B) {
      return this.api.get(`tx/${B}/status`).then((I) => I.status == 200 ? { status: 200, confirmed: I.data } : { status: I.status, confirmed: null });
    }
    async getData(B, I) {
      let C;
      try {
        C = await this.chunks.downloadChunkedData(B);
      } catch (N) {
        console.error(`Error while trying to download chunked data for ${B}`), console.error(N);
      }
      if (!C) {
        console.warn(`Falling back to gateway cache for ${B}`);
        try {
          C = (await this.api.get(`/${B}`)).data;
        } catch (N) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${B}`), console.error(N);
        }
      }
      if (!C)
        throw new Error(`${B} was not found!`);
      return I && I.decode && !I.string ? C : I && I.decode && I.string ? S.bufferToString(C) : S.bufferTob64Url(C);
    }
    async sign(B, I, C) {
      if (!(I || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if (I && I !== "use_wallet") {
        B.setOwner(I.n);
        let N = await B.getSignatureData(), q = await this.crypto.sign(I, N, C), D = await this.crypto.hash(q);
        B.setSignature({ id: S.bufferTob64Url(D), owner: I.n, signature: S.bufferTob64Url(q) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const N = await window.arweaveWallet.sign(B, C);
        B.setSignature({ id: N.id, owner: N.owner, reward: N.reward, tags: N.tags, signature: N.signature });
      }
    }
    async verify(B) {
      const I = await B.getSignatureData(), C = B.get("signature", { decode: !0, string: !1 }), N = S.bufferTob64Url(await this.crypto.hash(C));
      if (B.id !== N)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(B.owner, I, C);
    }
    async post(B) {
      if (typeof B == "string" ? B = new w.default(JSON.parse(B)) : typeof B.readInt32BE == "function" ? B = new w.default(JSON.parse(B.toString())) : typeof B != "object" || B instanceof w.default || (B = new w.default(B)), !(B instanceof w.default))
        throw new Error("Must be Transaction object");
      B.chunks || await B.prepareChunks(B.data);
      const I = await this.getUploader(B, B.data);
      try {
        for (; !I.isComplete; )
          await I.uploadChunk();
      } catch (C) {
        if (I.lastResponseStatus > 0)
          return { status: I.lastResponseStatus, statusText: I.lastResponseError, data: { error: I.lastResponseError } };
        throw C;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(B, I) {
      let C;
      if (I instanceof ArrayBuffer && (I = new Uint8Array(I)), B instanceof w.default) {
        if (I || (I = B.data), !(I instanceof Uint8Array))
          throw new Error("Data format is invalid");
        B.chunks || await B.prepareChunks(I), C = new T.TransactionUploader(this.api, B), C.data && C.data.length !== 0 || (C.data = I);
      } else {
        if (typeof B == "string" && (B = await T.TransactionUploader.fromTransactionId(this.api, B)), !(I && I instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        C = await T.TransactionUploader.fromSerialized(this.api, B, I);
      }
      return C;
    }
    upload(B, I) {
      return c(this, arguments, function* () {
        const C = yield u(this.getUploader(B, I));
        for (; !C.isComplete; )
          yield u(C.uploadChunk()), yield yield u(C);
        return yield u(C);
      });
    }
  }, transactions;
}
var wallets = {}, __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$3(n, o, a);
  return __setModuleDefault$3(n, o), n;
};
Object.defineProperty(wallets, "__esModule", { value: !0 });
const ArweaveUtils$2 = __importStar$3(utils$o);
class Wallets {
  constructor(n, a) {
    this.api = n, this.crypto = a;
  }
  getBalance(n) {
    return this.api.get(`wallet/${n}/balance`, { transformResponse: [function(a) {
      return a;
    }] }).then((a) => a.data);
  }
  getLastTransactionID(n) {
    return this.api.get(`wallet/${n}/last_tx`).then((a) => a.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(n) {
    return n && n !== "use_wallet" ? this.getAddress(n) : this.getAddress();
  }
  async getAddress(n) {
    if (n && n !== "use_wallet")
      return this.ownerToAddress(n.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(n) {
    return ArweaveUtils$2.bufferTob64Url(await this.crypto.hash(ArweaveUtils$2.b64UrlToBuffer(n)));
  }
}
wallets.default = Wallets;
var silo = {}, __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$2(n, o, a);
  return __setModuleDefault$2(n, o), n;
};
Object.defineProperty(silo, "__esModule", { value: !0 }), silo.SiloResource = void 0;
const ArweaveUtils$1 = __importStar$2(utils$o);
class Silo {
  constructor(n, a, u) {
    this.api = n, this.crypto = a, this.transactions = u;
  }
  async get(n) {
    if (!n)
      throw new Error("No Silo URI specified");
    const a = await this.parseUri(n), u = await this.transactions.search("Silo-Name", a.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const c = await this.transactions.get(u[0]);
    if (!c)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const m = c.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(m, a.getEncryptionKey());
  }
  async readTransactionData(n, a) {
    if (!a)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(a), c = n.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(c, u.getEncryptionKey());
  }
  async parseUri(n) {
    const a = n.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!a)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = a[1], c = Math.pow(2, parseInt(a[2])), m = await this.hash(ArweaveUtils$1.stringToBuffer(u), c), d = ArweaveUtils$1.bufferTob64(m.slice(0, 15)), w = await this.hash(m.slice(16, 31), 1);
    return new SiloResource(n, d, w);
  }
  async hash(n, a) {
    let u = await this.crypto.hash(n);
    for (let c = 0; c < a - 1; c++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo.default = Silo;
class SiloResource {
  constructor(n, a, u) {
    this.uri = n, this.accessKey = a, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo.SiloResource = SiloResource;
var chunks = {}, __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding$1(n, o, a);
  return __setModuleDefault$1(n, o), n;
};
Object.defineProperty(chunks, "__esModule", { value: !0 });
const error_1$1 = error, ArweaveUtils = __importStar$1(utils$o);
class Chunks {
  constructor(n) {
    this.api = n;
  }
  async getTransactionOffset(n) {
    const a = await this.api.get(`tx/${n}/offset`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$1.getError)(a)}`);
  }
  async getChunk(n) {
    const a = await this.api.get(`chunk/${n}`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$1.getError)(a)}`);
  }
  async getChunkData(n) {
    const a = await this.getChunk(n);
    return ArweaveUtils.b64UrlToBuffer(a.chunk);
  }
  firstChunkOffset(n) {
    return parseInt(n.offset) - parseInt(n.size) + 1;
  }
  async downloadChunkedData(n) {
    const a = await this.getTransactionOffset(n), u = parseInt(a.size), c = parseInt(a.offset) - u + 1, m = new Uint8Array(u);
    let d = 0;
    for (; d < u; ) {
      let w;
      this.api.config.logging && console.log(`[chunk] ${d}/${u}`);
      try {
        w = await this.getChunkData(c + d);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${c + d}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!w)
        throw new Error(`Couldn't complete data download at ${d}/${u}`);
      m.set(w, d), d += w.length;
    }
    return m;
  }
}
chunks.default = Chunks;
var blocks = {}, __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(blocks, "__esModule", { value: !0 });
const error_1 = __importDefault$7(error);
class Blocks {
  constructor(n, a) {
    this.api = n, this.network = a;
  }
  async get(n) {
    const a = await this.api.get(`${Blocks.ENDPOINT}${n}`);
    if (a.status === 200)
      return a.data;
    throw a.status === 404 ? new error_1.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${a}`);
  }
  async getCurrent() {
    const { current: n } = await this.network.getInfo();
    return await this.get(n);
  }
}
var hasRequiredCommon, hasRequiredDeepHash, hasRequiredTransaction;
function requireCommon() {
  if (hasRequiredCommon)
    return common$7;
  hasRequiredCommon = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(z, W, V, ee) {
    ee === void 0 && (ee = V);
    var P = Object.getOwnPropertyDescriptor(W, V);
    P && !("get" in P ? !W.__esModule : P.writable || P.configurable) || (P = { enumerable: !0, get: function() {
      return W[V];
    } }), Object.defineProperty(z, ee, P);
  } : function(z, W, V, ee) {
    ee === void 0 && (ee = V), z[ee] = W[V];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(z, W) {
    Object.defineProperty(z, "default", { enumerable: !0, value: W });
  } : function(z, W) {
    z.default = W;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(z) {
    if (z && z.__esModule)
      return z;
    var W = {};
    if (z != null)
      for (var V in z)
        V !== "default" && Object.prototype.hasOwnProperty.call(z, V) && o(W, z, V);
    return n(W, z), W;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(z) {
    return z && z.__esModule ? z : { default: z };
  };
  Object.defineProperty(common$7, "__esModule", { value: !0 });
  const c = u(ar), m = u(api$1), d = u(nodeDriver), w = u(network), S = u(requireTransactions()), T = u(wallets), B = u(requireTransaction()), I = a(utils$o), C = u(silo), N = u(chunks), q = u(blocks);
  class D {
    constructor(W) {
      this.api = new m.default(W), this.wallets = new T.default(this.api, D.crypto), this.chunks = new N.default(this.api), this.transactions = new S.default(this.api, D.crypto, this.chunks), this.silo = new C.default(this.api, this.crypto, this.transactions), this.network = new w.default(this.api), this.blocks = new q.default(this.api, this.network), this.ar = new c.default();
    }
    get crypto() {
      return D.crypto;
    }
    get utils() {
      return D.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(W, V) {
      const ee = {};
      if (Object.assign(ee, W), !(W.data || W.target && W.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (W.owner == null && V && V !== "use_wallet" && (ee.owner = V.n), W.last_tx == null && (ee.last_tx = await this.transactions.getTransactionAnchor()), typeof W.data == "string" && (W.data = I.stringToBuffer(W.data)), W.data instanceof ArrayBuffer && (W.data = new Uint8Array(W.data)), W.data && !(W.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (W.reward == null) {
        const F = W.data ? W.data.byteLength : 0;
        ee.reward = await this.transactions.getPrice(F, ee.target);
      }
      ee.data_root = "", ee.data_size = W.data ? W.data.byteLength.toString() : "0", ee.data = W.data || new Uint8Array(0);
      const P = new B.default(ee);
      return await P.getSignatureData(), P;
    }
    async createSiloTransaction(W, V, ee) {
      const P = {};
      if (Object.assign(P, W), !W.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!ee)
        throw new Error("No Silo URI specified.");
      if (W.target || W.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (W.owner == null) {
        if (!V || !V.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        P.owner = V.n;
      }
      W.last_tx == null && (P.last_tx = await this.transactions.getTransactionAnchor());
      const F = await this.silo.parseUri(ee);
      if (typeof W.data == "string") {
        const te = await this.crypto.encrypt(I.stringToBuffer(W.data), F.getEncryptionKey());
        P.reward = await this.transactions.getPrice(te.byteLength), P.data = I.bufferTob64Url(te);
      }
      if (W.data instanceof Uint8Array) {
        const te = await this.crypto.encrypt(W.data, F.getEncryptionKey());
        P.reward = await this.transactions.getPrice(te.byteLength), P.data = I.bufferTob64Url(te);
      }
      const H = new B.default(P);
      return H.addTag("Silo-Name", F.getAccessKey()), H.addTag("Silo-Version", "0.1.0"), H;
    }
    arql(W) {
      return this.api.post("/arql", W).then((V) => V.data || []);
    }
  }
  return common$7.default = D, D.crypto = new d.default(), D.utils = I, common$7;
}
function requireDeepHash() {
  if (hasRequiredDeepHash)
    return deepHash;
  hasRequiredDeepHash = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(deepHash, "__esModule", { value: !0 });
  const n = o(requireCommon());
  async function a(c) {
    if (Array.isArray(c)) {
      const w = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("list"), n.default.utils.stringToBuffer(c.length.toString())]);
      return await u(c, await n.default.crypto.hash(w, "SHA-384"));
    }
    const m = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("blob"), n.default.utils.stringToBuffer(c.byteLength.toString())]), d = n.default.utils.concatBuffers([await n.default.crypto.hash(m, "SHA-384"), await n.default.crypto.hash(c, "SHA-384")]);
    return await n.default.crypto.hash(d, "SHA-384");
  }
  async function u(c, m) {
    if (c.length < 1)
      return m;
    const d = n.default.utils.concatBuffers([m, await a(c[0])]), w = await n.default.crypto.hash(d, "SHA-384");
    return await u(c.slice(1), w);
  }
  return deepHash.default = a, deepHash;
}
function requireTransaction() {
  if (hasRequiredTransaction)
    return transaction;
  hasRequiredTransaction = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(T, B, I, C) {
    C === void 0 && (C = I);
    var N = Object.getOwnPropertyDescriptor(B, I);
    N && !("get" in N ? !B.__esModule : N.writable || N.configurable) || (N = { enumerable: !0, get: function() {
      return B[I];
    } }), Object.defineProperty(T, C, N);
  } : function(T, B, I, C) {
    C === void 0 && (C = I), T[C] = B[I];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(T, B) {
    Object.defineProperty(T, "default", { enumerable: !0, value: B });
  } : function(T, B) {
    T.default = B;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(T) {
    if (T && T.__esModule)
      return T;
    var B = {};
    if (T != null)
      for (var I in T)
        I !== "default" && Object.prototype.hasOwnProperty.call(T, I) && o(B, T, I);
    return n(B, T), B;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(T) {
    return T && T.__esModule ? T : { default: T };
  };
  Object.defineProperty(transaction, "__esModule", { value: !0 }), transaction.Tag = void 0;
  const c = a(utils$o), m = u(requireDeepHash()), d = requireMerkle();
  class w {
    get(B, I) {
      if (!Object.getOwnPropertyNames(this).includes(B))
        throw new Error(`Field "${B}" is not a property of the Arweave Transaction class.`);
      return this[B] instanceof Uint8Array ? I && I.decode && I.string ? c.bufferToString(this[B]) : I && I.decode && !I.string ? this[B] : c.bufferTob64Url(this[B]) : I && I.decode == 1 ? I && I.string ? c.b64UrlToString(this[B]) : c.b64UrlToBuffer(this[B]) : this[B];
    }
  }
  class S extends w {
    constructor(B, I, C = !1) {
      super(), this.name = B, this.value = I;
    }
  }
  return transaction.Tag = S, transaction.default = class extends w {
    constructor(T = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, T), typeof this.data == "string" && (this.data = c.b64UrlToBuffer(this.data)), T.tags && (this.tags = T.tags.map((B) => new S(B.name, B.value)));
    }
    addTag(T, B) {
      this.tags.push(new S(c.stringToB64Url(T), c.stringToB64Url(B)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: c.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(T) {
      this.owner = T;
    }
    setSignature({ id: T, owner: B, reward: I, tags: C, signature: N }) {
      this.id = T, this.owner = B, I && (this.reward = I), C && (this.tags = C), this.signature = N;
    }
    async prepareChunks(T) {
      !this.chunks && T.byteLength > 0 && (this.chunks = await (0, d.generateTransactionChunks)(T), this.data_root = c.bufferTob64Url(this.chunks.data_root)), this.chunks || T.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(T, B) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const I = this.chunks.proofs[T], C = this.chunks.chunks[T];
      return { data_root: this.data_root, data_size: this.data_size, data_path: c.bufferTob64Url(I.proof), offset: I.offset.toString(), chunk: c.bufferTob64Url(B.slice(C.minByteRange, C.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let T = this.tags.reduce((I, C) => c.concatBuffers([I, C.get("name", { decode: !0, string: !1 }), C.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return c.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), c.stringToBuffer(this.quantity), c.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), T]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const B = this.tags.map((I) => [I.get("name", { decode: !0, string: !1 }), I.get("value", { decode: !0, string: !1 })]);
          return await (0, m.default)([c.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), c.stringToBuffer(this.quantity), c.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), B, c.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction;
}
blocks.default = Blocks, Blocks.ENDPOINT = "block/hash/";
var npmBrowser$1 = {}, buffer$3 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(o) {
  const n = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = d, o.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, o.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function m(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, b) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return T(l);
    }
    return w(l, h, b);
  }
  function w(l, h, b) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | N(x, O);
        let Q = m(G);
        const ne = Q.write(x, O);
        return ne !== G && (Q = Q.slice(0, ne)), Q;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (le(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (le(l, ArrayBuffer) || l && le(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (le(l, SharedArrayBuffer) || l && le(l.buffer, SharedArrayBuffer)))
      return I(l, h, b);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const M = l.valueOf && l.valueOf();
    if (M != null && M !== l)
      return d.from(M, h, b);
    const k = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = m(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? m(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (k)
      return k;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, b);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function T(l) {
    return S(l), m(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), b = m(h);
    for (let M = 0; M < h; M += 1)
      b[M] = 255 & l[M];
    return b;
  }
  function I(l, h, b) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (b || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let M;
    return M = h === void 0 && b === void 0 ? new Uint8Array(l) : b === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, b), Object.setPrototypeOf(M, d.prototype), M;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function N(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || le(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const b = l.length, M = arguments.length > 2 && arguments[2] === !0;
    if (!M && b === 0)
      return 0;
    let k = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return b;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * b;
        case "hex":
          return b >>> 1;
        case "base64":
          return $e(l).length;
        default:
          if (k)
            return M ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), k = !0;
      }
  }
  function q(l, h, b) {
    let M = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return g(this, h, b);
        case "utf8":
        case "utf-8":
          return p(this, h, b);
        case "ascii":
          return _(this, h, b);
        case "latin1":
        case "binary":
          return y(this, h, b);
        case "base64":
          return te(this, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, b);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), M = !0;
      }
  }
  function D(l, h, b) {
    const M = l[h];
    l[h] = l[b], l[b] = M;
  }
  function z(l, h, b, M, k) {
    if (l.length === 0)
      return -1;
    if (typeof b == "string" ? (M = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), we(b = +b) && (b = k ? 0 : l.length - 1), b < 0 && (b = l.length + b), b >= l.length) {
      if (k)
        return -1;
      b = l.length - 1;
    } else if (b < 0) {
      if (!k)
        return -1;
      b = 0;
    }
    if (typeof h == "string" && (h = d.from(h, M)), d.isBuffer(h))
      return h.length === 0 ? -1 : W(l, h, b, M, k);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(l, h, b) : Uint8Array.prototype.lastIndexOf.call(l, h, b) : W(l, [h], b, M, k);
    throw new TypeError("val must be string, number or Buffer");
  }
  function W(l, h, b, M, k) {
    let x, O = 1, G = l.length, Q = h.length;
    if (M !== void 0 && ((M = String(M).toLowerCase()) === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, Q /= 2, b /= 2;
    }
    function ne(Y, ae) {
      return O === 1 ? Y[ae] : Y.readUInt16BE(ae * O);
    }
    if (k) {
      let Y = -1;
      for (x = b; x < G; x++)
        if (ne(l, x) === ne(h, Y === -1 ? 0 : x - Y)) {
          if (Y === -1 && (Y = x), x - Y + 1 === Q)
            return Y * O;
        } else
          Y !== -1 && (x -= x - Y), Y = -1;
    } else
      for (b + Q > G && (b = G - Q), x = b; x >= 0; x--) {
        let Y = !0;
        for (let ae = 0; ae < Q; ae++)
          if (ne(l, x + ae) !== ne(h, ae)) {
            Y = !1;
            break;
          }
        if (Y)
          return x;
      }
    return -1;
  }
  function V(l, h, b, M) {
    b = Number(b) || 0;
    const k = l.length - b;
    M ? (M = Number(M)) > k && (M = k) : M = k;
    const x = h.length;
    let O;
    for (M > x / 2 && (M = x / 2), O = 0; O < M; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[b + O] = G;
    }
    return O;
  }
  function ee(l, h, b, M) {
    return fe(he(h, l.length - b), l, b, M);
  }
  function P(l, h, b, M) {
    return fe(function(k) {
      const x = [];
      for (let O = 0; O < k.length; ++O)
        x.push(255 & k.charCodeAt(O));
      return x;
    }(h), l, b, M);
  }
  function F(l, h, b, M) {
    return fe($e(h), l, b, M);
  }
  function H(l, h, b, M) {
    return fe(function(k, x) {
      let O, G, Q;
      const ne = [];
      for (let Y = 0; Y < k.length && !((x -= 2) < 0); ++Y)
        O = k.charCodeAt(Y), G = O >> 8, Q = O % 256, ne.push(Q), ne.push(G);
      return ne;
    }(h, l.length - b), l, b, M);
  }
  function te(l, h, b) {
    return h === 0 && b === l.length ? n.fromByteArray(l) : n.fromByteArray(l.slice(h, b));
  }
  function p(l, h, b) {
    b = Math.min(l.length, b);
    const M = [];
    let k = h;
    for (; k < b; ) {
      const x = l[k];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (k + G <= b) {
        let Q, ne, Y, ae;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            Q = l[k + 1], (192 & Q) == 128 && (ae = (31 & x) << 6 | 63 & Q, ae > 127 && (O = ae));
            break;
          case 3:
            Q = l[k + 1], ne = l[k + 2], (192 & Q) == 128 && (192 & ne) == 128 && (ae = (15 & x) << 12 | (63 & Q) << 6 | 63 & ne, ae > 2047 && (ae < 55296 || ae > 57343) && (O = ae));
            break;
          case 4:
            Q = l[k + 1], ne = l[k + 2], Y = l[k + 3], (192 & Q) == 128 && (192 & ne) == 128 && (192 & Y) == 128 && (ae = (15 & x) << 18 | (63 & Q) << 12 | (63 & ne) << 6 | 63 & Y, ae > 65535 && ae < 1114112 && (O = ae));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, M.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), M.push(O), k += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", Q = 0;
      for (; Q < O; )
        G += String.fromCharCode.apply(String, x.slice(Q, Q += $));
      return G;
    }(M);
  }
  o.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, b) {
    return w(l, h, b);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, b) {
    return function(M, k, x) {
      return S(M), M <= 0 ? m(M) : k !== void 0 ? typeof x == "string" ? m(M).fill(k, x) : m(M).fill(k) : m(M);
    }(l, h, b);
  }, d.allocUnsafe = function(l) {
    return T(l);
  }, d.allocUnsafeSlow = function(l) {
    return T(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), le(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let b = l.length, M = h.length;
    for (let k = 0, x = Math.min(b, M); k < x; ++k)
      if (l[k] !== h[k]) {
        b = l[k], M = h[k];
        break;
      }
    return b < M ? -1 : M < b ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let b;
    if (h === void 0)
      for (h = 0, b = 0; b < l.length; ++b)
        h += l[b].length;
    const M = d.allocUnsafe(h);
    let k = 0;
    for (b = 0; b < l.length; ++b) {
      let x = l[b];
      if (le(x, Uint8Array))
        k + x.length > M.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(M, k)) : Uint8Array.prototype.set.call(M, x, k);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(M, k);
      }
      k += x.length;
    }
    return M;
  }, d.byteLength = N, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? p(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = o.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, b, M, k) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), b === void 0 && (b = l ? l.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), h < 0 || b > l.length || M < 0 || k > this.length)
      throw new RangeError("out of range index");
    if (M >= k && h >= b)
      return 0;
    if (M >= k)
      return -1;
    if (h >= b)
      return 1;
    if (this === l)
      return 0;
    let x = (k >>>= 0) - (M >>>= 0), O = (b >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), Q = this.slice(M, k), ne = l.slice(h, b);
    for (let Y = 0; Y < G; ++Y)
      if (Q[Y] !== ne[Y]) {
        x = Q[Y], O = ne[Y];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, b) {
    return this.indexOf(l, h, b) !== -1;
  }, d.prototype.indexOf = function(l, h, b) {
    return z(this, l, h, b, !0);
  }, d.prototype.lastIndexOf = function(l, h, b) {
    return z(this, l, h, b, !1);
  }, d.prototype.write = function(l, h, b, M) {
    if (h === void 0)
      M = "utf8", b = this.length, h = 0;
    else if (b === void 0 && typeof h == "string")
      M = h, b = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(b) ? (b >>>= 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
    }
    const k = this.length - h;
    if ((b === void 0 || b > k) && (b = k), l.length > 0 && (b < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    M || (M = "utf8");
    let x = !1;
    for (; ; )
      switch (M) {
        case "hex":
          return V(this, l, h, b);
        case "utf8":
        case "utf-8":
          return ee(this, l, h, b);
        case "ascii":
        case "latin1":
        case "binary":
          return P(this, l, h, b);
        case "base64":
          return F(this, l, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, b);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + M);
          M = ("" + M).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(127 & l[k]);
    return M;
  }
  function y(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(l[k]);
    return M;
  }
  function g(l, h, b) {
    const M = l.length;
    (!h || h < 0) && (h = 0), (!b || b < 0 || b > M) && (b = M);
    let k = "";
    for (let x = h; x < b; ++x)
      k += We[l[x]];
    return k;
  }
  function v(l, h, b) {
    const M = l.slice(h, b);
    let k = "";
    for (let x = 0; x < M.length - 1; x += 2)
      k += String.fromCharCode(M[x] + 256 * M[x + 1]);
    return k;
  }
  function E(l, h, b) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > b)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function A(l, h, b, M, k, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > k || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (b + M > l.length)
      throw new RangeError("Index out of range");
  }
  function L(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, b;
  }
  function j(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b + 7] = x, x >>= 8, l[b + 6] = x, x >>= 8, l[b + 5] = x, x >>= 8, l[b + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b + 3] = O, O >>= 8, l[b + 2] = O, O >>= 8, l[b + 1] = O, O >>= 8, l[b] = O, b + 8;
  }
  function J(l, h, b, M, k, x) {
    if (b + M > l.length)
      throw new RangeError("Index out of range");
    if (b < 0)
      throw new RangeError("Index out of range");
  }
  function X(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 4), a.write(l, h, b, M, 23, 4), b + 4;
  }
  function re(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 8), a.write(l, h, b, M, 52, 8), b + 8;
  }
  d.prototype.slice = function(l, h) {
    const b = this.length;
    (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (h = h === void 0 ? b : ~~h) < 0 ? (h += b) < 0 && (h = 0) : h > b && (h = b), h < l && (h = l);
    const M = this.subarray(l, h);
    return Object.setPrototypeOf(M, d.prototype), M;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return M;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l + --h], k = 1;
    for (; h > 0 && (k *= 256); )
      M += this[l + --h] * k;
    return M;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, k = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
    return BigInt(M) + (BigInt(k) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], k = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
    return (BigInt(M) << BigInt(32)) + BigInt(k);
  }), d.prototype.readIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return k *= 128, M >= k && (M -= Math.pow(2, 8 * h)), M;
  }, d.prototype.readIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = h, k = 1, x = this[l + --M];
    for (; M > 0 && (k *= 256); )
      x += this[l + --M] * k;
    return k *= 128, x >= k && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l] | this[l + 1] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l + 1] | this[l] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
    return (BigInt(M) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(M) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = 1, x = 0;
    for (this[h] = 255 & l; ++x < b && (k *= 256); )
      this[h + x] = l / k & 255;
    return h + b;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = b - 1, x = 1;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      this[h + k] = l / x & 255;
    return h + b;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++k < b && (x *= 256); )
      l < 0 && O === 0 && this[h + k - 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeIntBE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = b - 1, x = 1, O = 0;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + k + 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, b) {
    return X(this, l, h, !0, b);
  }, d.prototype.writeFloatBE = function(l, h, b) {
    return X(this, l, h, !1, b);
  }, d.prototype.writeDoubleLE = function(l, h, b) {
    return re(this, l, h, !0, b);
  }, d.prototype.writeDoubleBE = function(l, h, b) {
    return re(this, l, h, !1, b);
  }, d.prototype.copy = function(l, h, b, M) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (b || (b = 0), M || M === 0 || (M = this.length), h >= l.length && (h = l.length), h || (h = 0), M > 0 && M < b && (M = b), M === b || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (b < 0 || b >= this.length)
      throw new RangeError("Index out of range");
    if (M < 0)
      throw new RangeError("sourceEnd out of bounds");
    M > this.length && (M = this.length), l.length - h < M - b && (M = l.length - h + b);
    const k = M - b;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, b, M) : Uint8Array.prototype.set.call(l, this.subarray(b, M), h), k;
  }, d.prototype.fill = function(l, h, b, M) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (M = h, h = 0, b = this.length) : typeof b == "string" && (M = b, b = this.length), M !== void 0 && typeof M != "string")
        throw new TypeError("encoding must be a string");
      if (typeof M == "string" && !d.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (M === "utf8" && x < 128 || M === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < b)
      throw new RangeError("Out of range index");
    if (b <= h)
      return this;
    let k;
    if (h >>>= 0, b = b === void 0 ? this.length : b >>> 0, l || (l = 0), typeof l == "number")
      for (k = h; k < b; ++k)
        this[k] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, M), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (k = 0; k < b - h; ++k)
        this[k + h] = x[k % O];
    }
    return this;
  };
  const Z = {};
  function ie(l, h, b) {
    Z[l] = class extends b {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(M) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: M, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function oe(l) {
    let h = "", b = l.length;
    const M = l[0] === "-" ? 1 : 0;
    for (; b >= M + 4; b -= 3)
      h = `_${l.slice(b - 3, b)}${h}`;
    return `${l.slice(0, b)}${h}`;
  }
  function ue(l, h, b, M, k, x) {
    if (l > b || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${b}${O}`, new Z.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, Q) {
      se(G, "offset"), O[G] !== void 0 && O[G + Q] !== void 0 || ce(G, O.length - (Q + 1));
    })(M, k, x);
  }
  function se(l, h) {
    if (typeof l != "number")
      throw new Z.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function ce(l, h, b) {
    throw Math.floor(l) !== l ? (se(l, b), new Z.ERR_OUT_OF_RANGE(b || "offset", "an integer", l)) : h < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(b || "offset", `>= ${b ? 1 : 0} and <= ${h}`, l);
  }
  ie("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), ie("ERR_OUT_OF_RANGE", function(l, h, b) {
    let M = `The value of "${l}" is out of range.`, k = b;
    return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? k = oe(String(b)) : typeof b == "bigint" && (k = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (k = oe(k)), k += "n"), M += ` It must be ${h}. Received ${k}`, M;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let b;
    h = h || 1 / 0;
    const M = l.length;
    let k = null;
    const x = [];
    for (let O = 0; O < M; ++O) {
      if (b = l.charCodeAt(O), b > 55295 && b < 57344) {
        if (!k) {
          if (b > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === M) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          k = b;
          continue;
        }
        if (b < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), k = b;
          continue;
        }
        b = 65536 + (k - 55296 << 10 | b - 56320);
      } else
        k && (h -= 3) > -1 && x.push(239, 191, 189);
      if (k = null, b < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(b);
      } else if (b < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(b >> 6 | 192, 63 & b | 128);
      } else if (b < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(b >> 12 | 224, b >> 6 & 63 | 128, 63 & b | 128);
      } else {
        if (!(b < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, 63 & b | 128);
      }
    }
    return x;
  }
  function $e(l) {
    return n.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function fe(l, h, b, M) {
    let k;
    for (k = 0; k < M && !(k + b >= h.length || k >= l.length); ++k)
      h[k + b] = l[k];
    return k;
  }
  function le(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let b = 0; b < 16; ++b) {
      const M = 16 * b;
      for (let k = 0; k < 16; ++k)
        h[M + k] = l[b] + l[k];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$3), window.global = window, commonjsGlobal.fetch = window.fetch, npmBrowser$1.Buffer = buffer$3.Buffer;
var WarpFactory = {}, LevelDbCache$1 = {}, browser = {}, browserLevel = {}, abstractLevel$1 = {}, abstractLevel = {}, levelSupports = { supports: function(...o) {
  const n = o.reduce((a, u) => Object.assign(a, u), {});
  return Object.assign(n, { snapshots: n.snapshots || !1, permanence: n.permanence || !1, seek: n.seek || !1, clear: n.clear || !1, getMany: n.getMany || !1, keyIterator: n.keyIterator || !1, valueIterator: n.valueIterator || !1, iteratorNextv: n.iteratorNextv || !1, iteratorAll: n.iteratorAll || !1, status: n.status || !1, createIfMissing: n.createIfMissing || !1, errorIfExists: n.errorIfExists || !1, deferredOpen: n.deferredOpen || !1, promises: n.promises || !1, streams: n.streams || !1, encodings: Object.assign({}, n.encodings), events: Object.assign({}, n.events), additionalMethods: Object.assign({}, n.additionalMethods) });
} }, levelTranscoder = {}, moduleError = class extends Error {
  constructor(o, n) {
    super(o || ""), typeof n == "object" && n !== null && (n.code && (this.code = String(n.code)), n.expected && (this.expected = !0), n.transient && (this.transient = !0), n.cause && (this.cause = n.cause)), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}, encodings$1 = {}, buffer$2 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(o) {
  const n = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = d, o.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, o.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function m(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, b) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return T(l);
    }
    return w(l, h, b);
  }
  function w(l, h, b) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | N(x, O);
        let Q = m(G);
        const ne = Q.write(x, O);
        return ne !== G && (Q = Q.slice(0, ne)), Q;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (le(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (le(l, ArrayBuffer) || l && le(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (le(l, SharedArrayBuffer) || l && le(l.buffer, SharedArrayBuffer)))
      return I(l, h, b);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const M = l.valueOf && l.valueOf();
    if (M != null && M !== l)
      return d.from(M, h, b);
    const k = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = m(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? m(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (k)
      return k;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, b);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function T(l) {
    return S(l), m(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), b = m(h);
    for (let M = 0; M < h; M += 1)
      b[M] = 255 & l[M];
    return b;
  }
  function I(l, h, b) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (b || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let M;
    return M = h === void 0 && b === void 0 ? new Uint8Array(l) : b === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, b), Object.setPrototypeOf(M, d.prototype), M;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function N(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || le(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const b = l.length, M = arguments.length > 2 && arguments[2] === !0;
    if (!M && b === 0)
      return 0;
    let k = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return b;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * b;
        case "hex":
          return b >>> 1;
        case "base64":
          return $e(l).length;
        default:
          if (k)
            return M ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), k = !0;
      }
  }
  function q(l, h, b) {
    let M = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return g(this, h, b);
        case "utf8":
        case "utf-8":
          return p(this, h, b);
        case "ascii":
          return _(this, h, b);
        case "latin1":
        case "binary":
          return y(this, h, b);
        case "base64":
          return te(this, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, b);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), M = !0;
      }
  }
  function D(l, h, b) {
    const M = l[h];
    l[h] = l[b], l[b] = M;
  }
  function z(l, h, b, M, k) {
    if (l.length === 0)
      return -1;
    if (typeof b == "string" ? (M = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), we(b = +b) && (b = k ? 0 : l.length - 1), b < 0 && (b = l.length + b), b >= l.length) {
      if (k)
        return -1;
      b = l.length - 1;
    } else if (b < 0) {
      if (!k)
        return -1;
      b = 0;
    }
    if (typeof h == "string" && (h = d.from(h, M)), d.isBuffer(h))
      return h.length === 0 ? -1 : W(l, h, b, M, k);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(l, h, b) : Uint8Array.prototype.lastIndexOf.call(l, h, b) : W(l, [h], b, M, k);
    throw new TypeError("val must be string, number or Buffer");
  }
  function W(l, h, b, M, k) {
    let x, O = 1, G = l.length, Q = h.length;
    if (M !== void 0 && ((M = String(M).toLowerCase()) === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, Q /= 2, b /= 2;
    }
    function ne(Y, ae) {
      return O === 1 ? Y[ae] : Y.readUInt16BE(ae * O);
    }
    if (k) {
      let Y = -1;
      for (x = b; x < G; x++)
        if (ne(l, x) === ne(h, Y === -1 ? 0 : x - Y)) {
          if (Y === -1 && (Y = x), x - Y + 1 === Q)
            return Y * O;
        } else
          Y !== -1 && (x -= x - Y), Y = -1;
    } else
      for (b + Q > G && (b = G - Q), x = b; x >= 0; x--) {
        let Y = !0;
        for (let ae = 0; ae < Q; ae++)
          if (ne(l, x + ae) !== ne(h, ae)) {
            Y = !1;
            break;
          }
        if (Y)
          return x;
      }
    return -1;
  }
  function V(l, h, b, M) {
    b = Number(b) || 0;
    const k = l.length - b;
    M ? (M = Number(M)) > k && (M = k) : M = k;
    const x = h.length;
    let O;
    for (M > x / 2 && (M = x / 2), O = 0; O < M; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[b + O] = G;
    }
    return O;
  }
  function ee(l, h, b, M) {
    return fe(he(h, l.length - b), l, b, M);
  }
  function P(l, h, b, M) {
    return fe(function(k) {
      const x = [];
      for (let O = 0; O < k.length; ++O)
        x.push(255 & k.charCodeAt(O));
      return x;
    }(h), l, b, M);
  }
  function F(l, h, b, M) {
    return fe($e(h), l, b, M);
  }
  function H(l, h, b, M) {
    return fe(function(k, x) {
      let O, G, Q;
      const ne = [];
      for (let Y = 0; Y < k.length && !((x -= 2) < 0); ++Y)
        O = k.charCodeAt(Y), G = O >> 8, Q = O % 256, ne.push(Q), ne.push(G);
      return ne;
    }(h, l.length - b), l, b, M);
  }
  function te(l, h, b) {
    return h === 0 && b === l.length ? n.fromByteArray(l) : n.fromByteArray(l.slice(h, b));
  }
  function p(l, h, b) {
    b = Math.min(l.length, b);
    const M = [];
    let k = h;
    for (; k < b; ) {
      const x = l[k];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (k + G <= b) {
        let Q, ne, Y, ae;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            Q = l[k + 1], (192 & Q) == 128 && (ae = (31 & x) << 6 | 63 & Q, ae > 127 && (O = ae));
            break;
          case 3:
            Q = l[k + 1], ne = l[k + 2], (192 & Q) == 128 && (192 & ne) == 128 && (ae = (15 & x) << 12 | (63 & Q) << 6 | 63 & ne, ae > 2047 && (ae < 55296 || ae > 57343) && (O = ae));
            break;
          case 4:
            Q = l[k + 1], ne = l[k + 2], Y = l[k + 3], (192 & Q) == 128 && (192 & ne) == 128 && (192 & Y) == 128 && (ae = (15 & x) << 18 | (63 & Q) << 12 | (63 & ne) << 6 | 63 & Y, ae > 65535 && ae < 1114112 && (O = ae));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, M.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), M.push(O), k += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", Q = 0;
      for (; Q < O; )
        G += String.fromCharCode.apply(String, x.slice(Q, Q += $));
      return G;
    }(M);
  }
  o.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, b) {
    return w(l, h, b);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, b) {
    return function(M, k, x) {
      return S(M), M <= 0 ? m(M) : k !== void 0 ? typeof x == "string" ? m(M).fill(k, x) : m(M).fill(k) : m(M);
    }(l, h, b);
  }, d.allocUnsafe = function(l) {
    return T(l);
  }, d.allocUnsafeSlow = function(l) {
    return T(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), le(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let b = l.length, M = h.length;
    for (let k = 0, x = Math.min(b, M); k < x; ++k)
      if (l[k] !== h[k]) {
        b = l[k], M = h[k];
        break;
      }
    return b < M ? -1 : M < b ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let b;
    if (h === void 0)
      for (h = 0, b = 0; b < l.length; ++b)
        h += l[b].length;
    const M = d.allocUnsafe(h);
    let k = 0;
    for (b = 0; b < l.length; ++b) {
      let x = l[b];
      if (le(x, Uint8Array))
        k + x.length > M.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(M, k)) : Uint8Array.prototype.set.call(M, x, k);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(M, k);
      }
      k += x.length;
    }
    return M;
  }, d.byteLength = N, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? p(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = o.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, b, M, k) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), b === void 0 && (b = l ? l.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), h < 0 || b > l.length || M < 0 || k > this.length)
      throw new RangeError("out of range index");
    if (M >= k && h >= b)
      return 0;
    if (M >= k)
      return -1;
    if (h >= b)
      return 1;
    if (this === l)
      return 0;
    let x = (k >>>= 0) - (M >>>= 0), O = (b >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), Q = this.slice(M, k), ne = l.slice(h, b);
    for (let Y = 0; Y < G; ++Y)
      if (Q[Y] !== ne[Y]) {
        x = Q[Y], O = ne[Y];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, b) {
    return this.indexOf(l, h, b) !== -1;
  }, d.prototype.indexOf = function(l, h, b) {
    return z(this, l, h, b, !0);
  }, d.prototype.lastIndexOf = function(l, h, b) {
    return z(this, l, h, b, !1);
  }, d.prototype.write = function(l, h, b, M) {
    if (h === void 0)
      M = "utf8", b = this.length, h = 0;
    else if (b === void 0 && typeof h == "string")
      M = h, b = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(b) ? (b >>>= 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
    }
    const k = this.length - h;
    if ((b === void 0 || b > k) && (b = k), l.length > 0 && (b < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    M || (M = "utf8");
    let x = !1;
    for (; ; )
      switch (M) {
        case "hex":
          return V(this, l, h, b);
        case "utf8":
        case "utf-8":
          return ee(this, l, h, b);
        case "ascii":
        case "latin1":
        case "binary":
          return P(this, l, h, b);
        case "base64":
          return F(this, l, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, b);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + M);
          M = ("" + M).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(127 & l[k]);
    return M;
  }
  function y(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(l[k]);
    return M;
  }
  function g(l, h, b) {
    const M = l.length;
    (!h || h < 0) && (h = 0), (!b || b < 0 || b > M) && (b = M);
    let k = "";
    for (let x = h; x < b; ++x)
      k += We[l[x]];
    return k;
  }
  function v(l, h, b) {
    const M = l.slice(h, b);
    let k = "";
    for (let x = 0; x < M.length - 1; x += 2)
      k += String.fromCharCode(M[x] + 256 * M[x + 1]);
    return k;
  }
  function E(l, h, b) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > b)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function A(l, h, b, M, k, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > k || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (b + M > l.length)
      throw new RangeError("Index out of range");
  }
  function L(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, b;
  }
  function j(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b + 7] = x, x >>= 8, l[b + 6] = x, x >>= 8, l[b + 5] = x, x >>= 8, l[b + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b + 3] = O, O >>= 8, l[b + 2] = O, O >>= 8, l[b + 1] = O, O >>= 8, l[b] = O, b + 8;
  }
  function J(l, h, b, M, k, x) {
    if (b + M > l.length)
      throw new RangeError("Index out of range");
    if (b < 0)
      throw new RangeError("Index out of range");
  }
  function X(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 4), a.write(l, h, b, M, 23, 4), b + 4;
  }
  function re(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 8), a.write(l, h, b, M, 52, 8), b + 8;
  }
  d.prototype.slice = function(l, h) {
    const b = this.length;
    (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (h = h === void 0 ? b : ~~h) < 0 ? (h += b) < 0 && (h = 0) : h > b && (h = b), h < l && (h = l);
    const M = this.subarray(l, h);
    return Object.setPrototypeOf(M, d.prototype), M;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return M;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l + --h], k = 1;
    for (; h > 0 && (k *= 256); )
      M += this[l + --h] * k;
    return M;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, k = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
    return BigInt(M) + (BigInt(k) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], k = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
    return (BigInt(M) << BigInt(32)) + BigInt(k);
  }), d.prototype.readIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return k *= 128, M >= k && (M -= Math.pow(2, 8 * h)), M;
  }, d.prototype.readIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = h, k = 1, x = this[l + --M];
    for (; M > 0 && (k *= 256); )
      x += this[l + --M] * k;
    return k *= 128, x >= k && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l] | this[l + 1] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l + 1] | this[l] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
    return (BigInt(M) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(M) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = 1, x = 0;
    for (this[h] = 255 & l; ++x < b && (k *= 256); )
      this[h + x] = l / k & 255;
    return h + b;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = b - 1, x = 1;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      this[h + k] = l / x & 255;
    return h + b;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++k < b && (x *= 256); )
      l < 0 && O === 0 && this[h + k - 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeIntBE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = b - 1, x = 1, O = 0;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + k + 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, b) {
    return X(this, l, h, !0, b);
  }, d.prototype.writeFloatBE = function(l, h, b) {
    return X(this, l, h, !1, b);
  }, d.prototype.writeDoubleLE = function(l, h, b) {
    return re(this, l, h, !0, b);
  }, d.prototype.writeDoubleBE = function(l, h, b) {
    return re(this, l, h, !1, b);
  }, d.prototype.copy = function(l, h, b, M) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (b || (b = 0), M || M === 0 || (M = this.length), h >= l.length && (h = l.length), h || (h = 0), M > 0 && M < b && (M = b), M === b || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (b < 0 || b >= this.length)
      throw new RangeError("Index out of range");
    if (M < 0)
      throw new RangeError("sourceEnd out of bounds");
    M > this.length && (M = this.length), l.length - h < M - b && (M = l.length - h + b);
    const k = M - b;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, b, M) : Uint8Array.prototype.set.call(l, this.subarray(b, M), h), k;
  }, d.prototype.fill = function(l, h, b, M) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (M = h, h = 0, b = this.length) : typeof b == "string" && (M = b, b = this.length), M !== void 0 && typeof M != "string")
        throw new TypeError("encoding must be a string");
      if (typeof M == "string" && !d.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (M === "utf8" && x < 128 || M === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < b)
      throw new RangeError("Out of range index");
    if (b <= h)
      return this;
    let k;
    if (h >>>= 0, b = b === void 0 ? this.length : b >>> 0, l || (l = 0), typeof l == "number")
      for (k = h; k < b; ++k)
        this[k] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, M), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (k = 0; k < b - h; ++k)
        this[k + h] = x[k % O];
    }
    return this;
  };
  const Z = {};
  function ie(l, h, b) {
    Z[l] = class extends b {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(M) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: M, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function oe(l) {
    let h = "", b = l.length;
    const M = l[0] === "-" ? 1 : 0;
    for (; b >= M + 4; b -= 3)
      h = `_${l.slice(b - 3, b)}${h}`;
    return `${l.slice(0, b)}${h}`;
  }
  function ue(l, h, b, M, k, x) {
    if (l > b || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${b}${O}`, new Z.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, Q) {
      se(G, "offset"), O[G] !== void 0 && O[G + Q] !== void 0 || ce(G, O.length - (Q + 1));
    })(M, k, x);
  }
  function se(l, h) {
    if (typeof l != "number")
      throw new Z.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function ce(l, h, b) {
    throw Math.floor(l) !== l ? (se(l, b), new Z.ERR_OUT_OF_RANGE(b || "offset", "an integer", l)) : h < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(b || "offset", `>= ${b ? 1 : 0} and <= ${h}`, l);
  }
  ie("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), ie("ERR_OUT_OF_RANGE", function(l, h, b) {
    let M = `The value of "${l}" is out of range.`, k = b;
    return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? k = oe(String(b)) : typeof b == "bigint" && (k = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (k = oe(k)), k += "n"), M += ` It must be ${h}. Received ${k}`, M;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let b;
    h = h || 1 / 0;
    const M = l.length;
    let k = null;
    const x = [];
    for (let O = 0; O < M; ++O) {
      if (b = l.charCodeAt(O), b > 55295 && b < 57344) {
        if (!k) {
          if (b > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === M) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          k = b;
          continue;
        }
        if (b < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), k = b;
          continue;
        }
        b = 65536 + (k - 55296 << 10 | b - 56320);
      } else
        k && (h -= 3) > -1 && x.push(239, 191, 189);
      if (k = null, b < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(b);
      } else if (b < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(b >> 6 | 192, 63 & b | 128);
      } else if (b < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(b >> 12 | 224, b >> 6 & 63 | 128, 63 & b | 128);
      } else {
        if (!(b < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, 63 & b | 128);
      }
    }
    return x;
  }
  function $e(l) {
    return n.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function fe(l, h, b, M) {
    let k;
    for (k = 0; k < M && !(k + b >= h.length || k >= l.length); ++k)
      h[k + b] = l[k];
    return k;
  }
  function le(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let b = 0; b < 16; ++b) {
      const M = 16 * b;
      for (let k = 0; k < 16; ++k)
        h[M + k] = l[b] + l[k];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
let lazy = null;
var textEndec$1 = function() {
  return lazy === null && (lazy = { textEncoder: new TextEncoder(), textDecoder: new TextDecoder() }), lazy;
}, formats$2 = {}, encoding = {};
const ModuleError$9 = moduleError, formats$1 = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Encoding$2 {
  constructor(n) {
    if (this.encode = n.encode || this.encode, this.decode = n.decode || this.decode, this.name = n.name || this.name, this.format = n.format || this.format, typeof this.encode != "function")
      throw new TypeError("The 'encode' property must be a function");
    if (typeof this.decode != "function")
      throw new TypeError("The 'decode' property must be a function");
    if (this.encode = this.encode.bind(this), this.decode = this.decode.bind(this), typeof this.name != "string" || this.name === "")
      throw new TypeError("The 'name' property must be a string");
    if (typeof this.format != "string" || !formats$1.has(this.format))
      throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
    n.createViewTranscoder && (this.createViewTranscoder = n.createViewTranscoder), n.createBufferTranscoder && (this.createBufferTranscoder = n.createBufferTranscoder), n.createUTF8Transcoder && (this.createUTF8Transcoder = n.createUTF8Transcoder);
  }
  get commonName() {
    return this.name.split("+")[0];
  }
  createBufferTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createViewTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'view'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createUTF8Transcoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
}
encoding.Encoding = Encoding$2;
const { Buffer: Buffer$6 } = buffer$2 || {}, { Encoding: Encoding$1 } = encoding, textEndec = textEndec$1;
class BufferFormat$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "buffer" });
  }
  createViewTranscoder() {
    return new ViewFormat$2({ encode: this.encode, decode: (n) => this.decode(Buffer$6.from(n.buffer, n.byteOffset, n.byteLength)), name: `${this.name}+view` });
  }
  createBufferTranscoder() {
    return this;
  }
}
class ViewFormat$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "view" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (n) => {
      const a = this.encode(n);
      return Buffer$6.from(a.buffer, a.byteOffset, a.byteLength);
    }, decode: this.decode, name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    return this;
  }
}
class UTF8Format$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "utf8" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (n) => Buffer$6.from(this.encode(n), "utf8"), decode: (n) => this.decode(n.toString("utf8")), name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    const { textEncoder: n, textDecoder: a } = textEndec();
    return new ViewFormat$2({ encode: (u) => n.encode(this.encode(u)), decode: (u) => this.decode(a.decode(u)), name: `${this.name}+view` });
  }
  createUTF8Transcoder() {
    return this;
  }
}
formats$2.BufferFormat = BufferFormat$2, formats$2.ViewFormat = ViewFormat$2, formats$2.UTF8Format = UTF8Format$2;
const { Buffer: Buffer$5 } = buffer$2 || { Buffer: { isBuffer: () => !1 } }, { textEncoder: textEncoder$1, textDecoder } = textEndec$1(), { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2, identity = (o) => o;
encodings$1.utf8 = new UTF8Format$1({ encode: function(o) {
  return Buffer$5.isBuffer(o) ? o.toString("utf8") : ArrayBuffer.isView(o) ? textDecoder.decode(o) : String(o);
}, decode: identity, name: "utf8", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(o) {
    return ArrayBuffer.isView(o) ? o : textEncoder$1.encode(o);
  }, decode: function(o) {
    return textDecoder.decode(o);
  }, name: `${this.name}+view` });
}, createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(o) {
    return Buffer$5.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$5.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$5.from(String(o), "utf8");
  }, decode: function(o) {
    return o.toString("utf8");
  }, name: `${this.name}+buffer` });
} }), encodings$1.json = new UTF8Format$1({ encode: JSON.stringify, decode: JSON.parse, name: "json" }), encodings$1.buffer = new BufferFormat$1({ encode: function(o) {
  return Buffer$5.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$5.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$5.from(String(o), "utf8");
}, decode: identity, name: "buffer", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(o) {
    return ArrayBuffer.isView(o) ? o : Buffer$5.from(String(o), "utf8");
  }, decode: function(o) {
    return Buffer$5.from(o.buffer, o.byteOffset, o.byteLength);
  }, name: `${this.name}+view` });
} }), encodings$1.view = new ViewFormat$1({ encode: function(o) {
  return ArrayBuffer.isView(o) ? o : textEncoder$1.encode(o);
}, decode: identity, name: "view", createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(o) {
    return Buffer$5.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$5.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$5.from(String(o), "utf8");
  }, decode: identity, name: `${this.name}+buffer` });
} }), encodings$1.hex = new BufferFormat$1({ encode: function(o) {
  return Buffer$5.isBuffer(o) ? o : Buffer$5.from(String(o), "hex");
}, decode: function(o) {
  return o.toString("hex");
}, name: "hex" }), encodings$1.base64 = new BufferFormat$1({ encode: function(o) {
  return Buffer$5.isBuffer(o) ? o : Buffer$5.from(String(o), "base64");
}, decode: function(o) {
  return o.toString("base64");
}, name: "base64" });
const ModuleError$8 = moduleError, encodings = encodings$1, { Encoding } = encoding, { BufferFormat, ViewFormat, UTF8Format } = formats$2, kFormats = Symbol("formats"), kEncodings = Symbol("encodings"), validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Transcoder$1 {
  constructor(n) {
    if (!Array.isArray(n))
      throw new TypeError("The first argument 'formats' must be an array");
    if (!n.every((a) => validFormats.has(a)))
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    this[kEncodings] = /* @__PURE__ */ new Map(), this[kFormats] = new Set(n);
    for (const a in encodings)
      try {
        this.encoding(a);
      } catch (u) {
        if (u.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
          throw u;
      }
  }
  encodings() {
    return Array.from(new Set(this[kEncodings].values()));
  }
  encoding(n) {
    let a = this[kEncodings].get(n);
    if (a === void 0) {
      if (typeof n == "string" && n !== "") {
        if (a = lookup[n], !a)
          throw new ModuleError$8(`Encoding '${n}' is not found`, { code: "LEVEL_ENCODING_NOT_FOUND" });
      } else {
        if (typeof n != "object" || n === null)
          throw new TypeError("First argument 'encoding' must be a string or object");
        a = from(n);
      }
      const { name: u, format: c } = a;
      if (!this[kFormats].has(c))
        if (this[kFormats].has("view"))
          a = a.createViewTranscoder();
        else if (this[kFormats].has("buffer"))
          a = a.createBufferTranscoder();
        else {
          if (!this[kFormats].has("utf8"))
            throw new ModuleError$8(`Encoding '${u}' cannot be transcoded`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
          a = a.createUTF8Transcoder();
        }
      for (const m of [n, u, a.name, a.commonName])
        this[kEncodings].set(m, a);
    }
    return a;
  }
}
function from(o) {
  if (o instanceof Encoding)
    return o;
  const n = "type" in o && typeof o.type == "string" ? o.type : void 0, a = o.name || n || "anonymous-" + anonymousCount++;
  switch (detectFormat(o)) {
    case "view":
      return new ViewFormat({ ...o, name: a });
    case "utf8":
      return new UTF8Format({ ...o, name: a });
    case "buffer":
      return new BufferFormat({ ...o, name: a });
    default:
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
  }
}
function detectFormat(o) {
  return "format" in o && o.format !== void 0 ? o.format : "buffer" in o && typeof o.buffer == "boolean" ? o.buffer ? "buffer" : "utf8" : "code" in o && Number.isInteger(o.code) ? "view" : "buffer";
}
levelTranscoder.Transcoder = Transcoder$1;
const aliases = { binary: encodings.buffer, "utf-8": encodings.utf8 }, lookup = { ...encodings, ...aliases };
let anonymousCount = 0;
var events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(o, n, a) {
  return Function.prototype.apply.call(o, n, a);
}, ReflectOwnKeys;
function ProcessEmitWarning(o) {
  console && console.warn && console.warn(o);
}
ReflectOwnKeys = R && typeof R.ownKeys == "function" ? R.ownKeys : Object.getOwnPropertySymbols ? function(o) {
  return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
} : function(o) {
  return Object.getOwnPropertyNames(o);
};
var NumberIsNaN = Number.isNaN || function(o) {
  return o != o;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1, events.exports.once = once, EventEmitter$1.EventEmitter = EventEmitter$1, EventEmitter$1.prototype._events = void 0, EventEmitter$1.prototype._eventsCount = 0, EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(o) {
  if (typeof o != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof o);
}
function _getMaxListeners(o) {
  return o._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : o._maxListeners;
}
function _addListener(o, n, a, u) {
  var c, m, d;
  if (checkListener(a), (m = o._events) === void 0 ? (m = o._events = /* @__PURE__ */ Object.create(null), o._eventsCount = 0) : (m.newListener !== void 0 && (o.emit("newListener", n, a.listener ? a.listener : a), m = o._events), d = m[n]), d === void 0)
    d = m[n] = a, ++o._eventsCount;
  else if (typeof d == "function" ? d = m[n] = u ? [a, d] : [d, a] : u ? d.unshift(a) : d.push(a), (c = _getMaxListeners(o)) > 0 && d.length > c && !d.warned) {
    d.warned = !0;
    var w = new Error("Possible EventEmitter memory leak detected. " + d.length + " " + String(n) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    w.name = "MaxListenersExceededWarning", w.emitter = o, w.type = n, w.count = d.length, ProcessEmitWarning(w);
  }
  return o;
}
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(o, n, a) {
  var u = { fired: !1, wrapFn: void 0, target: o, type: n, listener: a }, c = onceWrapper.bind(u);
  return c.listener = a, u.wrapFn = c, c;
}
function _listeners(o, n, a) {
  var u = o._events;
  if (u === void 0)
    return [];
  var c = u[n];
  return c === void 0 ? [] : typeof c == "function" ? a ? [c.listener || c] : [c] : a ? unwrapListeners(c) : arrayClone(c, c.length);
}
function listenerCount(o) {
  var n = this._events;
  if (n !== void 0) {
    var a = n[o];
    if (typeof a == "function")
      return 1;
    if (a !== void 0)
      return a.length;
  }
  return 0;
}
function arrayClone(o, n) {
  for (var a = new Array(n), u = 0; u < n; ++u)
    a[u] = o[u];
  return a;
}
function spliceOne(o, n) {
  for (; n + 1 < o.length; n++)
    o[n] = o[n + 1];
  o.pop();
}
function unwrapListeners(o) {
  for (var n = new Array(o.length), a = 0; a < n.length; ++a)
    n[a] = o[a].listener || o[a];
  return n;
}
function once(o, n) {
  return new Promise(function(a, u) {
    function c(d) {
      o.removeListener(n, m), u(d);
    }
    function m() {
      typeof o.removeListener == "function" && o.removeListener("error", c), a([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(o, n, m, { once: !0 }), n !== "error" && addErrorHandlerIfEventEmitter(o, c, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(o, n, a) {
  typeof o.on == "function" && eventTargetAgnosticAddListener(o, "error", n, a);
}
function eventTargetAgnosticAddListener(o, n, a, u) {
  if (typeof o.on == "function")
    u.once ? o.once(n, a) : o.on(n, a);
  else {
    if (typeof o.addEventListener != "function")
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof o);
    o.addEventListener(n, function c(m) {
      u.once && o.removeEventListener(n, c), a(m);
    });
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", { enumerable: !0, get: function() {
  return defaultMaxListeners;
}, set: function(o) {
  if (typeof o != "number" || o < 0 || NumberIsNaN(o))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + o + ".");
  defaultMaxListeners = o;
} }), EventEmitter$1.init = function() {
  this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, EventEmitter$1.prototype.setMaxListeners = function(o) {
  if (typeof o != "number" || o < 0 || NumberIsNaN(o))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + o + ".");
  return this._maxListeners = o, this;
}, EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
}, EventEmitter$1.prototype.emit = function(o) {
  for (var n = [], a = 1; a < arguments.length; a++)
    n.push(arguments[a]);
  var u = o === "error", c = this._events;
  if (c !== void 0)
    u = u && c.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var m;
    if (n.length > 0 && (m = n[0]), m instanceof Error)
      throw m;
    var d = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
    throw d.context = m, d;
  }
  var w = c[o];
  if (w === void 0)
    return !1;
  if (typeof w == "function")
    ReflectApply(w, this, n);
  else {
    var S = w.length, T = arrayClone(w, S);
    for (a = 0; a < S; ++a)
      ReflectApply(T[a], this, n);
  }
  return !0;
}, EventEmitter$1.prototype.addListener = function(o, n) {
  return _addListener(this, o, n, !1);
}, EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener, EventEmitter$1.prototype.prependListener = function(o, n) {
  return _addListener(this, o, n, !0);
}, EventEmitter$1.prototype.once = function(o, n) {
  return checkListener(n), this.on(o, _onceWrap(this, o, n)), this;
}, EventEmitter$1.prototype.prependOnceListener = function(o, n) {
  return checkListener(n), this.prependListener(o, _onceWrap(this, o, n)), this;
}, EventEmitter$1.prototype.removeListener = function(o, n) {
  var a, u, c, m, d;
  if (checkListener(n), (u = this._events) === void 0)
    return this;
  if ((a = u[o]) === void 0)
    return this;
  if (a === n || a.listener === n)
    --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[o], u.removeListener && this.emit("removeListener", o, a.listener || n));
  else if (typeof a != "function") {
    for (c = -1, m = a.length - 1; m >= 0; m--)
      if (a[m] === n || a[m].listener === n) {
        d = a[m].listener, c = m;
        break;
      }
    if (c < 0)
      return this;
    c === 0 ? a.shift() : spliceOne(a, c), a.length === 1 && (u[o] = a[0]), u.removeListener !== void 0 && this.emit("removeListener", o, d || n);
  }
  return this;
}, EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener, EventEmitter$1.prototype.removeAllListeners = function(o) {
  var n, a, u;
  if ((a = this._events) === void 0)
    return this;
  if (a.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : a[o] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete a[o]), this;
  if (arguments.length === 0) {
    var c, m = Object.keys(a);
    for (u = 0; u < m.length; ++u)
      (c = m[u]) !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (typeof (n = a[o]) == "function")
    this.removeListener(o, n);
  else if (n !== void 0)
    for (u = n.length - 1; u >= 0; u--)
      this.removeListener(o, n[u]);
  return this;
}, EventEmitter$1.prototype.listeners = function(o) {
  return _listeners(this, o, !0);
}, EventEmitter$1.prototype.rawListeners = function(o) {
  return _listeners(this, o, !1);
}, EventEmitter$1.listenerCount = function(o, n) {
  return typeof o.listenerCount == "function" ? o.listenerCount(n) : listenerCount.call(o, n);
}, EventEmitter$1.prototype.listenerCount = listenerCount, EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
var catering = {}, nextTickBrowser$1 = typeof queueMicrotask == "function" ? queueMicrotask : (o) => Promise.resolve().then(o), nextTick = nextTickBrowser$1;
catering.fromCallback = function(o, n) {
  if (o === void 0) {
    var a = new Promise(function(u, c) {
      o = function(m, d) {
        m ? c(m) : u(d);
      };
    });
    o[n !== void 0 ? n : "promise"] = a;
  } else if (typeof o != "function")
    throw new TypeError("Callback must be a function");
  return o;
}, catering.fromPromise = function(o, n) {
  if (n === void 0)
    return o;
  o.then(function(a) {
    nextTick(() => n(null, a));
  }).catch(function(a) {
    nextTick(() => n(a));
  });
};
var abstractIterator = {}, common$6 = { getCallback: function(o, n) {
  return typeof o == "function" ? o : n;
}, getOptions: function(o, n) {
  return typeof o == "object" && o !== null ? o : n !== void 0 ? n : {};
} };
const { fromCallback: fromCallback$3 } = catering, ModuleError$7 = moduleError, { getOptions: getOptions$2, getCallback: getCallback$2 } = common$6, kPromise$3 = Symbol("promise"), kCallback$1 = Symbol("callback"), kWorking = Symbol("working"), kHandleOne$1 = Symbol("handleOne"), kHandleMany$1 = Symbol("handleMany"), kAutoClose = Symbol("autoClose"), kFinishWork = Symbol("finishWork"), kReturnMany = Symbol("returnMany"), kClosing = Symbol("closing"), kHandleClose = Symbol("handleClose"), kClosed = Symbol("closed"), kCloseCallbacks$1 = Symbol("closeCallbacks"), kKeyEncoding$1 = Symbol("keyEncoding"), kValueEncoding$1 = Symbol("valueEncoding"), kAbortOnClose = Symbol("abortOnClose"), kLegacy = Symbol("legacy"), kKeys = Symbol("keys"), kValues = Symbol("values"), kLimit = Symbol("limit"), kCount = Symbol("count"), emptyOptions$1 = Object.freeze({}), noop$1 = () => {
};
let warnedEnd = !1;
class CommonIterator {
  constructor(n, a, u) {
    if (typeof n != "object" || n === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (n === null ? "null" : typeof n));
    if (typeof a != "object" || a === null)
      throw new TypeError("The second argument must be an options object");
    this[kClosed] = !1, this[kCloseCallbacks$1] = [], this[kWorking] = !1, this[kClosing] = !1, this[kAutoClose] = !1, this[kCallback$1] = null, this[kHandleOne$1] = this[kHandleOne$1].bind(this), this[kHandleMany$1] = this[kHandleMany$1].bind(this), this[kHandleClose] = this[kHandleClose].bind(this), this[kKeyEncoding$1] = a[kKeyEncoding$1], this[kValueEncoding$1] = a[kValueEncoding$1], this[kLegacy] = u, this[kLimit] = Number.isInteger(a.limit) && a.limit >= 0 ? a.limit : 1 / 0, this[kCount] = 0, this[kAbortOnClose] = !!a.abortOnClose, this.db = n, this.db.attachResource(this), this.nextTick = n.nextTick;
  }
  get count() {
    return this[kCount];
  }
  get limit() {
    return this[kLimit];
  }
  next(n) {
    let a;
    if (n === void 0)
      a = new Promise((u, c) => {
        n = (m, d, w) => {
          m ? c(m) : this[kLegacy] ? d === void 0 && w === void 0 ? u() : u([d, w]) : u(d);
        };
      });
    else if (typeof n != "function")
      throw new TypeError("Callback must be a function");
    return this[kClosing] ? this.nextTick(n, new ModuleError$7("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(n, new ModuleError$7("Iterator is busy: cannot call next() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = n, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleOne$1], null) : this._next(this[kHandleOne$1])), a;
  }
  _next(n) {
    this.nextTick(n);
  }
  nextv(n, a, u) {
    return u = getCallback$2(a, u), u = fromCallback$3(u, kPromise$3), a = getOptions$2(a, emptyOptions$1), Number.isInteger(n) ? (this[kClosing] ? this.nextTick(u, new ModuleError$7("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(u, new ModuleError$7("Iterator is busy: cannot call nextv() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (n < 1 && (n = 1), this[kLimit] < 1 / 0 && (n = Math.min(n, this[kLimit] - this[kCount])), this[kWorking] = !0, this[kCallback$1] = u, n <= 0 ? this.nextTick(this[kHandleMany$1], null, []) : this._nextv(n, a, this[kHandleMany$1])), u[kPromise$3]) : (this.nextTick(u, new TypeError("The first argument 'size' must be an integer")), u[kPromise$3]);
  }
  _nextv(n, a, u) {
    const c = [], m = (d, w, S) => d ? u(d) : (this[kLegacy] ? w === void 0 && S === void 0 : w === void 0) ? u(null, c) : (c.push(this[kLegacy] ? [w, S] : w), void (c.length === n ? u(null, c) : this._next(m)));
    this._next(m);
  }
  all(n, a) {
    return a = getCallback$2(n, a), a = fromCallback$3(a, kPromise$3), n = getOptions$2(n, emptyOptions$1), this[kClosing] ? this.nextTick(a, new ModuleError$7("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(a, new ModuleError$7("Iterator is busy: cannot call all() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = a, this[kAutoClose] = !0, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleMany$1], null, []) : this._all(n, this[kHandleMany$1])), a[kPromise$3];
  }
  _all(n, a) {
    let u = this[kCount];
    const c = [], m = () => {
      const w = this[kLimit] < 1 / 0 ? Math.min(1e3, this[kLimit] - u) : 1e3;
      w <= 0 ? this.nextTick(a, null, c) : this._nextv(w, emptyOptions$1, d);
    }, d = (w, S) => {
      w ? a(w) : S.length === 0 ? a(null, c) : (c.push.apply(c, S), u += S.length, m());
    };
    m();
  }
  [kFinishWork]() {
    const n = this[kCallback$1];
    return this[kAbortOnClose] && n === null ? noop$1 : (this[kWorking] = !1, this[kCallback$1] = null, this[kClosing] && this._close(this[kHandleClose]), n);
  }
  [kReturnMany](n, a, u) {
    this[kAutoClose] ? this.close(n.bind(null, a, u)) : n(a, u);
  }
  seek(n, a) {
    if (a = getOptions$2(a, emptyOptions$1), !this[kClosing]) {
      if (this[kWorking])
        throw new ModuleError$7("Iterator is busy: cannot call seek() until next() has completed", { code: "LEVEL_ITERATOR_BUSY" });
      {
        const u = this.db.keyEncoding(a.keyEncoding || this[kKeyEncoding$1]), c = u.format;
        a.keyEncoding !== c && (a = { ...a, keyEncoding: c });
        const m = this.db.prefixKey(u.encode(n), c);
        this._seek(m, a);
      }
    }
  }
  _seek(n, a) {
    throw new ModuleError$7("Iterator does not support seek()", { code: "LEVEL_NOT_SUPPORTED" });
  }
  close(n) {
    return n = fromCallback$3(n, kPromise$3), this[kClosed] ? this.nextTick(n) : this[kClosing] ? this[kCloseCallbacks$1].push(n) : (this[kClosing] = !0, this[kCloseCallbacks$1].push(n), this[kWorking] ? this[kAbortOnClose] && this[kFinishWork]()(new ModuleError$7("Aborted on iterator close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this._close(this[kHandleClose])), n[kPromise$3];
  }
  _close(n) {
    this.nextTick(n);
  }
  [kHandleClose]() {
    this[kClosed] = !0, this.db.detachResource(this);
    const n = this[kCloseCallbacks$1];
    this[kCloseCallbacks$1] = [];
    for (const a of n)
      a();
  }
  async *[Symbol.asyncIterator]() {
    try {
      let n;
      for (; (n = await this.next()) !== void 0; )
        yield n;
    } finally {
      this[kClosed] || await this.close();
    }
  }
}
class AbstractIterator$4 extends CommonIterator {
  constructor(n, a) {
    super(n, a, !0), this[kKeys] = a.keys !== !1, this[kValues] = a.values !== !1;
  }
  [kHandleOne$1](n, a, u) {
    const c = this[kFinishWork]();
    if (n)
      return c(n);
    try {
      a = this[kKeys] && a !== void 0 ? this[kKeyEncoding$1].decode(a) : void 0, u = this[kValues] && u !== void 0 ? this[kValueEncoding$1].decode(u) : void 0;
    } catch (m) {
      return c(new IteratorDecodeError("entry", m));
    }
    a === void 0 && u === void 0 || this[kCount]++, c(null, a, u);
  }
  [kHandleMany$1](n, a) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (const c of a) {
        const m = c[0], d = c[1];
        c[0] = this[kKeys] && m !== void 0 ? this[kKeyEncoding$1].decode(m) : void 0, c[1] = this[kValues] && d !== void 0 ? this[kValueEncoding$1].decode(d) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("entries", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
  end(n) {
    return warnedEnd || typeof console > "u" || (warnedEnd = !0, console.warn(new ModuleError$7("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version", { code: "LEVEL_LEGACY" }))), this.close(n);
  }
}
class AbstractKeyIterator$3 extends CommonIterator {
  constructor(n, a) {
    super(n, a, !1);
  }
  [kHandleOne$1](n, a) {
    const u = this[kFinishWork]();
    if (n)
      return u(n);
    try {
      a = a !== void 0 ? this[kKeyEncoding$1].decode(a) : void 0;
    } catch (c) {
      return u(new IteratorDecodeError("key", c));
    }
    a !== void 0 && this[kCount]++, u(null, a);
  }
  [kHandleMany$1](n, a) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (let c = 0; c < a.length; c++) {
        const m = a[c];
        a[c] = m !== void 0 ? this[kKeyEncoding$1].decode(m) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("keys", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
}
class AbstractValueIterator$3 extends CommonIterator {
  constructor(n, a) {
    super(n, a, !1);
  }
  [kHandleOne$1](n, a) {
    const u = this[kFinishWork]();
    if (n)
      return u(n);
    try {
      a = a !== void 0 ? this[kValueEncoding$1].decode(a) : void 0;
    } catch (c) {
      return u(new IteratorDecodeError("value", c));
    }
    a !== void 0 && this[kCount]++, u(null, a);
  }
  [kHandleMany$1](n, a) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (let c = 0; c < a.length; c++) {
        const m = a[c];
        a[c] = m !== void 0 ? this[kValueEncoding$1].decode(m) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("values", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
}
class IteratorDecodeError extends ModuleError$7 {
  constructor(n, a) {
    super(`Iterator could not decode ${n}`, { code: "LEVEL_DECODE_ERROR", cause: a });
  }
}
for (const o of ["_ended property", "_nexting property", "_end method"])
  Object.defineProperty(AbstractIterator$4.prototype, o.split(" ")[0], { get() {
    throw new ModuleError$7(`The ${o} has been removed`, { code: "LEVEL_LEGACY" });
  }, set() {
    throw new ModuleError$7(`The ${o} has been removed`, { code: "LEVEL_LEGACY" });
  } });
AbstractIterator$4.keyEncoding = kKeyEncoding$1, AbstractIterator$4.valueEncoding = kValueEncoding$1, abstractIterator.AbstractIterator = AbstractIterator$4, abstractIterator.AbstractKeyIterator = AbstractKeyIterator$3, abstractIterator.AbstractValueIterator = AbstractValueIterator$3;
var defaultKvIterator = {};
const { AbstractKeyIterator: AbstractKeyIterator$2, AbstractValueIterator: AbstractValueIterator$2 } = abstractIterator, kIterator$1 = Symbol("iterator"), kCallback = Symbol("callback"), kHandleOne = Symbol("handleOne"), kHandleMany = Symbol("handleMany");
class DefaultKeyIterator$1 extends AbstractKeyIterator$2 {
  constructor(n, a) {
    super(n, a), this[kIterator$1] = n.iterator({ ...a, keys: !0, values: !1 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
class DefaultValueIterator$1 extends AbstractValueIterator$2 {
  constructor(n, a) {
    super(n, a), this[kIterator$1] = n.iterator({ ...a, keys: !1, values: !0 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
for (const o of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
  const n = o === DefaultKeyIterator$1, a = n ? (u) => u[0] : (u) => u[1];
  o.prototype._next = function(u) {
    this[kCallback] = u, this[kIterator$1].next(this[kHandleOne]);
  }, o.prototype[kHandleOne] = function(u, c, m) {
    const d = this[kCallback];
    u ? d(u) : d(null, n ? c : m);
  }, o.prototype._nextv = function(u, c, m) {
    this[kCallback] = m, this[kIterator$1].nextv(u, c, this[kHandleMany]);
  }, o.prototype._all = function(u, c) {
    this[kCallback] = c, this[kIterator$1].all(u, this[kHandleMany]);
  }, o.prototype[kHandleMany] = function(u, c) {
    const m = this[kCallback];
    u ? m(u) : m(null, c.map(a));
  }, o.prototype._seek = function(u, c) {
    this[kIterator$1].seek(u, c);
  }, o.prototype._close = function(u) {
    this[kIterator$1].close(u);
  };
}
defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1, defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;
var deferredIterator = {};
const { AbstractIterator: AbstractIterator$3, AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator, ModuleError$6 = moduleError, kNut = Symbol("nut"), kUndefer$1 = Symbol("undefer"), kFactory = Symbol("factory");
class DeferredIterator$1 extends AbstractIterator$3 {
  constructor(n, a) {
    super(n, a), this[kNut] = null, this[kFactory] = () => n.iterator(a), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredKeyIterator$1 extends AbstractKeyIterator$1 {
  constructor(n, a) {
    super(n, a), this[kNut] = null, this[kFactory] = () => n.keys(a), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredValueIterator$1 extends AbstractValueIterator$1 {
  constructor(n, a) {
    super(n, a), this[kNut] = null, this[kFactory] = () => n.values(a), this.db.defer(() => this[kUndefer$1]());
  }
}
for (const o of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1])
  o.prototype[kUndefer$1] = function() {
    this.db.status === "open" && (this[kNut] = this[kFactory]());
  }, o.prototype._next = function(n) {
    this[kNut] !== null ? this[kNut].next(n) : this.db.status === "opening" ? this.db.defer(() => this._next(n)) : this.nextTick(n, new ModuleError$6("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._nextv = function(n, a, u) {
    this[kNut] !== null ? this[kNut].nextv(n, a, u) : this.db.status === "opening" ? this.db.defer(() => this._nextv(n, a, u)) : this.nextTick(u, new ModuleError$6("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._all = function(n, a) {
    this[kNut] !== null ? this[kNut].all(a) : this.db.status === "opening" ? this.db.defer(() => this._all(n, a)) : this.nextTick(a, new ModuleError$6("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._seek = function(n, a) {
    this[kNut] !== null ? this[kNut]._seek(n, a) : this.db.status === "opening" && this.db.defer(() => this._seek(n, a));
  }, o.prototype._close = function(n) {
    this[kNut] !== null ? this[kNut].close(n) : this.db.status === "opening" ? this.db.defer(() => this._close(n)) : this.nextTick(n);
  };
deferredIterator.DeferredIterator = DeferredIterator$1, deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1, deferredIterator.DeferredValueIterator = DeferredValueIterator$1;
var defaultChainedBatch = {}, abstractChainedBatch = {};
const { fromCallback: fromCallback$2 } = catering, ModuleError$5 = moduleError, { getCallback: getCallback$1, getOptions: getOptions$1 } = common$6, kPromise$2 = Symbol("promise"), kStatus$1 = Symbol("status"), kOperations$1 = Symbol("operations"), kFinishClose = Symbol("finishClose"), kCloseCallbacks = Symbol("closeCallbacks");
class AbstractChainedBatch$1 {
  constructor(n) {
    if (typeof n != "object" || n === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (n === null ? "null" : typeof n));
    this[kOperations$1] = [], this[kCloseCallbacks] = [], this[kStatus$1] = "open", this[kFinishClose] = this[kFinishClose].bind(this), this.db = n, this.db.attachResource(this), this.nextTick = n.nextTick;
  }
  get length() {
    return this[kOperations$1].length;
  }
  put(n, a, u) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call put() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const c = this.db._checkKey(n) || this.db._checkValue(a);
    if (c)
      throw c;
    const m = u && u.sublevel != null ? u.sublevel : this.db, d = u, w = m.keyEncoding(u && u.keyEncoding), S = m.valueEncoding(u && u.valueEncoding), T = w.format;
    u = { ...u, keyEncoding: T, valueEncoding: S.format }, m !== this.db && (u.sublevel = null);
    const B = m.prefixKey(w.encode(n), T), I = S.encode(a);
    return this._put(B, I, u), this[kOperations$1].push({ ...d, type: "put", key: n, value: a }), this;
  }
  _put(n, a, u) {
  }
  del(n, a) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call del() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const u = this.db._checkKey(n);
    if (u)
      throw u;
    const c = a && a.sublevel != null ? a.sublevel : this.db, m = a, d = c.keyEncoding(a && a.keyEncoding), w = d.format;
    return a = { ...a, keyEncoding: w }, c !== this.db && (a.sublevel = null), this._del(c.prefixKey(d.encode(n), w), a), this[kOperations$1].push({ ...m, type: "del", key: n }), this;
  }
  _del(n, a) {
  }
  clear() {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call clear() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    return this._clear(), this[kOperations$1] = [], this;
  }
  _clear() {
  }
  write(n, a) {
    return a = getCallback$1(n, a), a = fromCallback$2(a, kPromise$2), n = getOptions$1(n), this[kStatus$1] !== "open" ? this.nextTick(a, new ModuleError$5("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" })) : this.length === 0 ? this.close(a) : (this[kStatus$1] = "writing", this._write(n, (u) => {
      this[kStatus$1] = "closing", this[kCloseCallbacks].push(() => a(u)), u || this.db.emit("batch", this[kOperations$1]), this._close(this[kFinishClose]);
    })), a[kPromise$2];
  }
  _write(n, a) {
  }
  close(n) {
    return n = fromCallback$2(n, kPromise$2), this[kStatus$1] === "closing" ? this[kCloseCallbacks].push(n) : this[kStatus$1] === "closed" ? this.nextTick(n) : (this[kCloseCallbacks].push(n), this[kStatus$1] !== "writing" && (this[kStatus$1] = "closing", this._close(this[kFinishClose]))), n[kPromise$2];
  }
  _close(n) {
    this.nextTick(n);
  }
  [kFinishClose]() {
    this[kStatus$1] = "closed", this.db.detachResource(this);
    const n = this[kCloseCallbacks];
    this[kCloseCallbacks] = [];
    for (const a of n)
      a();
  }
}
abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;
const { AbstractChainedBatch } = abstractChainedBatch, ModuleError$4 = moduleError, kEncoded = Symbol("encoded");
class DefaultChainedBatch$1 extends AbstractChainedBatch {
  constructor(n) {
    super(n), this[kEncoded] = [];
  }
  _put(n, a, u) {
    this[kEncoded].push({ ...u, type: "put", key: n, value: a });
  }
  _del(n, a) {
    this[kEncoded].push({ ...a, type: "del", key: n });
  }
  _clear() {
    this[kEncoded] = [];
  }
  _write(n, a) {
    this.db.status === "opening" ? this.db.defer(() => this._write(n, a)) : this.db.status === "open" ? this[kEncoded].length === 0 ? this.nextTick(a) : this.db._batch(this[kEncoded], n, a) : this.nextTick(a, new ModuleError$4("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" }));
  }
}
defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;
const ModuleError$3 = moduleError, hasOwnProperty$a = Object.prototype.hasOwnProperty, rangeOptions$2 = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
var rangeOptions_1 = function(o, n) {
  const a = {};
  for (const u in o)
    if (hasOwnProperty$a.call(o, u) && u !== "keyEncoding" && u !== "valueEncoding") {
      if (u === "start" || u === "end")
        throw new ModuleError$3(`The legacy range option '${u}' has been removed`, { code: "LEVEL_LEGACY" });
      if (u === "encoding")
        throw new ModuleError$3("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", { code: "LEVEL_LEGACY" });
      rangeOptions$2.has(u) ? a[u] = n.encode(o[u]) : a[u] = o[u];
    }
  return a.reverse = !!a.reverse, a.limit = Number.isInteger(a.limit) && a.limit >= 0 ? a.limit : -1, a;
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
};
let promise;
var queueMicrotask_1 = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : commonjsGlobal) : (o) => (promise || (promise = Promise.resolve())).then(o).catch((n) => setTimeout(() => {
  throw n;
}, 0)), nextTickBrowser, hasRequiredNextTickBrowser;
function requireNextTickBrowser() {
  if (hasRequiredNextTickBrowser)
    return nextTickBrowser;
  hasRequiredNextTickBrowser = 1;
  const o = queueMicrotask_1;
  return nextTickBrowser = function(n, ...a) {
    a.length === 0 ? o(n) : o(() => n(...a));
  };
}
var buffer$1 = {}, hasRequiredBuffer;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
function requireBuffer() {
  return hasRequiredBuffer || (hasRequiredBuffer = 1, function(o) {
    const n = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    o.Buffer = d, o.SlowBuffer = function(l) {
      return +l != l && (l = 0), d.alloc(+l);
    }, o.INSPECT_MAX_BYTES = 50;
    const c = 2147483647;
    function m(l) {
      if (l > c)
        throw new RangeError('The value "' + l + '" is invalid for option "size"');
      const h = new Uint8Array(l);
      return Object.setPrototypeOf(h, d.prototype), h;
    }
    function d(l, h, b) {
      if (typeof l == "number") {
        if (typeof h == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return T(l);
      }
      return w(l, h, b);
    }
    function w(l, h, b) {
      if (typeof l == "string")
        return function(x, O) {
          if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
            throw new TypeError("Unknown encoding: " + O);
          const G = 0 | N(x, O);
          let Q = m(G);
          const ne = Q.write(x, O);
          return ne !== G && (Q = Q.slice(0, ne)), Q;
        }(l, h);
      if (ArrayBuffer.isView(l))
        return function(x) {
          if (le(x, Uint8Array)) {
            const O = new Uint8Array(x);
            return I(O.buffer, O.byteOffset, O.byteLength);
          }
          return B(x);
        }(l);
      if (l == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
      if (le(l, ArrayBuffer) || l && le(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (le(l, SharedArrayBuffer) || l && le(l.buffer, SharedArrayBuffer)))
        return I(l, h, b);
      if (typeof l == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      const M = l.valueOf && l.valueOf();
      if (M != null && M !== l)
        return d.from(M, h, b);
      const k = function(x) {
        if (d.isBuffer(x)) {
          const O = 0 | C(x.length), G = m(O);
          return G.length === 0 || x.copy(G, 0, 0, O), G;
        }
        return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? m(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
      }(l);
      if (k)
        return k;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
        return d.from(l[Symbol.toPrimitive]("string"), h, b);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    }
    function S(l) {
      if (typeof l != "number")
        throw new TypeError('"size" argument must be of type number');
      if (l < 0)
        throw new RangeError('The value "' + l + '" is invalid for option "size"');
    }
    function T(l) {
      return S(l), m(l < 0 ? 0 : 0 | C(l));
    }
    function B(l) {
      const h = l.length < 0 ? 0 : 0 | C(l.length), b = m(h);
      for (let M = 0; M < h; M += 1)
        b[M] = 255 & l[M];
      return b;
    }
    function I(l, h, b) {
      if (h < 0 || l.byteLength < h)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (l.byteLength < h + (b || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let M;
      return M = h === void 0 && b === void 0 ? new Uint8Array(l) : b === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, b), Object.setPrototypeOf(M, d.prototype), M;
    }
    function C(l) {
      if (l >= c)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
      return 0 | l;
    }
    function N(l, h) {
      if (d.isBuffer(l))
        return l.length;
      if (ArrayBuffer.isView(l) || le(l, ArrayBuffer))
        return l.byteLength;
      if (typeof l != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
      const b = l.length, M = arguments.length > 2 && arguments[2] === !0;
      if (!M && b === 0)
        return 0;
      let k = !1;
      for (; ; )
        switch (h) {
          case "ascii":
          case "latin1":
          case "binary":
            return b;
          case "utf8":
          case "utf-8":
            return he(l).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * b;
          case "hex":
            return b >>> 1;
          case "base64":
            return $e(l).length;
          default:
            if (k)
              return M ? -1 : he(l).length;
            h = ("" + h).toLowerCase(), k = !0;
        }
    }
    function q(l, h, b) {
      let M = !1;
      if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0) <= (h >>>= 0))
        return "";
      for (l || (l = "utf8"); ; )
        switch (l) {
          case "hex":
            return g(this, h, b);
          case "utf8":
          case "utf-8":
            return p(this, h, b);
          case "ascii":
            return _(this, h, b);
          case "latin1":
          case "binary":
            return y(this, h, b);
          case "base64":
            return te(this, h, b);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return v(this, h, b);
          default:
            if (M)
              throw new TypeError("Unknown encoding: " + l);
            l = (l + "").toLowerCase(), M = !0;
        }
    }
    function D(l, h, b) {
      const M = l[h];
      l[h] = l[b], l[b] = M;
    }
    function z(l, h, b, M, k) {
      if (l.length === 0)
        return -1;
      if (typeof b == "string" ? (M = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), we(b = +b) && (b = k ? 0 : l.length - 1), b < 0 && (b = l.length + b), b >= l.length) {
        if (k)
          return -1;
        b = l.length - 1;
      } else if (b < 0) {
        if (!k)
          return -1;
        b = 0;
      }
      if (typeof h == "string" && (h = d.from(h, M)), d.isBuffer(h))
        return h.length === 0 ? -1 : W(l, h, b, M, k);
      if (typeof h == "number")
        return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(l, h, b) : Uint8Array.prototype.lastIndexOf.call(l, h, b) : W(l, [h], b, M, k);
      throw new TypeError("val must be string, number or Buffer");
    }
    function W(l, h, b, M, k) {
      let x, O = 1, G = l.length, Q = h.length;
      if (M !== void 0 && ((M = String(M).toLowerCase()) === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
        if (l.length < 2 || h.length < 2)
          return -1;
        O = 2, G /= 2, Q /= 2, b /= 2;
      }
      function ne(Y, ae) {
        return O === 1 ? Y[ae] : Y.readUInt16BE(ae * O);
      }
      if (k) {
        let Y = -1;
        for (x = b; x < G; x++)
          if (ne(l, x) === ne(h, Y === -1 ? 0 : x - Y)) {
            if (Y === -1 && (Y = x), x - Y + 1 === Q)
              return Y * O;
          } else
            Y !== -1 && (x -= x - Y), Y = -1;
      } else
        for (b + Q > G && (b = G - Q), x = b; x >= 0; x--) {
          let Y = !0;
          for (let ae = 0; ae < Q; ae++)
            if (ne(l, x + ae) !== ne(h, ae)) {
              Y = !1;
              break;
            }
          if (Y)
            return x;
        }
      return -1;
    }
    function V(l, h, b, M) {
      b = Number(b) || 0;
      const k = l.length - b;
      M ? (M = Number(M)) > k && (M = k) : M = k;
      const x = h.length;
      let O;
      for (M > x / 2 && (M = x / 2), O = 0; O < M; ++O) {
        const G = parseInt(h.substr(2 * O, 2), 16);
        if (we(G))
          return O;
        l[b + O] = G;
      }
      return O;
    }
    function ee(l, h, b, M) {
      return fe(he(h, l.length - b), l, b, M);
    }
    function P(l, h, b, M) {
      return fe(function(k) {
        const x = [];
        for (let O = 0; O < k.length; ++O)
          x.push(255 & k.charCodeAt(O));
        return x;
      }(h), l, b, M);
    }
    function F(l, h, b, M) {
      return fe($e(h), l, b, M);
    }
    function H(l, h, b, M) {
      return fe(function(k, x) {
        let O, G, Q;
        const ne = [];
        for (let Y = 0; Y < k.length && !((x -= 2) < 0); ++Y)
          O = k.charCodeAt(Y), G = O >> 8, Q = O % 256, ne.push(Q), ne.push(G);
        return ne;
      }(h, l.length - b), l, b, M);
    }
    function te(l, h, b) {
      return h === 0 && b === l.length ? n.fromByteArray(l) : n.fromByteArray(l.slice(h, b));
    }
    function p(l, h, b) {
      b = Math.min(l.length, b);
      const M = [];
      let k = h;
      for (; k < b; ) {
        const x = l[k];
        let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
        if (k + G <= b) {
          let Q, ne, Y, ae;
          switch (G) {
            case 1:
              x < 128 && (O = x);
              break;
            case 2:
              Q = l[k + 1], (192 & Q) == 128 && (ae = (31 & x) << 6 | 63 & Q, ae > 127 && (O = ae));
              break;
            case 3:
              Q = l[k + 1], ne = l[k + 2], (192 & Q) == 128 && (192 & ne) == 128 && (ae = (15 & x) << 12 | (63 & Q) << 6 | 63 & ne, ae > 2047 && (ae < 55296 || ae > 57343) && (O = ae));
              break;
            case 4:
              Q = l[k + 1], ne = l[k + 2], Y = l[k + 3], (192 & Q) == 128 && (192 & ne) == 128 && (192 & Y) == 128 && (ae = (15 & x) << 18 | (63 & Q) << 12 | (63 & ne) << 6 | 63 & Y, ae > 65535 && ae < 1114112 && (O = ae));
          }
        }
        O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, M.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), M.push(O), k += G;
      }
      return function(x) {
        const O = x.length;
        if (O <= $)
          return String.fromCharCode.apply(String, x);
        let G = "", Q = 0;
        for (; Q < O; )
          G += String.fromCharCode.apply(String, x.slice(Q, Q += $));
        return G;
      }(M);
    }
    o.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
      try {
        const l = new Uint8Array(1), h = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
      } catch {
        return !1;
      }
    }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
      if (d.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
      if (d.isBuffer(this))
        return this.byteOffset;
    } }), d.poolSize = 8192, d.from = function(l, h, b) {
      return w(l, h, b);
    }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, b) {
      return function(M, k, x) {
        return S(M), M <= 0 ? m(M) : k !== void 0 ? typeof x == "string" ? m(M).fill(k, x) : m(M).fill(k) : m(M);
      }(l, h, b);
    }, d.allocUnsafe = function(l) {
      return T(l);
    }, d.allocUnsafeSlow = function(l) {
      return T(l);
    }, d.isBuffer = function(l) {
      return l != null && l._isBuffer === !0 && l !== d.prototype;
    }, d.compare = function(l, h) {
      if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), le(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (l === h)
        return 0;
      let b = l.length, M = h.length;
      for (let k = 0, x = Math.min(b, M); k < x; ++k)
        if (l[k] !== h[k]) {
          b = l[k], M = h[k];
          break;
        }
      return b < M ? -1 : M < b ? 1 : 0;
    }, d.isEncoding = function(l) {
      switch (String(l).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, d.concat = function(l, h) {
      if (!Array.isArray(l))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (l.length === 0)
        return d.alloc(0);
      let b;
      if (h === void 0)
        for (h = 0, b = 0; b < l.length; ++b)
          h += l[b].length;
      const M = d.allocUnsafe(h);
      let k = 0;
      for (b = 0; b < l.length; ++b) {
        let x = l[b];
        if (le(x, Uint8Array))
          k + x.length > M.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(M, k)) : Uint8Array.prototype.set.call(M, x, k);
        else {
          if (!d.isBuffer(x))
            throw new TypeError('"list" argument must be an Array of Buffers');
          x.copy(M, k);
        }
        k += x.length;
      }
      return M;
    }, d.byteLength = N, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
      const l = this.length;
      if (l % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let h = 0; h < l; h += 2)
        D(this, h, h + 1);
      return this;
    }, d.prototype.swap32 = function() {
      const l = this.length;
      if (l % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let h = 0; h < l; h += 4)
        D(this, h, h + 3), D(this, h + 1, h + 2);
      return this;
    }, d.prototype.swap64 = function() {
      const l = this.length;
      if (l % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let h = 0; h < l; h += 8)
        D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
      return this;
    }, d.prototype.toString = function() {
      const l = this.length;
      return l === 0 ? "" : arguments.length === 0 ? p(this, 0, l) : q.apply(this, arguments);
    }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
      if (!d.isBuffer(l))
        throw new TypeError("Argument must be a Buffer");
      return this === l || d.compare(this, l) === 0;
    }, d.prototype.inspect = function() {
      let l = "";
      const h = o.INSPECT_MAX_BYTES;
      return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
    }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, b, M, k) {
      if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
      if (h === void 0 && (h = 0), b === void 0 && (b = l ? l.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), h < 0 || b > l.length || M < 0 || k > this.length)
        throw new RangeError("out of range index");
      if (M >= k && h >= b)
        return 0;
      if (M >= k)
        return -1;
      if (h >= b)
        return 1;
      if (this === l)
        return 0;
      let x = (k >>>= 0) - (M >>>= 0), O = (b >>>= 0) - (h >>>= 0);
      const G = Math.min(x, O), Q = this.slice(M, k), ne = l.slice(h, b);
      for (let Y = 0; Y < G; ++Y)
        if (Q[Y] !== ne[Y]) {
          x = Q[Y], O = ne[Y];
          break;
        }
      return x < O ? -1 : O < x ? 1 : 0;
    }, d.prototype.includes = function(l, h, b) {
      return this.indexOf(l, h, b) !== -1;
    }, d.prototype.indexOf = function(l, h, b) {
      return z(this, l, h, b, !0);
    }, d.prototype.lastIndexOf = function(l, h, b) {
      return z(this, l, h, b, !1);
    }, d.prototype.write = function(l, h, b, M) {
      if (h === void 0)
        M = "utf8", b = this.length, h = 0;
      else if (b === void 0 && typeof h == "string")
        M = h, b = this.length, h = 0;
      else {
        if (!isFinite(h))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        h >>>= 0, isFinite(b) ? (b >>>= 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
      }
      const k = this.length - h;
      if ((b === void 0 || b > k) && (b = k), l.length > 0 && (b < 0 || h < 0) || h > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      M || (M = "utf8");
      let x = !1;
      for (; ; )
        switch (M) {
          case "hex":
            return V(this, l, h, b);
          case "utf8":
          case "utf-8":
            return ee(this, l, h, b);
          case "ascii":
          case "latin1":
          case "binary":
            return P(this, l, h, b);
          case "base64":
            return F(this, l, h, b);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return H(this, l, h, b);
          default:
            if (x)
              throw new TypeError("Unknown encoding: " + M);
            M = ("" + M).toLowerCase(), x = !0;
        }
    }, d.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    const $ = 4096;
    function _(l, h, b) {
      let M = "";
      b = Math.min(l.length, b);
      for (let k = h; k < b; ++k)
        M += String.fromCharCode(127 & l[k]);
      return M;
    }
    function y(l, h, b) {
      let M = "";
      b = Math.min(l.length, b);
      for (let k = h; k < b; ++k)
        M += String.fromCharCode(l[k]);
      return M;
    }
    function g(l, h, b) {
      const M = l.length;
      (!h || h < 0) && (h = 0), (!b || b < 0 || b > M) && (b = M);
      let k = "";
      for (let x = h; x < b; ++x)
        k += We[l[x]];
      return k;
    }
    function v(l, h, b) {
      const M = l.slice(h, b);
      let k = "";
      for (let x = 0; x < M.length - 1; x += 2)
        k += String.fromCharCode(M[x] + 256 * M[x + 1]);
      return k;
    }
    function E(l, h, b) {
      if (l % 1 != 0 || l < 0)
        throw new RangeError("offset is not uint");
      if (l + h > b)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function A(l, h, b, M, k, x) {
      if (!d.isBuffer(l))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (h > k || h < x)
        throw new RangeError('"value" argument is out of bounds');
      if (b + M > l.length)
        throw new RangeError("Index out of range");
    }
    function L(l, h, b, M, k) {
      ue(h, M, k, l, b, 7);
      let x = Number(h & BigInt(4294967295));
      l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x;
      let O = Number(h >> BigInt(32) & BigInt(4294967295));
      return l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, b;
    }
    function j(l, h, b, M, k) {
      ue(h, M, k, l, b, 7);
      let x = Number(h & BigInt(4294967295));
      l[b + 7] = x, x >>= 8, l[b + 6] = x, x >>= 8, l[b + 5] = x, x >>= 8, l[b + 4] = x;
      let O = Number(h >> BigInt(32) & BigInt(4294967295));
      return l[b + 3] = O, O >>= 8, l[b + 2] = O, O >>= 8, l[b + 1] = O, O >>= 8, l[b] = O, b + 8;
    }
    function J(l, h, b, M, k, x) {
      if (b + M > l.length)
        throw new RangeError("Index out of range");
      if (b < 0)
        throw new RangeError("Index out of range");
    }
    function X(l, h, b, M, k) {
      return h = +h, b >>>= 0, k || J(l, 0, b, 4), a.write(l, h, b, M, 23, 4), b + 4;
    }
    function re(l, h, b, M, k) {
      return h = +h, b >>>= 0, k || J(l, 0, b, 8), a.write(l, h, b, M, 52, 8), b + 8;
    }
    d.prototype.slice = function(l, h) {
      const b = this.length;
      (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (h = h === void 0 ? b : ~~h) < 0 ? (h += b) < 0 && (h = 0) : h > b && (h = b), h < l && (h = l);
      const M = this.subarray(l, h);
      return Object.setPrototypeOf(M, d.prototype), M;
    }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, b) {
      l >>>= 0, h >>>= 0, b || E(l, h, this.length);
      let M = this[l], k = 1, x = 0;
      for (; ++x < h && (k *= 256); )
        M += this[l + x] * k;
      return M;
    }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, b) {
      l >>>= 0, h >>>= 0, b || E(l, h, this.length);
      let M = this[l + --h], k = 1;
      for (; h > 0 && (k *= 256); )
        M += this[l + --h] * k;
      return M;
    }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
      return l >>>= 0, h || E(l, 1, this.length), this[l];
    }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
      return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
    }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
      return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
    }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
    }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
    }, d.prototype.readBigUInt64LE = de(function(l) {
      se(l >>>= 0, "offset");
      const h = this[l], b = this[l + 7];
      h !== void 0 && b !== void 0 || ce(l, this.length - 8);
      const M = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, k = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
      return BigInt(M) + (BigInt(k) << BigInt(32));
    }), d.prototype.readBigUInt64BE = de(function(l) {
      se(l >>>= 0, "offset");
      const h = this[l], b = this[l + 7];
      h !== void 0 && b !== void 0 || ce(l, this.length - 8);
      const M = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], k = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
      return (BigInt(M) << BigInt(32)) + BigInt(k);
    }), d.prototype.readIntLE = function(l, h, b) {
      l >>>= 0, h >>>= 0, b || E(l, h, this.length);
      let M = this[l], k = 1, x = 0;
      for (; ++x < h && (k *= 256); )
        M += this[l + x] * k;
      return k *= 128, M >= k && (M -= Math.pow(2, 8 * h)), M;
    }, d.prototype.readIntBE = function(l, h, b) {
      l >>>= 0, h >>>= 0, b || E(l, h, this.length);
      let M = h, k = 1, x = this[l + --M];
      for (; M > 0 && (k *= 256); )
        x += this[l + --M] * k;
      return k *= 128, x >= k && (x -= Math.pow(2, 8 * h)), x;
    }, d.prototype.readInt8 = function(l, h) {
      return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
    }, d.prototype.readInt16LE = function(l, h) {
      l >>>= 0, h || E(l, 2, this.length);
      const b = this[l] | this[l + 1] << 8;
      return 32768 & b ? 4294901760 | b : b;
    }, d.prototype.readInt16BE = function(l, h) {
      l >>>= 0, h || E(l, 2, this.length);
      const b = this[l + 1] | this[l] << 8;
      return 32768 & b ? 4294901760 | b : b;
    }, d.prototype.readInt32LE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
    }, d.prototype.readInt32BE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
    }, d.prototype.readBigInt64LE = de(function(l) {
      se(l >>>= 0, "offset");
      const h = this[l], b = this[l + 7];
      h !== void 0 && b !== void 0 || ce(l, this.length - 8);
      const M = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
      return (BigInt(M) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
    }), d.prototype.readBigInt64BE = de(function(l) {
      se(l >>>= 0, "offset");
      const h = this[l], b = this[l + 7];
      h !== void 0 && b !== void 0 || ce(l, this.length - 8);
      const M = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
      return (BigInt(M) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
    }), d.prototype.readFloatLE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
    }, d.prototype.readFloatBE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
    }, d.prototype.readDoubleLE = function(l, h) {
      return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
    }, d.prototype.readDoubleBE = function(l, h) {
      return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
    }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, b, M) {
      l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
      let k = 1, x = 0;
      for (this[h] = 255 & l; ++x < b && (k *= 256); )
        this[h + x] = l / k & 255;
      return h + b;
    }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, b, M) {
      l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
      let k = b - 1, x = 1;
      for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
        this[h + k] = l / x & 255;
      return h + b;
    }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
    }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
    }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
    }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
    }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
    }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
      return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
    }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
      return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
    }), d.prototype.writeIntLE = function(l, h, b, M) {
      if (l = +l, h >>>= 0, !M) {
        const G = Math.pow(2, 8 * b - 1);
        A(this, l, h, b, G - 1, -G);
      }
      let k = 0, x = 1, O = 0;
      for (this[h] = 255 & l; ++k < b && (x *= 256); )
        l < 0 && O === 0 && this[h + k - 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
      return h + b;
    }, d.prototype.writeIntBE = function(l, h, b, M) {
      if (l = +l, h >>>= 0, !M) {
        const G = Math.pow(2, 8 * b - 1);
        A(this, l, h, b, G - 1, -G);
      }
      let k = b - 1, x = 1, O = 0;
      for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
        l < 0 && O === 0 && this[h + k + 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
      return h + b;
    }, d.prototype.writeInt8 = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
    }, d.prototype.writeInt16LE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
    }, d.prototype.writeInt16BE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
    }, d.prototype.writeInt32LE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
    }, d.prototype.writeInt32BE = function(l, h, b) {
      return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
    }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
      return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
      return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), d.prototype.writeFloatLE = function(l, h, b) {
      return X(this, l, h, !0, b);
    }, d.prototype.writeFloatBE = function(l, h, b) {
      return X(this, l, h, !1, b);
    }, d.prototype.writeDoubleLE = function(l, h, b) {
      return re(this, l, h, !0, b);
    }, d.prototype.writeDoubleBE = function(l, h, b) {
      return re(this, l, h, !1, b);
    }, d.prototype.copy = function(l, h, b, M) {
      if (!d.isBuffer(l))
        throw new TypeError("argument should be a Buffer");
      if (b || (b = 0), M || M === 0 || (M = this.length), h >= l.length && (h = l.length), h || (h = 0), M > 0 && M < b && (M = b), M === b || l.length === 0 || this.length === 0)
        return 0;
      if (h < 0)
        throw new RangeError("targetStart out of bounds");
      if (b < 0 || b >= this.length)
        throw new RangeError("Index out of range");
      if (M < 0)
        throw new RangeError("sourceEnd out of bounds");
      M > this.length && (M = this.length), l.length - h < M - b && (M = l.length - h + b);
      const k = M - b;
      return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, b, M) : Uint8Array.prototype.set.call(l, this.subarray(b, M), h), k;
    }, d.prototype.fill = function(l, h, b, M) {
      if (typeof l == "string") {
        if (typeof h == "string" ? (M = h, h = 0, b = this.length) : typeof b == "string" && (M = b, b = this.length), M !== void 0 && typeof M != "string")
          throw new TypeError("encoding must be a string");
        if (typeof M == "string" && !d.isEncoding(M))
          throw new TypeError("Unknown encoding: " + M);
        if (l.length === 1) {
          const x = l.charCodeAt(0);
          (M === "utf8" && x < 128 || M === "latin1") && (l = x);
        }
      } else
        typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
      if (h < 0 || this.length < h || this.length < b)
        throw new RangeError("Out of range index");
      if (b <= h)
        return this;
      let k;
      if (h >>>= 0, b = b === void 0 ? this.length : b >>> 0, l || (l = 0), typeof l == "number")
        for (k = h; k < b; ++k)
          this[k] = l;
      else {
        const x = d.isBuffer(l) ? l : d.from(l, M), O = x.length;
        if (O === 0)
          throw new TypeError('The value "' + l + '" is invalid for argument "value"');
        for (k = 0; k < b - h; ++k)
          this[k + h] = x[k % O];
      }
      return this;
    };
    const Z = {};
    function ie(l, h, b) {
      Z[l] = class extends b {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
        }
        get code() {
          return l;
        }
        set code(M) {
          Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: M, writable: !0 });
        }
        toString() {
          return `${this.name} [${l}]: ${this.message}`;
        }
      };
    }
    function oe(l) {
      let h = "", b = l.length;
      const M = l[0] === "-" ? 1 : 0;
      for (; b >= M + 4; b -= 3)
        h = `_${l.slice(b - 3, b)}${h}`;
      return `${l.slice(0, b)}${h}`;
    }
    function ue(l, h, b, M, k, x) {
      if (l > b || l < h) {
        const O = typeof h == "bigint" ? "n" : "";
        let G;
        throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${b}${O}`, new Z.ERR_OUT_OF_RANGE("value", G, l);
      }
      (function(O, G, Q) {
        se(G, "offset"), O[G] !== void 0 && O[G + Q] !== void 0 || ce(G, O.length - (Q + 1));
      })(M, k, x);
    }
    function se(l, h) {
      if (typeof l != "number")
        throw new Z.ERR_INVALID_ARG_TYPE(h, "number", l);
    }
    function ce(l, h, b) {
      throw Math.floor(l) !== l ? (se(l, b), new Z.ERR_OUT_OF_RANGE(b || "offset", "an integer", l)) : h < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(b || "offset", `>= ${b ? 1 : 0} and <= ${h}`, l);
    }
    ie("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
      return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(l, h) {
      return `The "${l}" argument must be of type number. Received type ${typeof h}`;
    }, TypeError), ie("ERR_OUT_OF_RANGE", function(l, h, b) {
      let M = `The value of "${l}" is out of range.`, k = b;
      return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? k = oe(String(b)) : typeof b == "bigint" && (k = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (k = oe(k)), k += "n"), M += ` It must be ${h}. Received ${k}`, M;
    }, RangeError);
    const Se = /[^+/0-9A-Za-z-_]/g;
    function he(l, h) {
      let b;
      h = h || 1 / 0;
      const M = l.length;
      let k = null;
      const x = [];
      for (let O = 0; O < M; ++O) {
        if (b = l.charCodeAt(O), b > 55295 && b < 57344) {
          if (!k) {
            if (b > 56319) {
              (h -= 3) > -1 && x.push(239, 191, 189);
              continue;
            }
            if (O + 1 === M) {
              (h -= 3) > -1 && x.push(239, 191, 189);
              continue;
            }
            k = b;
            continue;
          }
          if (b < 56320) {
            (h -= 3) > -1 && x.push(239, 191, 189), k = b;
            continue;
          }
          b = 65536 + (k - 55296 << 10 | b - 56320);
        } else
          k && (h -= 3) > -1 && x.push(239, 191, 189);
        if (k = null, b < 128) {
          if ((h -= 1) < 0)
            break;
          x.push(b);
        } else if (b < 2048) {
          if ((h -= 2) < 0)
            break;
          x.push(b >> 6 | 192, 63 & b | 128);
        } else if (b < 65536) {
          if ((h -= 3) < 0)
            break;
          x.push(b >> 12 | 224, b >> 6 & 63 | 128, 63 & b | 128);
        } else {
          if (!(b < 1114112))
            throw new Error("Invalid code point");
          if ((h -= 4) < 0)
            break;
          x.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, 63 & b | 128);
        }
      }
      return x;
    }
    function $e(l) {
      return n.toByteArray(function(h) {
        if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
          return "";
        for (; h.length % 4 != 0; )
          h += "=";
        return h;
      }(l));
    }
    function fe(l, h, b, M) {
      let k;
      for (k = 0; k < M && !(k + b >= h.length || k >= l.length); ++k)
        h[k + b] = l[k];
      return k;
    }
    function le(l, h) {
      return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
    }
    function we(l) {
      return l != l;
    }
    const We = function() {
      const l = "0123456789abcdef", h = new Array(256);
      for (let b = 0; b < 16; ++b) {
        const M = 16 * b;
        for (let k = 0; k < 16; ++k)
          h[M + k] = l[b] + l[k];
      }
      return h;
    }();
    function de(l) {
      return typeof BigInt > "u" ? ke : l;
    }
    function ke() {
      throw new Error("BigInt not supported");
    }
  }(buffer$1)), buffer$1;
}
var abstractSublevelIterator = {}, hasRequiredAbstractSublevelIterator, abstractSublevel, hasRequiredAbstractSublevel;
function requireAbstractSublevelIterator() {
  if (hasRequiredAbstractSublevelIterator)
    return abstractSublevelIterator;
  hasRequiredAbstractSublevelIterator = 1;
  const { AbstractIterator: o, AbstractKeyIterator: n, AbstractValueIterator: a } = abstractIterator, u = Symbol("unfix"), c = Symbol("iterator"), m = Symbol("handleOne"), d = Symbol("handleMany"), w = Symbol("callback");
  class S extends o {
    constructor(C, N, q, D) {
      super(C, N), this[c] = q, this[u] = D, this[m] = this[m].bind(this), this[d] = this[d].bind(this), this[w] = null;
    }
    [m](C, N, q) {
      const D = this[w];
      if (C)
        return D(C);
      N !== void 0 && (N = this[u](N)), D(C, N, q);
    }
    [d](C, N) {
      const q = this[w];
      if (C)
        return q(C);
      for (const D of N) {
        const z = D[0];
        z !== void 0 && (D[0] = this[u](z));
      }
      q(C, N);
    }
  }
  class T extends n {
    constructor(C, N, q, D) {
      super(C, N), this[c] = q, this[u] = D, this[m] = this[m].bind(this), this[d] = this[d].bind(this), this[w] = null;
    }
    [m](C, N) {
      const q = this[w];
      if (C)
        return q(C);
      N !== void 0 && (N = this[u](N)), q(C, N);
    }
    [d](C, N) {
      const q = this[w];
      if (C)
        return q(C);
      for (let D = 0; D < N.length; D++) {
        const z = N[D];
        z !== void 0 && (N[D] = this[u](z));
      }
      q(C, N);
    }
  }
  class B extends a {
    constructor(C, N, q) {
      super(C, N), this[c] = q;
    }
  }
  for (const I of [S, T])
    I.prototype._next = function(C) {
      this[w] = C, this[c].next(this[m]);
    }, I.prototype._nextv = function(C, N, q) {
      this[w] = q, this[c].nextv(C, N, this[d]);
    }, I.prototype._all = function(C, N) {
      this[w] = N, this[c].all(C, this[d]);
    };
  for (const I of [B])
    I.prototype._next = function(C) {
      this[c].next(C);
    }, I.prototype._nextv = function(C, N, q) {
      this[c].nextv(C, N, q);
    }, I.prototype._all = function(C, N) {
      this[c].all(C, N);
    };
  for (const I of [S, T, B])
    I.prototype._seek = function(C, N) {
      this[c].seek(C, N);
    }, I.prototype._close = function(C) {
      this[c].close(C);
    };
  return abstractSublevelIterator.AbstractSublevelIterator = S, abstractSublevelIterator.AbstractSublevelKeyIterator = T, abstractSublevelIterator.AbstractSublevelValueIterator = B, abstractSublevelIterator;
}
function requireAbstractSublevel() {
  if (hasRequiredAbstractSublevel)
    return abstractSublevel;
  hasRequiredAbstractSublevel = 1;
  const o = moduleError, { Buffer: n } = requireBuffer() || {}, { AbstractSublevelIterator: a, AbstractSublevelKeyIterator: u, AbstractSublevelValueIterator: c } = requireAbstractSublevelIterator(), m = Symbol("prefix"), d = Symbol("upperBound"), w = Symbol("prefixRange"), S = Symbol("parent"), T = Symbol("unfix"), B = new TextEncoder(), I = { separator: "!" };
  abstractSublevel = function({ AbstractLevel: W }) {
    class V extends W {
      static defaults(P) {
        if (typeof P == "string")
          throw new o("The subleveldown string shorthand for { separator } has been removed", { code: "LEVEL_LEGACY" });
        if (P && P.open)
          throw new o("The subleveldown open option has been removed", { code: "LEVEL_LEGACY" });
        return P == null ? I : P.separator ? P : { ...P, separator: "!" };
      }
      constructor(P, F, H) {
        const { separator: te, manifest: p, ...$ } = V.defaults(H);
        F = z(F, te);
        const _ = te.charCodeAt(0) + 1, y = P[S] || P;
        if (!B.encode(F).every((E) => E > _ && E < 127))
          throw new o(`Prefix must use bytes > ${_} < 127`, { code: "LEVEL_INVALID_PREFIX" });
        super(C(y, p), $);
        const g = (P.prefix || "") + te + F + te, v = g.slice(0, -1) + String.fromCharCode(_);
        this[S] = y, this[m] = new q(g), this[d] = new q(v), this[T] = new D(), this.nextTick = y.nextTick;
      }
      prefixKey(P, F) {
        if (F === "utf8")
          return this[m].utf8 + P;
        if (P.byteLength === 0)
          return this[m][F];
        if (F === "view") {
          const H = this[m].view, te = new Uint8Array(H.byteLength + P.byteLength);
          return te.set(H, 0), te.set(P, H.byteLength), te;
        }
        {
          const H = this[m].buffer;
          return n.concat([H, P], H.byteLength + P.byteLength);
        }
      }
      [w](P, F) {
        P.gte !== void 0 ? P.gte = this.prefixKey(P.gte, F) : P.gt !== void 0 ? P.gt = this.prefixKey(P.gt, F) : P.gte = this[m][F], P.lte !== void 0 ? P.lte = this.prefixKey(P.lte, F) : P.lt !== void 0 ? P.lt = this.prefixKey(P.lt, F) : P.lte = this[d][F];
      }
      get prefix() {
        return this[m].utf8;
      }
      get db() {
        return this[S];
      }
      _open(P, F) {
        this[S].open({ passive: !0 }, F);
      }
      _put(P, F, H, te) {
        this[S].put(P, F, H, te);
      }
      _get(P, F, H) {
        this[S].get(P, F, H);
      }
      _getMany(P, F, H) {
        this[S].getMany(P, F, H);
      }
      _del(P, F, H) {
        this[S].del(P, F, H);
      }
      _batch(P, F, H) {
        this[S].batch(P, F, H);
      }
      _clear(P, F) {
        this[w](P, P.keyEncoding), this[S].clear(P, F);
      }
      _iterator(P) {
        this[w](P, P.keyEncoding);
        const F = this[S].iterator(P), H = this[T].get(this[m].utf8.length, P.keyEncoding);
        return new a(this, P, F, H);
      }
      _keys(P) {
        this[w](P, P.keyEncoding);
        const F = this[S].keys(P), H = this[T].get(this[m].utf8.length, P.keyEncoding);
        return new u(this, P, F, H);
      }
      _values(P) {
        this[w](P, P.keyEncoding);
        const F = this[S].values(P);
        return new c(this, P, F);
      }
    }
    return { AbstractSublevel: V };
  };
  const C = function(W, V) {
    return { ...W.supports, createIfMissing: !1, errorIfExists: !1, events: {}, additionalMethods: {}, ...V, encodings: { utf8: N(W, "utf8"), buffer: N(W, "buffer"), view: N(W, "view") } };
  }, N = function(W, V) {
    return !!W.supports.encodings[V] && W.keyEncoding(V).name === V;
  };
  class q {
    constructor(V) {
      this.utf8 = V, this.view = B.encode(V), this.buffer = n ? n.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }
  class D {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(V, ee) {
      let P = this.cache.get(ee);
      return P === void 0 && (P = ee === "view" ? function(F, H) {
        return H.subarray(F);
      }.bind(null, V) : function(F, H) {
        return H.slice(F);
      }.bind(null, V), this.cache.set(ee, P)), P;
    }
  }
  const z = function(W, V) {
    let ee = 0, P = W.length;
    for (; ee < P && W[ee] === V; )
      ee++;
    for (; P > ee && W[P - 1] === V; )
      P--;
    return W.slice(ee, P);
  };
  return abstractSublevel;
}
const { supports } = levelSupports, { Transcoder } = levelTranscoder, { EventEmitter } = events.exports, { fromCallback: fromCallback$1 } = catering, ModuleError$2 = moduleError, { AbstractIterator: AbstractIterator$2 } = abstractIterator, { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator, { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator, { DefaultChainedBatch } = defaultChainedBatch, { getCallback, getOptions } = common$6, rangeOptions$1 = rangeOptions_1, kPromise$1 = Symbol("promise"), kLanded = Symbol("landed"), kResources = Symbol("resources"), kCloseResources = Symbol("closeResources"), kOperations = Symbol("operations"), kUndefer = Symbol("undefer"), kDeferOpen = Symbol("deferOpen"), kOptions$2 = Symbol("options"), kStatus = Symbol("status"), kDefaultOptions = Symbol("defaultOptions"), kTranscoder = Symbol("transcoder"), kKeyEncoding = Symbol("keyEncoding"), kValueEncoding = Symbol("valueEncoding"), noop = () => {
};
class AbstractLevel$2 extends EventEmitter {
  constructor(n, a) {
    if (super(), typeof n != "object" || n === null)
      throw new TypeError("The first argument 'manifest' must be an object");
    a = getOptions(a);
    const { keyEncoding: u, valueEncoding: c, passive: m, ...d } = a;
    this[kResources] = /* @__PURE__ */ new Set(), this[kOperations] = [], this[kDeferOpen] = !0, this[kOptions$2] = d, this[kStatus] = "opening", this.supports = supports(n, { status: !0, promises: !0, clear: !0, getMany: !0, deferredOpen: !0, snapshots: n.snapshots !== !1, permanence: n.permanence !== !1, keyIterator: !0, valueIterator: !0, iteratorNextv: !0, iteratorAll: !0, encodings: n.encodings || {}, events: Object.assign({}, n.events, { opening: !0, open: !0, closing: !0, closed: !0, put: !0, del: !0, batch: !0, clear: !0 }) }), this[kTranscoder] = new Transcoder(formats(this)), this[kKeyEncoding] = this[kTranscoder].encoding(u || "utf8"), this[kValueEncoding] = this[kTranscoder].encoding(c || "utf8");
    for (const w of this[kTranscoder].encodings())
      this.supports.encodings[w.commonName] || (this.supports.encodings[w.commonName] = !0);
    this[kDefaultOptions] = { empty: Object.freeze({}), entry: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName, valueEncoding: this[kValueEncoding].commonName }), key: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName }) }, this.nextTick(() => {
      this[kDeferOpen] && this.open({ passive: !1 }, noop);
    });
  }
  get status() {
    return this[kStatus];
  }
  keyEncoding(n) {
    return this[kTranscoder].encoding(n != null ? n : this[kKeyEncoding]);
  }
  valueEncoding(n) {
    return this[kTranscoder].encoding(n != null ? n : this[kValueEncoding]);
  }
  open(n, a) {
    a = getCallback(n, a), a = fromCallback$1(a, kPromise$1), (n = { ...this[kOptions$2], ...getOptions(n) }).createIfMissing = n.createIfMissing !== !1, n.errorIfExists = !!n.errorIfExists;
    const u = (c) => {
      this[kStatus] === "closing" || this[kStatus] === "opening" ? this.once(kLanded, c ? () => u(c) : u) : this[kStatus] !== "open" ? a(new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN", cause: c })) : a();
    };
    return n.passive ? this[kStatus] === "opening" ? this.once(kLanded, u) : this.nextTick(u) : this[kStatus] === "closed" || this[kDeferOpen] ? (this[kDeferOpen] = !1, this[kStatus] = "opening", this.emit("opening"), this._open(n, (c) => {
      if (c)
        return this[kStatus] = "closed", this[kCloseResources](() => {
          this.emit(kLanded), u(c);
        }), void this[kUndefer]();
      this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), this[kStatus] === "open" && this.emit("open"), this[kStatus] === "open" && this.emit("ready"), u();
    })) : this[kStatus] === "open" ? this.nextTick(u) : this.once(kLanded, () => this.open(n, a)), a[kPromise$1];
  }
  _open(n, a) {
    this.nextTick(a);
  }
  close(n) {
    n = fromCallback$1(n, kPromise$1);
    const a = (u) => {
      this[kStatus] === "opening" || this[kStatus] === "closing" ? this.once(kLanded, u ? a(u) : a) : this[kStatus] !== "closed" ? n(new ModuleError$2("Database is not closed", { code: "LEVEL_DATABASE_NOT_CLOSED", cause: u })) : n();
    };
    if (this[kStatus] === "open") {
      this[kStatus] = "closing", this.emit("closing");
      const u = (c) => {
        this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), a(c);
      };
      this[kCloseResources](() => {
        this._close((c) => {
          if (c)
            return u(c);
          this[kStatus] = "closed", this[kUndefer](), this.emit(kLanded), this[kStatus] === "closed" && this.emit("closed"), a();
        });
      });
    } else
      this[kStatus] === "closed" ? this.nextTick(a) : this.once(kLanded, () => this.close(n));
    return n[kPromise$1];
  }
  [kCloseResources](n) {
    if (this[kResources].size === 0)
      return this.nextTick(n);
    let a = this[kResources].size, u = !0;
    const c = () => {
      --a == 0 && (u ? this.nextTick(n) : n());
    };
    for (const m of this[kResources])
      m.close(c);
    u = !1, this[kResources].clear();
  }
  _close(n) {
    this.nextTick(n);
  }
  get(n, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.get(n, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const c = this._checkKey(n);
    if (c)
      return this.nextTick(u, c), u[kPromise$1];
    const m = this.keyEncoding(a.keyEncoding), d = this.valueEncoding(a.valueEncoding), w = m.format, S = d.format;
    return a.keyEncoding === w && a.valueEncoding === S || (a = Object.assign({}, a, { keyEncoding: w, valueEncoding: S })), this._get(this.prefixKey(m.encode(n), w), a, (T, B) => {
      if (T)
        return (T.code === "LEVEL_NOT_FOUND" || T.notFound || /NotFound/i.test(T)) && (T.code || (T.code = "LEVEL_NOT_FOUND"), T.notFound || (T.notFound = !0), T.status || (T.status = 404)), u(T);
      try {
        B = d.decode(B);
      } catch (I) {
        return u(new ModuleError$2("Could not decode value", { code: "LEVEL_DECODE_ERROR", cause: I }));
      }
      u(null, B);
    }), u[kPromise$1];
  }
  _get(n, a, u) {
    this.nextTick(u, new Error("NotFound"));
  }
  getMany(n, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.getMany(n, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(n))
      return this.nextTick(u, new TypeError("The first argument 'keys' must be an array")), u[kPromise$1];
    if (n.length === 0)
      return this.nextTick(u, null, []), u[kPromise$1];
    const c = this.keyEncoding(a.keyEncoding), m = this.valueEncoding(a.valueEncoding), d = c.format, w = m.format;
    a.keyEncoding === d && a.valueEncoding === w || (a = Object.assign({}, a, { keyEncoding: d, valueEncoding: w }));
    const S = new Array(n.length);
    for (let T = 0; T < n.length; T++) {
      const B = n[T], I = this._checkKey(B);
      if (I)
        return this.nextTick(u, I), u[kPromise$1];
      S[T] = this.prefixKey(c.encode(B), d);
    }
    return this._getMany(S, a, (T, B) => {
      if (T)
        return u(T);
      try {
        for (let I = 0; I < B.length; I++)
          B[I] !== void 0 && (B[I] = m.decode(B[I]));
      } catch (I) {
        return u(new ModuleError$2(`Could not decode one or more of ${B.length} value(s)`, { code: "LEVEL_DECODE_ERROR", cause: I }));
      }
      u(null, B);
    }), u[kPromise$1];
  }
  _getMany(n, a, u) {
    this.nextTick(u, null, new Array(n.length).fill(void 0));
  }
  put(n, a, u, c) {
    if (c = getCallback(u, c), c = fromCallback$1(c, kPromise$1), u = getOptions(u, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.put(n, a, u, c)), c[kPromise$1];
    if (maybeError(this, c))
      return c[kPromise$1];
    const m = this._checkKey(n) || this._checkValue(a);
    if (m)
      return this.nextTick(c, m), c[kPromise$1];
    const d = this.keyEncoding(u.keyEncoding), w = this.valueEncoding(u.valueEncoding), S = d.format, T = w.format;
    u.keyEncoding === S && u.valueEncoding === T || (u = Object.assign({}, u, { keyEncoding: S, valueEncoding: T }));
    const B = this.prefixKey(d.encode(n), S), I = w.encode(a);
    return this._put(B, I, u, (C) => {
      if (C)
        return c(C);
      this.emit("put", n, a), c();
    }), c[kPromise$1];
  }
  _put(n, a, u, c) {
    this.nextTick(c);
  }
  del(n, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].key), this[kStatus] === "opening")
      return this.defer(() => this.del(n, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const c = this._checkKey(n);
    if (c)
      return this.nextTick(u, c), u[kPromise$1];
    const m = this.keyEncoding(a.keyEncoding), d = m.format;
    return a.keyEncoding !== d && (a = Object.assign({}, a, { keyEncoding: d })), this._del(this.prefixKey(m.encode(n), d), a, (w) => {
      if (w)
        return u(w);
      this.emit("del", n), u();
    }), u[kPromise$1];
  }
  _del(n, a, u) {
    this.nextTick(u);
  }
  batch(n, a, u) {
    if (!arguments.length) {
      if (this[kStatus] === "opening")
        return new DefaultChainedBatch(this);
      if (this[kStatus] !== "open")
        throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
      return this._chainedBatch();
    }
    if (u = typeof n == "function" ? n : getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.batch(n, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(n))
      return this.nextTick(u, new TypeError("The first argument 'operations' must be an array")), u[kPromise$1];
    if (n.length === 0)
      return this.nextTick(u), u[kPromise$1];
    const c = new Array(n.length), { keyEncoding: m, valueEncoding: d, ...w } = a;
    for (let S = 0; S < n.length; S++) {
      if (typeof n[S] != "object" || n[S] === null)
        return this.nextTick(u, new TypeError("A batch operation must be an object")), u[kPromise$1];
      const T = Object.assign({}, n[S]);
      if (T.type !== "put" && T.type !== "del")
        return this.nextTick(u, new TypeError("A batch operation must have a type property that is 'put' or 'del'")), u[kPromise$1];
      const B = this._checkKey(T.key);
      if (B)
        return this.nextTick(u, B), u[kPromise$1];
      const I = T.sublevel != null ? T.sublevel : this, C = I.keyEncoding(T.keyEncoding || m), N = C.format;
      if (T.key = I.prefixKey(C.encode(T.key), N), T.keyEncoding = N, T.type === "put") {
        const q = this._checkValue(T.value);
        if (q)
          return this.nextTick(u, q), u[kPromise$1];
        const D = I.valueEncoding(T.valueEncoding || d);
        T.value = D.encode(T.value), T.valueEncoding = D.format;
      }
      I !== this && (T.sublevel = null), c[S] = T;
    }
    return this._batch(c, w, (S) => {
      if (S)
        return u(S);
      this.emit("batch", n), u();
    }), u[kPromise$1];
  }
  _batch(n, a, u) {
    this.nextTick(u);
  }
  sublevel(n, a) {
    return this._sublevel(n, AbstractSublevel.defaults(a));
  }
  _sublevel(n, a) {
    return new AbstractSublevel(this, n, a);
  }
  prefixKey(n, a) {
    return n;
  }
  clear(n, a) {
    if (a = getCallback(n, a), a = fromCallback$1(a, kPromise$1), n = getOptions(n, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.clear(n, a)), a[kPromise$1];
    if (maybeError(this, a))
      return a[kPromise$1];
    const u = n, c = this.keyEncoding(n.keyEncoding);
    return (n = rangeOptions$1(n, c)).keyEncoding = c.format, n.limit === 0 ? this.nextTick(a) : this._clear(n, (m) => {
      if (m)
        return a(m);
      this.emit("clear", u), a();
    }), a[kPromise$1];
  }
  _clear(n, a) {
    this.nextTick(a);
  }
  iterator(n) {
    const a = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, a)).keys = n.keys !== !1, n.values = n.values !== !1, n[AbstractIterator$2.keyEncoding] = a, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = a.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._iterator(n);
  }
  _iterator(n) {
    return new AbstractIterator$2(this, n);
  }
  keys(n) {
    const a = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, a))[AbstractIterator$2.keyEncoding] = a, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = a.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredKeyIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._keys(n);
  }
  _keys(n) {
    return new DefaultKeyIterator(this, n);
  }
  values(n) {
    const a = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, a))[AbstractIterator$2.keyEncoding] = a, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = a.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredValueIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._values(n);
  }
  _values(n) {
    return new DefaultValueIterator(this, n);
  }
  defer(n) {
    if (typeof n != "function")
      throw new TypeError("The first argument must be a function");
    this[kOperations].push(n);
  }
  [kUndefer]() {
    if (this[kOperations].length === 0)
      return;
    const n = this[kOperations];
    this[kOperations] = [];
    for (const a of n)
      a();
  }
  attachResource(n) {
    if (typeof n != "object" || n === null || typeof n.close != "function")
      throw new TypeError("The first argument must be a resource object");
    this[kResources].add(n);
  }
  detachResource(n) {
    this[kResources].delete(n);
  }
  _chainedBatch() {
    return new DefaultChainedBatch(this);
  }
  _checkKey(n) {
    if (n == null)
      return new ModuleError$2("Key cannot be null or undefined", { code: "LEVEL_INVALID_KEY" });
  }
  _checkValue(n) {
    if (n == null)
      return new ModuleError$2("Value cannot be null or undefined", { code: "LEVEL_INVALID_VALUE" });
  }
}
AbstractLevel$2.prototype.nextTick = requireNextTickBrowser();
const { AbstractSublevel } = requireAbstractSublevel()({ AbstractLevel: AbstractLevel$2 });
abstractLevel.AbstractLevel = AbstractLevel$2, abstractLevel.AbstractSublevel = AbstractSublevel;
const maybeError = function(o, n) {
  return o[kStatus] !== "open" && (o.nextTick(n, new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" })), !0);
}, formats = function(o) {
  return Object.keys(o.supports.encodings).filter((n) => !!o.supports.encodings[n]);
};
abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel, abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel, abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator, abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator, abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator, abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var runParallelLimit_1 = runParallelLimit;
const queueMicrotask$1 = queueMicrotask_1;
function runParallelLimit(o, n, a) {
  if (typeof n != "number")
    throw new Error("second argument must be a Number");
  let u, c, m, d, w, S, T = !0;
  function B(C) {
    function N() {
      a && a(C, u), a = null;
    }
    T ? queueMicrotask$1(N) : N();
  }
  function I(C, N, q) {
    if (u[C] = q, N && (w = !0), --m == 0 || N)
      B(N);
    else if (!w && S < c) {
      let D;
      d ? (D = d[S], S += 1, o[D](function(z, W) {
        I(D, z, W);
      })) : (D = S, S += 1, o[D](function(z, W) {
        I(D, z, W);
      }));
    }
  }
  Array.isArray(o) ? (u = [], m = c = o.length) : (d = Object.keys(o), u = {}, m = c = d.length), S = n, m ? d ? d.some(function(C, N) {
    return o[C](function(q, D) {
      I(C, q, D);
    }), N === n - 1;
  }) : o.some(function(C, N) {
    return C(function(q, D) {
      I(N, q, D);
    }), N === n - 1;
  }) : B(null), T = !1;
}
var iterator$1 = {}, keyRange = function(o) {
  const n = o.gte !== void 0 ? o.gte : o.gt !== void 0 ? o.gt : void 0, a = o.lte !== void 0 ? o.lte : o.lt !== void 0 ? o.lt : void 0, u = o.gte === void 0, c = o.lte === void 0;
  return n !== void 0 && a !== void 0 ? IDBKeyRange.bound(n, a, u, c) : n !== void 0 ? IDBKeyRange.lowerBound(n, u) : a !== void 0 ? IDBKeyRange.upperBound(a, c) : null;
};
const textEncoder = new TextEncoder();
var deserialize$2 = function(o) {
  return o instanceof Uint8Array ? o : o instanceof ArrayBuffer ? new Uint8Array(o) : textEncoder.encode(o);
};
const { AbstractIterator: AbstractIterator$1 } = abstractLevel$1, createKeyRange$1 = keyRange, deserialize$1 = deserialize$2, kCache = Symbol("cache"), kFinished = Symbol("finished"), kOptions$1 = Symbol("options"), kCurrentOptions = Symbol("currentOptions"), kPosition = Symbol("position"), kLocation$1 = Symbol("location"), kFirst = Symbol("first"), emptyOptions = {};
class Iterator$1 extends AbstractIterator$1 {
  constructor(n, a, u) {
    super(n, u), this[kCache] = [], this[kFinished] = this.limit === 0, this[kOptions$1] = u, this[kCurrentOptions] = { ...u }, this[kPosition] = void 0, this[kLocation$1] = a, this[kFirst] = !0;
  }
  _nextv(n, a, u) {
    if (this[kFirst] = !1, this[kFinished])
      return this.nextTick(u, null, []);
    if (this[kCache].length > 0)
      return n = Math.min(n, this[kCache].length), this.nextTick(u, null, this[kCache].splice(0, n));
    let c;
    this[kPosition] !== void 0 && (this[kOptions$1].reverse ? (this[kCurrentOptions].lt = this[kPosition], this[kCurrentOptions].lte = void 0) : (this[kCurrentOptions].gt = this[kPosition], this[kCurrentOptions].gte = void 0));
    try {
      c = createKeyRange$1(this[kCurrentOptions]);
    } catch {
      return this[kFinished] = !0, this.nextTick(u, null, []);
    }
    const m = this.db.db.transaction([this[kLocation$1]], "readonly"), d = m.objectStore(this[kLocation$1]), w = [];
    if (this[kOptions$1].reverse)
      d[!this[kOptions$1].values && d.openKeyCursor ? "openKeyCursor" : "openCursor"](c, "prev").onsuccess = (S) => {
        const T = S.target.result;
        if (T) {
          const { key: B, value: I } = T;
          this[kPosition] = B, w.push([this[kOptions$1].keys && B !== void 0 ? deserialize$1(B) : void 0, this[kOptions$1].values && I !== void 0 ? deserialize$1(I) : void 0]), w.length < n ? T.continue() : maybeCommit(m);
        } else
          this[kFinished] = !0;
      };
    else {
      let S, T;
      const B = () => {
        if (S === void 0 || T === void 0)
          return;
        const I = Math.max(S.length, T.length);
        I === 0 || n === 1 / 0 ? this[kFinished] = !0 : this[kPosition] = S[I - 1], w.length = I;
        for (let C = 0; C < I; C++) {
          const N = S[C], q = T[C];
          w[C] = [this[kOptions$1].keys && N !== void 0 ? deserialize$1(N) : void 0, this[kOptions$1].values && q !== void 0 ? deserialize$1(q) : void 0];
        }
        maybeCommit(m);
      };
      this[kOptions$1].keys || n < 1 / 0 ? d.getAllKeys(c, n < 1 / 0 ? n : void 0).onsuccess = (I) => {
        S = I.target.result, B();
      } : (S = [], this.nextTick(B)), this[kOptions$1].values ? d.getAll(c, n < 1 / 0 ? n : void 0).onsuccess = (I) => {
        T = I.target.result, B();
      } : (T = [], this.nextTick(B));
    }
    m.onabort = () => {
      u(m.error || new Error("aborted by user")), u = null;
    }, m.oncomplete = () => {
      u(null, w), u = null;
    };
  }
  _next(n) {
    if (this[kCache].length > 0) {
      const [a, u] = this[kCache].shift();
      this.nextTick(n, null, a, u);
    } else if (this[kFinished])
      this.nextTick(n);
    else {
      let a = Math.min(100, this.limit - this.count);
      this[kFirst] && (this[kFirst] = !1, a = 1), this._nextv(a, emptyOptions, (u, c) => {
        if (u)
          return n(u);
        this[kCache] = c, this._next(n);
      });
    }
  }
  _all(n, a) {
    this[kFirst] = !1;
    const u = this[kCache].splice(0, this[kCache].length), c = this.limit - this.count - u.length;
    if (c <= 0)
      return this.nextTick(a, null, u);
    this._nextv(c, emptyOptions, (m, d) => {
      if (m)
        return a(m);
      u.length > 0 && (d = u.concat(d)), a(null, d);
    });
  }
  _seek(n, a) {
    let u;
    this[kFirst] = !0, this[kCache] = [], this[kFinished] = !1, this[kPosition] = void 0, this[kCurrentOptions] = { ...this[kOptions$1] };
    try {
      u = createKeyRange$1(this[kOptions$1]);
    } catch {
      return void (this[kFinished] = !0);
    }
    u === null || u.includes(n) ? this[kOptions$1].reverse ? this[kCurrentOptions].lte = n : this[kCurrentOptions].gte = n : this[kFinished] = !0;
  }
}
function maybeCommit(o) {
  typeof o.commit == "function" && o.commit();
}
iterator$1.Iterator = Iterator$1;
var clear$1 = function(o, n, a, u, c) {
  if (u.limit === 0)
    return o.nextTick(c);
  const m = o.db.transaction([n], "readwrite"), d = m.objectStore(n);
  let w = 0;
  m.oncomplete = function() {
    c();
  }, m.onabort = function() {
    c(m.error || new Error("aborted by user"));
  };
  const S = d.openKeyCursor ? "openKeyCursor" : "openCursor", T = u.reverse ? "prev" : "next";
  d[S](a, T).onsuccess = function(B) {
    const I = B.target.result;
    I && (d.delete(I.key).onsuccess = function() {
      (u.limit <= 0 || ++w < u.limit) && I.continue();
    });
  };
};
const { AbstractLevel: AbstractLevel$1 } = abstractLevel$1, ModuleError$1 = moduleError, parallel = runParallelLimit_1, { fromCallback } = catering, { Iterator } = iterator$1, deserialize = deserialize$2, clear = clear$1, createKeyRange = keyRange, DEFAULT_PREFIX = "level-js-", kIDB = Symbol("idb"), kNamePrefix = Symbol("namePrefix"), kLocation = Symbol("location"), kVersion = Symbol("version"), kStore = Symbol("store"), kOnComplete = Symbol("onComplete"), kPromise = Symbol("promise");
class BrowserLevel extends AbstractLevel$1 {
  constructor(n, a, u) {
    if (typeof a == "function" || typeof u == "function")
      throw new ModuleError$1("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    const { prefix: c, version: m, ...d } = a || {};
    if (super({ encodings: { view: !0 }, snapshots: !1, createIfMissing: !1, errorIfExists: !1, seek: !0 }, d), typeof n != "string")
      throw new Error("constructor requires a location string argument");
    this[kLocation] = n, this[kNamePrefix] = c == null ? DEFAULT_PREFIX : c, this[kVersion] = parseInt(m || 1, 10), this[kIDB] = null;
  }
  get location() {
    return this[kLocation];
  }
  get namePrefix() {
    return this[kNamePrefix];
  }
  get version() {
    return this[kVersion];
  }
  get db() {
    return this[kIDB];
  }
  get type() {
    return "browser-level";
  }
  _open(n, a) {
    const u = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
    u.onerror = function() {
      a(u.error || new Error("unknown error"));
    }, u.onsuccess = () => {
      this[kIDB] = u.result, a();
    }, u.onupgradeneeded = (c) => {
      const m = c.target.result;
      m.objectStoreNames.contains(this[kLocation]) || m.createObjectStore(this[kLocation]);
    };
  }
  [kStore](n) {
    return this[kIDB].transaction([this[kLocation]], n).objectStore(this[kLocation]);
  }
  [kOnComplete](n, a) {
    const u = n.transaction;
    u.onabort = function() {
      a(u.error || new Error("aborted by user"));
    }, u.oncomplete = function() {
      a(null, n.result);
    };
  }
  _get(n, a, u) {
    const c = this[kStore]("readonly");
    let m;
    try {
      m = c.get(n);
    } catch (d) {
      return this.nextTick(u, d);
    }
    this[kOnComplete](m, function(d, w) {
      return d ? u(d) : w === void 0 ? u(new ModuleError$1("Entry not found", { code: "LEVEL_NOT_FOUND" })) : void u(null, deserialize(w));
    });
  }
  _getMany(n, a, u) {
    const c = this[kStore]("readonly"), m = n.map((d) => (w) => {
      let S;
      try {
        S = c.get(d);
      } catch (T) {
        return w(T);
      }
      S.onsuccess = () => {
        const T = S.result;
        w(null, T === void 0 ? T : deserialize(T));
      }, S.onerror = (T) => {
        T.stopPropagation(), w(S.error);
      };
    });
    parallel(m, 16, u);
  }
  _del(n, a, u) {
    const c = this[kStore]("readwrite");
    let m;
    try {
      m = c.delete(n);
    } catch (d) {
      return this.nextTick(u, d);
    }
    this[kOnComplete](m, u);
  }
  _put(n, a, u, c) {
    const m = this[kStore]("readwrite");
    let d;
    try {
      d = m.put(a, n);
    } catch (w) {
      return this.nextTick(c, w);
    }
    this[kOnComplete](d, c);
  }
  _iterator(n) {
    return new Iterator(this, this[kLocation], n);
  }
  _batch(n, a, u) {
    const c = this[kStore]("readwrite"), m = c.transaction;
    let d, w = 0;
    m.onabort = function() {
      u(d || m.error || new Error("aborted by user"));
    }, m.oncomplete = function() {
      u();
    }, function S() {
      const T = n[w++], B = T.key;
      let I;
      try {
        I = T.type === "del" ? c.delete(B) : c.put(T.value, B);
      } catch (C) {
        return d = C, void m.abort();
      }
      w < n.length ? I.onsuccess = S : typeof m.commit == "function" && m.commit();
    }();
  }
  _clear(n, a) {
    let u, c;
    try {
      u = createKeyRange(n);
    } catch {
      return this.nextTick(a);
    }
    if (n.limit >= 0)
      return clear(this, this[kLocation], u, n, a);
    try {
      const m = this[kStore]("readwrite");
      c = u ? m.delete(u) : m.clear();
    } catch (m) {
      return this.nextTick(a, m);
    }
    this[kOnComplete](c, a);
  }
  _close(n) {
    this[kIDB].close(), this.nextTick(n);
  }
}
BrowserLevel.destroy = function(o, n, a) {
  typeof n == "function" && (a = n, n = DEFAULT_PREFIX), a = fromCallback(a, kPromise);
  const u = indexedDB.deleteDatabase(n + o);
  return u.onsuccess = function() {
    a();
  }, u.onerror = function(c) {
    a(c);
  }, a[kPromise];
}, browserLevel.BrowserLevel = BrowserLevel, browser.Level = browserLevel.BrowserLevel;
var memoryLevel = {}, rbtree = createRBTree, RED = 0, BLACK = 1;
function RBNode(o, n, a, u, c, m) {
  this._color = o, this.key = n, this.value = a, this.left = u, this.right = c, this._count = m;
}
function cloneNode(o) {
  return new RBNode(o._color, o.key, o.value, o.left, o.right, o._count);
}
function repaint(o, n) {
  return new RBNode(o, n.key, n.value, n.left, n.right, n._count);
}
function recount(o) {
  o._count = 1 + (o.left ? o.left._count : 0) + (o.right ? o.right._count : 0);
}
function RedBlackTree(o, n) {
  this._compare = o, this.root = n;
}
var proto = RedBlackTree.prototype;
function doVisitFull(o, n) {
  var a;
  return n.left && (a = doVisitFull(o, n.left)) ? a : (a = o(n.key, n.value)) || (n.right ? doVisitFull(o, n.right) : void 0);
}
function doVisitHalf(o, n, a, u) {
  if (n(o, u.key) <= 0) {
    var c;
    if (u.left && (c = doVisitHalf(o, n, a, u.left)) || (c = a(u.key, u.value)))
      return c;
  }
  if (u.right)
    return doVisitHalf(o, n, a, u.right);
}
function doVisit(o, n, a, u, c) {
  var m, d = a(o, c.key), w = a(n, c.key);
  if (d <= 0 && (c.left && (m = doVisit(o, n, a, u, c.left)) || w > 0 && (m = u(c.key, c.value))))
    return m;
  if (w > 0 && c.right)
    return doVisit(o, n, a, u, c.right);
}
function RedBlackTreeIterator(o, n) {
  this.tree = o, this._stack = n;
}
Object.defineProperty(proto, "keys", { get: function() {
  var o = [];
  return this.forEach(function(n, a) {
    o.push(n);
  }), o;
} }), Object.defineProperty(proto, "values", { get: function() {
  var o = [];
  return this.forEach(function(n, a) {
    o.push(a);
  }), o;
} }), Object.defineProperty(proto, "length", { get: function() {
  return this.root ? this.root._count : 0;
} }), proto.insert = function(o, n) {
  for (var a = this._compare, u = this.root, c = [], m = []; u; ) {
    var d = a(o, u.key);
    c.push(u), m.push(d), u = d <= 0 ? u.left : u.right;
  }
  c.push(new RBNode(RED, o, n, null, null, 1));
  for (var w = c.length - 2; w >= 0; --w)
    u = c[w], m[w] <= 0 ? c[w] = new RBNode(u._color, u.key, u.value, c[w + 1], u.right, u._count + 1) : c[w] = new RBNode(u._color, u.key, u.value, u.left, c[w + 1], u._count + 1);
  for (w = c.length - 1; w > 1; --w) {
    var S = c[w - 1];
    if (u = c[w], S._color === BLACK || u._color === BLACK)
      break;
    var T = c[w - 2];
    if (T.left === S)
      if (S.left === u) {
        if (!(B = T.right) || B._color !== RED) {
          T._color = RED, T.left = S.right, S._color = BLACK, S.right = T, c[w - 2] = S, c[w - 1] = u, recount(T), recount(S), w >= 3 && ((I = c[w - 3]).left === T ? I.left = S : I.right = S);
          break;
        }
        S._color = BLACK, T.right = repaint(BLACK, B), T._color = RED, w -= 1;
      } else {
        if (!(B = T.right) || B._color !== RED) {
          S.right = u.left, T._color = RED, T.left = u.right, u._color = BLACK, u.left = S, u.right = T, c[w - 2] = u, c[w - 1] = S, recount(T), recount(S), recount(u), w >= 3 && ((I = c[w - 3]).left === T ? I.left = u : I.right = u);
          break;
        }
        S._color = BLACK, T.right = repaint(BLACK, B), T._color = RED, w -= 1;
      }
    else if (S.right === u) {
      if (!(B = T.left) || B._color !== RED) {
        T._color = RED, T.right = S.left, S._color = BLACK, S.left = T, c[w - 2] = S, c[w - 1] = u, recount(T), recount(S), w >= 3 && ((I = c[w - 3]).right === T ? I.right = S : I.left = S);
        break;
      }
      S._color = BLACK, T.left = repaint(BLACK, B), T._color = RED, w -= 1;
    } else {
      var B;
      if (!(B = T.left) || B._color !== RED) {
        var I;
        S.left = u.right, T._color = RED, T.right = u.left, u._color = BLACK, u.right = S, u.left = T, c[w - 2] = u, c[w - 1] = S, recount(T), recount(S), recount(u), w >= 3 && ((I = c[w - 3]).right === T ? I.right = u : I.left = u);
        break;
      }
      S._color = BLACK, T.left = repaint(BLACK, B), T._color = RED, w -= 1;
    }
  }
  return c[0]._color = BLACK, new RedBlackTree(a, c[0]);
}, proto.forEach = function(o, n, a) {
  if (this.root)
    switch (arguments.length) {
      case 1:
        return doVisitFull(o, this.root);
      case 2:
        return doVisitHalf(n, this._compare, o, this.root);
      case 3:
        return this._compare(n, a) >= 0 ? void 0 : doVisit(n, a, this._compare, o, this.root);
    }
}, Object.defineProperty(proto, "begin", { get: function() {
  for (var o = [], n = this.root; n; )
    o.push(n), n = n.left;
  return new RedBlackTreeIterator(this, o);
} }), Object.defineProperty(proto, "end", { get: function() {
  for (var o = [], n = this.root; n; )
    o.push(n), n = n.right;
  return new RedBlackTreeIterator(this, o);
} }), proto.at = function(o) {
  if (o < 0)
    return new RedBlackTreeIterator(this, []);
  for (var n = this.root, a = []; ; ) {
    if (a.push(n), n.left) {
      if (o < n.left._count) {
        n = n.left;
        continue;
      }
      o -= n.left._count;
    }
    if (!o)
      return new RedBlackTreeIterator(this, a);
    if (o -= 1, !n.right || o >= n.right._count)
      break;
    n = n.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.ge = function(o) {
  for (var n = this._compare, a = this.root, u = [], c = 0; a; ) {
    var m = n(o, a.key);
    u.push(a), m <= 0 && (c = u.length), a = m <= 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.gt = function(o) {
  for (var n = this._compare, a = this.root, u = [], c = 0; a; ) {
    var m = n(o, a.key);
    u.push(a), m < 0 && (c = u.length), a = m < 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.lt = function(o) {
  for (var n = this._compare, a = this.root, u = [], c = 0; a; ) {
    var m = n(o, a.key);
    u.push(a), m > 0 && (c = u.length), a = m <= 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.le = function(o) {
  for (var n = this._compare, a = this.root, u = [], c = 0; a; ) {
    var m = n(o, a.key);
    u.push(a), m >= 0 && (c = u.length), a = m < 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.find = function(o) {
  for (var n = this._compare, a = this.root, u = []; a; ) {
    var c = n(o, a.key);
    if (u.push(a), c === 0)
      return new RedBlackTreeIterator(this, u);
    a = c <= 0 ? a.left : a.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.remove = function(o) {
  var n = this.find(o);
  return n ? n.remove() : this;
}, proto.get = function(o) {
  for (var n = this._compare, a = this.root; a; ) {
    var u = n(o, a.key);
    if (u === 0)
      return a.value;
    a = u <= 0 ? a.left : a.right;
  }
};
var iproto = RedBlackTreeIterator.prototype;
function swapNode(o, n) {
  o.key = n.key, o.value = n.value, o.left = n.left, o.right = n.right, o._color = n._color, o._count = n._count;
}
function fixDoubleBlack(o) {
  for (var n, a, u, c, m = o.length - 1; m >= 0; --m) {
    if (n = o[m], m === 0)
      return void (n._color = BLACK);
    if ((a = o[m - 1]).left === n) {
      if ((u = a.right).right && u.right._color === RED)
        return c = (u = a.right = cloneNode(u)).right = cloneNode(u.right), a.right = u.left, u.left = a, u.right = c, u._color = a._color, n._color = BLACK, a._color = BLACK, c._color = BLACK, recount(a), recount(u), m > 1 && ((d = o[m - 2]).left === a ? d.left = u : d.right = u), void (o[m - 1] = u);
      if (u.left && u.left._color === RED)
        return c = (u = a.right = cloneNode(u)).left = cloneNode(u.left), a.right = c.left, u.left = c.right, c.left = a, c.right = u, c._color = a._color, a._color = BLACK, u._color = BLACK, n._color = BLACK, recount(a), recount(u), recount(c), m > 1 && ((d = o[m - 2]).left === a ? d.left = c : d.right = c), void (o[m - 1] = c);
      if (u._color === BLACK) {
        if (a._color === RED)
          return a._color = BLACK, void (a.right = repaint(RED, u));
        a.right = repaint(RED, u);
        continue;
      }
      u = cloneNode(u), a.right = u.left, u.left = a, u._color = a._color, a._color = RED, recount(a), recount(u), m > 1 && ((d = o[m - 2]).left === a ? d.left = u : d.right = u), o[m - 1] = u, o[m] = a, m + 1 < o.length ? o[m + 1] = n : o.push(n), m += 2;
    } else {
      if ((u = a.left).left && u.left._color === RED)
        return c = (u = a.left = cloneNode(u)).left = cloneNode(u.left), a.left = u.right, u.right = a, u.left = c, u._color = a._color, n._color = BLACK, a._color = BLACK, c._color = BLACK, recount(a), recount(u), m > 1 && ((d = o[m - 2]).right === a ? d.right = u : d.left = u), void (o[m - 1] = u);
      if (u.right && u.right._color === RED)
        return c = (u = a.left = cloneNode(u)).right = cloneNode(u.right), a.left = c.right, u.right = c.left, c.right = a, c.left = u, c._color = a._color, a._color = BLACK, u._color = BLACK, n._color = BLACK, recount(a), recount(u), recount(c), m > 1 && ((d = o[m - 2]).right === a ? d.right = c : d.left = c), void (o[m - 1] = c);
      if (u._color === BLACK) {
        if (a._color === RED)
          return a._color = BLACK, void (a.left = repaint(RED, u));
        a.left = repaint(RED, u);
        continue;
      }
      var d;
      u = cloneNode(u), a.left = u.right, u.right = a, u._color = a._color, a._color = RED, recount(a), recount(u), m > 1 && ((d = o[m - 2]).right === a ? d.right = u : d.left = u), o[m - 1] = u, o[m] = a, m + 1 < o.length ? o[m + 1] = n : o.push(n), m += 2;
    }
  }
}
function defaultCompare(o, n) {
  return o < n ? -1 : o > n ? 1 : 0;
}
function createRBTree(o) {
  return new RedBlackTree(o || defaultCompare, null);
}
Object.defineProperty(iproto, "valid", { get: function() {
  return this._stack.length > 0;
} }), Object.defineProperty(iproto, "node", { get: function() {
  return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
}, enumerable: !0 }), iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
}, iproto.remove = function() {
  var o = this._stack;
  if (o.length === 0)
    return this.tree;
  var n = new Array(o.length), a = o[o.length - 1];
  n[n.length - 1] = new RBNode(a._color, a.key, a.value, a.left, a.right, a._count);
  for (var u = o.length - 2; u >= 0; --u)
    (a = o[u]).left === o[u + 1] ? n[u] = new RBNode(a._color, a.key, a.value, n[u + 1], a.right, a._count) : n[u] = new RBNode(a._color, a.key, a.value, a.left, n[u + 1], a._count);
  if ((a = n[n.length - 1]).left && a.right) {
    var c = n.length;
    for (a = a.left; a.right; )
      n.push(a), a = a.right;
    var m = n[c - 1];
    for (n.push(new RBNode(a._color, m.key, m.value, a.left, a.right, a._count)), n[c - 1].key = a.key, n[c - 1].value = a.value, u = n.length - 2; u >= c; --u)
      a = n[u], n[u] = new RBNode(a._color, a.key, a.value, a.left, n[u + 1], a._count);
    n[c - 1].left = n[c];
  }
  if ((a = n[n.length - 1])._color === RED) {
    var d = n[n.length - 2];
    for (d.left === a ? d.left = null : d.right === a && (d.right = null), n.pop(), u = 0; u < n.length; ++u)
      n[u]._count--;
    return new RedBlackTree(this.tree._compare, n[0]);
  }
  if (a.left || a.right) {
    for (a.left ? swapNode(a, a.left) : a.right && swapNode(a, a.right), a._color = BLACK, u = 0; u < n.length - 1; ++u)
      n[u]._count--;
    return new RedBlackTree(this.tree._compare, n[0]);
  }
  if (n.length === 1)
    return new RedBlackTree(this.tree._compare, null);
  for (u = 0; u < n.length; ++u)
    n[u]._count--;
  var w = n[n.length - 2];
  return fixDoubleBlack(n), w.left === a ? w.left = null : w.right = null, new RedBlackTree(this.tree._compare, n[0]);
}, Object.defineProperty(iproto, "key", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].key;
}, enumerable: !0 }), Object.defineProperty(iproto, "value", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].value;
}, enumerable: !0 }), Object.defineProperty(iproto, "index", { get: function() {
  var o = 0, n = this._stack;
  if (n.length === 0) {
    var a = this.tree.root;
    return a ? a._count : 0;
  }
  n[n.length - 1].left && (o = n[n.length - 1].left._count);
  for (var u = n.length - 2; u >= 0; --u)
    n[u + 1] === n[u].right && (++o, n[u].left && (o += n[u].left._count));
  return o;
}, enumerable: !0 }), iproto.next = function() {
  var o = this._stack;
  if (o.length !== 0) {
    var n = o[o.length - 1];
    if (n.right)
      for (n = n.right; n; )
        o.push(n), n = n.left;
    else
      for (o.pop(); o.length > 0 && o[o.length - 1].right === n; )
        n = o[o.length - 1], o.pop();
  }
}, Object.defineProperty(iproto, "hasNext", { get: function() {
  var o = this._stack;
  if (o.length === 0)
    return !1;
  if (o[o.length - 1].right)
    return !0;
  for (var n = o.length - 1; n > 0; --n)
    if (o[n - 1].left === o[n])
      return !0;
  return !1;
} }), iproto.update = function(o) {
  var n = this._stack;
  if (n.length === 0)
    throw new Error("Can't update empty node!");
  var a = new Array(n.length), u = n[n.length - 1];
  a[a.length - 1] = new RBNode(u._color, u.key, o, u.left, u.right, u._count);
  for (var c = n.length - 2; c >= 0; --c)
    (u = n[c]).left === n[c + 1] ? a[c] = new RBNode(u._color, u.key, u.value, a[c + 1], u.right, u._count) : a[c] = new RBNode(u._color, u.key, u.value, u.left, a[c + 1], u._count);
  return new RedBlackTree(this.tree._compare, a[0]);
}, iproto.prev = function() {
  var o = this._stack;
  if (o.length !== 0) {
    var n = o[o.length - 1];
    if (n.left)
      for (n = n.left; n; )
        o.push(n), n = n.right;
    else
      for (o.pop(); o.length > 0 && o[o.length - 1].left === n; )
        n = o[o.length - 1], o.pop();
  }
}, Object.defineProperty(iproto, "hasPrev", { get: function() {
  var o = this._stack;
  if (o.length === 0)
    return !1;
  if (o[o.length - 1].left)
    return !0;
  for (var n = o.length - 1; n > 0; --n)
    if (o[n - 1].right === o[n])
      return !0;
  return !1;
} });
const { AbstractLevel, AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = abstractLevel$1, ModuleError = moduleError, createRBT = rbtree, rangeOptions = /* @__PURE__ */ new Set(["gt", "gte", "lt", "lte"]), kNone = Symbol("none"), kTree = Symbol("tree"), kIterator = Symbol("iterator"), kLowerBound = Symbol("lowerBound"), kUpperBound = Symbol("upperBound"), kOutOfRange = Symbol("outOfRange"), kReverse = Symbol("reverse"), kOptions = Symbol("options"), kTest = Symbol("test"), kAdvance = Symbol("advance"), kInit = Symbol("init");
function compare(o, n) {
  if (typeof o == "string")
    return o < n ? -1 : o > n ? 1 : 0;
  const a = Math.min(o.byteLength, n.byteLength);
  for (let u = 0; u < a; u++) {
    const c = o[u] - n[u];
    if (c !== 0)
      return c;
  }
  return o.byteLength - n.byteLength;
}
function gt(o) {
  return compare(o, this[kUpperBound]) > 0;
}
function gte(o) {
  return compare(o, this[kUpperBound]) >= 0;
}
function lt(o) {
  return compare(o, this[kUpperBound]) < 0;
}
function lte(o) {
  return compare(o, this[kUpperBound]) <= 0;
}
class MemoryIterator extends AbstractIterator {
  constructor(n, a) {
    super(n, a), this[kInit](n[kTree], a);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const a = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](a))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, a, u);
  }
  _nextv(n, a, u) {
    const c = this[kIterator], m = [];
    for (; c.valid && m.length < n && this[kTest](c.key); )
      m.push([c.key, c.value]), c[this[kAdvance]]();
    this.nextTick(u, null, m);
  }
  _all(n, a) {
    const u = this.limit - this.count, c = this[kIterator], m = [];
    for (; c.valid && m.length < u && this[kTest](c.key); )
      m.push([c.key, c.value]), c[this[kAdvance]]();
    this.nextTick(a, null, m);
  }
}
class MemoryKeyIterator extends AbstractKeyIterator {
  constructor(n, a) {
    super(n, a), this[kInit](n[kTree], a);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const a = this[kIterator].key;
    if (!this[kTest](a))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, a);
  }
  _nextv(n, a, u) {
    const c = this[kIterator], m = [];
    for (; c.valid && m.length < n && this[kTest](c.key); )
      m.push(c.key), c[this[kAdvance]]();
    this.nextTick(u, null, m);
  }
  _all(n, a) {
    const u = this.limit - this.count, c = this[kIterator], m = [];
    for (; c.valid && m.length < u && this[kTest](c.key); )
      m.push(c.key), c[this[kAdvance]]();
    this.nextTick(a, null, m);
  }
}
class MemoryValueIterator extends AbstractValueIterator {
  constructor(n, a) {
    super(n, a), this[kInit](n[kTree], a);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const a = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](a))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, u);
  }
  _nextv(n, a, u) {
    const c = this[kIterator], m = [];
    for (; c.valid && m.length < n && this[kTest](c.key); )
      m.push(c.value), c[this[kAdvance]]();
    this.nextTick(u, null, m);
  }
  _all(n, a) {
    const u = this.limit - this.count, c = this[kIterator], m = [];
    for (; c.valid && m.length < u && this[kTest](c.key); )
      m.push(c.value), c[this[kAdvance]]();
    this.nextTick(a, null, m);
  }
}
for (const o of [MemoryIterator, MemoryKeyIterator, MemoryValueIterator])
  o.prototype[kInit] = function(n, a) {
    this[kReverse] = a.reverse, this[kOptions] = a, this[kReverse] ? (this[kAdvance] = "prev", this[kLowerBound] = "lte" in a ? a.lte : "lt" in a ? a.lt : kNone, this[kUpperBound] = "gte" in a ? a.gte : "gt" in a ? a.gt : kNone, this[kLowerBound] === kNone ? this[kIterator] = n.end : this[kIterator] = "lte" in a ? n.le(this[kLowerBound]) : n.lt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "gte" in a ? gte : gt)) : (this[kAdvance] = "next", this[kLowerBound] = "gte" in a ? a.gte : "gt" in a ? a.gt : kNone, this[kUpperBound] = "lte" in a ? a.lte : "lt" in a ? a.lt : kNone, this[kLowerBound] === kNone ? this[kIterator] = n.begin : this[kIterator] = "gte" in a ? n.ge(this[kLowerBound]) : n.gt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "lte" in a ? lte : lt));
  }, o.prototype[kTest] = function() {
    return !0;
  }, o.prototype[kOutOfRange] = function(n) {
    return !this[kTest](n) || this[kLowerBound] !== kNone && (this[kReverse] ? "lte" in this[kOptions] ? compare(n, this[kLowerBound]) > 0 : compare(n, this[kLowerBound]) >= 0 : "gte" in this[kOptions] ? compare(n, this[kLowerBound]) < 0 : compare(n, this[kLowerBound]) <= 0);
  }, o.prototype._seek = function(n, a) {
    this[kOutOfRange](n) ? (this[kIterator] = this[kIterator].tree.end, this[kIterator].next()) : this[kReverse] ? this[kIterator] = this[kIterator].tree.le(n) : this[kIterator] = this[kIterator].tree.ge(n);
  };
class MemoryLevel extends AbstractLevel {
  constructor(n, a, u) {
    if (typeof n == "object" && n !== null && (a = n), typeof n == "function" || typeof a == "function" || typeof u == "function")
      throw new ModuleError("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    let { storeEncoding: c, ...m } = a || {};
    if (c = c || "buffer", !["buffer", "view", "utf8"].includes(c))
      throw new ModuleError("The storeEncoding option must be 'buffer', 'view' or 'utf8'", { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
    super({ seek: !0, permanence: !1, createIfMissing: !1, errorIfExists: !1, encodings: { [c]: !0 } }, m), this[kTree] = createRBT(compare);
  }
  _put(n, a, u, c) {
    const m = this[kTree].find(n);
    m.valid ? this[kTree] = m.update(a) : this[kTree] = this[kTree].insert(n, a), this.nextTick(c);
  }
  _get(n, a, u) {
    const c = this[kTree].get(n);
    if (c === void 0)
      return this.nextTick(u, new Error("NotFound"));
    this.nextTick(u, null, c);
  }
  _getMany(n, a, u) {
    this.nextTick(u, null, n.map((c) => this[kTree].get(c)));
  }
  _del(n, a, u) {
    this[kTree] = this[kTree].remove(n), this.nextTick(u);
  }
  _batch(n, a, u) {
    let c = this[kTree];
    for (const m of n) {
      const d = m.key, w = c.find(d);
      c = m.type === "put" ? w.valid ? w.update(m.value) : c.insert(d, m.value) : w.remove();
    }
    this[kTree] = c, this.nextTick(u);
  }
  _clear(n, a) {
    if (n.limit === -1 && !Object.keys(n).some(isRangeOption))
      return this[kTree] = createRBT(compare), this.nextTick(a);
    const u = this._keys({ ...n }), c = u.limit;
    let m = 0;
    const d = () => {
      for (let w = 0; w < 500; w++) {
        if (++m > c || !u[kIterator].valid || !u[kTest](u[kIterator].key))
          return a();
        this[kTree] = this[kTree].remove(u[kIterator].key), u[kIterator][u[kAdvance]]();
      }
      this.nextTick(d);
    };
    this.nextTick(d);
  }
  _iterator(n) {
    return new MemoryIterator(this, n);
  }
  _keys(n) {
    return new MemoryKeyIterator(this, n);
  }
  _values(n) {
    return new MemoryValueIterator(this, n);
  }
}
if (memoryLevel.MemoryLevel = MemoryLevel, typeof process < "u" && !process.browser && commonjsGlobal !== void 0 && typeof commonjsGlobal.setImmediate == "function") {
  const o = commonjsGlobal.setImmediate;
  MemoryLevel.prototype.nextTick = function(n, ...a) {
    a.length === 0 ? o(n) : o(() => n(...a));
  };
}
function isRangeOption(o) {
  return rangeOptions.has(o);
}
Object.defineProperty(LevelDbCache$1, "__esModule", { value: !0 }), LevelDbCache$1.LevelDbCache = void 0;
const level_1 = browser, memory_level_1 = memoryLevel, LoggerFactory_1$e = LoggerFactory$1;
class LevelDbCache {
  constructor(n) {
    if (this.logger = LoggerFactory_1$e.LoggerFactory.INST.create("LevelDbCache"), n.inMemory)
      this.db = new memory_level_1.MemoryLevel({ valueEncoding: "json" });
    else {
      if (!n.dbLocation)
        throw new Error("LevelDb cache configuration error - no db location specified");
      const a = n.dbLocation;
      this.logger.info(`Using location ${a}`), this.db = new level_1.Level(a, { valueEncoding: "json" });
    }
  }
  async get(n, a, u) {
    const c = this.db.sublevel(n, { valueEncoding: "json" });
    try {
      return { sortKey: a, cachedValue: await c.get(a) };
    } catch (m) {
      if (m.code == "LEVEL_NOT_FOUND")
        return null;
      throw m;
    }
  }
  async getLast(n) {
    const a = this.db.sublevel(n, { valueEncoding: "json" }), u = await a.keys({ reverse: !0, limit: 1 }).all();
    return u.length ? { sortKey: u[0], cachedValue: await a.get(u[0]) } : null;
  }
  async getLessOrEqual(n, a) {
    const u = this.db.sublevel(n, { valueEncoding: "json" }), c = await u.keys({ reverse: !0, lte: a, limit: 1 }).all();
    return c.length ? { sortKey: c[0], cachedValue: await u.get(c[0]) } : null;
  }
  async put(n, a) {
    const u = this.db.sublevel(n.contractTxId, { valueEncoding: "json" });
    await u.open(), await u.put(n.sortKey, a);
  }
  close() {
    return this.db.close();
  }
  async dump() {
    return await this.db.iterator().all();
  }
  async getLastSortKey() {
    let n = "";
    const a = await this.db.keys().all();
    for (const u of a) {
      const c = u.substring(45);
      c.localeCompare(n) > 0 && (n = c);
    }
    return n == "" ? null : n;
  }
  async allContracts() {
    const n = await this.db.keys().all(), a = /* @__PURE__ */ new Set();
    return n.forEach((u) => a.add(u.substring(1, 44))), Array.from(a);
  }
}
LevelDbCache$1.LevelDbCache = LevelDbCache;
var MemCache$1 = {};
Object.defineProperty(MemCache$1, "__esModule", { value: !0 }), MemCache$1.MemCache = void 0;
class MemCache {
  constructor() {
    this.storage = {};
  }
  clearAll() {
    Object.keys(this.storage).forEach((n) => {
      delete this.storage[n];
    });
  }
  contains(n) {
    return Object.prototype.hasOwnProperty.call(this.storage, n);
  }
  get(n) {
    return this.storage[n];
  }
  put(n, a) {
    this.storage[n] = a;
  }
  remove(n) {
    delete this.storage[n];
  }
}
MemCache$1.MemCache = MemCache;
var CacheableExecutorFactory$1 = {};
Object.defineProperty(CacheableExecutorFactory$1, "__esModule", { value: !0 }), CacheableExecutorFactory$1.CacheableExecutorFactory = void 0;
const LoggerFactory_1$d = LoggerFactory$1;
class CacheableExecutorFactory {
  constructor(n, a, u) {
    this.arweave = n, this.baseImplementation = a, this.cache = u, this.logger = LoggerFactory_1$d.LoggerFactory.INST.create("CacheableExecutorFactory");
  }
  async create(n, a) {
    return await this.baseImplementation.create(n, a);
  }
}
CacheableExecutorFactory$1.CacheableExecutorFactory = CacheableExecutorFactory;
var Evolve$1 = {}, errors = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.SmartWeaveError = o.SmartWeaveErrorType = void 0, (o.SmartWeaveErrorType || (o.SmartWeaveErrorType = {})).CONTRACT_NOT_FOUND = "CONTRACT_NOT_FOUND";
  class n extends Error {
    constructor(u, c = {}) {
      c.message ? super(c.message) : super(), this.type = u, this.otherInfo = c;
    }
    getType() {
      return this.type;
    }
  }
  o.SmartWeaveError = n;
})(errors), Object.defineProperty(Evolve$1, "__esModule", { value: !0 }), Evolve$1.Evolve = void 0;
const LoggerFactory_1$c = LoggerFactory$1, errors_1 = errors;
function isEvolveCompatible(o) {
  if (!o)
    return !1;
  const n = evalSettings(o);
  return o.evolve !== void 0 || n.has("evolve");
}
class Evolve {
  constructor() {
    this.logger = LoggerFactory_1$c.LoggerFactory.INST.create("Evolve"), this.modify = this.modify.bind(this);
  }
  async modify(n, a) {
    const { definitionLoader: u, executorFactory: c } = a.warp, m = a.contractDefinition.txId, d = Evolve.evolvedSrcTxId(n), w = a.contractDefinition.srcTxId;
    if (d && (this.logger.debug("Checking evolve:", { current: w, evolvedSrcTxId: d }), w !== d))
      try {
        this.logger.info("Evolving to: ", d);
        const S = await u.load(m, d), T = await c.create(S, a.evaluationOptions);
        return a.contractDefinition = S, a.handler = T, a.handler.initState(n), this.logger.debug("evolved to:", { evolve: d, newSrcTxId: a.contractDefinition.srcTxId, current: w, txId: a.contractDefinition.txId }), a;
      } catch {
        throw new errors_1.SmartWeaveError(errors_1.SmartWeaveErrorType.CONTRACT_NOT_FOUND, { message: `Contract having txId: ${m} not found`, requestedTxId: m });
      }
    return a;
  }
  static evolvedSrcTxId(n) {
    if (!isEvolveCompatible(n))
      return;
    const a = evalSettings(n), u = n.evolve || a.get("evolve");
    let c = n.canEvolve || a.get("canEvolve");
    return c == null && (c = !0), u && /[a-z0-9_-]{43}/i.test(u) && c ? u : void 0;
  }
}
function evalSettings(o) {
  let n = /* @__PURE__ */ new Map();
  return o.settings && (isIterable(o.settings) ? n = new Map(o.settings) : isObject$6(o.settings) && (n = new Map(Object.entries(o.settings)))), n;
}
function isIterable(o) {
  return o != null && typeof o[Symbol.iterator] == "function";
}
function isObject$6(o) {
  return typeof o == "object" && o !== null && !Array.isArray(o);
}
Evolve$1.Evolve = Evolve;
var CacheableStateEvaluator$1 = {}, SortKeyCache = {};
Object.defineProperty(SortKeyCache, "__esModule", { value: !0 }), SortKeyCache.SortKeyCacheResult = SortKeyCache.CacheKey = void 0;
class CacheKey {
  constructor(n, a) {
    this.contractTxId = n, this.sortKey = a;
  }
}
SortKeyCache.CacheKey = CacheKey;
class SortKeyCacheResult {
  constructor(n, a) {
    this.sortKey = n, this.cachedValue = a;
  }
}
SortKeyCache.SortKeyCacheResult = SortKeyCacheResult;
var utils$n = {};
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(o, n) {
  return o === n || o != o && n != n;
}
var eq_1 = eq$2, eq$1 = eq_1;
function assocIndexOf$4(o, n) {
  for (var a = o.length; a--; )
    if (eq$1(o[a][0], n))
      return a;
  return -1;
}
var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete$1(o) {
  var n = this.__data__, a = assocIndexOf$3(n, o);
  return !(a < 0 || (a == n.length - 1 ? n.pop() : splice.call(n, a, 1), --this.size, 0));
}
var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(o) {
  var n = this.__data__, a = assocIndexOf$2(n, o);
  return a < 0 ? void 0 : n[a][1];
}
var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(o) {
  return assocIndexOf$1(this.__data__, o) > -1;
}
var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
function listCacheSet$1(o, n) {
  var a = this.__data__, u = assocIndexOf(a, o);
  return u < 0 ? (++this.size, a.push([o, n])) : a[u][1] = n, this;
}
var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(o) {
  var n = -1, a = o == null ? 0 : o.length;
  for (this.clear(); ++n < a; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear, ListCache$4.prototype.delete = listCacheDelete, ListCache$4.prototype.get = listCacheGet, ListCache$4.prototype.has = listCacheHas, ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4, ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(o) {
  var n = this.__data__, a = n.delete(o);
  return this.size = n.size, a;
}
var _stackDelete = stackDelete$1;
function stackGet$1(o) {
  return this.__data__.get(o);
}
var _stackGet = stackGet$1;
function stackHas$1(o) {
  return this.__data__.has(o);
}
var _stackHas = stackHas$1, freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$8 = freeGlobal || freeSelf || Function("return this")(), _root = root$8, root$7 = _root, Symbol$4 = root$7.Symbol, _Symbol = Symbol$4, Symbol$3 = _Symbol, objectProto$c = Object.prototype, hasOwnProperty$9 = objectProto$c.hasOwnProperty, nativeObjectToString$1 = objectProto$c.toString, symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(o) {
  var n = hasOwnProperty$9.call(o, symToStringTag$1), a = o[symToStringTag$1];
  try {
    o[symToStringTag$1] = void 0;
    var u = !0;
  } catch {
  }
  var c = nativeObjectToString$1.call(o);
  return u && (n ? o[symToStringTag$1] = a : delete o[symToStringTag$1]), c;
}
var _getRawTag = getRawTag$1, objectProto$b = Object.prototype, nativeObjectToString = objectProto$b.toString;
function objectToString$1(o) {
  return nativeObjectToString.call(o);
}
var _objectToString = objectToString$1, Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(o) {
  return o == null ? o === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(o) ? getRawTag(o) : objectToString(o);
}
var _baseGetTag = baseGetTag$4;
function isObject$5(o) {
  var n = typeof o;
  return o != null && (n == "object" || n == "function");
}
var isObject_1 = isObject$5, baseGetTag$3 = _baseGetTag, isObject$4 = isObject_1, asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(o) {
  if (!isObject$4(o))
    return !1;
  var n = baseGetTag$3(o);
  return n == funcTag$2 || n == genTag$1 || n == asyncTag || n == proxyTag;
}
var isFunction_1 = isFunction$2, root$6 = _root, coreJsData$1 = root$6["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid;
function isMasked$1(o) {
  return !!maskSrcKey && maskSrcKey in o;
}
var _isMasked = isMasked$1, funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource$2(o) {
  if (o != null) {
    try {
      return funcToString$1.call(o);
    } catch {
    }
    try {
      return o + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource$2, isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$3 = isObject_1, toSource$1 = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$a = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$8 = objectProto$a.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(o) {
  return !(!isObject$3(o) || isMasked(o)) && (isFunction$1(o) ? reIsNative : reIsHostCtor).test(toSource$1(o));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(o, n) {
  return o == null ? void 0 : o[n];
}
var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(o, n) {
  var a = getValue(o, n);
  return baseIsNative(a) ? a : void 0;
}
var _getNative = getNative$7, getNative$6 = _getNative, root$5 = _root, Map$4 = getNative$6(root$5, "Map"), _Map = Map$4, getNative$5 = _getNative, nativeCreate$4 = getNative$5(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(o) {
  var n = this.has(o) && delete this.__data__[o];
  return this.size -= n ? 1 : 0, n;
}
var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__", objectProto$9 = Object.prototype, hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet$1(o) {
  var n = this.__data__;
  if (nativeCreate$2) {
    var a = n[o];
    return a === HASH_UNDEFINED$1 ? void 0 : a;
  }
  return hasOwnProperty$7.call(n, o) ? n[o] : void 0;
}
var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$8 = Object.prototype, hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas$1(o) {
  var n = this.__data__;
  return nativeCreate$1 ? n[o] !== void 0 : hasOwnProperty$6.call(n, o);
}
var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(o, n) {
  var a = this.__data__;
  return this.size += this.has(o) ? 0 : 1, a[o] = nativeCreate && n === void 0 ? HASH_UNDEFINED : n, this;
}
var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(o) {
  var n = -1, a = o == null ? 0 : o.length;
  for (this.clear(); ++n < a; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
Hash$1.prototype.clear = hashClear, Hash$1.prototype.delete = hashDelete, Hash$1.prototype.get = hashGet, Hash$1.prototype.has = hashHas, Hash$1.prototype.set = hashSet;
var _Hash = Hash$1, Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map$3 || ListCache$2)(), string: new Hash() };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(o) {
  var n = typeof o;
  return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? o !== "__proto__" : o === null;
}
var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
function getMapData$4(o, n) {
  var a = o.__data__;
  return isKeyable(n) ? a[typeof n == "string" ? "string" : "hash"] : a.map;
}
var _getMapData = getMapData$4, getMapData$3 = _getMapData;
function mapCacheDelete$1(o) {
  var n = getMapData$3(this, o).delete(o);
  return this.size -= n ? 1 : 0, n;
}
var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
function mapCacheGet$1(o) {
  return getMapData$2(this, o).get(o);
}
var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
function mapCacheHas$1(o) {
  return getMapData$1(this, o).has(o);
}
var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
function mapCacheSet$1(o, n) {
  var a = getMapData(this, o), u = a.size;
  return a.set(o, n), this.size += a.size == u ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(o) {
  var n = -1, a = o == null ? 0 : o.length;
  for (this.clear(); ++n < a; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear, MapCache$1.prototype.delete = mapCacheDelete, MapCache$1.prototype.get = mapCacheGet, MapCache$1.prototype.has = mapCacheHas, MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1, ListCache$1 = _ListCache, Map$2 = _Map, MapCache = _MapCache, LARGE_ARRAY_SIZE = 200;
function stackSet$1(o, n) {
  var a = this.__data__;
  if (a instanceof ListCache$1) {
    var u = a.__data__;
    if (!Map$2 || u.length < LARGE_ARRAY_SIZE - 1)
      return u.push([o, n]), this.size = ++a.size, this;
    a = this.__data__ = new MapCache(u);
  }
  return a.set(o, n), this.size = a.size, this;
}
var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(o) {
  var n = this.__data__ = new ListCache(o);
  this.size = n.size;
}
Stack$1.prototype.clear = stackClear, Stack$1.prototype.delete = stackDelete, Stack$1.prototype.get = stackGet, Stack$1.prototype.has = stackHas, Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
function arrayEach$1(o, n) {
  for (var a = -1, u = o == null ? 0 : o.length; ++a < u && n(o[a], a, o) !== !1; )
    ;
  return o;
}
var _arrayEach = arrayEach$1, getNative$4 = _getNative, defineProperty$1 = function() {
  try {
    var o = getNative$4(Object, "defineProperty");
    return o({}, "", {}), o;
  } catch {
  }
}(), _defineProperty = defineProperty$1, defineProperty = _defineProperty;
function baseAssignValue$2(o, n, a) {
  n == "__proto__" && defineProperty ? defineProperty(o, n, { configurable: !0, enumerable: !0, value: a, writable: !0 }) : o[n] = a;
}
var _baseAssignValue = baseAssignValue$2, baseAssignValue$1 = _baseAssignValue, eq = eq_1, objectProto$7 = Object.prototype, hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue$2(o, n, a) {
  var u = o[n];
  hasOwnProperty$5.call(o, n) && eq(u, a) && (a !== void 0 || n in o) || baseAssignValue$1(o, n, a);
}
var _assignValue = assignValue$2, assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(o, n, a, u) {
  var c = !a;
  a || (a = {});
  for (var m = -1, d = n.length; ++m < d; ) {
    var w = n[m], S = u ? u(a[w], o[w], w, a, o) : void 0;
    S === void 0 && (S = o[w]), c ? baseAssignValue(a, w, S) : assignValue$1(a, w, S);
  }
  return a;
}
var _copyObject = copyObject$4;
function baseTimes$1(o, n) {
  for (var a = -1, u = Array(o); ++a < o; )
    u[a] = n(a);
  return u;
}
var _baseTimes = baseTimes$1;
function isObjectLike$5(o) {
  return o != null && typeof o == "object";
}
var isObjectLike_1 = isObjectLike$5, baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1, argsTag$2 = "[object Arguments]";
function baseIsArguments$1(o) {
  return isObjectLike$4(o) && baseGetTag$2(o) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1, objectProto$6 = Object.prototype, hasOwnProperty$4 = objectProto$6.hasOwnProperty, propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable, isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(o) {
  return isObjectLike$3(o) && hasOwnProperty$4.call(o, "callee") && !propertyIsEnumerable$1.call(o, "callee");
}, isArguments_1 = isArguments$1, isArray$3 = Array.isArray, isArray_1 = isArray$3, isBuffer$2 = { exports: {} };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse;
(function(o, n) {
  var a = _root, u = stubFalse_1, c = n && !n.nodeType && n, m = c && o && !o.nodeType && o, d = m && m.exports === c ? a.Buffer : void 0, w = (d ? d.isBuffer : void 0) || u;
  o.exports = w;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(o, n) {
  var a = typeof o;
  return !!(n = n == null ? MAX_SAFE_INTEGER$1 : n) && (a == "number" || a != "symbol" && reIsUint.test(o)) && o > -1 && o % 1 == 0 && o < n;
}
var _isIndex = isIndex$1, MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(o) {
  return typeof o == "number" && o > -1 && o % 1 == 0 && o <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2, baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
function baseIsTypedArray$1(o) {
  return isObjectLike$2(o) && isLength$1(o.length) && !!typedArrayTags[baseGetTag$1(o)];
}
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(o) {
  return function(n) {
    return o(n);
  };
}
var _baseUnary = baseUnary$3, _nodeUtil = { exports: {} };
(function(o, n) {
  var a = _freeGlobal, u = n && !n.nodeType && n, c = u && o && !o.nodeType && o, m = c && c.exports === u && a.process, d = function() {
    try {
      return c && c.require && c.require("util").types || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  o.exports = d;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports, nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$1, baseTimes = _baseTimes, isArguments = isArguments_1, isArray$2 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1, objectProto$5 = Object.prototype, hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$2(o, n) {
  var a = isArray$2(o), u = !a && isArguments(o), c = !a && !u && isBuffer$1(o), m = !a && !u && !c && isTypedArray(o), d = a || u || c || m, w = d ? baseTimes(o.length, String) : [], S = w.length;
  for (var T in o)
    !n && !hasOwnProperty$3.call(o, T) || d && (T == "length" || c && (T == "offset" || T == "parent") || m && (T == "buffer" || T == "byteLength" || T == "byteOffset") || isIndex(T, S)) || w.push(T);
  return w;
}
var _arrayLikeKeys = arrayLikeKeys$2, objectProto$4 = Object.prototype;
function isPrototype$3(o) {
  var n = o && o.constructor;
  return o === (typeof n == "function" && n.prototype || objectProto$4);
}
var _isPrototype = isPrototype$3;
function overArg$2(o, n) {
  return function(a) {
    return o(n(a));
  };
}
var _overArg = overArg$2, overArg$1 = _overArg, nativeKeys$1 = overArg$1(Object.keys, Object), _nativeKeys = nativeKeys$1, isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys, objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys$1(o) {
  if (!isPrototype$2(o))
    return nativeKeys(o);
  var n = [];
  for (var a in Object(o))
    hasOwnProperty$2.call(o, a) && a != "constructor" && n.push(a);
  return n;
}
var _baseKeys = baseKeys$1, isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(o) {
  return o != null && isLength(o.length) && !isFunction(o);
}
var isArrayLike_1 = isArrayLike$2, arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$3(o) {
  return isArrayLike$1(o) ? arrayLikeKeys$1(o) : baseKeys(o);
}
var keys_1 = keys$3, copyObject$3 = _copyObject, keys$2 = keys_1;
function baseAssign$1(o, n) {
  return o && copyObject$3(n, keys$2(n), o);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(o) {
  var n = [];
  if (o != null)
    for (var a in Object(o))
      n.push(a);
  return n;
}
var _nativeKeysIn = nativeKeysIn$1, isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn, objectProto$2 = Object.prototype, hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn$1(o) {
  if (!isObject$2(o))
    return nativeKeysIn(o);
  var n = isPrototype$1(o), a = [];
  for (var u in o)
    (u != "constructor" || !n && hasOwnProperty$1.call(o, u)) && a.push(u);
  return a;
}
var _baseKeysIn = baseKeysIn$1, arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(o) {
  return isArrayLike(o) ? arrayLikeKeys(o, !0) : baseKeysIn(o);
}
var keysIn_1 = keysIn$3, copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(o, n) {
  return o && copyObject$2(n, keysIn$2(n), o);
}
var _baseAssignIn = baseAssignIn$1, _cloneBuffer = { exports: {} };
function copyArray$1(o, n) {
  var a = -1, u = o.length;
  for (n || (n = Array(u)); ++a < u; )
    n[a] = o[a];
  return n;
}
(function(o, n) {
  var a = _root, u = n && !n.nodeType && n, c = u && o && !o.nodeType && o, m = c && c.exports === u ? a.Buffer : void 0, d = m ? m.allocUnsafe : void 0;
  o.exports = function(w, S) {
    if (S)
      return w.slice();
    var T = w.length, B = d ? d(T) : new w.constructor(T);
    return w.copy(B), B;
  };
})(_cloneBuffer, _cloneBuffer.exports);
var _copyArray = copyArray$1;
function arrayFilter$1(o, n) {
  for (var a = -1, u = o == null ? 0 : o.length, c = 0, m = []; ++a < u; ) {
    var d = o[a];
    n(d, a, o) && (m[c++] = d);
  }
  return m;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2, arrayFilter = _arrayFilter, stubArray$1 = stubArray_1, objectProto$1 = Object.prototype, propertyIsEnumerable = objectProto$1.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols$3 = nativeGetSymbols$1 ? function(o) {
  return o == null ? [] : (o = Object(o), arrayFilter(nativeGetSymbols$1(o), function(n) {
    return propertyIsEnumerable.call(o, n);
  }));
} : stubArray$1, _getSymbols = getSymbols$3, copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(o, n) {
  return copyObject$1(o, getSymbols$2(o), n);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(o, n) {
  for (var a = -1, u = n.length, c = o.length; ++a < u; )
    o[c + a] = n[a];
  return o;
}
var _arrayPush = arrayPush$2, overArg = _overArg, getPrototype$2 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$2, arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn$2 = nativeGetSymbols ? function(o) {
  for (var n = []; o; )
    arrayPush$1(n, getSymbols$1(o)), o = getPrototype$1(o);
  return n;
} : stubArray, _getSymbolsIn = getSymbolsIn$2, copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(o, n) {
  return copyObject(o, getSymbolsIn$1(o), n);
}
var _copySymbolsIn = copySymbolsIn$1, arrayPush = _arrayPush, isArray$1 = isArray_1;
function baseGetAllKeys$2(o, n, a) {
  var u = n(o);
  return isArray$1(o) ? u : arrayPush(u, a(o));
}
var _baseGetAllKeys = baseGetAllKeys$2, baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(o) {
  return baseGetAllKeys$1(o, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1, baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(o) {
  return baseGetAllKeys(o, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1, getNative$3 = _getNative, root$4 = _root, DataView$2 = getNative$3(root$4, "DataView"), _DataView = DataView$2, getNative$2 = _getNative, root$3 = _root, Promise$2 = getNative$2(root$3, "Promise"), _Promise = Promise$2, getNative$1 = _getNative, root$2 = _root, Set$2 = getNative$1(root$2, "Set"), _Set = Set$2, getNative = _getNative, root$1 = _root, WeakMap$2 = getNative(root$1, "WeakMap"), _WeakMap = WeakMap$2, DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource, mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$2 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag$3 = baseGetTag;
(DataView$1 && getTag$3(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) && (getTag$3 = function(o) {
  var n = baseGetTag(o), a = n == objectTag$1 ? o.constructor : void 0, u = a ? toSource(a) : "";
  if (u)
    switch (u) {
      case dataViewCtorString:
        return dataViewTag$2;
      case mapCtorString:
        return mapTag$3;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$3;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return n;
});
var _getTag = getTag$3, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(o) {
  var n = o.length, a = new o.constructor(n);
  return n && typeof o[0] == "string" && hasOwnProperty.call(o, "index") && (a.index = o.index, a.input = o.input), a;
}
var _initCloneArray = initCloneArray$1, root = _root, Uint8Array$2 = root.Uint8Array, _Uint8Array = Uint8Array$2, Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(o) {
  var n = new o.constructor(o.byteLength);
  return new Uint8Array$1(n).set(new Uint8Array$1(o)), n;
}
var _cloneArrayBuffer = cloneArrayBuffer$3, cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(o, n) {
  var a = n ? cloneArrayBuffer$2(o.buffer) : o.buffer;
  return new o.constructor(a, o.byteOffset, o.byteLength);
}
var _cloneDataView = cloneDataView$1, reFlags = /\w*$/;
function cloneRegExp$1(o) {
  var n = new o.constructor(o.source, reFlags.exec(o));
  return n.lastIndex = o.lastIndex, n;
}
var _cloneRegExp = cloneRegExp$1, Symbol$1 = _Symbol, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(o) {
  return symbolValueOf ? Object(symbolValueOf.call(o)) : {};
}
var _cloneSymbol = cloneSymbol$1, cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(o, n) {
  var a = n ? cloneArrayBuffer$1(o.buffer) : o.buffer;
  return new o.constructor(a, o.byteOffset, o.length);
}
var _cloneTypedArray = cloneTypedArray$1, cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(o, n, a) {
  var u = o.constructor;
  switch (n) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(o);
    case boolTag$1:
    case dateTag$1:
      return new u(+o);
    case dataViewTag$1:
      return cloneDataView(o, a);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(o, a);
    case mapTag$2:
      return new u();
    case numberTag$1:
    case stringTag$1:
      return new u(o);
    case regexpTag$1:
      return cloneRegExp(o);
    case setTag$2:
      return new u();
    case symbolTag$1:
      return cloneSymbol(o);
  }
}
var _initCloneByTag = initCloneByTag$1, isObject$1 = isObject_1, objectCreate = Object.create, baseCreate$1 = function() {
  function o() {
  }
  return function(n) {
    if (!isObject$1(n))
      return {};
    if (objectCreate)
      return objectCreate(n);
    o.prototype = n;
    var a = new o();
    return o.prototype = void 0, a;
  };
}(), _baseCreate = baseCreate$1, baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(o) {
  return typeof o.constructor != "function" || isPrototype(o) ? {} : baseCreate(getPrototype(o));
}
var _initCloneObject = initCloneObject$1, getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1, mapTag$1 = "[object Map]";
function baseIsMap$1(o) {
  return isObjectLike$1(o) && getTag$2(o) == mapTag$1;
}
var _baseIsMap = baseIsMap$1, baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports, nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap, isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap, isMap_1 = isMap$1, getTag$1 = _getTag, isObjectLike = isObjectLike_1, setTag$1 = "[object Set]";
function baseIsSet$1(o) {
  return isObjectLike(o) && getTag$1(o) == setTag$1;
}
var _baseIsSet = baseIsSet$1, baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports, nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isSet_1 = isSet$1, Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBuffer$2.exports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1, CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
function baseClone$1(o, n, a, u, c, m) {
  var d, w = n & CLONE_DEEP_FLAG$1, S = n & CLONE_FLAT_FLAG, T = n & CLONE_SYMBOLS_FLAG$1;
  if (a && (d = c ? a(o, u, c, m) : a(o)), d !== void 0)
    return d;
  if (!isObject(o))
    return o;
  var B = isArray(o);
  if (B) {
    if (d = initCloneArray(o), !w)
      return copyArray(o, d);
  } else {
    var I = getTag(o), C = I == funcTag || I == genTag;
    if (isBuffer(o))
      return cloneBuffer(o, w);
    if (I == objectTag || I == argsTag || C && !c) {
      if (d = S || C ? {} : initCloneObject(o), !w)
        return S ? copySymbolsIn(o, baseAssignIn(d, o)) : copySymbols(o, baseAssign(d, o));
    } else {
      if (!cloneableTags[I])
        return c ? o : {};
      d = initCloneByTag(o, I, w);
    }
  }
  m || (m = new Stack());
  var N = m.get(o);
  if (N)
    return N;
  m.set(o, d), isSet(o) ? o.forEach(function(D) {
    d.add(baseClone$1(D, n, a, D, o, m));
  }) : isMap(o) && o.forEach(function(D, z) {
    d.set(z, baseClone$1(D, n, a, z, o, m));
  });
  var q = B ? void 0 : (T ? S ? getAllKeysIn : getAllKeys : S ? keysIn : keys)(o);
  return arrayEach(q || o, function(D, z) {
    q && (D = o[z = D]), assignValue(d, z, baseClone$1(D, n, a, z, o, m));
  }), d;
}
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
var _baseClone = baseClone$1, baseClone = _baseClone, CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(o) {
  return baseClone(o, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1$1 = cloneDeep, fastCopy = { exports: {} };
fastCopy.exports = function() {
  var o = Function.prototype.toString, n = Object.create, a = Object.defineProperty, u = Object.getOwnPropertyDescriptor, c = Object.getOwnPropertyNames, m = Object.getOwnPropertySymbols, d = Object.getPrototypeOf, w = Object.prototype, S = w.hasOwnProperty, T = w.propertyIsEnumerable, B = typeof m == "function", I = typeof WeakMap == "function", C = function() {
    if (I)
      return function() {
        return /* @__PURE__ */ new WeakMap();
      };
    var P = function() {
      function F() {
        this._keys = [], this._values = [];
      }
      return F.prototype.has = function(H) {
        return !!~this._keys.indexOf(H);
      }, F.prototype.get = function(H) {
        return this._values[this._keys.indexOf(H)];
      }, F.prototype.set = function(H, te) {
        this._keys.push(H), this._values.push(te);
      }, F;
    }();
    return function() {
      return new P();
    };
  }(), N = function(P, F) {
    var H = P.__proto__ || d(P);
    if (!H)
      return n(null);
    var te = H.constructor;
    if (te === F.Object)
      return H === F.Object.prototype ? {} : n(H);
    if (~o.call(te).indexOf("[native code]"))
      try {
        return new te();
      } catch {
      }
    return n(H);
  }, q = function(P, F, H, te) {
    var p = N(P, F);
    for (var $ in te.set(P, p), P)
      S.call(P, $) && (p[$] = H(P[$], te));
    if (B)
      for (var _ = m(P), y = 0, g = _.length, v = void 0; y < g; ++y)
        v = _[y], T.call(P, v) && (p[v] = H(P[v], te));
    return p;
  }, D = function(P, F, H, te) {
    var p = N(P, F);
    te.set(P, p);
    for (var $ = B ? c(P).concat(m(P)) : c(P), _ = 0, y = $.length, g = void 0, v = void 0; _ < y; ++_)
      if ((g = $[_]) !== "callee" && g !== "caller")
        if (v = u(P, g)) {
          v.get || v.set || (v.value = H(P[g], te));
          try {
            a(p, g, v);
          } catch {
            p[g] = v.value;
          }
        } else
          p[g] = H(P[g], te);
    return p;
  }, z = Array.isArray, W = Object.getPrototypeOf, V = function() {
    return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal !== void 0 ? commonjsGlobal : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
  }();
  function ee(P, F) {
    var H = !(!F || !F.isStrict), te = F && F.realm || V, p = H ? D : q, $ = function(_, y) {
      if (!_ || typeof _ != "object")
        return _;
      if (y.has(_))
        return y.get(_);
      var g, v = _.__proto__ || W(_), E = v && v.constructor;
      if (!E || E === te.Object)
        return p(_, te, $, y);
      if (z(_)) {
        if (H)
          return D(_, te, $, y);
        g = new E(), y.set(_, g);
        for (var A = 0, L = _.length; A < L; ++A)
          g[A] = $(_[A], y);
        return g;
      }
      if (_ instanceof te.Date)
        return new E(_.getTime());
      if (_ instanceof te.RegExp)
        return (g = new E(_.source, _.flags || function(j) {
          var J = "";
          return j.global && (J += "g"), j.ignoreCase && (J += "i"), j.multiline && (J += "m"), j.unicode && (J += "u"), j.sticky && (J += "y"), J;
        }(_))).lastIndex = _.lastIndex, g;
      if (te.Map && _ instanceof te.Map)
        return g = new E(), y.set(_, g), _.forEach(function(j, J) {
          g.set(J, $(j, y));
        }), g;
      if (te.Set && _ instanceof te.Set)
        return g = new E(), y.set(_, g), _.forEach(function(j) {
          g.add($(j, y));
        }), g;
      if (te.Blob && _ instanceof te.Blob)
        return _.slice(0, _.size, _.type);
      if (te.Buffer && te.Buffer.isBuffer(_))
        return g = te.Buffer.allocUnsafe ? te.Buffer.allocUnsafe(_.length) : new E(_.length), y.set(_, g), _.copy(g), g;
      if (te.ArrayBuffer) {
        if (te.ArrayBuffer.isView(_))
          return g = new E(_.buffer.slice(0)), y.set(_, g), g;
        if (_ instanceof te.ArrayBuffer)
          return g = _.slice(0), y.set(_, g), g;
      }
      return typeof _.then == "function" || _ instanceof Error || te.WeakMap && _ instanceof te.WeakMap || te.WeakSet && _ instanceof te.WeakSet ? _ : p(_, te, $, y);
    };
    return $(P, C());
  }
  return ee.default = ee, ee.strict = function(P, F) {
    return ee(P, { isStrict: !0, realm: F ? F.realm : void 0 });
  }, ee;
}();
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(utils$n, "__esModule", { value: !0 }), utils$n.isomorphicRandomUUID = utils$n.bufToBn = utils$n.indent = utils$n.stripTrailingSlash = utils$n.timeout = utils$n.descS = utils$n.desc = utils$n.ascS = utils$n.asc = utils$n.mapReviver = utils$n.mapReplacer = utils$n.deepCopy = utils$n.sleep = void 0;
const cloneDeep_1 = __importDefault$6(cloneDeep_1$1), fast_copy_1 = __importDefault$6(fastCopy.exports), crypto_1 = require$$2$1, sleep = (o) => new Promise((n) => setTimeout(n, o));
utils$n.sleep = sleep;
const deepCopy = (o, n = !1) => n ? (0, fast_copy_1.default)(o) : (0, cloneDeep_1.default)(o);
utils$n.deepCopy = deepCopy;
const mapReplacer = (o, n) => n instanceof Map ? { dataType: "Map", value: Array.from(n.entries()) } : n;
utils$n.mapReplacer = mapReplacer;
const mapReviver = (o, n) => typeof n == "object" && n !== null && n.dataType === "Map" ? new Map(n.value) : n;
utils$n.mapReviver = mapReviver;
const asc = (o, n) => o - n;
utils$n.asc = asc;
const ascS = (o, n) => +o - +n;
utils$n.ascS = ascS;
const desc = (o, n) => n - o;
utils$n.desc = desc;
const descS = (o, n) => +n - +o;
function timeout(o) {
  let n = null;
  const a = new Promise((u, c) => {
    n = setTimeout(() => {
      clearTimeout(n), c("timeout");
    }, 1e3 * o);
  });
  return { timeoutId: n, timeoutPromise: a };
}
function stripTrailingSlash(o) {
  return o.endsWith("/") ? o.slice(0, -1) : o;
}
function indent(o) {
  return "".padEnd(2 * o, " ");
}
function bufToBn(o) {
  const n = [];
  return Uint8Array.from(o).forEach(function(a) {
    let u = a.toString(16);
    u.length % 2 && (u = "0" + u), n.push(u);
  }), BigInt("0x" + n.join(""));
}
function isomorphicRandomUUID() {
  return isBrowser() && self.crypto ? self.crypto.randomUUID() : (0, crypto_1.randomUUID)();
}
utils$n.descS = descS, utils$n.timeout = timeout, utils$n.stripTrailingSlash = stripTrailingSlash, utils$n.indent = indent, utils$n.bufToBn = bufToBn, utils$n.isomorphicRandomUUID = isomorphicRandomUUID;
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
var DefaultStateEvaluator$1 = {}, elliptic$1 = {};
const name = "elliptic", version = "6.5.4", description = "EC cryptography", main = "lib/elliptic.js", files = ["lib"], scripts = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository = { type: "git", url: "git@github.com:indutny/elliptic" }, keywords = ["EC", "Elliptic", "curve", "Cryptography"], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = { url: "https://github.com/indutny/elliptic/issues" }, homepage = "https://github.com/indutny/elliptic", devDependencies = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" }, require$$0$2 = { name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies };
var utils$m = {}, bn$2 = { exports: {} };
(function(o, n) {
  function a(p, $) {
    if (!p)
      throw new Error($ || "Assertion failed");
  }
  function u(p, $) {
    p.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, p.prototype = new _(), p.prototype.constructor = p;
  }
  function c(p, $, _) {
    if (c.isBN(p))
      return p;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(p || 0, $ || 10, _ || "be"));
  }
  var m;
  typeof bn$2 == "object" ? bn$2.exports = c : n.BN = c, c.BN = c, c.wordSize = 26;
  try {
    m = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(p, $) {
    var _ = p.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(p, $, _) {
    var y = d(p, _);
    return _ - 1 >= $ && (y |= d(p, _ - 1) << 4), y;
  }
  function S(p, $, _, y) {
    for (var g = 0, v = Math.min(p.length, _), E = $; E < v; E++) {
      var A = p.charCodeAt(E) - 48;
      g *= y, g += A >= 49 ? A - 49 + 10 : A >= 17 ? A - 17 + 10 : A;
    }
    return g;
  }
  c.isBN = function(p) {
    return p instanceof c || p !== null && typeof p == "object" && p.constructor.wordSize === c.wordSize && Array.isArray(p.words);
  }, c.max = function(p, $) {
    return p.cmp($) > 0 ? p : $;
  }, c.min = function(p, $) {
    return p.cmp($) < 0 ? p : $;
  }, c.prototype._init = function(p, $, _) {
    if (typeof p == "number")
      return this._initNumber(p, $, _);
    if (typeof p == "object")
      return this._initArray(p, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var y = 0;
    (p = p.toString().replace(/\s+/g, ""))[0] === "-" && (y++, this.negative = 1), y < p.length && ($ === 16 ? this._parseHex(p, y, _) : (this._parseBase(p, $, y), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(p, $, _) {
    p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [67108863 & p], this.length = 1) : p < 4503599627370496 ? (this.words = [67108863 & p, p / 67108864 & 67108863], this.length = 2) : (a(p < 9007199254740992), this.words = [67108863 & p, p / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(p, $, _) {
    if (a(typeof p.length == "number"), p.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v, E = 0;
    if (_ === "be")
      for (y = p.length - 1, g = 0; y >= 0; y -= 3)
        v = p[y] | p[y - 1] << 8 | p[y - 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    else if (_ === "le")
      for (y = 0, g = 0; y < p.length; y += 3)
        v = p[y] | p[y + 1] << 8 | p[y + 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    return this.strip();
  }, c.prototype._parseHex = function(p, $, _) {
    this.length = Math.ceil((p.length - $) / 6), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v = 0, E = 0;
    if (_ === "be")
      for (y = p.length - 1; y >= $; y -= 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    else
      for (y = (p.length - $) % 2 == 0 ? $ + 1 : $; y < p.length; y += 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(p, $, _) {
    this.words = [0], this.length = 1;
    for (var y = 0, g = 1; g <= 67108863; g *= $)
      y++;
    y--, g = g / $ | 0;
    for (var v = p.length - _, E = v % y, A = Math.min(v, v - E) + _, L = 0, j = _; j < A; j += y)
      L = S(p, j, j + y, $), this.imuln(g), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    if (E !== 0) {
      var J = 1;
      for (L = S(p, j, p.length, $), j = 0; j < E; j++)
        J *= $;
      this.imuln(J), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    }
    this.strip();
  }, c.prototype.copy = function(p) {
    p.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      p.words[$] = this.words[$];
    p.length = this.length, p.negative = this.negative, p.red = this.red;
  }, c.prototype.clone = function() {
    var p = new c(null);
    return this.copy(p), p;
  }, c.prototype._expand = function(p) {
    for (; this.length < p; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var T = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(p, $, _) {
    _.negative = $.negative ^ p.negative;
    var y = p.length + $.length | 0;
    _.length = y, y = y - 1 | 0;
    var g = 0 | p.words[0], v = 0 | $.words[0], E = g * v, A = 67108863 & E, L = E / 67108864 | 0;
    _.words[0] = A;
    for (var j = 1; j < y; j++) {
      for (var J = L >>> 26, X = 67108863 & L, re = Math.min(j, $.length - 1), Z = Math.max(0, j - p.length + 1); Z <= re; Z++) {
        var ie = j - Z | 0;
        J += (E = (g = 0 | p.words[ie]) * (v = 0 | $.words[Z]) + X) / 67108864 | 0, X = 67108863 & E;
      }
      _.words[j] = 0 | X, L = 0 | J;
    }
    return L !== 0 ? _.words[j] = 0 | L : _.length--, _.strip();
  }
  c.prototype.toString = function(p, $) {
    var _;
    if ($ = 0 | $ || 1, (p = p || 10) === 16 || p === "hex") {
      _ = "";
      for (var y = 0, g = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], A = (16777215 & (E << y | g)).toString(16);
        _ = (g = E >>> 24 - y & 16777215) != 0 || v !== this.length - 1 ? T[6 - A.length] + A + _ : A + _, (y += 2) >= 26 && (y -= 26, v--);
      }
      for (g !== 0 && (_ = g.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (p === (0 | p) && p >= 2 && p <= 36) {
      var L = B[p], j = I[p];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var X = J.modn(j).toString(p);
        _ = (J = J.idivn(j)).isZero() ? X + _ : T[L - X.length] + X + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var p = this.words[0];
    return this.length === 2 ? p += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(p, $) {
    return a(m !== void 0), this.toArrayLike(m, p, $);
  }, c.prototype.toArray = function(p, $) {
    return this.toArrayLike(Array, p, $);
  }, c.prototype.toArrayLike = function(p, $, _) {
    var y = this.byteLength(), g = _ || Math.max(1, y);
    a(y <= g, "byte array longer than desired length"), a(g > 0, "Requested array length <= 0"), this.strip();
    var v, E, A = $ === "le", L = new p(g), j = this.clone();
    if (A) {
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[E] = v;
      for (; E < g; E++)
        L[E] = 0;
    } else {
      for (E = 0; E < g - y; E++)
        L[E] = 0;
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[g - E - 1] = v;
    }
    return L;
  }, Math.clz32 ? c.prototype._countBits = function(p) {
    return 32 - Math.clz32(p);
  } : c.prototype._countBits = function(p) {
    var $ = p, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(p) {
    if (p === 0)
      return 26;
    var $ = p, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var p = this.words[this.length - 1], $ = this._countBits(p);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var p = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (p += _, _ !== 26)
        break;
    }
    return p;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(p) {
    return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(p) {
    return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(p) {
    for (; this.length < p.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < p.length; $++)
      this.words[$] = this.words[$] | p.words[$];
    return this.strip();
  }, c.prototype.ior = function(p) {
    return a((this.negative | p.negative) == 0), this.iuor(p);
  }, c.prototype.or = function(p) {
    return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
  }, c.prototype.uor = function(p) {
    return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
  }, c.prototype.iuand = function(p) {
    var $;
    $ = this.length > p.length ? p : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & p.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(p) {
    return a((this.negative | p.negative) == 0), this.iuand(p);
  }, c.prototype.and = function(p) {
    return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
  }, c.prototype.uand = function(p) {
    return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
  }, c.prototype.iuxor = function(p) {
    var $, _;
    this.length > p.length ? ($ = this, _ = p) : ($ = p, _ = this);
    for (var y = 0; y < _.length; y++)
      this.words[y] = $.words[y] ^ _.words[y];
    if (this !== $)
      for (; y < $.length; y++)
        this.words[y] = $.words[y];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(p) {
    return a((this.negative | p.negative) == 0), this.iuxor(p);
  }, c.prototype.xor = function(p) {
    return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
  }, c.prototype.uxor = function(p) {
    return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
  }, c.prototype.inotn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = 0 | Math.ceil(p / 26), _ = p % 26;
    this._expand($), _ > 0 && $--;
    for (var y = 0; y < $; y++)
      this.words[y] = 67108863 & ~this.words[y];
    return _ > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(p) {
    return this.clone().inotn(p);
  }, c.prototype.setn = function(p, $) {
    a(typeof p == "number" && p >= 0);
    var _ = p / 26 | 0, y = p % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << y : this.words[_] & ~(1 << y), this.strip();
  }, c.prototype.iadd = function(p) {
    var $, _, y;
    if (this.negative !== 0 && p.negative === 0)
      return this.negative = 0, $ = this.isub(p), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && p.negative !== 0)
      return p.negative = 0, $ = this.isub(p), p.negative = 1, $._normSign();
    this.length > p.length ? (_ = this, y = p) : (_ = p, y = this);
    for (var g = 0, v = 0; v < y.length; v++)
      $ = (0 | _.words[v]) + (0 | y.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    for (; g !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    if (this.length = _.length, g !== 0)
      this.words[this.length] = g, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(p) {
    var $;
    return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, $ = this.sub(p), p.negative ^= 1, $) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = p.sub(this), this.negative = 1, $) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
  }, c.prototype.isub = function(p) {
    if (p.negative !== 0) {
      p.negative = 0;
      var $ = this.iadd(p);
      return p.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
    var _, y, g = this.cmp(p);
    if (g === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    g > 0 ? (_ = this, y = p) : (_ = p, y = this);
    for (var v = 0, E = 0; E < y.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | y.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(p) {
    return this.clone().isub(p);
  };
  var N = function(p, $, _) {
    var y, g, v, E = p.words, A = $.words, L = _.words, j = 0, J = 0 | E[0], X = 8191 & J, re = J >>> 13, Z = 0 | E[1], ie = 8191 & Z, oe = Z >>> 13, ue = 0 | E[2], se = 8191 & ue, ce = ue >>> 13, Se = 0 | E[3], he = 8191 & Se, $e = Se >>> 13, fe = 0 | E[4], le = 8191 & fe, we = fe >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, b = l >>> 13, M = 0 | E[7], k = 8191 & M, x = M >>> 13, O = 0 | E[8], G = 8191 & O, Q = O >>> 13, ne = 0 | E[9], Y = 8191 & ne, ae = ne >>> 13, Ee = 0 | A[0], pe = 8191 & Ee, ye = Ee >>> 13, Le = 0 | A[1], ge = 8191 & Le, be = Le >>> 13, Re = 0 | A[2], me = 8191 & Re, Ae = Re >>> 13, He = 0 | A[3], ve = 8191 & He, Me = He >>> 13, Fe = 0 | A[4], _e = 8191 & Fe, Oe = Fe >>> 13, qe = 0 | A[5], Te = 8191 & qe, Pe = qe >>> 13, ze = 0 | A[6], xe = 8191 & ze, Ne = ze >>> 13, Ve = 0 | A[7], Be = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | A[8], Ie = 8191 & Je, je = Je >>> 13, Xe = 0 | A[9], Ce = 8191 & Xe, De = Xe >>> 13;
    _.negative = p.negative ^ $.negative, _.length = 19;
    var Ge = (j + (y = Math.imul(X, pe)) | 0) + ((8191 & (g = (g = Math.imul(X, ye)) + Math.imul(re, pe) | 0)) << 13) | 0;
    j = ((v = Math.imul(re, ye)) + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, y = Math.imul(ie, pe), g = (g = Math.imul(ie, ye)) + Math.imul(oe, pe) | 0, v = Math.imul(oe, ye);
    var Ke = (j + (y = y + Math.imul(X, ge) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, be) | 0) + Math.imul(re, ge) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, be) | 0) + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, y = Math.imul(se, pe), g = (g = Math.imul(se, ye)) + Math.imul(ce, pe) | 0, v = Math.imul(ce, ye), y = y + Math.imul(ie, ge) | 0, g = (g = g + Math.imul(ie, be) | 0) + Math.imul(oe, ge) | 0, v = v + Math.imul(oe, be) | 0;
    var Ye = (j + (y = y + Math.imul(X, me) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ae) | 0) + Math.imul(re, me) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ae) | 0) + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, y = Math.imul(he, pe), g = (g = Math.imul(he, ye)) + Math.imul($e, pe) | 0, v = Math.imul($e, ye), y = y + Math.imul(se, ge) | 0, g = (g = g + Math.imul(se, be) | 0) + Math.imul(ce, ge) | 0, v = v + Math.imul(ce, be) | 0, y = y + Math.imul(ie, me) | 0, g = (g = g + Math.imul(ie, Ae) | 0) + Math.imul(oe, me) | 0, v = v + Math.imul(oe, Ae) | 0;
    var Ze = (j + (y = y + Math.imul(X, ve) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Me) | 0) + Math.imul(re, ve) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Me) | 0) + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, y = Math.imul(le, pe), g = (g = Math.imul(le, ye)) + Math.imul(we, pe) | 0, v = Math.imul(we, ye), y = y + Math.imul(he, ge) | 0, g = (g = g + Math.imul(he, be) | 0) + Math.imul($e, ge) | 0, v = v + Math.imul($e, be) | 0, y = y + Math.imul(se, me) | 0, g = (g = g + Math.imul(se, Ae) | 0) + Math.imul(ce, me) | 0, v = v + Math.imul(ce, Ae) | 0, y = y + Math.imul(ie, ve) | 0, g = (g = g + Math.imul(ie, Me) | 0) + Math.imul(oe, ve) | 0, v = v + Math.imul(oe, Me) | 0;
    var Qe = (j + (y = y + Math.imul(X, _e) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Oe) | 0) + Math.imul(re, _e) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Oe) | 0) + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, y = Math.imul(de, pe), g = (g = Math.imul(de, ye)) + Math.imul(ke, pe) | 0, v = Math.imul(ke, ye), y = y + Math.imul(le, ge) | 0, g = (g = g + Math.imul(le, be) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, be) | 0, y = y + Math.imul(he, me) | 0, g = (g = g + Math.imul(he, Ae) | 0) + Math.imul($e, me) | 0, v = v + Math.imul($e, Ae) | 0, y = y + Math.imul(se, ve) | 0, g = (g = g + Math.imul(se, Me) | 0) + Math.imul(ce, ve) | 0, v = v + Math.imul(ce, Me) | 0, y = y + Math.imul(ie, _e) | 0, g = (g = g + Math.imul(ie, Oe) | 0) + Math.imul(oe, _e) | 0, v = v + Math.imul(oe, Oe) | 0;
    var et = (j + (y = y + Math.imul(X, Te) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Pe) | 0) + Math.imul(re, Te) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Pe) | 0) + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, y = Math.imul(h, pe), g = (g = Math.imul(h, ye)) + Math.imul(b, pe) | 0, v = Math.imul(b, ye), y = y + Math.imul(de, ge) | 0, g = (g = g + Math.imul(de, be) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, be) | 0, y = y + Math.imul(le, me) | 0, g = (g = g + Math.imul(le, Ae) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ae) | 0, y = y + Math.imul(he, ve) | 0, g = (g = g + Math.imul(he, Me) | 0) + Math.imul($e, ve) | 0, v = v + Math.imul($e, Me) | 0, y = y + Math.imul(se, _e) | 0, g = (g = g + Math.imul(se, Oe) | 0) + Math.imul(ce, _e) | 0, v = v + Math.imul(ce, Oe) | 0, y = y + Math.imul(ie, Te) | 0, g = (g = g + Math.imul(ie, Pe) | 0) + Math.imul(oe, Te) | 0, v = v + Math.imul(oe, Pe) | 0;
    var tt = (j + (y = y + Math.imul(X, xe) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ne) | 0) + Math.imul(re, xe) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ne) | 0) + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, y = Math.imul(k, pe), g = (g = Math.imul(k, ye)) + Math.imul(x, pe) | 0, v = Math.imul(x, ye), y = y + Math.imul(h, ge) | 0, g = (g = g + Math.imul(h, be) | 0) + Math.imul(b, ge) | 0, v = v + Math.imul(b, be) | 0, y = y + Math.imul(de, me) | 0, g = (g = g + Math.imul(de, Ae) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ae) | 0, y = y + Math.imul(le, ve) | 0, g = (g = g + Math.imul(le, Me) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Me) | 0, y = y + Math.imul(he, _e) | 0, g = (g = g + Math.imul(he, Oe) | 0) + Math.imul($e, _e) | 0, v = v + Math.imul($e, Oe) | 0, y = y + Math.imul(se, Te) | 0, g = (g = g + Math.imul(se, Pe) | 0) + Math.imul(ce, Te) | 0, v = v + Math.imul(ce, Pe) | 0, y = y + Math.imul(ie, xe) | 0, g = (g = g + Math.imul(ie, Ne) | 0) + Math.imul(oe, xe) | 0, v = v + Math.imul(oe, Ne) | 0;
    var rt = (j + (y = y + Math.imul(X, Be) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ue) | 0) + Math.imul(re, Be) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ue) | 0) + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, y = Math.imul(G, pe), g = (g = Math.imul(G, ye)) + Math.imul(Q, pe) | 0, v = Math.imul(Q, ye), y = y + Math.imul(k, ge) | 0, g = (g = g + Math.imul(k, be) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, be) | 0, y = y + Math.imul(h, me) | 0, g = (g = g + Math.imul(h, Ae) | 0) + Math.imul(b, me) | 0, v = v + Math.imul(b, Ae) | 0, y = y + Math.imul(de, ve) | 0, g = (g = g + Math.imul(de, Me) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Me) | 0, y = y + Math.imul(le, _e) | 0, g = (g = g + Math.imul(le, Oe) | 0) + Math.imul(we, _e) | 0, v = v + Math.imul(we, Oe) | 0, y = y + Math.imul(he, Te) | 0, g = (g = g + Math.imul(he, Pe) | 0) + Math.imul($e, Te) | 0, v = v + Math.imul($e, Pe) | 0, y = y + Math.imul(se, xe) | 0, g = (g = g + Math.imul(se, Ne) | 0) + Math.imul(ce, xe) | 0, v = v + Math.imul(ce, Ne) | 0, y = y + Math.imul(ie, Be) | 0, g = (g = g + Math.imul(ie, Ue) | 0) + Math.imul(oe, Be) | 0, v = v + Math.imul(oe, Ue) | 0;
    var nt = (j + (y = y + Math.imul(X, Ie) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, je) | 0) + Math.imul(re, Ie) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, je) | 0) + (g >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, y = Math.imul(Y, pe), g = (g = Math.imul(Y, ye)) + Math.imul(ae, pe) | 0, v = Math.imul(ae, ye), y = y + Math.imul(G, ge) | 0, g = (g = g + Math.imul(G, be) | 0) + Math.imul(Q, ge) | 0, v = v + Math.imul(Q, be) | 0, y = y + Math.imul(k, me) | 0, g = (g = g + Math.imul(k, Ae) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ae) | 0, y = y + Math.imul(h, ve) | 0, g = (g = g + Math.imul(h, Me) | 0) + Math.imul(b, ve) | 0, v = v + Math.imul(b, Me) | 0, y = y + Math.imul(de, _e) | 0, g = (g = g + Math.imul(de, Oe) | 0) + Math.imul(ke, _e) | 0, v = v + Math.imul(ke, Oe) | 0, y = y + Math.imul(le, Te) | 0, g = (g = g + Math.imul(le, Pe) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Pe) | 0, y = y + Math.imul(he, xe) | 0, g = (g = g + Math.imul(he, Ne) | 0) + Math.imul($e, xe) | 0, v = v + Math.imul($e, Ne) | 0, y = y + Math.imul(se, Be) | 0, g = (g = g + Math.imul(se, Ue) | 0) + Math.imul(ce, Be) | 0, v = v + Math.imul(ce, Ue) | 0, y = y + Math.imul(ie, Ie) | 0, g = (g = g + Math.imul(ie, je) | 0) + Math.imul(oe, Ie) | 0, v = v + Math.imul(oe, je) | 0;
    var it = (j + (y = y + Math.imul(X, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, De) | 0) + Math.imul(re, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, De) | 0) + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, y = Math.imul(Y, ge), g = (g = Math.imul(Y, be)) + Math.imul(ae, ge) | 0, v = Math.imul(ae, be), y = y + Math.imul(G, me) | 0, g = (g = g + Math.imul(G, Ae) | 0) + Math.imul(Q, me) | 0, v = v + Math.imul(Q, Ae) | 0, y = y + Math.imul(k, ve) | 0, g = (g = g + Math.imul(k, Me) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Me) | 0, y = y + Math.imul(h, _e) | 0, g = (g = g + Math.imul(h, Oe) | 0) + Math.imul(b, _e) | 0, v = v + Math.imul(b, Oe) | 0, y = y + Math.imul(de, Te) | 0, g = (g = g + Math.imul(de, Pe) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Pe) | 0, y = y + Math.imul(le, xe) | 0, g = (g = g + Math.imul(le, Ne) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ne) | 0, y = y + Math.imul(he, Be) | 0, g = (g = g + Math.imul(he, Ue) | 0) + Math.imul($e, Be) | 0, v = v + Math.imul($e, Ue) | 0, y = y + Math.imul(se, Ie) | 0, g = (g = g + Math.imul(se, je) | 0) + Math.imul(ce, Ie) | 0, v = v + Math.imul(ce, je) | 0;
    var ot = (j + (y = y + Math.imul(ie, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(ie, De) | 0) + Math.imul(oe, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(oe, De) | 0) + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, y = Math.imul(Y, me), g = (g = Math.imul(Y, Ae)) + Math.imul(ae, me) | 0, v = Math.imul(ae, Ae), y = y + Math.imul(G, ve) | 0, g = (g = g + Math.imul(G, Me) | 0) + Math.imul(Q, ve) | 0, v = v + Math.imul(Q, Me) | 0, y = y + Math.imul(k, _e) | 0, g = (g = g + Math.imul(k, Oe) | 0) + Math.imul(x, _e) | 0, v = v + Math.imul(x, Oe) | 0, y = y + Math.imul(h, Te) | 0, g = (g = g + Math.imul(h, Pe) | 0) + Math.imul(b, Te) | 0, v = v + Math.imul(b, Pe) | 0, y = y + Math.imul(de, xe) | 0, g = (g = g + Math.imul(de, Ne) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ne) | 0, y = y + Math.imul(le, Be) | 0, g = (g = g + Math.imul(le, Ue) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, Ue) | 0, y = y + Math.imul(he, Ie) | 0, g = (g = g + Math.imul(he, je) | 0) + Math.imul($e, Ie) | 0, v = v + Math.imul($e, je) | 0;
    var at = (j + (y = y + Math.imul(se, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(se, De) | 0) + Math.imul(ce, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ce, De) | 0) + (g >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, y = Math.imul(Y, ve), g = (g = Math.imul(Y, Me)) + Math.imul(ae, ve) | 0, v = Math.imul(ae, Me), y = y + Math.imul(G, _e) | 0, g = (g = g + Math.imul(G, Oe) | 0) + Math.imul(Q, _e) | 0, v = v + Math.imul(Q, Oe) | 0, y = y + Math.imul(k, Te) | 0, g = (g = g + Math.imul(k, Pe) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Pe) | 0, y = y + Math.imul(h, xe) | 0, g = (g = g + Math.imul(h, Ne) | 0) + Math.imul(b, xe) | 0, v = v + Math.imul(b, Ne) | 0, y = y + Math.imul(de, Be) | 0, g = (g = g + Math.imul(de, Ue) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, Ue) | 0, y = y + Math.imul(le, Ie) | 0, g = (g = g + Math.imul(le, je) | 0) + Math.imul(we, Ie) | 0, v = v + Math.imul(we, je) | 0;
    var st = (j + (y = y + Math.imul(he, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(he, De) | 0) + Math.imul($e, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul($e, De) | 0) + (g >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, y = Math.imul(Y, _e), g = (g = Math.imul(Y, Oe)) + Math.imul(ae, _e) | 0, v = Math.imul(ae, Oe), y = y + Math.imul(G, Te) | 0, g = (g = g + Math.imul(G, Pe) | 0) + Math.imul(Q, Te) | 0, v = v + Math.imul(Q, Pe) | 0, y = y + Math.imul(k, xe) | 0, g = (g = g + Math.imul(k, Ne) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ne) | 0, y = y + Math.imul(h, Be) | 0, g = (g = g + Math.imul(h, Ue) | 0) + Math.imul(b, Be) | 0, v = v + Math.imul(b, Ue) | 0, y = y + Math.imul(de, Ie) | 0, g = (g = g + Math.imul(de, je) | 0) + Math.imul(ke, Ie) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (j + (y = y + Math.imul(le, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(le, De) | 0) + Math.imul(we, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(we, De) | 0) + (g >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, y = Math.imul(Y, Te), g = (g = Math.imul(Y, Pe)) + Math.imul(ae, Te) | 0, v = Math.imul(ae, Pe), y = y + Math.imul(G, xe) | 0, g = (g = g + Math.imul(G, Ne) | 0) + Math.imul(Q, xe) | 0, v = v + Math.imul(Q, Ne) | 0, y = y + Math.imul(k, Be) | 0, g = (g = g + Math.imul(k, Ue) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, Ue) | 0, y = y + Math.imul(h, Ie) | 0, g = (g = g + Math.imul(h, je) | 0) + Math.imul(b, Ie) | 0, v = v + Math.imul(b, je) | 0;
    var ct = (j + (y = y + Math.imul(de, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(de, De) | 0) + Math.imul(ke, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ke, De) | 0) + (g >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, y = Math.imul(Y, xe), g = (g = Math.imul(Y, Ne)) + Math.imul(ae, xe) | 0, v = Math.imul(ae, Ne), y = y + Math.imul(G, Be) | 0, g = (g = g + Math.imul(G, Ue) | 0) + Math.imul(Q, Be) | 0, v = v + Math.imul(Q, Ue) | 0, y = y + Math.imul(k, Ie) | 0, g = (g = g + Math.imul(k, je) | 0) + Math.imul(x, Ie) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (j + (y = y + Math.imul(h, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(h, De) | 0) + Math.imul(b, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(b, De) | 0) + (g >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, y = Math.imul(Y, Be), g = (g = Math.imul(Y, Ue)) + Math.imul(ae, Be) | 0, v = Math.imul(ae, Ue), y = y + Math.imul(G, Ie) | 0, g = (g = g + Math.imul(G, je) | 0) + Math.imul(Q, Ie) | 0, v = v + Math.imul(Q, je) | 0;
    var ht = (j + (y = y + Math.imul(k, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(k, De) | 0) + Math.imul(x, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(x, De) | 0) + (g >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, y = Math.imul(Y, Ie), g = (g = Math.imul(Y, je)) + Math.imul(ae, Ie) | 0, v = Math.imul(ae, je);
    var dt = (j + (y = y + Math.imul(G, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(G, De) | 0) + Math.imul(Q, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(Q, De) | 0) + (g >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (j + (y = Math.imul(Y, Ce)) | 0) + ((8191 & (g = (g = Math.imul(Y, De)) + Math.imul(ae, Ce) | 0)) << 13) | 0;
    return j = ((v = Math.imul(ae, De)) + (g >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L[0] = Ge, L[1] = Ke, L[2] = Ye, L[3] = Ze, L[4] = Qe, L[5] = et, L[6] = tt, L[7] = rt, L[8] = nt, L[9] = it, L[10] = ot, L[11] = at, L[12] = st, L[13] = ut, L[14] = ct, L[15] = ft, L[16] = ht, L[17] = dt, L[18] = pt, j !== 0 && (L[19] = j, _.length++), _;
  };
  function q(p, $, _) {
    return new D().mulp(p, $, _);
  }
  function D(p, $) {
    this.x = p, this.y = $;
  }
  Math.imul || (N = C), c.prototype.mulTo = function(p, $) {
    var _, y = this.length + p.length;
    return _ = this.length === 10 && p.length === 10 ? N(this, p, $) : y < 63 ? C(this, p, $) : y < 1024 ? function(g, v, E) {
      E.negative = v.negative ^ g.negative, E.length = g.length + v.length;
      for (var A = 0, L = 0, j = 0; j < E.length - 1; j++) {
        var J = L;
        L = 0;
        for (var X = 67108863 & A, re = Math.min(j, v.length - 1), Z = Math.max(0, j - g.length + 1); Z <= re; Z++) {
          var ie = j - Z, oe = (0 | g.words[ie]) * (0 | v.words[Z]), ue = 67108863 & oe;
          X = 67108863 & (ue = ue + X | 0), L += (J = (J = J + (oe / 67108864 | 0) | 0) + (ue >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[j] = X, A = J, J = L;
      }
      return A !== 0 ? E.words[j] = A : E.length--, E.strip();
    }(this, p, $) : q(this, p, $), _;
  }, D.prototype.makeRBT = function(p) {
    for (var $ = new Array(p), _ = c.prototype._countBits(p) - 1, y = 0; y < p; y++)
      $[y] = this.revBin(y, _, p);
    return $;
  }, D.prototype.revBin = function(p, $, _) {
    if (p === 0 || p === _ - 1)
      return p;
    for (var y = 0, g = 0; g < $; g++)
      y |= (1 & p) << $ - g - 1, p >>= 1;
    return y;
  }, D.prototype.permute = function(p, $, _, y, g, v) {
    for (var E = 0; E < v; E++)
      y[E] = $[p[E]], g[E] = _[p[E]];
  }, D.prototype.transform = function(p, $, _, y, g, v) {
    this.permute(v, p, $, _, y, g);
    for (var E = 1; E < g; E <<= 1)
      for (var A = E << 1, L = Math.cos(2 * Math.PI / A), j = Math.sin(2 * Math.PI / A), J = 0; J < g; J += A)
        for (var X = L, re = j, Z = 0; Z < E; Z++) {
          var ie = _[J + Z], oe = y[J + Z], ue = _[J + Z + E], se = y[J + Z + E], ce = X * ue - re * se;
          se = X * se + re * ue, ue = ce, _[J + Z] = ie + ue, y[J + Z] = oe + se, _[J + Z + E] = ie - ue, y[J + Z + E] = oe - se, Z !== A && (ce = L * X - j * re, re = L * re + j * X, X = ce);
        }
  }, D.prototype.guessLen13b = function(p, $) {
    var _ = 1 | Math.max($, p), y = 1 & _, g = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      g++;
    return 1 << g + 1 + y;
  }, D.prototype.conjugate = function(p, $, _) {
    if (!(_ <= 1))
      for (var y = 0; y < _ / 2; y++) {
        var g = p[y];
        p[y] = p[_ - y - 1], p[_ - y - 1] = g, g = $[y], $[y] = -$[_ - y - 1], $[_ - y - 1] = -g;
      }
  }, D.prototype.normalize13b = function(p, $) {
    for (var _ = 0, y = 0; y < $ / 2; y++) {
      var g = 8192 * Math.round(p[2 * y + 1] / $) + Math.round(p[2 * y] / $) + _;
      p[y] = 67108863 & g, _ = g < 67108864 ? 0 : g / 67108864 | 0;
    }
    return p;
  }, D.prototype.convert13b = function(p, $, _, y) {
    for (var g = 0, v = 0; v < $; v++)
      g += 0 | p[v], _[2 * v] = 8191 & g, g >>>= 13, _[2 * v + 1] = 8191 & g, g >>>= 13;
    for (v = 2 * $; v < y; ++v)
      _[v] = 0;
    a(g === 0), a((-8192 & g) == 0);
  }, D.prototype.stub = function(p) {
    for (var $ = new Array(p), _ = 0; _ < p; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(p, $, _) {
    var y = 2 * this.guessLen13b(p.length, $.length), g = this.makeRBT(y), v = this.stub(y), E = new Array(y), A = new Array(y), L = new Array(y), j = new Array(y), J = new Array(y), X = new Array(y), re = _.words;
    re.length = y, this.convert13b(p.words, p.length, E, y), this.convert13b($.words, $.length, j, y), this.transform(E, v, A, L, y, g), this.transform(j, v, J, X, y, g);
    for (var Z = 0; Z < y; Z++) {
      var ie = A[Z] * J[Z] - L[Z] * X[Z];
      L[Z] = A[Z] * X[Z] + L[Z] * J[Z], A[Z] = ie;
    }
    return this.conjugate(A, L, y), this.transform(A, L, re, v, y, g), this.conjugate(re, v, y), this.normalize13b(re, y), _.negative = p.negative ^ $.negative, _.length = p.length + $.length, _.strip();
  }, c.prototype.mul = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), this.mulTo(p, $);
  }, c.prototype.mulf = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), q(this, p, $);
  }, c.prototype.imul = function(p) {
    return this.clone().mulTo(p, this);
  }, c.prototype.imuln = function(p) {
    a(typeof p == "number"), a(p < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var y = (0 | this.words[_]) * p, g = (67108863 & y) + (67108863 & $);
      $ >>= 26, $ += y / 67108864 | 0, $ += g >>> 26, this.words[_] = 67108863 & g;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(p) {
    return this.clone().imuln(p);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(p) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), A = 0; A < E.length; A++) {
        var L = A / 26 | 0, j = A % 26;
        E[A] = (v.words[L] & 1 << j) >>> j;
      }
      return E;
    }(p);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, y = 0; y < $.length && $[y] === 0; y++, _ = _.sqr())
      ;
    if (++y < $.length)
      for (var g = _.sqr(); y < $.length; y++, g = g.sqr())
        $[y] !== 0 && (_ = _.mul(g));
    return _;
  }, c.prototype.iushln = function(p) {
    a(typeof p == "number" && p >= 0);
    var $, _ = p % 26, y = (p - _) / 26, g = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & g, A = (0 | this.words[$]) - E << _;
        this.words[$] = A | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (y !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + y] = this.words[$];
      for ($ = 0; $ < y; $++)
        this.words[$] = 0;
      this.length += y;
    }
    return this.strip();
  }, c.prototype.ishln = function(p) {
    return a(this.negative === 0), this.iushln(p);
  }, c.prototype.iushrn = function(p, $, _) {
    var y;
    a(typeof p == "number" && p >= 0), y = $ ? ($ - $ % 26) / 26 : 0;
    var g = p % 26, v = Math.min((p - g) / 26, this.length), E = 67108863 ^ 67108863 >>> g << g, A = _;
    if (y -= v, y = Math.max(0, y), A) {
      for (var L = 0; L < v; L++)
        A.words[L] = this.words[L];
      A.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, L = 0; L < this.length; L++)
          this.words[L] = this.words[L + v];
      else
        this.words[0] = 0, this.length = 1;
    var j = 0;
    for (L = this.length - 1; L >= 0 && (j !== 0 || L >= y); L--) {
      var J = 0 | this.words[L];
      this.words[L] = j << 26 - g | J >>> g, j = J & E;
    }
    return A && j !== 0 && (A.words[A.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(p, $, _) {
    return a(this.negative === 0), this.iushrn(p, $, _);
  }, c.prototype.shln = function(p) {
    return this.clone().ishln(p);
  }, c.prototype.ushln = function(p) {
    return this.clone().iushln(p);
  }, c.prototype.shrn = function(p) {
    return this.clone().ishrn(p);
  }, c.prototype.ushrn = function(p) {
    return this.clone().iushrn(p);
  }, c.prototype.testn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    return !(this.length <= _ || !(this.words[_] & y));
  }, c.prototype.imaskn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var y = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= y;
    }
    return this.strip();
  }, c.prototype.maskn = function(p) {
    return this.clone().imaskn(p);
  }, c.prototype.iaddn = function(p) {
    return a(typeof p == "number"), a(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < p ? (this.words[0] = p - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
  }, c.prototype._iaddn = function(p) {
    this.words[0] += p;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(p) {
    if (a(typeof p == "number"), a(p < 67108864), p < 0)
      return this.iaddn(-p);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(p), this.negative = 1, this;
    if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(p) {
    return this.clone().iaddn(p);
  }, c.prototype.subn = function(p) {
    return this.clone().isubn(p);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(p, $, _) {
    var y, g, v = p.length + _;
    this._expand(v);
    var E = 0;
    for (y = 0; y < p.length; y++) {
      g = (0 | this.words[y + _]) + E;
      var A = (0 | p.words[y]) * $;
      E = ((g -= 67108863 & A) >> 26) - (A / 67108864 | 0), this.words[y + _] = 67108863 & g;
    }
    for (; y < this.length - _; y++)
      E = (g = (0 | this.words[y + _]) + E) >> 26, this.words[y + _] = 67108863 & g;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, y = 0; y < this.length; y++)
      E = (g = -(0 | this.words[y]) + E) >> 26, this.words[y] = 67108863 & g;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(p, $) {
    var _ = (this.length, p.length), y = this.clone(), g = p, v = 0 | g.words[g.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (g = g.ushln(_), y.iushln(_), v = 0 | g.words[g.length - 1]);
    var E, A = y.length - g.length;
    if ($ !== "mod") {
      (E = new c(null)).length = A + 1, E.words = new Array(E.length);
      for (var L = 0; L < E.length; L++)
        E.words[L] = 0;
    }
    var j = y.clone()._ishlnsubmul(g, 1, A);
    j.negative === 0 && (y = j, E && (E.words[A] = 1));
    for (var J = A - 1; J >= 0; J--) {
      var X = 67108864 * (0 | y.words[g.length + J]) + (0 | y.words[g.length + J - 1]);
      for (X = Math.min(X / v | 0, 67108863), y._ishlnsubmul(g, X, J); y.negative !== 0; )
        X--, y.negative = 0, y._ishlnsubmul(g, 1, J), y.isZero() || (y.negative ^= 1);
      E && (E.words[J] = X);
    }
    return E && E.strip(), y.strip(), $ !== "div" && _ !== 0 && y.iushrn(_), { div: E || null, mod: y };
  }, c.prototype.divmod = function(p, $, _) {
    return a(!p.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && p.negative === 0 ? (v = this.neg().divmod(p, $), $ !== "mod" && (y = v.div.neg()), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.iadd(p)), { div: y, mod: g }) : this.negative === 0 && p.negative !== 0 ? (v = this.divmod(p.neg(), $), $ !== "mod" && (y = v.div.neg()), { div: y, mod: v.mod }) : (this.negative & p.negative) != 0 ? (v = this.neg().divmod(p.neg(), $), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.isub(p)), { div: v.div, mod: g }) : p.length > this.length || this.cmp(p) < 0 ? { div: new c(0), mod: this } : p.length === 1 ? $ === "div" ? { div: this.divn(p.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(p.words[0])) } : { div: this.divn(p.words[0]), mod: new c(this.modn(p.words[0])) } : this._wordDiv(p, $);
    var y, g, v;
  }, c.prototype.div = function(p) {
    return this.divmod(p, "div", !1).div;
  }, c.prototype.mod = function(p) {
    return this.divmod(p, "mod", !1).mod;
  }, c.prototype.umod = function(p) {
    return this.divmod(p, "mod", !0).mod;
  }, c.prototype.divRound = function(p) {
    var $ = this.divmod(p);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(p) : $.mod, y = p.ushrn(1), g = p.andln(1), v = _.cmp(y);
    return v < 0 || g === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(p) {
    a(p <= 67108863);
    for (var $ = (1 << 26) % p, _ = 0, y = this.length - 1; y >= 0; y--)
      _ = ($ * _ + (0 | this.words[y])) % p;
    return _;
  }, c.prototype.idivn = function(p) {
    a(p <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = y / p | 0, $ = y % p;
    }
    return this.strip();
  }, c.prototype.divn = function(p) {
    return this.clone().idivn(p);
  }, c.prototype.egcd = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y = new c(1), g = new c(0), v = new c(0), E = new c(1), A = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++A;
    for (var L = _.clone(), j = $.clone(); !$.isZero(); ) {
      for (var J = 0, X = 1; ($.words[0] & X) == 0 && J < 26; ++J, X <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (y.isOdd() || g.isOdd()) && (y.iadd(L), g.isub(j)), y.iushrn(1), g.iushrn(1);
      for (var re = 0, Z = 1; (_.words[0] & Z) == 0 && re < 26; ++re, Z <<= 1)
        ;
      if (re > 0)
        for (_.iushrn(re); re-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(L), E.isub(j)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), y.isub(v), g.isub(E)) : (_.isub($), v.isub(y), E.isub(g));
    }
    return { a: v, b: E, gcd: _.iushln(A) };
  }, c.prototype._invmp = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y, g = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var A = 0, L = 1; ($.words[0] & L) == 0 && A < 26; ++A, L <<= 1)
        ;
      if (A > 0)
        for ($.iushrn(A); A-- > 0; )
          g.isOdd() && g.iadd(E), g.iushrn(1);
      for (var j = 0, J = 1; (_.words[0] & J) == 0 && j < 26; ++j, J <<= 1)
        ;
      if (j > 0)
        for (_.iushrn(j); j-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), g.isub(v)) : (_.isub($), v.isub(g));
    }
    return (y = $.cmpn(1) === 0 ? g : v).cmpn(0) < 0 && y.iadd(p), y;
  }, c.prototype.gcd = function(p) {
    if (this.isZero())
      return p.abs();
    if (p.isZero())
      return this.abs();
    var $ = this.clone(), _ = p.clone();
    $.negative = 0, _.negative = 0;
    for (var y = 0; $.isEven() && _.isEven(); y++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var g = $.cmp(_);
      if (g < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (g === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(y);
  }, c.prototype.invm = function(p) {
    return this.egcd(p).a.umod(p);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(p) {
    return this.words[0] & p;
  }, c.prototype.bincn = function(p) {
    a(typeof p == "number");
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= y, this;
    for (var g = y, v = _; g !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      g = (E += g) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return g !== 0 && (this.words[v] = g, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(p) {
    var $, _ = p < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (p = -p), a(p <= 67108863, "Number is too big");
      var y = 0 | this.words[0];
      $ = y === p ? 0 : y < p ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(p) {
    if (this.negative !== 0 && p.negative === 0)
      return -1;
    if (this.negative === 0 && p.negative !== 0)
      return 1;
    var $ = this.ucmp(p);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(p) {
    if (this.length > p.length)
      return 1;
    if (this.length < p.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = 0 | this.words[_], g = 0 | p.words[_];
      if (y !== g) {
        y < g ? $ = -1 : y > g && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(p) {
    return this.cmpn(p) === 1;
  }, c.prototype.gt = function(p) {
    return this.cmp(p) === 1;
  }, c.prototype.gten = function(p) {
    return this.cmpn(p) >= 0;
  }, c.prototype.gte = function(p) {
    return this.cmp(p) >= 0;
  }, c.prototype.ltn = function(p) {
    return this.cmpn(p) === -1;
  }, c.prototype.lt = function(p) {
    return this.cmp(p) === -1;
  }, c.prototype.lten = function(p) {
    return this.cmpn(p) <= 0;
  }, c.prototype.lte = function(p) {
    return this.cmp(p) <= 0;
  }, c.prototype.eqn = function(p) {
    return this.cmpn(p) === 0;
  }, c.prototype.eq = function(p) {
    return this.cmp(p) === 0;
  }, c.red = function(p) {
    return new H(p);
  }, c.prototype.toRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(p) {
    return this.red = p, this;
  }, c.prototype.forceRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(p);
  }, c.prototype.redAdd = function(p) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
  }, c.prototype.redIAdd = function(p) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
  }, c.prototype.redSub = function(p) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
  }, c.prototype.redISub = function(p) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
  }, c.prototype.redShl = function(p) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
  }, c.prototype.redMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
  }, c.prototype.redIMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(p) {
    return a(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function W(p, $) {
    this.name = p, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    W.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function ee() {
    W.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function P() {
    W.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function F() {
    W.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(p) {
    if (typeof p == "string") {
      var $ = c._prime(p);
      this.m = $.p, this.prime = $;
    } else
      a(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
  }
  function te(p) {
    H.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  W.prototype._tmp = function() {
    var p = new c(null);
    return p.words = new Array(Math.ceil(this.n / 13)), p;
  }, W.prototype.ireduce = function(p) {
    var $, _ = p;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var y = $ < this.n ? -1 : _.ucmp(this.p);
    return y === 0 ? (_.words[0] = 0, _.length = 1) : y > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, W.prototype.split = function(p, $) {
    p.iushrn(this.n, 0, $);
  }, W.prototype.imulK = function(p) {
    return p.imul(this.k);
  }, u(V, W), V.prototype.split = function(p, $) {
    for (var _ = 4194303, y = Math.min(p.length, 9), g = 0; g < y; g++)
      $.words[g] = p.words[g];
    if ($.length = y, p.length <= 9)
      return p.words[0] = 0, void (p.length = 1);
    var v = p.words[9];
    for ($.words[$.length++] = v & _, g = 10; g < p.length; g++) {
      var E = 0 | p.words[g];
      p.words[g - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, p.words[g - 10] = v, v === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
  }, V.prototype.imulK = function(p) {
    p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 0 | p.words[_];
      $ += 977 * y, p.words[_] = 67108863 & $, $ = 64 * y + ($ / 67108864 | 0);
    }
    return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
  }, u(ee, W), u(P, W), u(F, W), F.prototype.imulK = function(p) {
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 19 * (0 | p.words[_]) + $, g = 67108863 & y;
      y >>>= 26, p.words[_] = g, $ = y;
    }
    return $ !== 0 && (p.words[p.length++] = $), p;
  }, c._prime = function(p) {
    if (z[p])
      return z[p];
    var $;
    if (p === "k256")
      $ = new V();
    else if (p === "p224")
      $ = new ee();
    else if (p === "p192")
      $ = new P();
    else {
      if (p !== "p25519")
        throw new Error("Unknown prime " + p);
      $ = new F();
    }
    return z[p] = $, $;
  }, H.prototype._verify1 = function(p) {
    a(p.negative === 0, "red works only with positives"), a(p.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(p, $) {
    a((p.negative | $.negative) == 0, "red works only with positives"), a(p.red && p.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(p) {
    return this.prime ? this.prime.ireduce(p)._forceRed(this) : p.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(p) {
    return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
  }, H.prototype.add = function(p, $) {
    this._verify2(p, $);
    var _ = p.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(p, $) {
    this._verify2(p, $);
    var _ = p.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(p, $) {
    this._verify2(p, $);
    var _ = p.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(p, $) {
    this._verify2(p, $);
    var _ = p.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(p, $) {
    return this._verify1(p), this.imod(p.ushln($));
  }, H.prototype.imul = function(p, $) {
    return this._verify2(p, $), this.imod(p.imul($));
  }, H.prototype.mul = function(p, $) {
    return this._verify2(p, $), this.imod(p.mul($));
  }, H.prototype.isqr = function(p) {
    return this.imul(p, p.clone());
  }, H.prototype.sqr = function(p) {
    return this.mul(p, p);
  }, H.prototype.sqrt = function(p) {
    if (p.isZero())
      return p.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(p, _);
    }
    for (var y = this.m.subn(1), g = 0; !y.isZero() && y.andln(1) === 0; )
      g++, y.iushrn(1);
    a(!y.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), A = this.m.subn(1).iushrn(1), L = this.m.bitLength();
    for (L = new c(2 * L * L).toRed(this); this.pow(L, A).cmp(E) !== 0; )
      L.redIAdd(E);
    for (var j = this.pow(L, y), J = this.pow(p, y.addn(1).iushrn(1)), X = this.pow(p, y), re = g; X.cmp(v) !== 0; ) {
      for (var Z = X, ie = 0; Z.cmp(v) !== 0; ie++)
        Z = Z.redSqr();
      a(ie < re);
      var oe = this.pow(j, new c(1).iushln(re - ie - 1));
      J = J.redMul(oe), j = oe.redSqr(), X = X.redMul(j), re = ie;
    }
    return J;
  }, H.prototype.invm = function(p) {
    var $ = p._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(p, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return p.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = p;
    for (var y = 2; y < _.length; y++)
      _[y] = this.mul(_[y - 1], p);
    var g = _[0], v = 0, E = 0, A = $.bitLength() % 26;
    for (A === 0 && (A = 26), y = $.length - 1; y >= 0; y--) {
      for (var L = $.words[y], j = A - 1; j >= 0; j--) {
        var J = L >> j & 1;
        g !== _[0] && (g = this.sqr(g)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || y === 0 && j === 0) && (g = this.mul(g, _[v]), E = 0, v = 0)) : E = 0;
      }
      A = 26;
    }
    return g;
  }, H.prototype.convertTo = function(p) {
    var $ = p.umod(this.m);
    return $ === p ? $.clone() : $;
  }, H.prototype.convertFrom = function(p) {
    var $ = p.clone();
    return $.red = null, $;
  }, c.mont = function(p) {
    return new te(p);
  }, u(te, H), te.prototype.convertTo = function(p) {
    return this.imod(p.ushln(this.shift));
  }, te.prototype.convertFrom = function(p) {
    var $ = this.imod(p.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(p, $) {
    if (p.isZero() || $.isZero())
      return p.words[0] = 0, p.length = 1, p;
    var _ = p.imul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(p, $) {
    if (p.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = p.mul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(p) {
    return this.imod(p._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var utils$l = {};
(function(o) {
  var n = utils$l;
  function a(c) {
    return c.length === 1 ? "0" + c : c;
  }
  function u(c) {
    for (var m = "", d = 0; d < c.length; d++)
      m += a(c[d].toString(16));
    return m;
  }
  n.toArray = function(c, m) {
    if (Array.isArray(c))
      return c.slice();
    if (!c)
      return [];
    var d = [];
    if (typeof c != "string") {
      for (var w = 0; w < c.length; w++)
        d[w] = 0 | c[w];
      return d;
    }
    if (m === "hex")
      for ((c = c.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (c = "0" + c), w = 0; w < c.length; w += 2)
        d.push(parseInt(c[w] + c[w + 1], 16));
    else
      for (w = 0; w < c.length; w++) {
        var S = c.charCodeAt(w), T = S >> 8, B = 255 & S;
        T ? d.push(T, B) : d.push(B);
      }
    return d;
  }, n.zero2 = a, n.toHex = u, n.encode = function(c, m) {
    return m === "hex" ? u(c) : c;
  };
})(), function(o) {
  var n = utils$m, a = bn$2.exports, u = minimalisticAssert, c = utils$l;
  n.assert = u, n.toArray = c.toArray, n.zero2 = c.zero2, n.toHex = c.toHex, n.encode = c.encode, n.getNAF = function(m, d, w) {
    var S = new Array(Math.max(m.bitLength(), w) + 1);
    S.fill(0);
    for (var T = 1 << d + 1, B = m.clone(), I = 0; I < S.length; I++) {
      var C, N = B.andln(T - 1);
      B.isOdd() ? (C = N > (T >> 1) - 1 ? (T >> 1) - N : N, B.isubn(C)) : C = 0, S[I] = C, B.iushrn(1);
    }
    return S;
  }, n.getJSF = function(m, d) {
    var w = [[], []];
    m = m.clone(), d = d.clone();
    for (var S, T = 0, B = 0; m.cmpn(-T) > 0 || d.cmpn(-B) > 0; ) {
      var I, C, N = m.andln(3) + T & 3, q = d.andln(3) + B & 3;
      N === 3 && (N = -1), q === 3 && (q = -1), I = (1 & N) == 0 ? 0 : (S = m.andln(7) + T & 7) != 3 && S !== 5 || q !== 2 ? N : -N, w[0].push(I), C = (1 & q) == 0 ? 0 : (S = d.andln(7) + B & 7) != 3 && S !== 5 || N !== 2 ? q : -q, w[1].push(C), 2 * T === I + 1 && (T = 1 - T), 2 * B === C + 1 && (B = 1 - B), m.iushrn(1), d.iushrn(1);
    }
    return w;
  }, n.cachedProperty = function(m, d, w) {
    var S = "_" + d;
    m.prototype[d] = function() {
      return this[S] !== void 0 ? this[S] : this[S] = w.call(this);
    };
  }, n.parseBytes = function(m) {
    return typeof m == "string" ? n.toArray(m, "hex") : m;
  }, n.intFromLE = function(m) {
    return new a(m, "hex", "le");
  };
}();
var brorand = { exports: {} }, r$1;
function Rand(o) {
  this.rand = o;
}
if (brorand.exports = function(o) {
  return r$1 || (r$1 = new Rand(null)), r$1.generate(o);
}, brorand.exports.Rand = Rand, Rand.prototype.generate = function(o) {
  return this._rand(o);
}, Rand.prototype._rand = function(o) {
  if (this.rand.getBytes)
    return this.rand.getBytes(o);
  for (var n = new Uint8Array(o), a = 0; a < n.length; a++)
    n[a] = this.rand.getByte();
  return n;
}, typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(o) {
    var n = new Uint8Array(o);
    return self.crypto.getRandomValues(n), n;
  } : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(o) {
    var n = new Uint8Array(o);
    return self.msCrypto.getRandomValues(n), n;
  } : typeof window == "object" && (Rand.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var crypto$1 = require$$2$1;
    if (typeof crypto$1.randomBytes != "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function(o) {
      return crypto$1.randomBytes(o);
    };
  } catch {
  }
var curve = {}, BN$8 = bn$2.exports, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(o, n) {
  this.type = o, this.p = new BN$8(n.p, 16), this.red = n.prime ? BN$8.red(n.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = n.n && new BN$8(n.n, 16), this.g = n.g && this.pointFromJSON(n.g, n.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var a = this.n && this.p.div(this.n);
  !a || a.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
function BasePoint(o, n) {
  this.curve = o, this.type = n, this.precomputed = null;
}
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype._fixedNafMul = function(o, n) {
  assert$e(o.precomputed);
  var a = o._getDoubles(), u = getNAF(n, 1, this._bitLength), c = (1 << a.step + 1) - (a.step % 2 == 0 ? 2 : 1);
  c /= 3;
  var m, d, w = [];
  for (m = 0; m < u.length; m += a.step) {
    d = 0;
    for (var S = m + a.step - 1; S >= m; S--)
      d = (d << 1) + u[S];
    w.push(d);
  }
  for (var T = this.jpoint(null, null, null), B = this.jpoint(null, null, null), I = c; I > 0; I--) {
    for (m = 0; m < w.length; m++)
      (d = w[m]) === I ? B = B.mixedAdd(a.points[m]) : d === -I && (B = B.mixedAdd(a.points[m].neg()));
    T = T.add(B);
  }
  return T.toP();
}, BaseCurve.prototype._wnafMul = function(o, n) {
  var a = 4, u = o._getNAFPoints(a);
  a = u.wnd;
  for (var c = u.points, m = getNAF(n, a, this._bitLength), d = this.jpoint(null, null, null), w = m.length - 1; w >= 0; w--) {
    for (var S = 0; w >= 0 && m[w] === 0; w--)
      S++;
    if (w >= 0 && S++, d = d.dblp(S), w < 0)
      break;
    var T = m[w];
    assert$e(T !== 0), d = o.type === "affine" ? T > 0 ? d.mixedAdd(c[T - 1 >> 1]) : d.mixedAdd(c[-T - 1 >> 1].neg()) : T > 0 ? d.add(c[T - 1 >> 1]) : d.add(c[-T - 1 >> 1].neg());
  }
  return o.type === "affine" ? d.toP() : d;
}, BaseCurve.prototype._wnafMulAdd = function(o, n, a, u, c) {
  var m, d, w, S = this._wnafT1, T = this._wnafT2, B = this._wnafT3, I = 0;
  for (m = 0; m < u; m++) {
    var C = (w = n[m])._getNAFPoints(o);
    S[m] = C.wnd, T[m] = C.points;
  }
  for (m = u - 1; m >= 1; m -= 2) {
    var N = m - 1, q = m;
    if (S[N] === 1 && S[q] === 1) {
      var D = [n[N], null, null, n[q]];
      n[N].y.cmp(n[q].y) === 0 ? (D[1] = n[N].add(n[q]), D[2] = n[N].toJ().mixedAdd(n[q].neg())) : n[N].y.cmp(n[q].y.redNeg()) === 0 ? (D[1] = n[N].toJ().mixedAdd(n[q]), D[2] = n[N].add(n[q].neg())) : (D[1] = n[N].toJ().mixedAdd(n[q]), D[2] = n[N].toJ().mixedAdd(n[q].neg()));
      var z = [-3, -1, -5, -7, 0, 7, 5, 1, 3], W = getJSF(a[N], a[q]);
      for (I = Math.max(W[0].length, I), B[N] = new Array(I), B[q] = new Array(I), d = 0; d < I; d++) {
        var V = 0 | W[0][d], ee = 0 | W[1][d];
        B[N][d] = z[3 * (V + 1) + (ee + 1)], B[q][d] = 0, T[N] = D;
      }
    } else
      B[N] = getNAF(a[N], S[N], this._bitLength), B[q] = getNAF(a[q], S[q], this._bitLength), I = Math.max(B[N].length, I), I = Math.max(B[q].length, I);
  }
  var P = this.jpoint(null, null, null), F = this._wnafT4;
  for (m = I; m >= 0; m--) {
    for (var H = 0; m >= 0; ) {
      var te = !0;
      for (d = 0; d < u; d++)
        F[d] = 0 | B[d][m], F[d] !== 0 && (te = !1);
      if (!te)
        break;
      H++, m--;
    }
    if (m >= 0 && H++, P = P.dblp(H), m < 0)
      break;
    for (d = 0; d < u; d++) {
      var p = F[d];
      p !== 0 && (p > 0 ? w = T[d][p - 1 >> 1] : p < 0 && (w = T[d][-p - 1 >> 1].neg()), P = w.type === "affine" ? P.mixedAdd(w) : P.add(w));
    }
  }
  for (m = 0; m < u; m++)
    T[m] = null;
  return c ? P : P.toP();
}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
}, BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
}, BaseCurve.prototype.decodePoint = function(o, n) {
  o = utils$k.toArray(o, n);
  var a = this.p.byteLength();
  if ((o[0] === 4 || o[0] === 6 || o[0] === 7) && o.length - 1 == 2 * a)
    return o[0] === 6 ? assert$e(o[o.length - 1] % 2 == 0) : o[0] === 7 && assert$e(o[o.length - 1] % 2 == 1), this.point(o.slice(1, 1 + a), o.slice(1 + a, 1 + 2 * a));
  if ((o[0] === 2 || o[0] === 3) && o.length - 1 === a)
    return this.pointFromX(o.slice(1, 1 + a), o[0] === 3);
  throw new Error("Unknown point format");
}, BasePoint.prototype.encodeCompressed = function(o) {
  return this.encode(o, !0);
}, BasePoint.prototype._encode = function(o) {
  var n = this.curve.p.byteLength(), a = this.getX().toArray("be", n);
  return o ? [this.getY().isEven() ? 2 : 3].concat(a) : [4].concat(a, this.getY().toArray("be", n));
}, BasePoint.prototype.encode = function(o, n) {
  return utils$k.encode(this._encode(n), o);
}, BasePoint.prototype.precompute = function(o) {
  if (this.precomputed)
    return this;
  var n = { doubles: null, naf: null, beta: null };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, o), n.beta = this._getBeta(), this.precomputed = n, this;
}, BasePoint.prototype._hasDoubles = function(o) {
  if (!this.precomputed)
    return !1;
  var n = this.precomputed.doubles;
  return !!n && n.points.length >= Math.ceil((o.bitLength() + 1) / n.step);
}, BasePoint.prototype._getDoubles = function(o, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var a = [this], u = this, c = 0; c < n; c += o) {
    for (var m = 0; m < o; m++)
      u = u.dbl();
    a.push(u);
  }
  return { step: o, points: a };
}, BasePoint.prototype._getNAFPoints = function(o) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var n = [this], a = (1 << o) - 1, u = a === 1 ? null : this.dbl(), c = 1; c < a; c++)
    n[c] = n[c - 1].add(u);
  return { wnd: o, points: n };
}, BasePoint.prototype._getBeta = function() {
  return null;
}, BasePoint.prototype.dblp = function(o) {
  for (var n = this, a = 0; a < o; a++)
    n = n.dbl();
  return n;
};
var utils$j = utils$m, BN$7 = bn$2.exports, inherits$3 = requireInherits_browser(), Base$2 = base, assert$d = utils$j.assert;
function ShortCurve(o) {
  Base$2.call(this, "short", o), this.a = new BN$7(o.a, 16).toRed(this.red), this.b = new BN$7(o.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(o), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve, Base$2);
var short = ShortCurve;
function Point$2(o, n, a, u) {
  Base$2.BasePoint.call(this, o, "affine"), n === null && a === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$7(n, 16), this.y = new BN$7(a, 16), u && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
function JPoint(o, n, a, u) {
  Base$2.BasePoint.call(this, o, "jacobian"), n === null && a === null && u === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$7(0)) : (this.x = new BN$7(n, 16), this.y = new BN$7(a, 16), this.z = new BN$7(u, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
ShortCurve.prototype._getEndomorphism = function(o) {
  if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
    var n, a;
    if (o.beta)
      n = new BN$7(o.beta, 16).toRed(this.red);
    else {
      var u = this._getEndoRoots(this.p);
      n = (n = u[0].cmp(u[1]) < 0 ? u[0] : u[1]).toRed(this.red);
    }
    if (o.lambda)
      a = new BN$7(o.lambda, 16);
    else {
      var c = this._getEndoRoots(this.n);
      this.g.mul(c[0]).x.cmp(this.g.x.redMul(n)) === 0 ? a = c[0] : (a = c[1], assert$d(this.g.mul(a).x.cmp(this.g.x.redMul(n)) === 0));
    }
    return { beta: n, lambda: a, basis: o.basis ? o.basis.map(function(m) {
      return { a: new BN$7(m.a, 16), b: new BN$7(m.b, 16) };
    }) : this._getEndoBasis(a) };
  }
}, ShortCurve.prototype._getEndoRoots = function(o) {
  var n = o === this.p ? this.red : BN$7.mont(o), a = new BN$7(2).toRed(n).redInvm(), u = a.redNeg(), c = new BN$7(3).toRed(n).redNeg().redSqrt().redMul(a);
  return [u.redAdd(c).fromRed(), u.redSub(c).fromRed()];
}, ShortCurve.prototype._getEndoBasis = function(o) {
  for (var n, a, u, c, m, d, w, S, T, B = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), I = o, C = this.n.clone(), N = new BN$7(1), q = new BN$7(0), D = new BN$7(0), z = new BN$7(1), W = 0; I.cmpn(0) !== 0; ) {
    var V = C.div(I);
    S = C.sub(V.mul(I)), T = D.sub(V.mul(N));
    var ee = z.sub(V.mul(q));
    if (!u && S.cmp(B) < 0)
      n = w.neg(), a = N, u = S.neg(), c = T;
    else if (u && ++W == 2)
      break;
    w = S, C = I, I = S, D = N, N = T, z = q, q = ee;
  }
  m = S.neg(), d = T;
  var P = u.sqr().add(c.sqr());
  return m.sqr().add(d.sqr()).cmp(P) >= 0 && (m = n, d = a), u.negative && (u = u.neg(), c = c.neg()), m.negative && (m = m.neg(), d = d.neg()), [{ a: u, b: c }, { a: m, b: d }];
}, ShortCurve.prototype._endoSplit = function(o) {
  var n = this.endo.basis, a = n[0], u = n[1], c = u.b.mul(o).divRound(this.n), m = a.b.neg().mul(o).divRound(this.n), d = c.mul(a.a), w = m.mul(u.a), S = c.mul(a.b), T = m.mul(u.b);
  return { k1: o.sub(d).sub(w), k2: S.add(T).neg() };
}, ShortCurve.prototype.pointFromX = function(o, n) {
  (o = new BN$7(o, 16)).red || (o = o.toRed(this.red));
  var a = o.redSqr().redMul(o).redIAdd(o.redMul(this.a)).redIAdd(this.b), u = a.redSqrt();
  if (u.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var c = u.fromRed().isOdd();
  return (n && !c || !n && c) && (u = u.redNeg()), this.point(o, u);
}, ShortCurve.prototype.validate = function(o) {
  if (o.inf)
    return !0;
  var n = o.x, a = o.y, u = this.a.redMul(n), c = n.redSqr().redMul(n).redIAdd(u).redIAdd(this.b);
  return a.redSqr().redISub(c).cmpn(0) === 0;
}, ShortCurve.prototype._endoWnafMulAdd = function(o, n, a) {
  for (var u = this._endoWnafT1, c = this._endoWnafT2, m = 0; m < o.length; m++) {
    var d = this._endoSplit(n[m]), w = o[m], S = w._getBeta();
    d.k1.negative && (d.k1.ineg(), w = w.neg(!0)), d.k2.negative && (d.k2.ineg(), S = S.neg(!0)), u[2 * m] = w, u[2 * m + 1] = S, c[2 * m] = d.k1, c[2 * m + 1] = d.k2;
  }
  for (var T = this._wnafMulAdd(1, u, c, 2 * m, a), B = 0; B < 2 * m; B++)
    u[B] = null, c[B] = null;
  return T;
}, inherits$3(Point$2, Base$2.BasePoint), ShortCurve.prototype.point = function(o, n, a) {
  return new Point$2(this, o, n, a);
}, ShortCurve.prototype.pointFromJSON = function(o, n) {
  return Point$2.fromJSON(this, o, n);
}, Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var o = this.precomputed;
    if (o && o.beta)
      return o.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (o) {
      var a = this.curve, u = function(c) {
        return a.point(c.x.redMul(a.endo.beta), c.y);
      };
      o.beta = n, n.precomputed = { beta: null, naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(u) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(u) } };
    }
    return n;
  }
}, Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, Point$2.fromJSON = function(o, n, a) {
  typeof n == "string" && (n = JSON.parse(n));
  var u = o.point(n[0], n[1], a);
  if (!n[2])
    return u;
  function c(d) {
    return o.point(d[0], d[1], a);
  }
  var m = n[2];
  return u.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [u].concat(m.doubles.points.map(c)) }, naf: m.naf && { wnd: m.naf.wnd, points: [u].concat(m.naf.points.map(c)) } }, u;
}, Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, Point$2.prototype.isInfinity = function() {
  return this.inf;
}, Point$2.prototype.add = function(o) {
  if (this.inf)
    return o;
  if (o.inf)
    return this;
  if (this.eq(o))
    return this.dbl();
  if (this.neg().eq(o))
    return this.curve.point(null, null);
  if (this.x.cmp(o.x) === 0)
    return this.curve.point(null, null);
  var n = this.y.redSub(o.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(o.x).redInvm()));
  var a = n.redSqr().redISub(this.x).redISub(o.x), u = n.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, u);
}, Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var o = this.y.redAdd(this.y);
  if (o.cmpn(0) === 0)
    return this.curve.point(null, null);
  var n = this.curve.a, a = this.x.redSqr(), u = o.redInvm(), c = a.redAdd(a).redIAdd(a).redIAdd(n).redMul(u), m = c.redSqr().redISub(this.x.redAdd(this.x)), d = c.redMul(this.x.redSub(m)).redISub(this.y);
  return this.curve.point(m, d);
}, Point$2.prototype.getX = function() {
  return this.x.fromRed();
}, Point$2.prototype.getY = function() {
  return this.y.fromRed();
}, Point$2.prototype.mul = function(o) {
  return o = new BN$7(o, 16), this.isInfinity() ? this : this._hasDoubles(o) ? this.curve._fixedNafMul(this, o) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [o]) : this.curve._wnafMul(this, o);
}, Point$2.prototype.mulAdd = function(o, n, a) {
  var u = [this, n], c = [o, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, c) : this.curve._wnafMulAdd(1, u, c, 2);
}, Point$2.prototype.jmulAdd = function(o, n, a) {
  var u = [this, n], c = [o, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, c, !0) : this.curve._wnafMulAdd(1, u, c, 2, !0);
}, Point$2.prototype.eq = function(o) {
  return this === o || this.inf === o.inf && (this.inf || this.x.cmp(o.x) === 0 && this.y.cmp(o.y) === 0);
}, Point$2.prototype.neg = function(o) {
  if (this.inf)
    return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (o && this.precomputed) {
    var a = this.precomputed, u = function(c) {
      return c.neg();
    };
    n.precomputed = { naf: a.naf && { wnd: a.naf.wnd, points: a.naf.points.map(u) }, doubles: a.doubles && { step: a.doubles.step, points: a.doubles.points.map(u) } };
  }
  return n;
}, Point$2.prototype.toJ = function() {
  return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
}, inherits$3(JPoint, Base$2.BasePoint), ShortCurve.prototype.jpoint = function(o, n, a) {
  return new JPoint(this, o, n, a);
}, JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var o = this.z.redInvm(), n = o.redSqr(), a = this.x.redMul(n), u = this.y.redMul(n).redMul(o);
  return this.curve.point(a, u);
}, JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, JPoint.prototype.add = function(o) {
  if (this.isInfinity())
    return o;
  if (o.isInfinity())
    return this;
  var n = o.z.redSqr(), a = this.z.redSqr(), u = this.x.redMul(n), c = o.x.redMul(a), m = this.y.redMul(n.redMul(o.z)), d = o.y.redMul(a.redMul(this.z)), w = u.redSub(c), S = m.redSub(d);
  if (w.cmpn(0) === 0)
    return S.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var T = w.redSqr(), B = T.redMul(w), I = u.redMul(T), C = S.redSqr().redIAdd(B).redISub(I).redISub(I), N = S.redMul(I.redISub(C)).redISub(m.redMul(B)), q = this.z.redMul(o.z).redMul(w);
  return this.curve.jpoint(C, N, q);
}, JPoint.prototype.mixedAdd = function(o) {
  if (this.isInfinity())
    return o.toJ();
  if (o.isInfinity())
    return this;
  var n = this.z.redSqr(), a = this.x, u = o.x.redMul(n), c = this.y, m = o.y.redMul(n).redMul(this.z), d = a.redSub(u), w = c.redSub(m);
  if (d.cmpn(0) === 0)
    return w.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var S = d.redSqr(), T = S.redMul(d), B = a.redMul(S), I = w.redSqr().redIAdd(T).redISub(B).redISub(B), C = w.redMul(B.redISub(I)).redISub(c.redMul(T)), N = this.z.redMul(d);
  return this.curve.jpoint(I, C, N);
}, JPoint.prototype.dblp = function(o) {
  if (o === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!o)
    return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var a = this;
    for (n = 0; n < o; n++)
      a = a.dbl();
    return a;
  }
  var u = this.curve.a, c = this.curve.tinv, m = this.x, d = this.y, w = this.z, S = w.redSqr().redSqr(), T = d.redAdd(d);
  for (n = 0; n < o; n++) {
    var B = m.redSqr(), I = T.redSqr(), C = I.redSqr(), N = B.redAdd(B).redIAdd(B).redIAdd(u.redMul(S)), q = m.redMul(I), D = N.redSqr().redISub(q.redAdd(q)), z = q.redISub(D), W = N.redMul(z);
    W = W.redIAdd(W).redISub(C);
    var V = T.redMul(w);
    n + 1 < o && (S = S.redMul(C)), m = D, w = V, T = W;
  }
  return this.curve.jpoint(m, T.redMul(c), w);
}, JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, JPoint.prototype._zeroDbl = function() {
  var o, n, a;
  if (this.zOne) {
    var u = this.x.redSqr(), c = this.y.redSqr(), m = c.redSqr(), d = this.x.redAdd(c).redSqr().redISub(u).redISub(m);
    d = d.redIAdd(d);
    var w = u.redAdd(u).redIAdd(u), S = w.redSqr().redISub(d).redISub(d), T = m.redIAdd(m);
    T = (T = T.redIAdd(T)).redIAdd(T), o = S, n = w.redMul(d.redISub(S)).redISub(T), a = this.y.redAdd(this.y);
  } else {
    var B = this.x.redSqr(), I = this.y.redSqr(), C = I.redSqr(), N = this.x.redAdd(I).redSqr().redISub(B).redISub(C);
    N = N.redIAdd(N);
    var q = B.redAdd(B).redIAdd(B), D = q.redSqr(), z = C.redIAdd(C);
    z = (z = z.redIAdd(z)).redIAdd(z), o = D.redISub(N).redISub(N), n = q.redMul(N.redISub(o)).redISub(z), a = (a = this.y.redMul(this.z)).redIAdd(a);
  }
  return this.curve.jpoint(o, n, a);
}, JPoint.prototype._threeDbl = function() {
  var o, n, a;
  if (this.zOne) {
    var u = this.x.redSqr(), c = this.y.redSqr(), m = c.redSqr(), d = this.x.redAdd(c).redSqr().redISub(u).redISub(m);
    d = d.redIAdd(d);
    var w = u.redAdd(u).redIAdd(u).redIAdd(this.curve.a), S = w.redSqr().redISub(d).redISub(d);
    o = S;
    var T = m.redIAdd(m);
    T = (T = T.redIAdd(T)).redIAdd(T), n = w.redMul(d.redISub(S)).redISub(T), a = this.y.redAdd(this.y);
  } else {
    var B = this.z.redSqr(), I = this.y.redSqr(), C = this.x.redMul(I), N = this.x.redSub(B).redMul(this.x.redAdd(B));
    N = N.redAdd(N).redIAdd(N);
    var q = C.redIAdd(C), D = (q = q.redIAdd(q)).redAdd(q);
    o = N.redSqr().redISub(D), a = this.y.redAdd(this.z).redSqr().redISub(I).redISub(B);
    var z = I.redSqr();
    z = (z = (z = z.redIAdd(z)).redIAdd(z)).redIAdd(z), n = N.redMul(q.redISub(o)).redISub(z);
  }
  return this.curve.jpoint(o, n, a);
}, JPoint.prototype._dbl = function() {
  var o = this.curve.a, n = this.x, a = this.y, u = this.z, c = u.redSqr().redSqr(), m = n.redSqr(), d = a.redSqr(), w = m.redAdd(m).redIAdd(m).redIAdd(o.redMul(c)), S = n.redAdd(n), T = (S = S.redIAdd(S)).redMul(d), B = w.redSqr().redISub(T.redAdd(T)), I = T.redISub(B), C = d.redSqr();
  C = (C = (C = C.redIAdd(C)).redIAdd(C)).redIAdd(C);
  var N = w.redMul(I).redISub(C), q = a.redAdd(a).redMul(u);
  return this.curve.jpoint(B, N, q);
}, JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var o = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr(), u = n.redSqr(), c = o.redAdd(o).redIAdd(o), m = c.redSqr(), d = this.x.redAdd(n).redSqr().redISub(o).redISub(u), w = (d = (d = (d = d.redIAdd(d)).redAdd(d).redIAdd(d)).redISub(m)).redSqr(), S = u.redIAdd(u);
  S = (S = (S = S.redIAdd(S)).redIAdd(S)).redIAdd(S);
  var T = c.redIAdd(d).redSqr().redISub(m).redISub(w).redISub(S), B = n.redMul(T);
  B = (B = B.redIAdd(B)).redIAdd(B);
  var I = this.x.redMul(w).redISub(B);
  I = (I = I.redIAdd(I)).redIAdd(I);
  var C = this.y.redMul(T.redMul(S.redISub(T)).redISub(d.redMul(w)));
  C = (C = (C = C.redIAdd(C)).redIAdd(C)).redIAdd(C);
  var N = this.z.redAdd(d).redSqr().redISub(a).redISub(w);
  return this.curve.jpoint(I, C, N);
}, JPoint.prototype.mul = function(o, n) {
  return o = new BN$7(o, n), this.curve._wnafMul(this, o);
}, JPoint.prototype.eq = function(o) {
  if (o.type === "affine")
    return this.eq(o.toJ());
  if (this === o)
    return !0;
  var n = this.z.redSqr(), a = o.z.redSqr();
  if (this.x.redMul(a).redISub(o.x.redMul(n)).cmpn(0) !== 0)
    return !1;
  var u = n.redMul(this.z), c = a.redMul(o.z);
  return this.y.redMul(c).redISub(o.y.redMul(u)).cmpn(0) === 0;
}, JPoint.prototype.eqXToP = function(o) {
  var n = this.z.redSqr(), a = o.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var u = o.clone(), c = this.curve.redN.redMul(n); ; ) {
    if (u.iadd(this.curve.n), u.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(c), this.x.cmp(a) === 0)
      return !0;
  }
}, JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$6 = bn$2.exports, inherits$2 = requireInherits_browser(), Base$1 = base, utils$i = utils$m;
function MontCurve(o) {
  Base$1.call(this, "mont", o), this.a = new BN$6(o.a, 16).toRed(this.red), this.b = new BN$6(o.b, 16).toRed(this.red), this.i4 = new BN$6(4).toRed(this.red).redInvm(), this.two = new BN$6(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;
function Point$1(o, n, a) {
  Base$1.BasePoint.call(this, o, "projective"), n === null && a === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$6(n, 16), this.z = new BN$6(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
MontCurve.prototype.validate = function(o) {
  var n = o.normalize().x, a = n.redSqr(), u = a.redMul(n).redAdd(a.redMul(this.a)).redAdd(n);
  return u.redSqrt().redSqr().cmp(u) === 0;
}, inherits$2(Point$1, Base$1.BasePoint), MontCurve.prototype.decodePoint = function(o, n) {
  return this.point(utils$i.toArray(o, n), 1);
}, MontCurve.prototype.point = function(o, n) {
  return new Point$1(this, o, n);
}, MontCurve.prototype.pointFromJSON = function(o) {
  return Point$1.fromJSON(this, o);
}, Point$1.prototype.precompute = function() {
}, Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
}, Point$1.fromJSON = function(o, n) {
  return new Point$1(o, n[0], n[1] || o.one);
}, Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
}, Point$1.prototype.dbl = function() {
  var o = this.x.redAdd(this.z).redSqr(), n = this.x.redSub(this.z).redSqr(), a = o.redSub(n), u = o.redMul(n), c = a.redMul(n.redAdd(this.curve.a24.redMul(a)));
  return this.curve.point(u, c);
}, Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.diffAdd = function(o, n) {
  var a = this.x.redAdd(this.z), u = this.x.redSub(this.z), c = o.x.redAdd(o.z), m = o.x.redSub(o.z).redMul(a), d = c.redMul(u), w = n.z.redMul(m.redAdd(d).redSqr()), S = n.x.redMul(m.redISub(d).redSqr());
  return this.curve.point(w, S);
}, Point$1.prototype.mul = function(o) {
  for (var n = o.clone(), a = this, u = this.curve.point(null, null), c = []; n.cmpn(0) !== 0; n.iushrn(1))
    c.push(n.andln(1));
  for (var m = c.length - 1; m >= 0; m--)
    c[m] === 0 ? (a = a.diffAdd(u, this), u = u.dbl()) : (u = a.diffAdd(u, this), a = a.dbl());
  return u;
}, Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.eq = function(o) {
  return this.getX().cmp(o.getX()) === 0;
}, Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
}, Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$5 = bn$2.exports, inherits$1 = requireInherits_browser(), Base = base, assert$c = utils$h.assert;
function EdwardsCurve(o) {
  this.twisted = (0 | o.a) != 1, this.mOneA = this.twisted && (0 | o.a) == -1, this.extended = this.mOneA, Base.call(this, "edwards", o), this.a = new BN$5(o.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$5(o.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$5(o.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | o.c) == 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve, e;
function Point(o, n, a, u, c) {
  Base.BasePoint.call(this, o, "projective"), n === null && a === null && u === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$5(n, 16), this.y = new BN$5(a, 16), this.z = u ? new BN$5(u, 16) : this.curve.one, this.t = c && new BN$5(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
EdwardsCurve.prototype._mulA = function(o) {
  return this.mOneA ? o.redNeg() : this.a.redMul(o);
}, EdwardsCurve.prototype._mulC = function(o) {
  return this.oneC ? o : this.c.redMul(o);
}, EdwardsCurve.prototype.jpoint = function(o, n, a, u) {
  return this.point(o, n, a, u);
}, EdwardsCurve.prototype.pointFromX = function(o, n) {
  (o = new BN$5(o, 16)).red || (o = o.toRed(this.red));
  var a = o.redSqr(), u = this.c2.redSub(this.a.redMul(a)), c = this.one.redSub(this.c2.redMul(this.d).redMul(a)), m = u.redMul(c.redInvm()), d = m.redSqrt();
  if (d.redSqr().redSub(m).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var w = d.fromRed().isOdd();
  return (n && !w || !n && w) && (d = d.redNeg()), this.point(o, d);
}, EdwardsCurve.prototype.pointFromY = function(o, n) {
  (o = new BN$5(o, 16)).red || (o = o.toRed(this.red));
  var a = o.redSqr(), u = a.redSub(this.c2), c = a.redMul(this.d).redMul(this.c2).redSub(this.a), m = u.redMul(c.redInvm());
  if (m.cmp(this.zero) === 0) {
    if (n)
      throw new Error("invalid point");
    return this.point(this.zero, o);
  }
  var d = m.redSqrt();
  if (d.redSqr().redSub(m).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return d.fromRed().isOdd() !== n && (d = d.redNeg()), this.point(d, o);
}, EdwardsCurve.prototype.validate = function(o) {
  if (o.isInfinity())
    return !0;
  o.normalize();
  var n = o.x.redSqr(), a = o.y.redSqr(), u = n.redMul(this.a).redAdd(a), c = this.c2.redMul(this.one.redAdd(this.d.redMul(n).redMul(a)));
  return u.cmp(c) === 0;
}, inherits$1(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(o) {
  return Point.fromJSON(this, o);
}, EdwardsCurve.prototype.point = function(o, n, a, u) {
  return new Point(this, o, n, a, u);
}, Point.fromJSON = function(o, n) {
  return new Point(o, n[0], n[1], n[2]);
}, Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
}, Point.prototype._extDbl = function() {
  var o = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr();
  a = a.redIAdd(a);
  var u = this.curve._mulA(o), c = this.x.redAdd(this.y).redSqr().redISub(o).redISub(n), m = u.redAdd(n), d = m.redSub(a), w = u.redSub(n), S = c.redMul(d), T = m.redMul(w), B = c.redMul(w), I = d.redMul(m);
  return this.curve.point(S, T, I, B);
}, Point.prototype._projDbl = function() {
  var o, n, a, u, c, m, d = this.x.redAdd(this.y).redSqr(), w = this.x.redSqr(), S = this.y.redSqr();
  if (this.curve.twisted) {
    var T = (u = this.curve._mulA(w)).redAdd(S);
    this.zOne ? (o = d.redSub(w).redSub(S).redMul(T.redSub(this.curve.two)), n = T.redMul(u.redSub(S)), a = T.redSqr().redSub(T).redSub(T)) : (c = this.z.redSqr(), m = T.redSub(c).redISub(c), o = d.redSub(w).redISub(S).redMul(m), n = T.redMul(u.redSub(S)), a = T.redMul(m));
  } else
    u = w.redAdd(S), c = this.curve._mulC(this.z).redSqr(), m = u.redSub(c).redSub(c), o = this.curve._mulC(d.redISub(u)).redMul(m), n = this.curve._mulC(u).redMul(w.redISub(S)), a = u.redMul(m);
  return this.curve.point(o, n, a);
}, Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
}, Point.prototype._extAdd = function(o) {
  var n = this.y.redSub(this.x).redMul(o.y.redSub(o.x)), a = this.y.redAdd(this.x).redMul(o.y.redAdd(o.x)), u = this.t.redMul(this.curve.dd).redMul(o.t), c = this.z.redMul(o.z.redAdd(o.z)), m = a.redSub(n), d = c.redSub(u), w = c.redAdd(u), S = a.redAdd(n), T = m.redMul(d), B = w.redMul(S), I = m.redMul(S), C = d.redMul(w);
  return this.curve.point(T, B, C, I);
}, Point.prototype._projAdd = function(o) {
  var n, a, u = this.z.redMul(o.z), c = u.redSqr(), m = this.x.redMul(o.x), d = this.y.redMul(o.y), w = this.curve.d.redMul(m).redMul(d), S = c.redSub(w), T = c.redAdd(w), B = this.x.redAdd(this.y).redMul(o.x.redAdd(o.y)).redISub(m).redISub(d), I = u.redMul(S).redMul(B);
  return this.curve.twisted ? (n = u.redMul(T).redMul(d.redSub(this.curve._mulA(m))), a = S.redMul(T)) : (n = u.redMul(T).redMul(d.redSub(m)), a = this.curve._mulC(S).redMul(T)), this.curve.point(I, n, a);
}, Point.prototype.add = function(o) {
  return this.isInfinity() ? o : o.isInfinity() ? this : this.curve.extended ? this._extAdd(o) : this._projAdd(o);
}, Point.prototype.mul = function(o) {
  return this._hasDoubles(o) ? this.curve._fixedNafMul(this, o) : this.curve._wnafMul(this, o);
}, Point.prototype.mulAdd = function(o, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [o, a], 2, !1);
}, Point.prototype.jmulAdd = function(o, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [o, a], 2, !0);
}, Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var o = this.z.redInvm();
  return this.x = this.x.redMul(o), this.y = this.y.redMul(o), this.t && (this.t = this.t.redMul(o)), this.z = this.curve.one, this.zOne = !0, this;
}, Point.prototype.neg = function() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
}, Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
}, Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
}, Point.prototype.eq = function(o) {
  return this === o || this.getX().cmp(o.getX()) === 0 && this.getY().cmp(o.getY()) === 0;
}, Point.prototype.eqXToP = function(o) {
  var n = o.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var a = o.clone(), u = this.curve.redN.redMul(this.z); ; ) {
    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(u), this.x.cmp(n) === 0)
      return !0;
  }
}, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add, e = curve, e.base = base, e.short = short, e.mont = mont, e.edwards = edwards;
var curves$2 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits = requireInherits_browser();
function isSurrogatePair(o, n) {
  return (64512 & o.charCodeAt(n)) == 55296 && !(n < 0 || n + 1 >= o.length) && (64512 & o.charCodeAt(n + 1)) == 56320;
}
function toArray(o, n) {
  if (Array.isArray(o))
    return o.slice();
  if (!o)
    return [];
  var a = [];
  if (typeof o == "string")
    if (n) {
      if (n === "hex")
        for ((o = o.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (o = "0" + o), c = 0; c < o.length; c += 2)
          a.push(parseInt(o[c] + o[c + 1], 16));
    } else
      for (var u = 0, c = 0; c < o.length; c++) {
        var m = o.charCodeAt(c);
        m < 128 ? a[u++] = m : m < 2048 ? (a[u++] = m >> 6 | 192, a[u++] = 63 & m | 128) : isSurrogatePair(o, c) ? (m = 65536 + ((1023 & m) << 10) + (1023 & o.charCodeAt(++c)), a[u++] = m >> 18 | 240, a[u++] = m >> 12 & 63 | 128, a[u++] = m >> 6 & 63 | 128, a[u++] = 63 & m | 128) : (a[u++] = m >> 12 | 224, a[u++] = m >> 6 & 63 | 128, a[u++] = 63 & m | 128);
      }
  else
    for (c = 0; c < o.length; c++)
      a[c] = 0 | o[c];
  return a;
}
function toHex(o) {
  for (var n = "", a = 0; a < o.length; a++)
    n += zero2(o[a].toString(16));
  return n;
}
function htonl(o) {
  return (o >>> 24 | o >>> 8 & 65280 | o << 8 & 16711680 | (255 & o) << 24) >>> 0;
}
function toHex32(o, n) {
  for (var a = "", u = 0; u < o.length; u++) {
    var c = o[u];
    n === "little" && (c = htonl(c)), a += zero8(c.toString(16));
  }
  return a;
}
function zero2(o) {
  return o.length === 1 ? "0" + o : o;
}
function zero8(o) {
  return o.length === 7 ? "0" + o : o.length === 6 ? "00" + o : o.length === 5 ? "000" + o : o.length === 4 ? "0000" + o : o.length === 3 ? "00000" + o : o.length === 2 ? "000000" + o : o.length === 1 ? "0000000" + o : o;
}
function join32(o, n, a, u) {
  var c = a - n;
  assert$b(c % 4 == 0);
  for (var m = new Array(c / 4), d = 0, w = n; d < m.length; d++, w += 4) {
    var S;
    S = u === "big" ? o[w] << 24 | o[w + 1] << 16 | o[w + 2] << 8 | o[w + 3] : o[w + 3] << 24 | o[w + 2] << 16 | o[w + 1] << 8 | o[w], m[d] = S >>> 0;
  }
  return m;
}
function split32(o, n) {
  for (var a = new Array(4 * o.length), u = 0, c = 0; u < o.length; u++, c += 4) {
    var m = o[u];
    n === "big" ? (a[c] = m >>> 24, a[c + 1] = m >>> 16 & 255, a[c + 2] = m >>> 8 & 255, a[c + 3] = 255 & m) : (a[c + 3] = m >>> 24, a[c + 2] = m >>> 16 & 255, a[c + 1] = m >>> 8 & 255, a[c] = 255 & m);
  }
  return a;
}
function rotr32$1(o, n) {
  return o >>> n | o << 32 - n;
}
function rotl32$2(o, n) {
  return o << n | o >>> 32 - n;
}
function sum32$3(o, n) {
  return o + n >>> 0;
}
function sum32_3$1(o, n, a) {
  return o + n + a >>> 0;
}
function sum32_4$2(o, n, a, u) {
  return o + n + a + u >>> 0;
}
function sum32_5$2(o, n, a, u, c) {
  return o + n + a + u + c >>> 0;
}
function sum64$1(o, n, a, u) {
  var c = o[n], m = u + o[n + 1] >>> 0, d = (m < u ? 1 : 0) + a + c;
  o[n] = d >>> 0, o[n + 1] = m;
}
function sum64_hi$1(o, n, a, u) {
  return (n + u >>> 0 < n ? 1 : 0) + o + a >>> 0;
}
function sum64_lo$1(o, n, a, u) {
  return n + u >>> 0;
}
function sum64_4_hi$1(o, n, a, u, c, m, d, w) {
  var S = 0, T = n;
  return S += (T = T + u >>> 0) < n ? 1 : 0, S += (T = T + m >>> 0) < m ? 1 : 0, o + a + c + d + (S += (T = T + w >>> 0) < w ? 1 : 0) >>> 0;
}
function sum64_4_lo$1(o, n, a, u, c, m, d, w) {
  return n + u + m + w >>> 0;
}
function sum64_5_hi$1(o, n, a, u, c, m, d, w, S, T) {
  var B = 0, I = n;
  return B += (I = I + u >>> 0) < n ? 1 : 0, B += (I = I + m >>> 0) < m ? 1 : 0, B += (I = I + w >>> 0) < w ? 1 : 0, o + a + c + d + S + (B += (I = I + T >>> 0) < T ? 1 : 0) >>> 0;
}
function sum64_5_lo$1(o, n, a, u, c, m, d, w, S, T) {
  return n + u + m + w + T >>> 0;
}
function rotr64_hi$1(o, n, a) {
  return (n << 32 - a | o >>> a) >>> 0;
}
function rotr64_lo$1(o, n, a) {
  return (o << 32 - a | n >>> a) >>> 0;
}
function shr64_hi$1(o, n, a) {
  return o >>> a;
}
function shr64_lo$1(o, n, a) {
  return (o << 32 - a | n >>> a) >>> 0;
}
utils$g.inherits = inherits, utils$g.toArray = toArray, utils$g.toHex = toHex, utils$g.htonl = htonl, utils$g.toHex32 = toHex32, utils$g.zero2 = zero2, utils$g.zero8 = zero8, utils$g.join32 = join32, utils$g.split32 = split32, utils$g.rotr32 = rotr32$1, utils$g.rotl32 = rotl32$2, utils$g.sum32 = sum32$3, utils$g.sum32_3 = sum32_3$1, utils$g.sum32_4 = sum32_4$2, utils$g.sum32_5 = sum32_5$2, utils$g.sum64 = sum64$1, utils$g.sum64_hi = sum64_hi$1, utils$g.sum64_lo = sum64_lo$1, utils$g.sum64_4_hi = sum64_4_hi$1, utils$g.sum64_4_lo = sum64_4_lo$1, utils$g.sum64_5_hi = sum64_5_hi$1, utils$g.sum64_5_lo = sum64_5_lo$1, utils$g.rotr64_hi = rotr64_hi$1, utils$g.rotr64_lo = rotr64_lo$1, utils$g.shr64_hi = shr64_hi$1, utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4, BlockHash$4.prototype.update = function(o, n) {
  if (o = utils$f.toArray(o, n), this.pending ? this.pending = this.pending.concat(o) : this.pending = o, this.pendingTotal += o.length, this.pending.length >= this._delta8) {
    var a = (o = this.pending).length % this._delta8;
    this.pending = o.slice(o.length - a, o.length), this.pending.length === 0 && (this.pending = null), o = utils$f.join32(o, 0, o.length - a, this.endian);
    for (var u = 0; u < o.length; u += this._delta32)
      this._update(o, u, u + this._delta32);
  }
  return this;
}, BlockHash$4.prototype.digest = function(o) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(o);
}, BlockHash$4.prototype._pad = function() {
  var o = this.pendingTotal, n = this._delta8, a = n - (o + this.padLength) % n, u = new Array(a + this.padLength);
  u[0] = 128;
  for (var c = 1; c < a; c++)
    u[c] = 0;
  if (o <<= 3, this.endian === "big") {
    for (var m = 8; m < this.padLength; m++)
      u[c++] = 0;
    u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = o >>> 24 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 8 & 255, u[c++] = 255 & o;
  } else
    for (u[c++] = 255 & o, u[c++] = o >>> 8 & 255, u[c++] = o >>> 16 & 255, u[c++] = o >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, m = 8; m < this.padLength; m++)
      u[c++] = 0;
  return u;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(o, n, a, u) {
  return o === 0 ? ch32$1(n, a, u) : o === 1 || o === 3 ? p32(n, a, u) : o === 2 ? maj32$1(n, a, u) : void 0;
}
function ch32$1(o, n, a) {
  return o & n ^ ~o & a;
}
function maj32$1(o, n, a) {
  return o & n ^ o & a ^ n & a;
}
function p32(o, n, a) {
  return o ^ n ^ a;
}
function s0_256$1(o) {
  return rotr32(o, 2) ^ rotr32(o, 13) ^ rotr32(o, 22);
}
function s1_256$1(o) {
  return rotr32(o, 6) ^ rotr32(o, 11) ^ rotr32(o, 25);
}
function g0_256$1(o) {
  return rotr32(o, 7) ^ rotr32(o, 18) ^ o >>> 3;
}
function g1_256$1(o) {
  return rotr32(o, 17) ^ rotr32(o, 19) ^ o >>> 10;
}
common$4.ft_1 = ft_1$1, common$4.ch32 = ch32$1, common$4.maj32 = maj32$1, common$4.p32 = p32, common$4.s0_256 = s0_256$1, common$4.s1_256 = s1_256$1, common$4.g0_256 = g0_256$1, common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(o, n) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = o[n + u];
  for (; u < a.length; u++)
    a[u] = rotl32$1(a[u - 3] ^ a[u - 8] ^ a[u - 14] ^ a[u - 16], 1);
  var c = this.h[0], m = this.h[1], d = this.h[2], w = this.h[3], S = this.h[4];
  for (u = 0; u < a.length; u++) {
    var T = ~~(u / 20), B = sum32_5$1(rotl32$1(c, 5), ft_1(T, m, d, w), S, a[u], sha1_K[T]);
    S = w, w = d, d = rotl32$1(m, 30), m = c, c = B;
  }
  this.h[0] = sum32$2(this.h[0], c), this.h[1] = sum32$2(this.h[1], m), this.h[2] = sum32$2(this.h[2], d), this.h[3] = sum32$2(this.h[3], w), this.h[4] = sum32$2(this.h[4], S);
}, SHA1.prototype._digest = function(o) {
  return o === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512, SHA256$1.outSize = 256, SHA256$1.hmacStrength = 192, SHA256$1.padLength = 64, SHA256$1.prototype._update = function(o, n) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = o[n + u];
  for (; u < a.length; u++)
    a[u] = sum32_4$1(g1_256(a[u - 2]), a[u - 7], g0_256(a[u - 15]), a[u - 16]);
  var c = this.h[0], m = this.h[1], d = this.h[2], w = this.h[3], S = this.h[4], T = this.h[5], B = this.h[6], I = this.h[7];
  for (assert$9(this.k.length === a.length), u = 0; u < a.length; u++) {
    var C = sum32_5(I, s1_256(S), ch32(S, T, B), this.k[u], a[u]), N = sum32$1(s0_256(c), maj32(c, m, d));
    I = B, B = T, T = S, S = sum32$1(w, C), w = d, d = m, m = c, c = sum32$1(C, N);
  }
  this.h[0] = sum32$1(this.h[0], c), this.h[1] = sum32$1(this.h[1], m), this.h[2] = sum32$1(this.h[2], d), this.h[3] = sum32$1(this.h[3], w), this.h[4] = sum32$1(this.h[4], S), this.h[5] = sum32$1(this.h[5], T), this.h[6] = sum32$1(this.h[6], B), this.h[7] = sum32$1(this.h[7], I);
}, SHA256$1.prototype._digest = function(o) {
  return o === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(o) {
  return o === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
function ch64_hi(o, n, a, u, c) {
  var m = o & a ^ ~o & c;
  return m < 0 && (m += 4294967296), m;
}
function ch64_lo(o, n, a, u, c, m) {
  var d = n & u ^ ~n & m;
  return d < 0 && (d += 4294967296), d;
}
function maj64_hi(o, n, a, u, c) {
  var m = o & a ^ o & c ^ a & c;
  return m < 0 && (m += 4294967296), m;
}
function maj64_lo(o, n, a, u, c, m) {
  var d = n & u ^ n & m ^ u & m;
  return d < 0 && (d += 4294967296), d;
}
function s0_512_hi(o, n) {
  var a = rotr64_hi(o, n, 28) ^ rotr64_hi(n, o, 2) ^ rotr64_hi(n, o, 7);
  return a < 0 && (a += 4294967296), a;
}
function s0_512_lo(o, n) {
  var a = rotr64_lo(o, n, 28) ^ rotr64_lo(n, o, 2) ^ rotr64_lo(n, o, 7);
  return a < 0 && (a += 4294967296), a;
}
function s1_512_hi(o, n) {
  var a = rotr64_hi(o, n, 14) ^ rotr64_hi(o, n, 18) ^ rotr64_hi(n, o, 9);
  return a < 0 && (a += 4294967296), a;
}
function s1_512_lo(o, n) {
  var a = rotr64_lo(o, n, 14) ^ rotr64_lo(o, n, 18) ^ rotr64_lo(n, o, 9);
  return a < 0 && (a += 4294967296), a;
}
function g0_512_hi(o, n) {
  var a = rotr64_hi(o, n, 1) ^ rotr64_hi(o, n, 8) ^ shr64_hi(o, n, 7);
  return a < 0 && (a += 4294967296), a;
}
function g0_512_lo(o, n) {
  var a = rotr64_lo(o, n, 1) ^ rotr64_lo(o, n, 8) ^ shr64_lo(o, n, 7);
  return a < 0 && (a += 4294967296), a;
}
function g1_512_hi(o, n) {
  var a = rotr64_hi(o, n, 19) ^ rotr64_hi(n, o, 29) ^ shr64_hi(o, n, 6);
  return a < 0 && (a += 4294967296), a;
}
function g1_512_lo(o, n) {
  var a = rotr64_lo(o, n, 19) ^ rotr64_lo(n, o, 29) ^ shr64_lo(o, n, 6);
  return a < 0 && (a += 4294967296), a;
}
SHA512$1.blockSize = 1024, SHA512$1.outSize = 512, SHA512$1.hmacStrength = 192, SHA512$1.padLength = 128, SHA512$1.prototype._prepareBlock = function(o, n) {
  for (var a = this.W, u = 0; u < 32; u++)
    a[u] = o[n + u];
  for (; u < a.length; u += 2) {
    var c = g1_512_hi(a[u - 4], a[u - 3]), m = g1_512_lo(a[u - 4], a[u - 3]), d = a[u - 14], w = a[u - 13], S = g0_512_hi(a[u - 30], a[u - 29]), T = g0_512_lo(a[u - 30], a[u - 29]), B = a[u - 32], I = a[u - 31];
    a[u] = sum64_4_hi(c, m, d, w, S, T, B, I), a[u + 1] = sum64_4_lo(c, m, d, w, S, T, B, I);
  }
}, SHA512$1.prototype._update = function(o, n) {
  this._prepareBlock(o, n);
  var a = this.W, u = this.h[0], c = this.h[1], m = this.h[2], d = this.h[3], w = this.h[4], S = this.h[5], T = this.h[6], B = this.h[7], I = this.h[8], C = this.h[9], N = this.h[10], q = this.h[11], D = this.h[12], z = this.h[13], W = this.h[14], V = this.h[15];
  assert$8(this.k.length === a.length);
  for (var ee = 0; ee < a.length; ee += 2) {
    var P = W, F = V, H = s1_512_hi(I, C), te = s1_512_lo(I, C), p = ch64_hi(I, C, N, q, D), $ = ch64_lo(I, C, N, q, D, z), _ = this.k[ee], y = this.k[ee + 1], g = a[ee], v = a[ee + 1], E = sum64_5_hi(P, F, H, te, p, $, _, y, g, v), A = sum64_5_lo(P, F, H, te, p, $, _, y, g, v);
    P = s0_512_hi(u, c), F = s0_512_lo(u, c), H = maj64_hi(u, c, m, d, w), te = maj64_lo(u, c, m, d, w, S);
    var L = sum64_hi(P, F, H, te), j = sum64_lo(P, F, H, te);
    W = D, V = z, D = N, z = q, N = I, q = C, I = sum64_hi(T, B, E, A), C = sum64_lo(B, B, E, A), T = w, B = S, w = m, S = d, m = u, d = c, u = sum64_hi(E, A, L, j), c = sum64_lo(E, A, L, j);
  }
  sum64(this.h, 0, u, c), sum64(this.h, 2, m, d), sum64(this.h, 4, w, S), sum64(this.h, 6, T, B), sum64(this.h, 8, I, C), sum64(this.h, 10, N, q), sum64(this.h, 12, D, z), sum64(this.h, 14, W, V);
}, SHA512$1.prototype._digest = function(o) {
  return o === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(o) {
  return o === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
}, sha.sha1 = _1, sha.sha224 = _224, sha.sha256 = _256, sha.sha384 = _384, sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
function f(o, n, a, u) {
  return o <= 15 ? n ^ a ^ u : o <= 31 ? n & a | ~n & u : o <= 47 ? (n | ~a) ^ u : o <= 63 ? n & u | a & ~u : n ^ (a | ~u);
}
function K(o) {
  return o <= 15 ? 0 : o <= 31 ? 1518500249 : o <= 47 ? 1859775393 : o <= 63 ? 2400959708 : 2840853838;
}
function Kh(o) {
  return o <= 15 ? 1352829926 : o <= 31 ? 1548603684 : o <= 47 ? 1836072691 : o <= 63 ? 2053994217 : 0;
}
utils$8.inherits(RIPEMD160, BlockHash), ripemd.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(o, n) {
  for (var a = this.h[0], u = this.h[1], c = this.h[2], m = this.h[3], d = this.h[4], w = a, S = u, T = c, B = m, I = d, C = 0; C < 80; C++) {
    var N = sum32(rotl32(sum32_4(a, f(C, u, c, m), o[r[C] + n], K(C)), s[C]), d);
    a = d, d = m, m = rotl32(c, 10), c = u, u = N, N = sum32(rotl32(sum32_4(w, f(79 - C, S, T, B), o[rh[C] + n], Kh(C)), sh[C]), I), w = I, I = B, B = rotl32(T, 10), T = S, S = N;
  }
  N = sum32_3(this.h[1], c, B), this.h[1] = sum32_3(this.h[2], m, I), this.h[2] = sum32_3(this.h[3], d, w), this.h[3] = sum32_3(this.h[4], a, S), this.h[4] = sum32_3(this.h[0], u, T), this.h[0] = N;
}, RIPEMD160.prototype._digest = function(o) {
  return o === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(o, n, a) {
  if (!(this instanceof Hmac))
    return new Hmac(o, n, a);
  this.Hash = o, this.blockSize = o.blockSize / 8, this.outSize = o.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(n, a));
}
var hmac = Hmac, secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 ? secp256k1 : (hasRequiredSecp256k1 = 1, secp256k1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } });
}
Hmac.prototype._init = function(o) {
  o.length > this.blockSize && (o = new this.Hash().update(o).digest()), assert$7(o.length <= this.blockSize);
  for (var n = o.length; n < this.blockSize; n++)
    o.push(0);
  for (n = 0; n < o.length; n++)
    o[n] ^= 54;
  for (this.inner = new this.Hash().update(o), n = 0; n < o.length; n++)
    o[n] ^= 106;
  this.outer = new this.Hash().update(o);
}, Hmac.prototype.update = function(o, n) {
  return this.inner.update(o, n), this;
}, Hmac.prototype.digest = function(o) {
  return this.outer.update(this.inner.digest()), this.outer.digest(o);
}, function(o) {
  var n = hash$2;
  n.utils = utils$g, n.common = common$5, n.sha = sha, n.ripemd = ripemd, n.hmac = hmac, n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160;
}(), function(o) {
  var n, a = curves$2, u = hash$2, c = curve, m = utils$m.assert;
  function d(S) {
    S.type === "short" ? this.curve = new c.short(S) : S.type === "edwards" ? this.curve = new c.edwards(S) : this.curve = new c.mont(S), this.g = this.curve.g, this.n = this.curve.n, this.hash = S.hash, m(this.g.validate(), "Invalid curve"), m(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  function w(S, T) {
    Object.defineProperty(a, S, { configurable: !0, enumerable: !0, get: function() {
      var B = new d(T);
      return Object.defineProperty(a, S, { configurable: !0, enumerable: !0, value: B }), B;
    } });
  }
  a.PresetCurve = d, w("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: u.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), w("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: u.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), w("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: u.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), w("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: u.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), w("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: u.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), w("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["9"] }), w("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  try {
    n = requireSecp256k1();
  } catch {
    n = void 0;
  }
  w("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: u.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] });
}();
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG$1(o) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(o);
  this.hash = o.hash, this.predResist = !!o.predResist, this.outLen = this.hash.outSize, this.minEntropy = o.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var n = utils$6.toArray(o.entropy, o.entropyEnc || "hex"), a = utils$6.toArray(o.nonce, o.nonceEnc || "hex"), u = utils$6.toArray(o.pers, o.persEnc || "hex");
  assert$6(n.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(n, a, u);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(o, n, a) {
  var u = o.concat(n).concat(a);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var c = 0; c < this.V.length; c++)
    this.K[c] = 0, this.V[c] = 1;
  this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
}, HmacDRBG$1.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
}, HmacDRBG$1.prototype._update = function(o) {
  var n = this._hmac().update(this.V).update([0]);
  o && (n = n.update(o)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), o && (this.K = this._hmac().update(this.V).update([1]).update(o).digest(), this.V = this._hmac().update(this.V).digest());
}, HmacDRBG$1.prototype.reseed = function(o, n, a, u) {
  typeof n != "string" && (u = a, a = n, n = null), o = utils$6.toArray(o, n), a = utils$6.toArray(a, u), assert$6(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(o.concat(a || [])), this._reseed = 1;
}, HmacDRBG$1.prototype.generate = function(o, n, a, u) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof n != "string" && (u = a, a = n, n = null), a && (a = utils$6.toArray(a, u || "hex"), this._update(a));
  for (var c = []; c.length < o; )
    this.V = this._hmac().update(this.V).digest(), c = c.concat(this.V);
  var m = c.slice(0, o);
  return this._update(a), this._reseed++, utils$6.encode(m, n);
};
var BN$4 = bn$2.exports, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$3(o, n) {
  this.ec = o, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc);
}
var key$2 = KeyPair$3;
KeyPair$3.fromPublic = function(o, n, a) {
  return n instanceof KeyPair$3 ? n : new KeyPair$3(o, { pub: n, pubEnc: a });
}, KeyPair$3.fromPrivate = function(o, n, a) {
  return n instanceof KeyPair$3 ? n : new KeyPair$3(o, { priv: n, privEnc: a });
}, KeyPair$3.prototype.validate = function() {
  var o = this.getPublic();
  return o.isInfinity() ? { result: !1, reason: "Invalid public key" } : o.validate() ? o.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
}, KeyPair$3.prototype.getPublic = function(o, n) {
  return typeof o == "string" && (n = o, o = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, o) : this.pub;
}, KeyPair$3.prototype.getPrivate = function(o) {
  return o === "hex" ? this.priv.toString(16, 2) : this.priv;
}, KeyPair$3.prototype._importPrivate = function(o, n) {
  this.priv = new BN$4(o, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, KeyPair$3.prototype._importPublic = function(o, n) {
  if (o.x || o.y)
    return this.ec.curve.type === "mont" ? assert$5(o.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || assert$5(o.x && o.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(o.x, o.y));
  this.pub = this.ec.curve.decodePoint(o, n);
}, KeyPair$3.prototype.derive = function(o) {
  return o.validate() || assert$5(o.validate(), "public point not validated"), o.mul(this.priv).getX();
}, KeyPair$3.prototype.sign = function(o, n, a) {
  return this.ec.sign(o, this, n, a);
}, KeyPair$3.prototype.verify = function(o, n) {
  return this.ec.verify(o, n, this);
}, KeyPair$3.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$3 = bn$2.exports, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$3(o, n) {
  if (o instanceof Signature$3)
    return o;
  this._importDER(o, n) || (assert$4(o.r && o.s, "Signature without r or s"), this.r = new BN$3(o.r, 16), this.s = new BN$3(o.s, 16), o.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = o.recoveryParam);
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(o, n) {
  var a = o[n.place++];
  if (!(128 & a))
    return a;
  var u = 15 & a;
  if (u === 0 || u > 4)
    return !1;
  for (var c = 0, m = 0, d = n.place; m < u; m++, d++)
    c <<= 8, c |= o[d], c >>>= 0;
  return !(c <= 127) && (n.place = d, c);
}
function rmPadding(o) {
  for (var n = 0, a = o.length - 1; !o[n] && !(128 & o[n + 1]) && n < a; )
    n++;
  return n === 0 ? o : o.slice(n);
}
function constructLength(o, n) {
  if (n < 128)
    o.push(n);
  else {
    var a = 1 + (Math.log(n) / Math.LN2 >>> 3);
    for (o.push(128 | a); --a; )
      o.push(n >>> (a << 3) & 255);
    o.push(n);
  }
}
Signature$3.prototype._importDER = function(o, n) {
  o = utils$4.toArray(o, n);
  var a = new Position();
  if (o[a.place++] !== 48)
    return !1;
  var u = getLength(o, a);
  if (u === !1 || u + a.place !== o.length || o[a.place++] !== 2)
    return !1;
  var c = getLength(o, a);
  if (c === !1)
    return !1;
  var m = o.slice(a.place, c + a.place);
  if (a.place += c, o[a.place++] !== 2)
    return !1;
  var d = getLength(o, a);
  if (d === !1 || o.length !== d + a.place)
    return !1;
  var w = o.slice(a.place, d + a.place);
  if (m[0] === 0) {
    if (!(128 & m[1]))
      return !1;
    m = m.slice(1);
  }
  if (w[0] === 0) {
    if (!(128 & w[1]))
      return !1;
    w = w.slice(1);
  }
  return this.r = new BN$3(m), this.s = new BN$3(w), this.recoveryParam = null, !0;
}, Signature$3.prototype.toDER = function(o) {
  var n = this.r.toArray(), a = this.s.toArray();
  for (128 & n[0] && (n = [0].concat(n)), 128 & a[0] && (a = [0].concat(a)), n = rmPadding(n), a = rmPadding(a); !(a[0] || 128 & a[1]); )
    a = a.slice(1);
  var u = [2];
  constructLength(u, n.length), (u = u.concat(n)).push(2), constructLength(u, a.length);
  var c = u.concat(a), m = [48];
  return constructLength(m, c.length), m = m.concat(c), utils$4.encode(m, o);
};
var BN$2 = bn$2.exports, HmacDRBG = hmacDrbg, utils$3 = utils$m, curves$1 = curves$2, rand = brorand.exports, assert$3 = utils$3.assert, KeyPair$2 = key$2, Signature$2 = signature$1;
function EC$3(o) {
  if (!(this instanceof EC$3))
    return new EC$3(o);
  typeof o == "string" && (assert$3(Object.prototype.hasOwnProperty.call(curves$1, o), "Unknown curve " + o), o = curves$1[o]), o instanceof curves$1.PresetCurve && (o = { curve: o }), this.curve = o.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = o.curve.g, this.g.precompute(o.curve.n.bitLength() + 1), this.hash = o.hash || o.curve.hash;
}
var ec = EC$3;
EC$3.prototype.keyPair = function(o) {
  return new KeyPair$2(this, o);
}, EC$3.prototype.keyFromPrivate = function(o, n) {
  return KeyPair$2.fromPrivate(this, o, n);
}, EC$3.prototype.keyFromPublic = function(o, n) {
  return KeyPair$2.fromPublic(this, o, n);
}, EC$3.prototype.genKeyPair = function(o) {
  o || (o = {});
  for (var n = new HmacDRBG({ hash: this.hash, pers: o.pers, persEnc: o.persEnc || "utf8", entropy: o.entropy || rand(this.hash.hmacStrength), entropyEnc: o.entropy && o.entropyEnc || "utf8", nonce: this.n.toArray() }), a = this.n.byteLength(), u = this.n.sub(new BN$2(2)); ; ) {
    var c = new BN$2(n.generate(a));
    if (!(c.cmp(u) > 0))
      return c.iaddn(1), this.keyFromPrivate(c);
  }
}, EC$3.prototype._truncateToN = function(o, n) {
  var a = 8 * o.byteLength() - this.n.bitLength();
  return a > 0 && (o = o.ushrn(a)), !n && o.cmp(this.n) >= 0 ? o.sub(this.n) : o;
}, EC$3.prototype.sign = function(o, n, a, u) {
  typeof a == "object" && (u = a, a = null), u || (u = {}), n = this.keyFromPrivate(n, a), o = this._truncateToN(new BN$2(o, 16));
  for (var c = this.n.byteLength(), m = n.getPrivate().toArray("be", c), d = o.toArray("be", c), w = new HmacDRBG({ hash: this.hash, entropy: m, nonce: d, pers: u.pers, persEnc: u.persEnc || "utf8" }), S = this.n.sub(new BN$2(1)), T = 0; ; T++) {
    var B = u.k ? u.k(T) : new BN$2(w.generate(this.n.byteLength()));
    if (!((B = this._truncateToN(B, !0)).cmpn(1) <= 0 || B.cmp(S) >= 0)) {
      var I = this.g.mul(B);
      if (!I.isInfinity()) {
        var C = I.getX(), N = C.umod(this.n);
        if (N.cmpn(0) !== 0) {
          var q = B.invm(this.n).mul(N.mul(n.getPrivate()).iadd(o));
          if ((q = q.umod(this.n)).cmpn(0) !== 0) {
            var D = (I.getY().isOdd() ? 1 : 0) | (C.cmp(N) !== 0 ? 2 : 0);
            return u.canonical && q.cmp(this.nh) > 0 && (q = this.n.sub(q), D ^= 1), new Signature$2({ r: N, s: q, recoveryParam: D });
          }
        }
      }
    }
  }
}, EC$3.prototype.verify = function(o, n, a, u) {
  o = this._truncateToN(new BN$2(o, 16)), a = this.keyFromPublic(a, u);
  var c = (n = new Signature$2(n, "hex")).r, m = n.s;
  if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
    return !1;
  var d, w = m.invm(this.n), S = w.mul(o).umod(this.n), T = w.mul(c).umod(this.n);
  return this.curve._maxwellTrick ? !(d = this.g.jmulAdd(S, a.getPublic(), T)).isInfinity() && d.eqXToP(c) : !(d = this.g.mulAdd(S, a.getPublic(), T)).isInfinity() && d.getX().umod(this.n).cmp(c) === 0;
}, EC$3.prototype.recoverPubKey = function(o, n, a, u) {
  assert$3((3 & a) === a, "The recovery param is more than two bits"), n = new Signature$2(n, u);
  var c = this.n, m = new BN$2(o), d = n.r, w = n.s, S = 1 & a, T = a >> 1;
  if (d.cmp(this.curve.p.umod(this.curve.n)) >= 0 && T)
    throw new Error("Unable to find sencond key candinate");
  d = T ? this.curve.pointFromX(d.add(this.curve.n), S) : this.curve.pointFromX(d, S);
  var B = n.r.invm(c), I = c.sub(m).mul(B).umod(c), C = w.mul(B).umod(c);
  return this.g.mulAdd(I, d, C);
}, EC$3.prototype.getKeyRecoveryParam = function(o, n, a, u) {
  if ((n = new Signature$2(n, u)).recoveryParam !== null)
    return n.recoveryParam;
  for (var c = 0; c < 4; c++) {
    var m;
    try {
      m = this.recoverPubKey(o, n, c);
    } catch {
      continue;
    }
    if (m.eq(a))
      return c;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$2 = utils$m, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(o, n) {
  this.eddsa = o, this._secret = parseBytes$2(n.secret), o.isPoint(n.pub) ? this._pub = n.pub : this._pubBytes = parseBytes$2(n.pub);
}
KeyPair$1.fromPublic = function(o, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(o, { pub: n });
}, KeyPair$1.fromSecret = function(o, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(o, { secret: n });
}, KeyPair$1.prototype.secret = function() {
  return this._secret;
}, cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
}), cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
}), cachedProperty$1(KeyPair$1, "privBytes", function() {
  var o = this.eddsa, n = this.hash(), a = o.encodingLength - 1, u = n.slice(0, o.encodingLength);
  return u[0] &= 248, u[a] &= 127, u[a] |= 64, u;
}), cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
}), cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
}), cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
}), KeyPair$1.prototype.sign = function(o) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
}, KeyPair$1.prototype.verify = function(o, n) {
  return this.eddsa.verify(o, n, this);
}, KeyPair$1.prototype.getSecret = function(o) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), o);
}, KeyPair$1.prototype.getPublic = function(o) {
  return utils$2.encode(this.pubBytes(), o);
};
var key$1 = KeyPair$1, BN$1 = bn$2.exports, utils$1 = utils$m, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(o, n) {
  this.eddsa = o, typeof n != "object" && (n = parseBytes$1(n)), Array.isArray(n) && (n = { R: n.slice(0, o.encodingLength), S: n.slice(o.encodingLength) }), assert$1(n.R && n.S, "Signature without R or S"), o.isPoint(n.R) && (this._R = n.R), n.S instanceof BN$1 && (this._S = n.S), this._Rencoded = Array.isArray(n.R) ? n.R : n.Rencoded, this._Sencoded = Array.isArray(n.S) ? n.S : n.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
}), cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
}), cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
}), cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
}), Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
}, Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$2, utils = utils$m, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(o) {
  if (assert(o === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(o);
  o = curves[o].curve, this.curve = o, this.g = o.g, this.g.precompute(o.n.bitLength() + 1), this.pointClass = o.point().constructor, this.encodingLength = Math.ceil(o.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(o, n) {
  o = parseBytes(o);
  var a = this.keyFromSecret(n), u = this.hashInt(a.messagePrefix(), o), c = this.g.mul(u), m = this.encodePoint(c), d = this.hashInt(m, a.pubBytes(), o).mul(a.priv()), w = u.add(d).umod(this.curve.n);
  return this.makeSignature({ R: c, S: w, Rencoded: m });
}, EDDSA.prototype.verify = function(o, n, a) {
  o = parseBytes(o), n = this.makeSignature(n);
  var u = this.keyFromPublic(a), c = this.hashInt(n.Rencoded(), u.pubBytes(), o), m = this.g.mul(n.S());
  return n.R().add(u.pub().mul(c)).eq(m);
}, EDDSA.prototype.hashInt = function() {
  for (var o = this.hash(), n = 0; n < arguments.length; n++)
    o.update(arguments[n]);
  return utils.intFromLE(o.digest()).umod(this.curve.n);
}, EDDSA.prototype.keyFromPublic = function(o) {
  return KeyPair.fromPublic(this, o);
}, EDDSA.prototype.keyFromSecret = function(o) {
  return KeyPair.fromSecret(this, o);
}, EDDSA.prototype.makeSignature = function(o) {
  return o instanceof Signature ? o : new Signature(this, o);
}, EDDSA.prototype.encodePoint = function(o) {
  var n = o.getY().toArray("le", this.encodingLength);
  return n[this.encodingLength - 1] |= o.getX().isOdd() ? 128 : 0, n;
}, EDDSA.prototype.decodePoint = function(o) {
  var n = (o = utils.parseBytes(o)).length - 1, a = o.slice(0, n).concat(-129 & o[n]), u = (128 & o[n]) != 0, c = utils.intFromLE(a);
  return this.curve.pointFromY(c, u);
}, EDDSA.prototype.encodeInt = function(o) {
  return o.toArray("le", this.encodingLength);
}, EDDSA.prototype.decodeInt = function(o) {
  return utils.intFromLE(o);
}, EDDSA.prototype.isPoint = function(o) {
  return o instanceof this.pointClass;
}, function(o) {
  var n = elliptic$1;
  n.version = require$$0$2.version, n.utils = utils$m, n.rand = brorand.exports, n.curve = curve, n.curves = curves$2, n.ec = ec, n.eddsa = eddsa;
}();
var bn$1 = { exports: {} };
(function(o, n) {
  function a(_, y) {
    if (!_)
      throw new Error(y || "Assertion failed");
  }
  function u(_, y) {
    _.super_ = y;
    var g = function() {
    };
    g.prototype = y.prototype, _.prototype = new g(), _.prototype.constructor = _;
  }
  function c(_, y, g) {
    if (c.isBN(_))
      return _;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null && (y !== "le" && y !== "be" || (g = y, y = 10), this._init(_ || 0, y || 10, g || "be"));
  }
  var m;
  typeof bn$1 == "object" ? bn$1.exports = c : n.BN = c, c.BN = c, c.wordSize = 26;
  try {
    m = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(_, y) {
    var g = _.charCodeAt(y);
    return g >= 48 && g <= 57 ? g - 48 : g >= 65 && g <= 70 ? g - 55 : g >= 97 && g <= 102 ? g - 87 : void a(!1, "Invalid character in " + _);
  }
  function w(_, y, g) {
    var v = d(_, g);
    return g - 1 >= y && (v |= d(_, g - 1) << 4), v;
  }
  function S(_, y, g, v) {
    for (var E = 0, A = 0, L = Math.min(_.length, g), j = y; j < L; j++) {
      var J = _.charCodeAt(j) - 48;
      E *= v, A = J >= 49 ? J - 49 + 10 : J >= 17 ? J - 17 + 10 : J, a(J >= 0 && A < v, "Invalid character"), E += A;
    }
    return E;
  }
  function T(_, y) {
    _.words = y.words, _.length = y.length, _.negative = y.negative, _.red = y.red;
  }
  if (c.isBN = function(_) {
    return _ instanceof c || _ !== null && typeof _ == "object" && _.constructor.wordSize === c.wordSize && Array.isArray(_.words);
  }, c.max = function(_, y) {
    return _.cmp(y) > 0 ? _ : y;
  }, c.min = function(_, y) {
    return _.cmp(y) < 0 ? _ : y;
  }, c.prototype._init = function(_, y, g) {
    if (typeof _ == "number")
      return this._initNumber(_, y, g);
    if (typeof _ == "object")
      return this._initArray(_, y, g);
    y === "hex" && (y = 16), a(y === (0 | y) && y >= 2 && y <= 36);
    var v = 0;
    (_ = _.toString().replace(/\s+/g, ""))[0] === "-" && (v++, this.negative = 1), v < _.length && (y === 16 ? this._parseHex(_, v, g) : (this._parseBase(_, y, v), g === "le" && this._initArray(this.toArray(), y, g)));
  }, c.prototype._initNumber = function(_, y, g) {
    _ < 0 && (this.negative = 1, _ = -_), _ < 67108864 ? (this.words = [67108863 & _], this.length = 1) : _ < 4503599627370496 ? (this.words = [67108863 & _, _ / 67108864 & 67108863], this.length = 2) : (a(_ < 9007199254740992), this.words = [67108863 & _, _ / 67108864 & 67108863, 1], this.length = 3), g === "le" && this._initArray(this.toArray(), y, g);
  }, c.prototype._initArray = function(_, y, g) {
    if (a(typeof _.length == "number"), _.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(_.length / 3), this.words = new Array(this.length);
    for (var v = 0; v < this.length; v++)
      this.words[v] = 0;
    var E, A, L = 0;
    if (g === "be")
      for (v = _.length - 1, E = 0; v >= 0; v -= 3)
        A = _[v] | _[v - 1] << 8 | _[v - 2] << 16, this.words[E] |= A << L & 67108863, this.words[E + 1] = A >>> 26 - L & 67108863, (L += 24) >= 26 && (L -= 26, E++);
    else if (g === "le")
      for (v = 0, E = 0; v < _.length; v += 3)
        A = _[v] | _[v + 1] << 8 | _[v + 2] << 16, this.words[E] |= A << L & 67108863, this.words[E + 1] = A >>> 26 - L & 67108863, (L += 24) >= 26 && (L -= 26, E++);
    return this._strip();
  }, c.prototype._parseHex = function(_, y, g) {
    this.length = Math.ceil((_.length - y) / 6), this.words = new Array(this.length);
    for (var v = 0; v < this.length; v++)
      this.words[v] = 0;
    var E, A = 0, L = 0;
    if (g === "be")
      for (v = _.length - 1; v >= y; v -= 2)
        E = w(_, y, v) << A, this.words[L] |= 67108863 & E, A >= 18 ? (A -= 18, L += 1, this.words[L] |= E >>> 26) : A += 8;
    else
      for (v = (_.length - y) % 2 == 0 ? y + 1 : y; v < _.length; v += 2)
        E = w(_, y, v) << A, this.words[L] |= 67108863 & E, A >= 18 ? (A -= 18, L += 1, this.words[L] |= E >>> 26) : A += 8;
    this._strip();
  }, c.prototype._parseBase = function(_, y, g) {
    this.words = [0], this.length = 1;
    for (var v = 0, E = 1; E <= 67108863; E *= y)
      v++;
    v--, E = E / y | 0;
    for (var A = _.length - g, L = A % v, j = Math.min(A, A - L) + g, J = 0, X = g; X < j; X += v)
      J = S(_, X, X + v, y), this.imuln(E), this.words[0] + J < 67108864 ? this.words[0] += J : this._iaddn(J);
    if (L !== 0) {
      var re = 1;
      for (J = S(_, X, _.length, y), X = 0; X < L; X++)
        re *= y;
      this.imuln(re), this.words[0] + J < 67108864 ? this.words[0] += J : this._iaddn(J);
    }
    this._strip();
  }, c.prototype.copy = function(_) {
    _.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      _.words[y] = this.words[y];
    _.length = this.length, _.negative = this.negative, _.red = this.red;
  }, c.prototype._move = function(_) {
    T(_, this);
  }, c.prototype.clone = function() {
    var _ = new c(null);
    return this.copy(_), _;
  }, c.prototype._expand = function(_) {
    for (; this.length < _; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype._strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, typeof Symbol < "u" && typeof Symbol.for == "function")
    try {
      c.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
    } catch {
      c.prototype.inspect = B;
    }
  else
    c.prototype.inspect = B;
  function B() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  }
  var I = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], C = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], N = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function q(_, y, g) {
    g.negative = y.negative ^ _.negative;
    var v = _.length + y.length | 0;
    g.length = v, v = v - 1 | 0;
    var E = 0 | _.words[0], A = 0 | y.words[0], L = E * A, j = 67108863 & L, J = L / 67108864 | 0;
    g.words[0] = j;
    for (var X = 1; X < v; X++) {
      for (var re = J >>> 26, Z = 67108863 & J, ie = Math.min(X, y.length - 1), oe = Math.max(0, X - _.length + 1); oe <= ie; oe++) {
        var ue = X - oe | 0;
        re += (L = (E = 0 | _.words[ue]) * (A = 0 | y.words[oe]) + Z) / 67108864 | 0, Z = 67108863 & L;
      }
      g.words[X] = 0 | Z, J = 0 | re;
    }
    return J !== 0 ? g.words[X] = 0 | J : g.length--, g._strip();
  }
  c.prototype.toString = function(_, y) {
    var g;
    if (y = 0 | y || 1, (_ = _ || 10) === 16 || _ === "hex") {
      g = "";
      for (var v = 0, E = 0, A = 0; A < this.length; A++) {
        var L = this.words[A], j = (16777215 & (L << v | E)).toString(16);
        E = L >>> 24 - v & 16777215, (v += 2) >= 26 && (v -= 26, A--), g = E !== 0 || A !== this.length - 1 ? I[6 - j.length] + j + g : j + g;
      }
      for (E !== 0 && (g = E.toString(16) + g); g.length % y != 0; )
        g = "0" + g;
      return this.negative !== 0 && (g = "-" + g), g;
    }
    if (_ === (0 | _) && _ >= 2 && _ <= 36) {
      var J = C[_], X = N[_];
      g = "";
      var re = this.clone();
      for (re.negative = 0; !re.isZero(); ) {
        var Z = re.modrn(X).toString(_);
        g = (re = re.idivn(X)).isZero() ? Z + g : I[J - Z.length] + Z + g;
      }
      for (this.isZero() && (g = "0" + g); g.length % y != 0; )
        g = "0" + g;
      return this.negative !== 0 && (g = "-" + g), g;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var _ = this.words[0];
    return this.length === 2 ? _ += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? _ += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -_ : _;
  }, c.prototype.toJSON = function() {
    return this.toString(16, 2);
  }, m && (c.prototype.toBuffer = function(_, y) {
    return this.toArrayLike(m, _, y);
  }), c.prototype.toArray = function(_, y) {
    return this.toArrayLike(Array, _, y);
  }, c.prototype.toArrayLike = function(_, y, g) {
    this._strip();
    var v = this.byteLength(), E = g || Math.max(1, v);
    a(v <= E, "byte array longer than desired length"), a(E > 0, "Requested array length <= 0");
    var A = function(L, j) {
      return L.allocUnsafe ? L.allocUnsafe(j) : new L(j);
    }(_, E);
    return this["_toArrayLike" + (y === "le" ? "LE" : "BE")](A, v), A;
  }, c.prototype._toArrayLikeLE = function(_, y) {
    for (var g = 0, v = 0, E = 0, A = 0; E < this.length; E++) {
      var L = this.words[E] << A | v;
      _[g++] = 255 & L, g < _.length && (_[g++] = L >> 8 & 255), g < _.length && (_[g++] = L >> 16 & 255), A === 6 ? (g < _.length && (_[g++] = L >> 24 & 255), v = 0, A = 0) : (v = L >>> 24, A += 2);
    }
    if (g < _.length)
      for (_[g++] = v; g < _.length; )
        _[g++] = 0;
  }, c.prototype._toArrayLikeBE = function(_, y) {
    for (var g = _.length - 1, v = 0, E = 0, A = 0; E < this.length; E++) {
      var L = this.words[E] << A | v;
      _[g--] = 255 & L, g >= 0 && (_[g--] = L >> 8 & 255), g >= 0 && (_[g--] = L >> 16 & 255), A === 6 ? (g >= 0 && (_[g--] = L >> 24 & 255), v = 0, A = 0) : (v = L >>> 24, A += 2);
    }
    if (g >= 0)
      for (_[g--] = v; g >= 0; )
        _[g--] = 0;
  }, Math.clz32 ? c.prototype._countBits = function(_) {
    return 32 - Math.clz32(_);
  } : c.prototype._countBits = function(_) {
    var y = _, g = 0;
    return y >= 4096 && (g += 13, y >>>= 13), y >= 64 && (g += 7, y >>>= 7), y >= 8 && (g += 4, y >>>= 4), y >= 2 && (g += 2, y >>>= 2), g + y;
  }, c.prototype._zeroBits = function(_) {
    if (_ === 0)
      return 26;
    var y = _, g = 0;
    return (8191 & y) == 0 && (g += 13, y >>>= 13), (127 & y) == 0 && (g += 7, y >>>= 7), (15 & y) == 0 && (g += 4, y >>>= 4), (3 & y) == 0 && (g += 2, y >>>= 2), (1 & y) == 0 && g++, g;
  }, c.prototype.bitLength = function() {
    var _ = this.words[this.length - 1], y = this._countBits(_);
    return 26 * (this.length - 1) + y;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var _ = 0, y = 0; y < this.length; y++) {
      var g = this._zeroBits(this.words[y]);
      if (_ += g, g !== 26)
        break;
    }
    return _;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(_) {
    return this.negative !== 0 ? this.abs().inotn(_).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(_) {
    return this.testn(_ - 1) ? this.notn(_).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(_) {
    for (; this.length < _.length; )
      this.words[this.length++] = 0;
    for (var y = 0; y < _.length; y++)
      this.words[y] = this.words[y] | _.words[y];
    return this._strip();
  }, c.prototype.ior = function(_) {
    return a((this.negative | _.negative) == 0), this.iuor(_);
  }, c.prototype.or = function(_) {
    return this.length > _.length ? this.clone().ior(_) : _.clone().ior(this);
  }, c.prototype.uor = function(_) {
    return this.length > _.length ? this.clone().iuor(_) : _.clone().iuor(this);
  }, c.prototype.iuand = function(_) {
    var y;
    y = this.length > _.length ? _ : this;
    for (var g = 0; g < y.length; g++)
      this.words[g] = this.words[g] & _.words[g];
    return this.length = y.length, this._strip();
  }, c.prototype.iand = function(_) {
    return a((this.negative | _.negative) == 0), this.iuand(_);
  }, c.prototype.and = function(_) {
    return this.length > _.length ? this.clone().iand(_) : _.clone().iand(this);
  }, c.prototype.uand = function(_) {
    return this.length > _.length ? this.clone().iuand(_) : _.clone().iuand(this);
  }, c.prototype.iuxor = function(_) {
    var y, g;
    this.length > _.length ? (y = this, g = _) : (y = _, g = this);
    for (var v = 0; v < g.length; v++)
      this.words[v] = y.words[v] ^ g.words[v];
    if (this !== y)
      for (; v < y.length; v++)
        this.words[v] = y.words[v];
    return this.length = y.length, this._strip();
  }, c.prototype.ixor = function(_) {
    return a((this.negative | _.negative) == 0), this.iuxor(_);
  }, c.prototype.xor = function(_) {
    return this.length > _.length ? this.clone().ixor(_) : _.clone().ixor(this);
  }, c.prototype.uxor = function(_) {
    return this.length > _.length ? this.clone().iuxor(_) : _.clone().iuxor(this);
  }, c.prototype.inotn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var y = 0 | Math.ceil(_ / 26), g = _ % 26;
    this._expand(y), g > 0 && y--;
    for (var v = 0; v < y; v++)
      this.words[v] = 67108863 & ~this.words[v];
    return g > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - g), this._strip();
  }, c.prototype.notn = function(_) {
    return this.clone().inotn(_);
  }, c.prototype.setn = function(_, y) {
    a(typeof _ == "number" && _ >= 0);
    var g = _ / 26 | 0, v = _ % 26;
    return this._expand(g + 1), this.words[g] = y ? this.words[g] | 1 << v : this.words[g] & ~(1 << v), this._strip();
  }, c.prototype.iadd = function(_) {
    var y, g, v;
    if (this.negative !== 0 && _.negative === 0)
      return this.negative = 0, y = this.isub(_), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && _.negative !== 0)
      return _.negative = 0, y = this.isub(_), _.negative = 1, y._normSign();
    this.length > _.length ? (g = this, v = _) : (g = _, v = this);
    for (var E = 0, A = 0; A < v.length; A++)
      y = (0 | g.words[A]) + (0 | v.words[A]) + E, this.words[A] = 67108863 & y, E = y >>> 26;
    for (; E !== 0 && A < g.length; A++)
      y = (0 | g.words[A]) + E, this.words[A] = 67108863 & y, E = y >>> 26;
    if (this.length = g.length, E !== 0)
      this.words[this.length] = E, this.length++;
    else if (g !== this)
      for (; A < g.length; A++)
        this.words[A] = g.words[A];
    return this;
  }, c.prototype.add = function(_) {
    var y;
    return _.negative !== 0 && this.negative === 0 ? (_.negative = 0, y = this.sub(_), _.negative ^= 1, y) : _.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = _.sub(this), this.negative = 1, y) : this.length > _.length ? this.clone().iadd(_) : _.clone().iadd(this);
  }, c.prototype.isub = function(_) {
    if (_.negative !== 0) {
      _.negative = 0;
      var y = this.iadd(_);
      return _.negative = 1, y._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(_), this.negative = 1, this._normSign();
    var g, v, E = this.cmp(_);
    if (E === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    E > 0 ? (g = this, v = _) : (g = _, v = this);
    for (var A = 0, L = 0; L < v.length; L++)
      A = (y = (0 | g.words[L]) - (0 | v.words[L]) + A) >> 26, this.words[L] = 67108863 & y;
    for (; A !== 0 && L < g.length; L++)
      A = (y = (0 | g.words[L]) + A) >> 26, this.words[L] = 67108863 & y;
    if (A === 0 && L < g.length && g !== this)
      for (; L < g.length; L++)
        this.words[L] = g.words[L];
    return this.length = Math.max(this.length, L), g !== this && (this.negative = 1), this._strip();
  }, c.prototype.sub = function(_) {
    return this.clone().isub(_);
  };
  var D = function(_, y, g) {
    var v, E, A, L = _.words, j = y.words, J = g.words, X = 0, re = 0 | L[0], Z = 8191 & re, ie = re >>> 13, oe = 0 | L[1], ue = 8191 & oe, se = oe >>> 13, ce = 0 | L[2], Se = 8191 & ce, he = ce >>> 13, $e = 0 | L[3], fe = 8191 & $e, le = $e >>> 13, we = 0 | L[4], We = 8191 & we, de = we >>> 13, ke = 0 | L[5], l = 8191 & ke, h = ke >>> 13, b = 0 | L[6], M = 8191 & b, k = b >>> 13, x = 0 | L[7], O = 8191 & x, G = x >>> 13, Q = 0 | L[8], ne = 8191 & Q, Y = Q >>> 13, ae = 0 | L[9], Ee = 8191 & ae, pe = ae >>> 13, ye = 0 | j[0], Le = 8191 & ye, ge = ye >>> 13, be = 0 | j[1], Re = 8191 & be, me = be >>> 13, Ae = 0 | j[2], He = 8191 & Ae, ve = Ae >>> 13, Me = 0 | j[3], Fe = 8191 & Me, _e = Me >>> 13, Oe = 0 | j[4], qe = 8191 & Oe, Te = Oe >>> 13, Pe = 0 | j[5], ze = 8191 & Pe, xe = Pe >>> 13, Ne = 0 | j[6], Ve = 8191 & Ne, Be = Ne >>> 13, Ue = 0 | j[7], Je = 8191 & Ue, Ie = Ue >>> 13, je = 0 | j[8], Xe = 8191 & je, Ce = je >>> 13, De = 0 | j[9], Ge = 8191 & De, Ke = De >>> 13;
    g.negative = _.negative ^ y.negative, g.length = 19;
    var Ye = (X + (v = Math.imul(Z, Le)) | 0) + ((8191 & (E = (E = Math.imul(Z, ge)) + Math.imul(ie, Le) | 0)) << 13) | 0;
    X = ((A = Math.imul(ie, ge)) + (E >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, v = Math.imul(ue, Le), E = (E = Math.imul(ue, ge)) + Math.imul(se, Le) | 0, A = Math.imul(se, ge);
    var Ze = (X + (v = v + Math.imul(Z, Re) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, me) | 0) + Math.imul(ie, Re) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, me) | 0) + (E >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, v = Math.imul(Se, Le), E = (E = Math.imul(Se, ge)) + Math.imul(he, Le) | 0, A = Math.imul(he, ge), v = v + Math.imul(ue, Re) | 0, E = (E = E + Math.imul(ue, me) | 0) + Math.imul(se, Re) | 0, A = A + Math.imul(se, me) | 0;
    var Qe = (X + (v = v + Math.imul(Z, He) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, ve) | 0) + Math.imul(ie, He) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, ve) | 0) + (E >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, v = Math.imul(fe, Le), E = (E = Math.imul(fe, ge)) + Math.imul(le, Le) | 0, A = Math.imul(le, ge), v = v + Math.imul(Se, Re) | 0, E = (E = E + Math.imul(Se, me) | 0) + Math.imul(he, Re) | 0, A = A + Math.imul(he, me) | 0, v = v + Math.imul(ue, He) | 0, E = (E = E + Math.imul(ue, ve) | 0) + Math.imul(se, He) | 0, A = A + Math.imul(se, ve) | 0;
    var et = (X + (v = v + Math.imul(Z, Fe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, _e) | 0) + Math.imul(ie, Fe) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, _e) | 0) + (E >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, v = Math.imul(We, Le), E = (E = Math.imul(We, ge)) + Math.imul(de, Le) | 0, A = Math.imul(de, ge), v = v + Math.imul(fe, Re) | 0, E = (E = E + Math.imul(fe, me) | 0) + Math.imul(le, Re) | 0, A = A + Math.imul(le, me) | 0, v = v + Math.imul(Se, He) | 0, E = (E = E + Math.imul(Se, ve) | 0) + Math.imul(he, He) | 0, A = A + Math.imul(he, ve) | 0, v = v + Math.imul(ue, Fe) | 0, E = (E = E + Math.imul(ue, _e) | 0) + Math.imul(se, Fe) | 0, A = A + Math.imul(se, _e) | 0;
    var tt = (X + (v = v + Math.imul(Z, qe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, Te) | 0) + Math.imul(ie, qe) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, Te) | 0) + (E >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, v = Math.imul(l, Le), E = (E = Math.imul(l, ge)) + Math.imul(h, Le) | 0, A = Math.imul(h, ge), v = v + Math.imul(We, Re) | 0, E = (E = E + Math.imul(We, me) | 0) + Math.imul(de, Re) | 0, A = A + Math.imul(de, me) | 0, v = v + Math.imul(fe, He) | 0, E = (E = E + Math.imul(fe, ve) | 0) + Math.imul(le, He) | 0, A = A + Math.imul(le, ve) | 0, v = v + Math.imul(Se, Fe) | 0, E = (E = E + Math.imul(Se, _e) | 0) + Math.imul(he, Fe) | 0, A = A + Math.imul(he, _e) | 0, v = v + Math.imul(ue, qe) | 0, E = (E = E + Math.imul(ue, Te) | 0) + Math.imul(se, qe) | 0, A = A + Math.imul(se, Te) | 0;
    var rt = (X + (v = v + Math.imul(Z, ze) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, xe) | 0) + Math.imul(ie, ze) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, xe) | 0) + (E >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, v = Math.imul(M, Le), E = (E = Math.imul(M, ge)) + Math.imul(k, Le) | 0, A = Math.imul(k, ge), v = v + Math.imul(l, Re) | 0, E = (E = E + Math.imul(l, me) | 0) + Math.imul(h, Re) | 0, A = A + Math.imul(h, me) | 0, v = v + Math.imul(We, He) | 0, E = (E = E + Math.imul(We, ve) | 0) + Math.imul(de, He) | 0, A = A + Math.imul(de, ve) | 0, v = v + Math.imul(fe, Fe) | 0, E = (E = E + Math.imul(fe, _e) | 0) + Math.imul(le, Fe) | 0, A = A + Math.imul(le, _e) | 0, v = v + Math.imul(Se, qe) | 0, E = (E = E + Math.imul(Se, Te) | 0) + Math.imul(he, qe) | 0, A = A + Math.imul(he, Te) | 0, v = v + Math.imul(ue, ze) | 0, E = (E = E + Math.imul(ue, xe) | 0) + Math.imul(se, ze) | 0, A = A + Math.imul(se, xe) | 0;
    var nt = (X + (v = v + Math.imul(Z, Ve) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, Be) | 0) + Math.imul(ie, Ve) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, Be) | 0) + (E >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, v = Math.imul(O, Le), E = (E = Math.imul(O, ge)) + Math.imul(G, Le) | 0, A = Math.imul(G, ge), v = v + Math.imul(M, Re) | 0, E = (E = E + Math.imul(M, me) | 0) + Math.imul(k, Re) | 0, A = A + Math.imul(k, me) | 0, v = v + Math.imul(l, He) | 0, E = (E = E + Math.imul(l, ve) | 0) + Math.imul(h, He) | 0, A = A + Math.imul(h, ve) | 0, v = v + Math.imul(We, Fe) | 0, E = (E = E + Math.imul(We, _e) | 0) + Math.imul(de, Fe) | 0, A = A + Math.imul(de, _e) | 0, v = v + Math.imul(fe, qe) | 0, E = (E = E + Math.imul(fe, Te) | 0) + Math.imul(le, qe) | 0, A = A + Math.imul(le, Te) | 0, v = v + Math.imul(Se, ze) | 0, E = (E = E + Math.imul(Se, xe) | 0) + Math.imul(he, ze) | 0, A = A + Math.imul(he, xe) | 0, v = v + Math.imul(ue, Ve) | 0, E = (E = E + Math.imul(ue, Be) | 0) + Math.imul(se, Ve) | 0, A = A + Math.imul(se, Be) | 0;
    var it = (X + (v = v + Math.imul(Z, Je) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, Ie) | 0) + Math.imul(ie, Je) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, Ie) | 0) + (E >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, v = Math.imul(ne, Le), E = (E = Math.imul(ne, ge)) + Math.imul(Y, Le) | 0, A = Math.imul(Y, ge), v = v + Math.imul(O, Re) | 0, E = (E = E + Math.imul(O, me) | 0) + Math.imul(G, Re) | 0, A = A + Math.imul(G, me) | 0, v = v + Math.imul(M, He) | 0, E = (E = E + Math.imul(M, ve) | 0) + Math.imul(k, He) | 0, A = A + Math.imul(k, ve) | 0, v = v + Math.imul(l, Fe) | 0, E = (E = E + Math.imul(l, _e) | 0) + Math.imul(h, Fe) | 0, A = A + Math.imul(h, _e) | 0, v = v + Math.imul(We, qe) | 0, E = (E = E + Math.imul(We, Te) | 0) + Math.imul(de, qe) | 0, A = A + Math.imul(de, Te) | 0, v = v + Math.imul(fe, ze) | 0, E = (E = E + Math.imul(fe, xe) | 0) + Math.imul(le, ze) | 0, A = A + Math.imul(le, xe) | 0, v = v + Math.imul(Se, Ve) | 0, E = (E = E + Math.imul(Se, Be) | 0) + Math.imul(he, Ve) | 0, A = A + Math.imul(he, Be) | 0, v = v + Math.imul(ue, Je) | 0, E = (E = E + Math.imul(ue, Ie) | 0) + Math.imul(se, Je) | 0, A = A + Math.imul(se, Ie) | 0;
    var ot = (X + (v = v + Math.imul(Z, Xe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, Ce) | 0) + Math.imul(ie, Xe) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, Ce) | 0) + (E >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, v = Math.imul(Ee, Le), E = (E = Math.imul(Ee, ge)) + Math.imul(pe, Le) | 0, A = Math.imul(pe, ge), v = v + Math.imul(ne, Re) | 0, E = (E = E + Math.imul(ne, me) | 0) + Math.imul(Y, Re) | 0, A = A + Math.imul(Y, me) | 0, v = v + Math.imul(O, He) | 0, E = (E = E + Math.imul(O, ve) | 0) + Math.imul(G, He) | 0, A = A + Math.imul(G, ve) | 0, v = v + Math.imul(M, Fe) | 0, E = (E = E + Math.imul(M, _e) | 0) + Math.imul(k, Fe) | 0, A = A + Math.imul(k, _e) | 0, v = v + Math.imul(l, qe) | 0, E = (E = E + Math.imul(l, Te) | 0) + Math.imul(h, qe) | 0, A = A + Math.imul(h, Te) | 0, v = v + Math.imul(We, ze) | 0, E = (E = E + Math.imul(We, xe) | 0) + Math.imul(de, ze) | 0, A = A + Math.imul(de, xe) | 0, v = v + Math.imul(fe, Ve) | 0, E = (E = E + Math.imul(fe, Be) | 0) + Math.imul(le, Ve) | 0, A = A + Math.imul(le, Be) | 0, v = v + Math.imul(Se, Je) | 0, E = (E = E + Math.imul(Se, Ie) | 0) + Math.imul(he, Je) | 0, A = A + Math.imul(he, Ie) | 0, v = v + Math.imul(ue, Xe) | 0, E = (E = E + Math.imul(ue, Ce) | 0) + Math.imul(se, Xe) | 0, A = A + Math.imul(se, Ce) | 0;
    var at = (X + (v = v + Math.imul(Z, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Z, Ke) | 0) + Math.imul(ie, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(ie, Ke) | 0) + (E >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v = Math.imul(Ee, Re), E = (E = Math.imul(Ee, me)) + Math.imul(pe, Re) | 0, A = Math.imul(pe, me), v = v + Math.imul(ne, He) | 0, E = (E = E + Math.imul(ne, ve) | 0) + Math.imul(Y, He) | 0, A = A + Math.imul(Y, ve) | 0, v = v + Math.imul(O, Fe) | 0, E = (E = E + Math.imul(O, _e) | 0) + Math.imul(G, Fe) | 0, A = A + Math.imul(G, _e) | 0, v = v + Math.imul(M, qe) | 0, E = (E = E + Math.imul(M, Te) | 0) + Math.imul(k, qe) | 0, A = A + Math.imul(k, Te) | 0, v = v + Math.imul(l, ze) | 0, E = (E = E + Math.imul(l, xe) | 0) + Math.imul(h, ze) | 0, A = A + Math.imul(h, xe) | 0, v = v + Math.imul(We, Ve) | 0, E = (E = E + Math.imul(We, Be) | 0) + Math.imul(de, Ve) | 0, A = A + Math.imul(de, Be) | 0, v = v + Math.imul(fe, Je) | 0, E = (E = E + Math.imul(fe, Ie) | 0) + Math.imul(le, Je) | 0, A = A + Math.imul(le, Ie) | 0, v = v + Math.imul(Se, Xe) | 0, E = (E = E + Math.imul(Se, Ce) | 0) + Math.imul(he, Xe) | 0, A = A + Math.imul(he, Ce) | 0;
    var st = (X + (v = v + Math.imul(ue, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(ue, Ke) | 0) + Math.imul(se, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(se, Ke) | 0) + (E >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, v = Math.imul(Ee, He), E = (E = Math.imul(Ee, ve)) + Math.imul(pe, He) | 0, A = Math.imul(pe, ve), v = v + Math.imul(ne, Fe) | 0, E = (E = E + Math.imul(ne, _e) | 0) + Math.imul(Y, Fe) | 0, A = A + Math.imul(Y, _e) | 0, v = v + Math.imul(O, qe) | 0, E = (E = E + Math.imul(O, Te) | 0) + Math.imul(G, qe) | 0, A = A + Math.imul(G, Te) | 0, v = v + Math.imul(M, ze) | 0, E = (E = E + Math.imul(M, xe) | 0) + Math.imul(k, ze) | 0, A = A + Math.imul(k, xe) | 0, v = v + Math.imul(l, Ve) | 0, E = (E = E + Math.imul(l, Be) | 0) + Math.imul(h, Ve) | 0, A = A + Math.imul(h, Be) | 0, v = v + Math.imul(We, Je) | 0, E = (E = E + Math.imul(We, Ie) | 0) + Math.imul(de, Je) | 0, A = A + Math.imul(de, Ie) | 0, v = v + Math.imul(fe, Xe) | 0, E = (E = E + Math.imul(fe, Ce) | 0) + Math.imul(le, Xe) | 0, A = A + Math.imul(le, Ce) | 0;
    var ut = (X + (v = v + Math.imul(Se, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Se, Ke) | 0) + Math.imul(he, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(he, Ke) | 0) + (E >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, v = Math.imul(Ee, Fe), E = (E = Math.imul(Ee, _e)) + Math.imul(pe, Fe) | 0, A = Math.imul(pe, _e), v = v + Math.imul(ne, qe) | 0, E = (E = E + Math.imul(ne, Te) | 0) + Math.imul(Y, qe) | 0, A = A + Math.imul(Y, Te) | 0, v = v + Math.imul(O, ze) | 0, E = (E = E + Math.imul(O, xe) | 0) + Math.imul(G, ze) | 0, A = A + Math.imul(G, xe) | 0, v = v + Math.imul(M, Ve) | 0, E = (E = E + Math.imul(M, Be) | 0) + Math.imul(k, Ve) | 0, A = A + Math.imul(k, Be) | 0, v = v + Math.imul(l, Je) | 0, E = (E = E + Math.imul(l, Ie) | 0) + Math.imul(h, Je) | 0, A = A + Math.imul(h, Ie) | 0, v = v + Math.imul(We, Xe) | 0, E = (E = E + Math.imul(We, Ce) | 0) + Math.imul(de, Xe) | 0, A = A + Math.imul(de, Ce) | 0;
    var ct = (X + (v = v + Math.imul(fe, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(fe, Ke) | 0) + Math.imul(le, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(le, Ke) | 0) + (E >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, v = Math.imul(Ee, qe), E = (E = Math.imul(Ee, Te)) + Math.imul(pe, qe) | 0, A = Math.imul(pe, Te), v = v + Math.imul(ne, ze) | 0, E = (E = E + Math.imul(ne, xe) | 0) + Math.imul(Y, ze) | 0, A = A + Math.imul(Y, xe) | 0, v = v + Math.imul(O, Ve) | 0, E = (E = E + Math.imul(O, Be) | 0) + Math.imul(G, Ve) | 0, A = A + Math.imul(G, Be) | 0, v = v + Math.imul(M, Je) | 0, E = (E = E + Math.imul(M, Ie) | 0) + Math.imul(k, Je) | 0, A = A + Math.imul(k, Ie) | 0, v = v + Math.imul(l, Xe) | 0, E = (E = E + Math.imul(l, Ce) | 0) + Math.imul(h, Xe) | 0, A = A + Math.imul(h, Ce) | 0;
    var ft = (X + (v = v + Math.imul(We, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(We, Ke) | 0) + Math.imul(de, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(de, Ke) | 0) + (E >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, v = Math.imul(Ee, ze), E = (E = Math.imul(Ee, xe)) + Math.imul(pe, ze) | 0, A = Math.imul(pe, xe), v = v + Math.imul(ne, Ve) | 0, E = (E = E + Math.imul(ne, Be) | 0) + Math.imul(Y, Ve) | 0, A = A + Math.imul(Y, Be) | 0, v = v + Math.imul(O, Je) | 0, E = (E = E + Math.imul(O, Ie) | 0) + Math.imul(G, Je) | 0, A = A + Math.imul(G, Ie) | 0, v = v + Math.imul(M, Xe) | 0, E = (E = E + Math.imul(M, Ce) | 0) + Math.imul(k, Xe) | 0, A = A + Math.imul(k, Ce) | 0;
    var ht = (X + (v = v + Math.imul(l, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(l, Ke) | 0) + Math.imul(h, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(h, Ke) | 0) + (E >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, v = Math.imul(Ee, Ve), E = (E = Math.imul(Ee, Be)) + Math.imul(pe, Ve) | 0, A = Math.imul(pe, Be), v = v + Math.imul(ne, Je) | 0, E = (E = E + Math.imul(ne, Ie) | 0) + Math.imul(Y, Je) | 0, A = A + Math.imul(Y, Ie) | 0, v = v + Math.imul(O, Xe) | 0, E = (E = E + Math.imul(O, Ce) | 0) + Math.imul(G, Xe) | 0, A = A + Math.imul(G, Ce) | 0;
    var dt = (X + (v = v + Math.imul(M, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(M, Ke) | 0) + Math.imul(k, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(k, Ke) | 0) + (E >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v = Math.imul(Ee, Je), E = (E = Math.imul(Ee, Ie)) + Math.imul(pe, Je) | 0, A = Math.imul(pe, Ie), v = v + Math.imul(ne, Xe) | 0, E = (E = E + Math.imul(ne, Ce) | 0) + Math.imul(Y, Xe) | 0, A = A + Math.imul(Y, Ce) | 0;
    var pt = (X + (v = v + Math.imul(O, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(O, Ke) | 0) + Math.imul(G, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(G, Ke) | 0) + (E >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, v = Math.imul(Ee, Xe), E = (E = Math.imul(Ee, Ce)) + Math.imul(pe, Xe) | 0, A = Math.imul(pe, Ce);
    var mt = (X + (v = v + Math.imul(ne, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(ne, Ke) | 0) + Math.imul(Y, Ge) | 0)) << 13) | 0;
    X = ((A = A + Math.imul(Y, Ke) | 0) + (E >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863;
    var yt = (X + (v = Math.imul(Ee, Ge)) | 0) + ((8191 & (E = (E = Math.imul(Ee, Ke)) + Math.imul(pe, Ge) | 0)) << 13) | 0;
    return X = ((A = Math.imul(pe, Ke)) + (E >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, J[0] = Ye, J[1] = Ze, J[2] = Qe, J[3] = et, J[4] = tt, J[5] = rt, J[6] = nt, J[7] = it, J[8] = ot, J[9] = at, J[10] = st, J[11] = ut, J[12] = ct, J[13] = ft, J[14] = ht, J[15] = dt, J[16] = pt, J[17] = mt, J[18] = yt, X !== 0 && (J[19] = X, g.length++), g;
  };
  function z(_, y, g) {
    g.negative = y.negative ^ _.negative, g.length = _.length + y.length;
    for (var v = 0, E = 0, A = 0; A < g.length - 1; A++) {
      var L = E;
      E = 0;
      for (var j = 67108863 & v, J = Math.min(A, y.length - 1), X = Math.max(0, A - _.length + 1); X <= J; X++) {
        var re = A - X, Z = (0 | _.words[re]) * (0 | y.words[X]), ie = 67108863 & Z;
        j = 67108863 & (ie = ie + j | 0), E += (L = (L = L + (Z / 67108864 | 0) | 0) + (ie >>> 26) | 0) >>> 26, L &= 67108863;
      }
      g.words[A] = j, v = L, L = E;
    }
    return v !== 0 ? g.words[A] = v : g.length--, g._strip();
  }
  function W(_, y, g) {
    return z(_, y, g);
  }
  Math.imul || (D = q), c.prototype.mulTo = function(_, y) {
    var g = this.length + _.length;
    return this.length === 10 && _.length === 10 ? D(this, _, y) : g < 63 ? q(this, _, y) : g < 1024 ? z(this, _, y) : W(this, _, y);
  }, c.prototype.mul = function(_) {
    var y = new c(null);
    return y.words = new Array(this.length + _.length), this.mulTo(_, y);
  }, c.prototype.mulf = function(_) {
    var y = new c(null);
    return y.words = new Array(this.length + _.length), W(this, _, y);
  }, c.prototype.imul = function(_) {
    return this.clone().mulTo(_, this);
  }, c.prototype.imuln = function(_) {
    var y = _ < 0;
    y && (_ = -_), a(typeof _ == "number"), a(_ < 67108864);
    for (var g = 0, v = 0; v < this.length; v++) {
      var E = (0 | this.words[v]) * _, A = (67108863 & E) + (67108863 & g);
      g >>= 26, g += E / 67108864 | 0, g += A >>> 26, this.words[v] = 67108863 & A;
    }
    return g !== 0 && (this.words[v] = g, this.length++), y ? this.ineg() : this;
  }, c.prototype.muln = function(_) {
    return this.clone().imuln(_);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(_) {
    var y = function(A) {
      for (var L = new Array(A.bitLength()), j = 0; j < L.length; j++) {
        var J = j / 26 | 0, X = j % 26;
        L[j] = A.words[J] >>> X & 1;
      }
      return L;
    }(_);
    if (y.length === 0)
      return new c(1);
    for (var g = this, v = 0; v < y.length && y[v] === 0; v++, g = g.sqr())
      ;
    if (++v < y.length)
      for (var E = g.sqr(); v < y.length; v++, E = E.sqr())
        y[v] !== 0 && (g = g.mul(E));
    return g;
  }, c.prototype.iushln = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var y, g = _ % 26, v = (_ - g) / 26, E = 67108863 >>> 26 - g << 26 - g;
    if (g !== 0) {
      var A = 0;
      for (y = 0; y < this.length; y++) {
        var L = this.words[y] & E, j = (0 | this.words[y]) - L << g;
        this.words[y] = j | A, A = L >>> 26 - g;
      }
      A && (this.words[y] = A, this.length++);
    }
    if (v !== 0) {
      for (y = this.length - 1; y >= 0; y--)
        this.words[y + v] = this.words[y];
      for (y = 0; y < v; y++)
        this.words[y] = 0;
      this.length += v;
    }
    return this._strip();
  }, c.prototype.ishln = function(_) {
    return a(this.negative === 0), this.iushln(_);
  }, c.prototype.iushrn = function(_, y, g) {
    var v;
    a(typeof _ == "number" && _ >= 0), v = y ? (y - y % 26) / 26 : 0;
    var E = _ % 26, A = Math.min((_ - E) / 26, this.length), L = 67108863 ^ 67108863 >>> E << E, j = g;
    if (v -= A, v = Math.max(0, v), j) {
      for (var J = 0; J < A; J++)
        j.words[J] = this.words[J];
      j.length = A;
    }
    if (A !== 0)
      if (this.length > A)
        for (this.length -= A, J = 0; J < this.length; J++)
          this.words[J] = this.words[J + A];
      else
        this.words[0] = 0, this.length = 1;
    var X = 0;
    for (J = this.length - 1; J >= 0 && (X !== 0 || J >= v); J--) {
      var re = 0 | this.words[J];
      this.words[J] = X << 26 - E | re >>> E, X = re & L;
    }
    return j && X !== 0 && (j.words[j.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
  }, c.prototype.ishrn = function(_, y, g) {
    return a(this.negative === 0), this.iushrn(_, y, g);
  }, c.prototype.shln = function(_) {
    return this.clone().ishln(_);
  }, c.prototype.ushln = function(_) {
    return this.clone().iushln(_);
  }, c.prototype.shrn = function(_) {
    return this.clone().ishrn(_);
  }, c.prototype.ushrn = function(_) {
    return this.clone().iushrn(_);
  }, c.prototype.testn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var y = _ % 26, g = (_ - y) / 26, v = 1 << y;
    return !(this.length <= g || !(this.words[g] & v));
  }, c.prototype.imaskn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var y = _ % 26, g = (_ - y) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
      return this;
    if (y !== 0 && g++, this.length = Math.min(g, this.length), y !== 0) {
      var v = 67108863 ^ 67108863 >>> y << y;
      this.words[this.length - 1] &= v;
    }
    return this._strip();
  }, c.prototype.maskn = function(_) {
    return this.clone().imaskn(_);
  }, c.prototype.iaddn = function(_) {
    return a(typeof _ == "number"), a(_ < 67108864), _ < 0 ? this.isubn(-_) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) <= _ ? (this.words[0] = _ - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(_), this.negative = 1, this) : this._iaddn(_);
  }, c.prototype._iaddn = function(_) {
    this.words[0] += _;
    for (var y = 0; y < this.length && this.words[y] >= 67108864; y++)
      this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
    return this.length = Math.max(this.length, y + 1), this;
  }, c.prototype.isubn = function(_) {
    if (a(typeof _ == "number"), a(_ < 67108864), _ < 0)
      return this.iaddn(-_);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(_), this.negative = 1, this;
    if (this.words[0] -= _, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var y = 0; y < this.length && this.words[y] < 0; y++)
        this.words[y] += 67108864, this.words[y + 1] -= 1;
    return this._strip();
  }, c.prototype.addn = function(_) {
    return this.clone().iaddn(_);
  }, c.prototype.subn = function(_) {
    return this.clone().isubn(_);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(_, y, g) {
    var v, E, A = _.length + g;
    this._expand(A);
    var L = 0;
    for (v = 0; v < _.length; v++) {
      E = (0 | this.words[v + g]) + L;
      var j = (0 | _.words[v]) * y;
      L = ((E -= 67108863 & j) >> 26) - (j / 67108864 | 0), this.words[v + g] = 67108863 & E;
    }
    for (; v < this.length - g; v++)
      L = (E = (0 | this.words[v + g]) + L) >> 26, this.words[v + g] = 67108863 & E;
    if (L === 0)
      return this._strip();
    for (a(L === -1), L = 0, v = 0; v < this.length; v++)
      L = (E = -(0 | this.words[v]) + L) >> 26, this.words[v] = 67108863 & E;
    return this.negative = 1, this._strip();
  }, c.prototype._wordDiv = function(_, y) {
    var g = (this.length, _.length), v = this.clone(), E = _, A = 0 | E.words[E.length - 1];
    (g = 26 - this._countBits(A)) != 0 && (E = E.ushln(g), v.iushln(g), A = 0 | E.words[E.length - 1]);
    var L, j = v.length - E.length;
    if (y !== "mod") {
      (L = new c(null)).length = j + 1, L.words = new Array(L.length);
      for (var J = 0; J < L.length; J++)
        L.words[J] = 0;
    }
    var X = v.clone()._ishlnsubmul(E, 1, j);
    X.negative === 0 && (v = X, L && (L.words[j] = 1));
    for (var re = j - 1; re >= 0; re--) {
      var Z = 67108864 * (0 | v.words[E.length + re]) + (0 | v.words[E.length + re - 1]);
      for (Z = Math.min(Z / A | 0, 67108863), v._ishlnsubmul(E, Z, re); v.negative !== 0; )
        Z--, v.negative = 0, v._ishlnsubmul(E, 1, re), v.isZero() || (v.negative ^= 1);
      L && (L.words[re] = Z);
    }
    return L && L._strip(), v._strip(), y !== "div" && g !== 0 && v.iushrn(g), { div: L || null, mod: v };
  }, c.prototype.divmod = function(_, y, g) {
    return a(!_.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && _.negative === 0 ? (A = this.neg().divmod(_, y), y !== "mod" && (v = A.div.neg()), y !== "div" && (E = A.mod.neg(), g && E.negative !== 0 && E.iadd(_)), { div: v, mod: E }) : this.negative === 0 && _.negative !== 0 ? (A = this.divmod(_.neg(), y), y !== "mod" && (v = A.div.neg()), { div: v, mod: A.mod }) : (this.negative & _.negative) != 0 ? (A = this.neg().divmod(_.neg(), y), y !== "div" && (E = A.mod.neg(), g && E.negative !== 0 && E.isub(_)), { div: A.div, mod: E }) : _.length > this.length || this.cmp(_) < 0 ? { div: new c(0), mod: this } : _.length === 1 ? y === "div" ? { div: this.divn(_.words[0]), mod: null } : y === "mod" ? { div: null, mod: new c(this.modrn(_.words[0])) } : { div: this.divn(_.words[0]), mod: new c(this.modrn(_.words[0])) } : this._wordDiv(_, y);
    var v, E, A;
  }, c.prototype.div = function(_) {
    return this.divmod(_, "div", !1).div;
  }, c.prototype.mod = function(_) {
    return this.divmod(_, "mod", !1).mod;
  }, c.prototype.umod = function(_) {
    return this.divmod(_, "mod", !0).mod;
  }, c.prototype.divRound = function(_) {
    var y = this.divmod(_);
    if (y.mod.isZero())
      return y.div;
    var g = y.div.negative !== 0 ? y.mod.isub(_) : y.mod, v = _.ushrn(1), E = _.andln(1), A = g.cmp(v);
    return A < 0 || E === 1 && A === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
  }, c.prototype.modrn = function(_) {
    var y = _ < 0;
    y && (_ = -_), a(_ <= 67108863);
    for (var g = (1 << 26) % _, v = 0, E = this.length - 1; E >= 0; E--)
      v = (g * v + (0 | this.words[E])) % _;
    return y ? -v : v;
  }, c.prototype.modn = function(_) {
    return this.modrn(_);
  }, c.prototype.idivn = function(_) {
    var y = _ < 0;
    y && (_ = -_), a(_ <= 67108863);
    for (var g = 0, v = this.length - 1; v >= 0; v--) {
      var E = (0 | this.words[v]) + 67108864 * g;
      this.words[v] = E / _ | 0, g = E % _;
    }
    return this._strip(), y ? this.ineg() : this;
  }, c.prototype.divn = function(_) {
    return this.clone().idivn(_);
  }, c.prototype.egcd = function(_) {
    a(_.negative === 0), a(!_.isZero());
    var y = this, g = _.clone();
    y = y.negative !== 0 ? y.umod(_) : y.clone();
    for (var v = new c(1), E = new c(0), A = new c(0), L = new c(1), j = 0; y.isEven() && g.isEven(); )
      y.iushrn(1), g.iushrn(1), ++j;
    for (var J = g.clone(), X = y.clone(); !y.isZero(); ) {
      for (var re = 0, Z = 1; (y.words[0] & Z) == 0 && re < 26; ++re, Z <<= 1)
        ;
      if (re > 0)
        for (y.iushrn(re); re-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(J), E.isub(X)), v.iushrn(1), E.iushrn(1);
      for (var ie = 0, oe = 1; (g.words[0] & oe) == 0 && ie < 26; ++ie, oe <<= 1)
        ;
      if (ie > 0)
        for (g.iushrn(ie); ie-- > 0; )
          (A.isOdd() || L.isOdd()) && (A.iadd(J), L.isub(X)), A.iushrn(1), L.iushrn(1);
      y.cmp(g) >= 0 ? (y.isub(g), v.isub(A), E.isub(L)) : (g.isub(y), A.isub(v), L.isub(E));
    }
    return { a: A, b: L, gcd: g.iushln(j) };
  }, c.prototype._invmp = function(_) {
    a(_.negative === 0), a(!_.isZero());
    var y = this, g = _.clone();
    y = y.negative !== 0 ? y.umod(_) : y.clone();
    for (var v, E = new c(1), A = new c(0), L = g.clone(); y.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
      for (var j = 0, J = 1; (y.words[0] & J) == 0 && j < 26; ++j, J <<= 1)
        ;
      if (j > 0)
        for (y.iushrn(j); j-- > 0; )
          E.isOdd() && E.iadd(L), E.iushrn(1);
      for (var X = 0, re = 1; (g.words[0] & re) == 0 && X < 26; ++X, re <<= 1)
        ;
      if (X > 0)
        for (g.iushrn(X); X-- > 0; )
          A.isOdd() && A.iadd(L), A.iushrn(1);
      y.cmp(g) >= 0 ? (y.isub(g), E.isub(A)) : (g.isub(y), A.isub(E));
    }
    return (v = y.cmpn(1) === 0 ? E : A).cmpn(0) < 0 && v.iadd(_), v;
  }, c.prototype.gcd = function(_) {
    if (this.isZero())
      return _.abs();
    if (_.isZero())
      return this.abs();
    var y = this.clone(), g = _.clone();
    y.negative = 0, g.negative = 0;
    for (var v = 0; y.isEven() && g.isEven(); v++)
      y.iushrn(1), g.iushrn(1);
    for (; ; ) {
      for (; y.isEven(); )
        y.iushrn(1);
      for (; g.isEven(); )
        g.iushrn(1);
      var E = y.cmp(g);
      if (E < 0) {
        var A = y;
        y = g, g = A;
      } else if (E === 0 || g.cmpn(1) === 0)
        break;
      y.isub(g);
    }
    return g.iushln(v);
  }, c.prototype.invm = function(_) {
    return this.egcd(_).a.umod(_);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(_) {
    return this.words[0] & _;
  }, c.prototype.bincn = function(_) {
    a(typeof _ == "number");
    var y = _ % 26, g = (_ - y) / 26, v = 1 << y;
    if (this.length <= g)
      return this._expand(g + 1), this.words[g] |= v, this;
    for (var E = v, A = g; E !== 0 && A < this.length; A++) {
      var L = 0 | this.words[A];
      E = (L += E) >>> 26, L &= 67108863, this.words[A] = L;
    }
    return E !== 0 && (this.words[A] = E, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(_) {
    var y, g = _ < 0;
    if (this.negative !== 0 && !g)
      return -1;
    if (this.negative === 0 && g)
      return 1;
    if (this._strip(), this.length > 1)
      y = 1;
    else {
      g && (_ = -_), a(_ <= 67108863, "Number is too big");
      var v = 0 | this.words[0];
      y = v === _ ? 0 : v < _ ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -y : y;
  }, c.prototype.cmp = function(_) {
    if (this.negative !== 0 && _.negative === 0)
      return -1;
    if (this.negative === 0 && _.negative !== 0)
      return 1;
    var y = this.ucmp(_);
    return this.negative !== 0 ? 0 | -y : y;
  }, c.prototype.ucmp = function(_) {
    if (this.length > _.length)
      return 1;
    if (this.length < _.length)
      return -1;
    for (var y = 0, g = this.length - 1; g >= 0; g--) {
      var v = 0 | this.words[g], E = 0 | _.words[g];
      if (v !== E) {
        v < E ? y = -1 : v > E && (y = 1);
        break;
      }
    }
    return y;
  }, c.prototype.gtn = function(_) {
    return this.cmpn(_) === 1;
  }, c.prototype.gt = function(_) {
    return this.cmp(_) === 1;
  }, c.prototype.gten = function(_) {
    return this.cmpn(_) >= 0;
  }, c.prototype.gte = function(_) {
    return this.cmp(_) >= 0;
  }, c.prototype.ltn = function(_) {
    return this.cmpn(_) === -1;
  }, c.prototype.lt = function(_) {
    return this.cmp(_) === -1;
  }, c.prototype.lten = function(_) {
    return this.cmpn(_) <= 0;
  }, c.prototype.lte = function(_) {
    return this.cmp(_) <= 0;
  }, c.prototype.eqn = function(_) {
    return this.cmpn(_) === 0;
  }, c.prototype.eq = function(_) {
    return this.cmp(_) === 0;
  }, c.red = function(_) {
    return new p(_);
  }, c.prototype.toRed = function(_) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), _.convertTo(this)._forceRed(_);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(_) {
    return this.red = _, this;
  }, c.prototype.forceRed = function(_) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(_);
  }, c.prototype.redAdd = function(_) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, _);
  }, c.prototype.redIAdd = function(_) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, _);
  }, c.prototype.redSub = function(_) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, _);
  }, c.prototype.redISub = function(_) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, _);
  }, c.prototype.redShl = function(_) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, _);
  }, c.prototype.redMul = function(_) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.mul(this, _);
  }, c.prototype.redIMul = function(_) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.imul(this, _);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(_) {
    return a(this.red && !_.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, _);
  };
  var V = { k256: null, p224: null, p192: null, p25519: null };
  function ee(_, y) {
    this.name = _, this.p = new c(y, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function P() {
    ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function F() {
    ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function H() {
    ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function te() {
    ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function p(_) {
    if (typeof _ == "string") {
      var y = c._prime(_);
      this.m = y.p, this.prime = y;
    } else
      a(_.gtn(1), "modulus must be greater than 1"), this.m = _, this.prime = null;
  }
  function $(_) {
    p.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  ee.prototype._tmp = function() {
    var _ = new c(null);
    return _.words = new Array(Math.ceil(this.n / 13)), _;
  }, ee.prototype.ireduce = function(_) {
    var y, g = _;
    do
      this.split(g, this.tmp), y = (g = (g = this.imulK(g)).iadd(this.tmp)).bitLength();
    while (y > this.n);
    var v = y < this.n ? -1 : g.ucmp(this.p);
    return v === 0 ? (g.words[0] = 0, g.length = 1) : v > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(), g;
  }, ee.prototype.split = function(_, y) {
    _.iushrn(this.n, 0, y);
  }, ee.prototype.imulK = function(_) {
    return _.imul(this.k);
  }, u(P, ee), P.prototype.split = function(_, y) {
    for (var g = 4194303, v = Math.min(_.length, 9), E = 0; E < v; E++)
      y.words[E] = _.words[E];
    if (y.length = v, _.length <= 9)
      return _.words[0] = 0, void (_.length = 1);
    var A = _.words[9];
    for (y.words[y.length++] = A & g, E = 10; E < _.length; E++) {
      var L = 0 | _.words[E];
      _.words[E - 10] = (L & g) << 4 | A >>> 22, A = L;
    }
    A >>>= 22, _.words[E - 10] = A, A === 0 && _.length > 10 ? _.length -= 10 : _.length -= 9;
  }, P.prototype.imulK = function(_) {
    _.words[_.length] = 0, _.words[_.length + 1] = 0, _.length += 2;
    for (var y = 0, g = 0; g < _.length; g++) {
      var v = 0 | _.words[g];
      y += 977 * v, _.words[g] = 67108863 & y, y = 64 * v + (y / 67108864 | 0);
    }
    return _.words[_.length - 1] === 0 && (_.length--, _.words[_.length - 1] === 0 && _.length--), _;
  }, u(F, ee), u(H, ee), u(te, ee), te.prototype.imulK = function(_) {
    for (var y = 0, g = 0; g < _.length; g++) {
      var v = 19 * (0 | _.words[g]) + y, E = 67108863 & v;
      v >>>= 26, _.words[g] = E, y = v;
    }
    return y !== 0 && (_.words[_.length++] = y), _;
  }, c._prime = function(_) {
    if (V[_])
      return V[_];
    var y;
    if (_ === "k256")
      y = new P();
    else if (_ === "p224")
      y = new F();
    else if (_ === "p192")
      y = new H();
    else {
      if (_ !== "p25519")
        throw new Error("Unknown prime " + _);
      y = new te();
    }
    return V[_] = y, y;
  }, p.prototype._verify1 = function(_) {
    a(_.negative === 0, "red works only with positives"), a(_.red, "red works only with red numbers");
  }, p.prototype._verify2 = function(_, y) {
    a((_.negative | y.negative) == 0, "red works only with positives"), a(_.red && _.red === y.red, "red works only with red numbers");
  }, p.prototype.imod = function(_) {
    return this.prime ? this.prime.ireduce(_)._forceRed(this) : (T(_, _.umod(this.m)._forceRed(this)), _);
  }, p.prototype.neg = function(_) {
    return _.isZero() ? _.clone() : this.m.sub(_)._forceRed(this);
  }, p.prototype.add = function(_, y) {
    this._verify2(_, y);
    var g = _.add(y);
    return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
  }, p.prototype.iadd = function(_, y) {
    this._verify2(_, y);
    var g = _.iadd(y);
    return g.cmp(this.m) >= 0 && g.isub(this.m), g;
  }, p.prototype.sub = function(_, y) {
    this._verify2(_, y);
    var g = _.sub(y);
    return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
  }, p.prototype.isub = function(_, y) {
    this._verify2(_, y);
    var g = _.isub(y);
    return g.cmpn(0) < 0 && g.iadd(this.m), g;
  }, p.prototype.shl = function(_, y) {
    return this._verify1(_), this.imod(_.ushln(y));
  }, p.prototype.imul = function(_, y) {
    return this._verify2(_, y), this.imod(_.imul(y));
  }, p.prototype.mul = function(_, y) {
    return this._verify2(_, y), this.imod(_.mul(y));
  }, p.prototype.isqr = function(_) {
    return this.imul(_, _.clone());
  }, p.prototype.sqr = function(_) {
    return this.mul(_, _);
  }, p.prototype.sqrt = function(_) {
    if (_.isZero())
      return _.clone();
    var y = this.m.andln(3);
    if (a(y % 2 == 1), y === 3) {
      var g = this.m.add(new c(1)).iushrn(2);
      return this.pow(_, g);
    }
    for (var v = this.m.subn(1), E = 0; !v.isZero() && v.andln(1) === 0; )
      E++, v.iushrn(1);
    a(!v.isZero());
    var A = new c(1).toRed(this), L = A.redNeg(), j = this.m.subn(1).iushrn(1), J = this.m.bitLength();
    for (J = new c(2 * J * J).toRed(this); this.pow(J, j).cmp(L) !== 0; )
      J.redIAdd(L);
    for (var X = this.pow(J, v), re = this.pow(_, v.addn(1).iushrn(1)), Z = this.pow(_, v), ie = E; Z.cmp(A) !== 0; ) {
      for (var oe = Z, ue = 0; oe.cmp(A) !== 0; ue++)
        oe = oe.redSqr();
      a(ue < ie);
      var se = this.pow(X, new c(1).iushln(ie - ue - 1));
      re = re.redMul(se), X = se.redSqr(), Z = Z.redMul(X), ie = ue;
    }
    return re;
  }, p.prototype.invm = function(_) {
    var y = _._invmp(this.m);
    return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
  }, p.prototype.pow = function(_, y) {
    if (y.isZero())
      return new c(1).toRed(this);
    if (y.cmpn(1) === 0)
      return _.clone();
    var g = new Array(16);
    g[0] = new c(1).toRed(this), g[1] = _;
    for (var v = 2; v < g.length; v++)
      g[v] = this.mul(g[v - 1], _);
    var E = g[0], A = 0, L = 0, j = y.bitLength() % 26;
    for (j === 0 && (j = 26), v = y.length - 1; v >= 0; v--) {
      for (var J = y.words[v], X = j - 1; X >= 0; X--) {
        var re = J >> X & 1;
        E !== g[0] && (E = this.sqr(E)), re !== 0 || A !== 0 ? (A <<= 1, A |= re, (++L == 4 || v === 0 && X === 0) && (E = this.mul(E, g[A]), L = 0, A = 0)) : L = 0;
      }
      j = 26;
    }
    return E;
  }, p.prototype.convertTo = function(_) {
    var y = _.umod(this.m);
    return y === _ ? y.clone() : y;
  }, p.prototype.convertFrom = function(_) {
    var y = _.clone();
    return y.red = null, y;
  }, c.mont = function(_) {
    return new $(_);
  }, u($, p), $.prototype.convertTo = function(_) {
    return this.imod(_.ushln(this.shift));
  }, $.prototype.convertFrom = function(_) {
    var y = this.imod(_.mul(this.rinv));
    return y.red = null, y;
  }, $.prototype.imul = function(_, y) {
    if (_.isZero() || y.isZero())
      return _.words[0] = 0, _.length = 1, _;
    var g = _.imul(y), v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(v).iushrn(this.shift), A = E;
    return E.cmp(this.m) >= 0 ? A = E.isub(this.m) : E.cmpn(0) < 0 && (A = E.iadd(this.m)), A._forceRed(this);
  }, $.prototype.mul = function(_, y) {
    if (_.isZero() || y.isZero())
      return new c(0)._forceRed(this);
    var g = _.mul(y), v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = g.isub(v).iushrn(this.shift), A = E;
    return E.cmp(this.m) >= 0 ? A = E.isub(this.m) : E.cmpn(0) < 0 && (A = E.iadd(this.m)), A._forceRed(this);
  }, $.prototype.invm = function(_) {
    return this.imod(_._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    !root.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(o) {
      return Object.prototype.toString.call(o) === "[object Array]";
    }), !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(o) {
      return typeof o == "object" && o.buffer && o.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(o, n) {
      return function(a) {
        return new Sha256(n, !0).update(a)[o]();
      };
    }, createMethod = function(o) {
      var n = createOutputMethod("hex", o);
      NODE_JS && (n = nodeWrap(n, o)), n.create = function() {
        return new Sha256(o);
      }, n.update = function(c) {
        return n.create().update(c);
      };
      for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
        var u = OUTPUT_TYPES[a];
        n[u] = createOutputMethod(u, o);
      }
      return n;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(o) {
        if (typeof o == "string")
          return crypto.createHash(algorithm).update(o, "utf8").digest("hex");
        if (o == null)
          throw new Error(ERROR);
        return o.constructor === ArrayBuffer && (o = new Uint8Array(o)), Array.isArray(o) || ArrayBuffer.isView(o) || o.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(o)).digest("hex") : method(o);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(o, n) {
      return function(a, u) {
        return new HmacSha256(a, n, !0).update(u)[o]();
      };
    }, createHmacMethod = function(o) {
      var n = createHmacOutputMethod("hex", o);
      n.create = function(c) {
        return new HmacSha256(c, o);
      }, n.update = function(c, m) {
        return n.create(c).update(m);
      };
      for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
        var u = OUTPUT_TYPES[a];
        n[u] = createHmacOutputMethod(u, o);
      }
      return n;
    };
    function Sha256(o, n) {
      n ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], o ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = o;
    }
    function HmacSha256(o, n, a) {
      var u, c = typeof o;
      if (c === "string") {
        var m, d = [], w = o.length, S = 0;
        for (u = 0; u < w; ++u)
          (m = o.charCodeAt(u)) < 128 ? d[S++] = m : m < 2048 ? (d[S++] = 192 | m >> 6, d[S++] = 128 | 63 & m) : m < 55296 || m >= 57344 ? (d[S++] = 224 | m >> 12, d[S++] = 128 | m >> 6 & 63, d[S++] = 128 | 63 & m) : (m = 65536 + ((1023 & m) << 10 | 1023 & o.charCodeAt(++u)), d[S++] = 240 | m >> 18, d[S++] = 128 | m >> 12 & 63, d[S++] = 128 | m >> 6 & 63, d[S++] = 128 | 63 & m);
        o = d;
      } else {
        if (c !== "object")
          throw new Error(ERROR);
        if (o === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && o.constructor === ArrayBuffer)
          o = new Uint8Array(o);
        else if (!(Array.isArray(o) || ARRAY_BUFFER && ArrayBuffer.isView(o)))
          throw new Error(ERROR);
      }
      o.length > 64 && (o = new Sha256(n, !0).update(o).array());
      var T = [], B = [];
      for (u = 0; u < 64; ++u) {
        var I = o[u] || 0;
        T[u] = 92 ^ I, B[u] = 54 ^ I;
      }
      Sha256.call(this, n, a), this.update(B), this.oKeyPad = T, this.inner = !0, this.sharedMemory = a;
    }
    Sha256.prototype.update = function(o) {
      if (!this.finalized) {
        var n, a = typeof o;
        if (a !== "string") {
          if (a !== "object")
            throw new Error(ERROR);
          if (o === null)
            throw new Error(ERROR);
          if (ARRAY_BUFFER && o.constructor === ArrayBuffer)
            o = new Uint8Array(o);
          else if (!(Array.isArray(o) || ARRAY_BUFFER && ArrayBuffer.isView(o)))
            throw new Error(ERROR);
          n = !0;
        }
        for (var u, c, m = 0, d = o.length, w = this.blocks; m < d; ) {
          if (this.hashed && (this.hashed = !1, w[0] = this.block, w[16] = w[1] = w[2] = w[3] = w[4] = w[5] = w[6] = w[7] = w[8] = w[9] = w[10] = w[11] = w[12] = w[13] = w[14] = w[15] = 0), n)
            for (c = this.start; m < d && c < 64; ++m)
              w[c >> 2] |= o[m] << SHIFT[3 & c++];
          else
            for (c = this.start; m < d && c < 64; ++m)
              (u = o.charCodeAt(m)) < 128 ? w[c >> 2] |= u << SHIFT[3 & c++] : u < 2048 ? (w[c >> 2] |= (192 | u >> 6) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]) : u < 55296 || u >= 57344 ? (w[c >> 2] |= (224 | u >> 12) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]) : (u = 65536 + ((1023 & u) << 10 | 1023 & o.charCodeAt(++m)), w[c >> 2] |= (240 | u >> 18) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 12 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]);
          this.lastByteIndex = c, this.bytes += c - this.start, c >= 64 ? (this.block = w[16], this.start = c - 64, this.hash(), this.hashed = !0) : this.start = c;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var o = this.blocks, n = this.lastByteIndex;
        o[16] = this.block, o[n >> 2] |= EXTRA[3 & n], this.block = o[16], n >= 56 && (this.hashed || this.hash(), o[0] = this.block, o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), o[14] = this.hBytes << 3 | this.bytes >>> 29, o[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var o, n, a, u, c, m, d, w, S, T = this.h0, B = this.h1, I = this.h2, C = this.h3, N = this.h4, q = this.h5, D = this.h6, z = this.h7, W = this.blocks;
      for (o = 16; o < 64; ++o)
        n = ((c = W[o - 15]) >>> 7 | c << 25) ^ (c >>> 18 | c << 14) ^ c >>> 3, a = ((c = W[o - 2]) >>> 17 | c << 15) ^ (c >>> 19 | c << 13) ^ c >>> 10, W[o] = W[o - 16] + n + W[o - 7] + a << 0;
      for (S = B & I, o = 0; o < 64; o += 4)
        this.first ? (this.is224 ? (m = 300032, z = (c = W[0] - 1413257819) - 150054599 << 0, C = c + 24177077 << 0) : (m = 704751109, z = (c = W[0] - 210244248) - 1521486534 << 0, C = c + 143694565 << 0), this.first = !1) : (n = (T >>> 2 | T << 30) ^ (T >>> 13 | T << 19) ^ (T >>> 22 | T << 10), u = (m = T & B) ^ T & I ^ S, z = C + (c = z + (a = (N >>> 6 | N << 26) ^ (N >>> 11 | N << 21) ^ (N >>> 25 | N << 7)) + (N & q ^ ~N & D) + K[o] + W[o]) << 0, C = c + (n + u) << 0), n = (C >>> 2 | C << 30) ^ (C >>> 13 | C << 19) ^ (C >>> 22 | C << 10), u = (d = C & T) ^ C & B ^ m, D = I + (c = D + (a = (z >>> 6 | z << 26) ^ (z >>> 11 | z << 21) ^ (z >>> 25 | z << 7)) + (z & N ^ ~z & q) + K[o + 1] + W[o + 1]) << 0, n = ((I = c + (n + u) << 0) >>> 2 | I << 30) ^ (I >>> 13 | I << 19) ^ (I >>> 22 | I << 10), u = (w = I & C) ^ I & T ^ d, q = B + (c = q + (a = (D >>> 6 | D << 26) ^ (D >>> 11 | D << 21) ^ (D >>> 25 | D << 7)) + (D & z ^ ~D & N) + K[o + 2] + W[o + 2]) << 0, n = ((B = c + (n + u) << 0) >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10), u = (S = B & I) ^ B & C ^ w, N = T + (c = N + (a = (q >>> 6 | q << 26) ^ (q >>> 11 | q << 21) ^ (q >>> 25 | q << 7)) + (q & D ^ ~q & z) + K[o + 3] + W[o + 3]) << 0, T = c + (n + u) << 0;
      this.h0 = this.h0 + T << 0, this.h1 = this.h1 + B << 0, this.h2 = this.h2 + I << 0, this.h3 = this.h3 + C << 0, this.h4 = this.h4 + N << 0, this.h5 = this.h5 + q << 0, this.h6 = this.h6 + D << 0, this.h7 = this.h7 + z << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var o = this.h0, n = this.h1, a = this.h2, u = this.h3, c = this.h4, m = this.h5, d = this.h6, w = this.h7, S = HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[15 & o] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[15 & a] + HEX_CHARS[u >> 28 & 15] + HEX_CHARS[u >> 24 & 15] + HEX_CHARS[u >> 20 & 15] + HEX_CHARS[u >> 16 & 15] + HEX_CHARS[u >> 12 & 15] + HEX_CHARS[u >> 8 & 15] + HEX_CHARS[u >> 4 & 15] + HEX_CHARS[15 & u] + HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[15 & c] + HEX_CHARS[m >> 28 & 15] + HEX_CHARS[m >> 24 & 15] + HEX_CHARS[m >> 20 & 15] + HEX_CHARS[m >> 16 & 15] + HEX_CHARS[m >> 12 & 15] + HEX_CHARS[m >> 8 & 15] + HEX_CHARS[m >> 4 & 15] + HEX_CHARS[15 & m] + HEX_CHARS[d >> 28 & 15] + HEX_CHARS[d >> 24 & 15] + HEX_CHARS[d >> 20 & 15] + HEX_CHARS[d >> 16 & 15] + HEX_CHARS[d >> 12 & 15] + HEX_CHARS[d >> 8 & 15] + HEX_CHARS[d >> 4 & 15] + HEX_CHARS[15 & d];
      return this.is224 || (S += HEX_CHARS[w >> 28 & 15] + HEX_CHARS[w >> 24 & 15] + HEX_CHARS[w >> 20 & 15] + HEX_CHARS[w >> 16 & 15] + HEX_CHARS[w >> 12 & 15] + HEX_CHARS[w >> 8 & 15] + HEX_CHARS[w >> 4 & 15] + HEX_CHARS[15 & w]), S;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var o = this.h0, n = this.h1, a = this.h2, u = this.h3, c = this.h4, m = this.h5, d = this.h6, w = this.h7, S = [o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, 255 & m, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];
      return this.is224 || S.push(w >> 24 & 255, w >> 16 & 255, w >> 8 & 255, 255 & w), S;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var o = new ArrayBuffer(this.is224 ? 28 : 32), n = new DataView(o);
      return n.setUint32(0, this.h0), n.setUint32(4, this.h1), n.setUint32(8, this.h2), n.setUint32(12, this.h3), n.setUint32(16, this.h4), n.setUint32(20, this.h5), n.setUint32(24, this.h6), this.is224 || n.setUint32(28, this.h7), o;
    }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var o = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(o), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$1);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(o) {
  (function() {
    var n = "input is invalid type", a = typeof window == "object", u = a ? window : {};
    u.JS_SHA512_NO_WINDOW && (a = !1);
    var c = !a && typeof self == "object";
    !u.JS_SHA512_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node ? u = commonjsGlobal : c && (u = self);
    var m = !u.JS_SHA512_NO_COMMON_JS && o.exports, d = !u.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", w = "0123456789abcdef".split(""), S = [-2147483648, 8388608, 32768, 128], T = [24, 16, 8, 0], B = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], I = ["hex", "array", "digest", "arrayBuffer"], C = [];
    !u.JS_SHA512_NO_NODE_JS && Array.isArray || (Array.isArray = function(P) {
      return Object.prototype.toString.call(P) === "[object Array]";
    }), !d || !u.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(P) {
      return typeof P == "object" && P.buffer && P.buffer.constructor === ArrayBuffer;
    });
    var N = function(P, F) {
      return function(H) {
        return new W(F, !0).update(H)[P]();
      };
    }, q = function(P) {
      var F = N("hex", P);
      F.create = function() {
        return new W(P);
      }, F.update = function(p) {
        return F.create().update(p);
      };
      for (var H = 0; H < I.length; ++H) {
        var te = I[H];
        F[te] = N(te, P);
      }
      return F;
    }, D = function(P, F) {
      return function(H, te) {
        return new V(H, F, !0).update(te)[P]();
      };
    }, z = function(P) {
      var F = D("hex", P);
      F.create = function(p) {
        return new V(p, P);
      }, F.update = function(p, $) {
        return F.create(p).update($);
      };
      for (var H = 0; H < I.length; ++H) {
        var te = I[H];
        F[te] = D(te, P);
      }
      return F;
    };
    function W(P, F) {
      F ? (C[0] = C[1] = C[2] = C[3] = C[4] = C[5] = C[6] = C[7] = C[8] = C[9] = C[10] = C[11] = C[12] = C[13] = C[14] = C[15] = C[16] = C[17] = C[18] = C[19] = C[20] = C[21] = C[22] = C[23] = C[24] = C[25] = C[26] = C[27] = C[28] = C[29] = C[30] = C[31] = C[32] = 0, this.blocks = C) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], P == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : P == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : P == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = P, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1;
    }
    function V(P, F, H) {
      var te, p = typeof P;
      if (p !== "string") {
        if (p !== "object")
          throw new Error(n);
        if (P === null)
          throw new Error(n);
        if (d && P.constructor === ArrayBuffer)
          P = new Uint8Array(P);
        else if (!(Array.isArray(P) || d && ArrayBuffer.isView(P)))
          throw new Error(n);
        te = !0;
      }
      var $ = P.length;
      if (!te) {
        for (var _, y = [], g = ($ = P.length, 0), v = 0; v < $; ++v)
          (_ = P.charCodeAt(v)) < 128 ? y[g++] = _ : _ < 2048 ? (y[g++] = 192 | _ >> 6, y[g++] = 128 | 63 & _) : _ < 55296 || _ >= 57344 ? (y[g++] = 224 | _ >> 12, y[g++] = 128 | _ >> 6 & 63, y[g++] = 128 | 63 & _) : (_ = 65536 + ((1023 & _) << 10 | 1023 & P.charCodeAt(++v)), y[g++] = 240 | _ >> 18, y[g++] = 128 | _ >> 12 & 63, y[g++] = 128 | _ >> 6 & 63, y[g++] = 128 | 63 & _);
        P = y;
      }
      P.length > 128 && (P = new W(F, !0).update(P).array());
      var E = [], A = [];
      for (v = 0; v < 128; ++v) {
        var L = P[v] || 0;
        E[v] = 92 ^ L, A[v] = 54 ^ L;
      }
      W.call(this, F, H), this.update(A), this.oKeyPad = E, this.inner = !0, this.sharedMemory = H;
    }
    W.prototype.update = function(P) {
      if (this.finalized)
        throw new Error("finalize already called");
      var F, H = typeof P;
      if (H !== "string") {
        if (H !== "object")
          throw new Error(n);
        if (P === null)
          throw new Error(n);
        if (d && P.constructor === ArrayBuffer)
          P = new Uint8Array(P);
        else if (!(Array.isArray(P) || d && ArrayBuffer.isView(P)))
          throw new Error(n);
        F = !0;
      }
      for (var te, p, $ = 0, _ = P.length, y = this.blocks; $ < _; ) {
        if (this.hashed && (this.hashed = !1, y[0] = this.block, y[1] = y[2] = y[3] = y[4] = y[5] = y[6] = y[7] = y[8] = y[9] = y[10] = y[11] = y[12] = y[13] = y[14] = y[15] = y[16] = y[17] = y[18] = y[19] = y[20] = y[21] = y[22] = y[23] = y[24] = y[25] = y[26] = y[27] = y[28] = y[29] = y[30] = y[31] = y[32] = 0), F)
          for (p = this.start; $ < _ && p < 128; ++$)
            y[p >> 2] |= P[$] << T[3 & p++];
        else
          for (p = this.start; $ < _ && p < 128; ++$)
            (te = P.charCodeAt($)) < 128 ? y[p >> 2] |= te << T[3 & p++] : te < 2048 ? (y[p >> 2] |= (192 | te >> 6) << T[3 & p++], y[p >> 2] |= (128 | 63 & te) << T[3 & p++]) : te < 55296 || te >= 57344 ? (y[p >> 2] |= (224 | te >> 12) << T[3 & p++], y[p >> 2] |= (128 | te >> 6 & 63) << T[3 & p++], y[p >> 2] |= (128 | 63 & te) << T[3 & p++]) : (te = 65536 + ((1023 & te) << 10 | 1023 & P.charCodeAt(++$)), y[p >> 2] |= (240 | te >> 18) << T[3 & p++], y[p >> 2] |= (128 | te >> 12 & 63) << T[3 & p++], y[p >> 2] |= (128 | te >> 6 & 63) << T[3 & p++], y[p >> 2] |= (128 | 63 & te) << T[3 & p++]);
        this.lastByteIndex = p, this.bytes += p - this.start, p >= 128 ? (this.block = y[32], this.start = p - 128, this.hash(), this.hashed = !0) : this.start = p;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, W.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var P = this.blocks, F = this.lastByteIndex;
        P[32] = this.block, P[F >> 2] |= S[3 & F], this.block = P[32], F >= 112 && (this.hashed || this.hash(), P[0] = this.block, P[1] = P[2] = P[3] = P[4] = P[5] = P[6] = P[7] = P[8] = P[9] = P[10] = P[11] = P[12] = P[13] = P[14] = P[15] = P[16] = P[17] = P[18] = P[19] = P[20] = P[21] = P[22] = P[23] = P[24] = P[25] = P[26] = P[27] = P[28] = P[29] = P[30] = P[31] = P[32] = 0), P[30] = this.hBytes << 3 | this.bytes >>> 29, P[31] = this.bytes << 3, this.hash();
      }
    }, W.prototype.hash = function() {
      var P, F, H, te, p, $, _, y, g, v, E, A, L, j, J, X, re, Z, ie, oe, ue, se, ce, Se, he, $e = this.h0h, fe = this.h0l, le = this.h1h, we = this.h1l, We = this.h2h, de = this.h2l, ke = this.h3h, l = this.h3l, h = this.h4h, b = this.h4l, M = this.h5h, k = this.h5l, x = this.h6h, O = this.h6l, G = this.h7h, Q = this.h7l, ne = this.blocks;
      for (P = 32; P < 160; P += 2)
        F = ((oe = ne[P - 30]) >>> 1 | (ue = ne[P - 29]) << 31) ^ (oe >>> 8 | ue << 24) ^ oe >>> 7, H = (ue >>> 1 | oe << 31) ^ (ue >>> 8 | oe << 24) ^ (ue >>> 7 | oe << 25), te = ((oe = ne[P - 4]) >>> 19 | (ue = ne[P - 3]) << 13) ^ (ue >>> 29 | oe << 3) ^ oe >>> 6, p = (ue >>> 19 | oe << 13) ^ (oe >>> 29 | ue << 3) ^ (ue >>> 6 | oe << 26), oe = ne[P - 32], ue = ne[P - 31], g = ((se = ne[P - 14]) >>> 16) + (oe >>> 16) + (F >>> 16) + (te >>> 16) + ((y = (65535 & se) + (65535 & oe) + (65535 & F) + (65535 & te) + ((_ = ((ce = ne[P - 13]) >>> 16) + (ue >>> 16) + (H >>> 16) + (p >>> 16) + (($ = (65535 & ce) + (65535 & ue) + (65535 & H) + (65535 & p)) >>> 16)) >>> 16)) >>> 16), ne[P] = g << 16 | 65535 & y, ne[P + 1] = _ << 16 | 65535 & $;
      var Y = $e, ae = fe, Ee = le, pe = we, ye = We, Le = de, ge = ke, be = l, Re = h, me = b, Ae = M, He = k, ve = x, Me = O, Fe = G, _e = Q;
      for (X = Ee & ye, re = pe & Le, P = 0; P < 160; P += 8)
        F = (Y >>> 28 | ae << 4) ^ (ae >>> 2 | Y << 30) ^ (ae >>> 7 | Y << 25), H = (ae >>> 28 | Y << 4) ^ (Y >>> 2 | ae << 30) ^ (Y >>> 7 | ae << 25), te = (Re >>> 14 | me << 18) ^ (Re >>> 18 | me << 14) ^ (me >>> 9 | Re << 23), p = (me >>> 14 | Re << 18) ^ (me >>> 18 | Re << 14) ^ (Re >>> 9 | me << 23), Z = (v = Y & Ee) ^ Y & ye ^ X, ie = (E = ae & pe) ^ ae & Le ^ re, Se = Re & Ae ^ ~Re & ve, he = me & He ^ ~me & Me, oe = ne[P], ue = ne[P + 1], oe = (g = ((se = B[P]) >>> 16) + (oe >>> 16) + (Se >>> 16) + (te >>> 16) + (Fe >>> 16) + ((y = (65535 & se) + (65535 & oe) + (65535 & Se) + (65535 & te) + (65535 & Fe) + ((_ = ((ce = B[P + 1]) >>> 16) + (ue >>> 16) + (he >>> 16) + (p >>> 16) + (_e >>> 16) + (($ = (65535 & ce) + (65535 & ue) + (65535 & he) + (65535 & p) + (65535 & _e)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ue = _ << 16 | 65535 & $, se = (g = (Z >>> 16) + (F >>> 16) + ((y = (65535 & Z) + (65535 & F) + ((_ = (ie >>> 16) + (H >>> 16) + (($ = (65535 & ie) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ce = _ << 16 | 65535 & $, Fe = (g = (ge >>> 16) + (oe >>> 16) + ((y = (65535 & ge) + (65535 & oe) + ((_ = (be >>> 16) + (ue >>> 16) + (($ = (65535 & be) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, _e = _ << 16 | 65535 & $, F = ((ge = (g = (se >>> 16) + (oe >>> 16) + ((y = (65535 & se) + (65535 & oe) + ((_ = (ce >>> 16) + (ue >>> 16) + (($ = (65535 & ce) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y) >>> 28 | (be = _ << 16 | 65535 & $) << 4) ^ (be >>> 2 | ge << 30) ^ (be >>> 7 | ge << 25), H = (be >>> 28 | ge << 4) ^ (ge >>> 2 | be << 30) ^ (ge >>> 7 | be << 25), te = (Fe >>> 14 | _e << 18) ^ (Fe >>> 18 | _e << 14) ^ (_e >>> 9 | Fe << 23), p = (_e >>> 14 | Fe << 18) ^ (_e >>> 18 | Fe << 14) ^ (Fe >>> 9 | _e << 23), Z = (A = ge & Y) ^ ge & Ee ^ v, ie = (L = be & ae) ^ be & pe ^ E, Se = Fe & Re ^ ~Fe & Ae, he = _e & me ^ ~_e & He, oe = ne[P + 2], ue = ne[P + 3], oe = (g = ((se = B[P + 2]) >>> 16) + (oe >>> 16) + (Se >>> 16) + (te >>> 16) + (ve >>> 16) + ((y = (65535 & se) + (65535 & oe) + (65535 & Se) + (65535 & te) + (65535 & ve) + ((_ = ((ce = B[P + 3]) >>> 16) + (ue >>> 16) + (he >>> 16) + (p >>> 16) + (Me >>> 16) + (($ = (65535 & ce) + (65535 & ue) + (65535 & he) + (65535 & p) + (65535 & Me)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ue = _ << 16 | 65535 & $, se = (g = (Z >>> 16) + (F >>> 16) + ((y = (65535 & Z) + (65535 & F) + ((_ = (ie >>> 16) + (H >>> 16) + (($ = (65535 & ie) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ce = _ << 16 | 65535 & $, ve = (g = (ye >>> 16) + (oe >>> 16) + ((y = (65535 & ye) + (65535 & oe) + ((_ = (Le >>> 16) + (ue >>> 16) + (($ = (65535 & Le) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, Me = _ << 16 | 65535 & $, F = ((ye = (g = (se >>> 16) + (oe >>> 16) + ((y = (65535 & se) + (65535 & oe) + ((_ = (ce >>> 16) + (ue >>> 16) + (($ = (65535 & ce) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y) >>> 28 | (Le = _ << 16 | 65535 & $) << 4) ^ (Le >>> 2 | ye << 30) ^ (Le >>> 7 | ye << 25), H = (Le >>> 28 | ye << 4) ^ (ye >>> 2 | Le << 30) ^ (ye >>> 7 | Le << 25), te = (ve >>> 14 | Me << 18) ^ (ve >>> 18 | Me << 14) ^ (Me >>> 9 | ve << 23), p = (Me >>> 14 | ve << 18) ^ (Me >>> 18 | ve << 14) ^ (ve >>> 9 | Me << 23), Z = (j = ye & ge) ^ ye & Y ^ A, ie = (J = Le & be) ^ Le & ae ^ L, Se = ve & Fe ^ ~ve & Re, he = Me & _e ^ ~Me & me, oe = ne[P + 4], ue = ne[P + 5], oe = (g = ((se = B[P + 4]) >>> 16) + (oe >>> 16) + (Se >>> 16) + (te >>> 16) + (Ae >>> 16) + ((y = (65535 & se) + (65535 & oe) + (65535 & Se) + (65535 & te) + (65535 & Ae) + ((_ = ((ce = B[P + 5]) >>> 16) + (ue >>> 16) + (he >>> 16) + (p >>> 16) + (He >>> 16) + (($ = (65535 & ce) + (65535 & ue) + (65535 & he) + (65535 & p) + (65535 & He)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ue = _ << 16 | 65535 & $, se = (g = (Z >>> 16) + (F >>> 16) + ((y = (65535 & Z) + (65535 & F) + ((_ = (ie >>> 16) + (H >>> 16) + (($ = (65535 & ie) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ce = _ << 16 | 65535 & $, Ae = (g = (Ee >>> 16) + (oe >>> 16) + ((y = (65535 & Ee) + (65535 & oe) + ((_ = (pe >>> 16) + (ue >>> 16) + (($ = (65535 & pe) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, He = _ << 16 | 65535 & $, F = ((Ee = (g = (se >>> 16) + (oe >>> 16) + ((y = (65535 & se) + (65535 & oe) + ((_ = (ce >>> 16) + (ue >>> 16) + (($ = (65535 & ce) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y) >>> 28 | (pe = _ << 16 | 65535 & $) << 4) ^ (pe >>> 2 | Ee << 30) ^ (pe >>> 7 | Ee << 25), H = (pe >>> 28 | Ee << 4) ^ (Ee >>> 2 | pe << 30) ^ (Ee >>> 7 | pe << 25), te = (Ae >>> 14 | He << 18) ^ (Ae >>> 18 | He << 14) ^ (He >>> 9 | Ae << 23), p = (He >>> 14 | Ae << 18) ^ (He >>> 18 | Ae << 14) ^ (Ae >>> 9 | He << 23), Z = (X = Ee & ye) ^ Ee & ge ^ j, ie = (re = pe & Le) ^ pe & be ^ J, Se = Ae & ve ^ ~Ae & Fe, he = He & Me ^ ~He & _e, oe = ne[P + 6], ue = ne[P + 7], oe = (g = ((se = B[P + 6]) >>> 16) + (oe >>> 16) + (Se >>> 16) + (te >>> 16) + (Re >>> 16) + ((y = (65535 & se) + (65535 & oe) + (65535 & Se) + (65535 & te) + (65535 & Re) + ((_ = ((ce = B[P + 7]) >>> 16) + (ue >>> 16) + (he >>> 16) + (p >>> 16) + (me >>> 16) + (($ = (65535 & ce) + (65535 & ue) + (65535 & he) + (65535 & p) + (65535 & me)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ue = _ << 16 | 65535 & $, se = (g = (Z >>> 16) + (F >>> 16) + ((y = (65535 & Z) + (65535 & F) + ((_ = (ie >>> 16) + (H >>> 16) + (($ = (65535 & ie) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ce = _ << 16 | 65535 & $, Re = (g = (Y >>> 16) + (oe >>> 16) + ((y = (65535 & Y) + (65535 & oe) + ((_ = (ae >>> 16) + (ue >>> 16) + (($ = (65535 & ae) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, me = _ << 16 | 65535 & $, Y = (g = (se >>> 16) + (oe >>> 16) + ((y = (65535 & se) + (65535 & oe) + ((_ = (ce >>> 16) + (ue >>> 16) + (($ = (65535 & ce) + (65535 & ue)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & y, ae = _ << 16 | 65535 & $;
      g = ($e >>> 16) + (Y >>> 16) + ((y = (65535 & $e) + (65535 & Y) + ((_ = (fe >>> 16) + (ae >>> 16) + (($ = (65535 & fe) + (65535 & ae)) >>> 16)) >>> 16)) >>> 16), this.h0h = g << 16 | 65535 & y, this.h0l = _ << 16 | 65535 & $, g = (le >>> 16) + (Ee >>> 16) + ((y = (65535 & le) + (65535 & Ee) + ((_ = (we >>> 16) + (pe >>> 16) + (($ = (65535 & we) + (65535 & pe)) >>> 16)) >>> 16)) >>> 16), this.h1h = g << 16 | 65535 & y, this.h1l = _ << 16 | 65535 & $, g = (We >>> 16) + (ye >>> 16) + ((y = (65535 & We) + (65535 & ye) + ((_ = (de >>> 16) + (Le >>> 16) + (($ = (65535 & de) + (65535 & Le)) >>> 16)) >>> 16)) >>> 16), this.h2h = g << 16 | 65535 & y, this.h2l = _ << 16 | 65535 & $, g = (ke >>> 16) + (ge >>> 16) + ((y = (65535 & ke) + (65535 & ge) + ((_ = (l >>> 16) + (be >>> 16) + (($ = (65535 & l) + (65535 & be)) >>> 16)) >>> 16)) >>> 16), this.h3h = g << 16 | 65535 & y, this.h3l = _ << 16 | 65535 & $, g = (h >>> 16) + (Re >>> 16) + ((y = (65535 & h) + (65535 & Re) + ((_ = (b >>> 16) + (me >>> 16) + (($ = (65535 & b) + (65535 & me)) >>> 16)) >>> 16)) >>> 16), this.h4h = g << 16 | 65535 & y, this.h4l = _ << 16 | 65535 & $, g = (M >>> 16) + (Ae >>> 16) + ((y = (65535 & M) + (65535 & Ae) + ((_ = (k >>> 16) + (He >>> 16) + (($ = (65535 & k) + (65535 & He)) >>> 16)) >>> 16)) >>> 16), this.h5h = g << 16 | 65535 & y, this.h5l = _ << 16 | 65535 & $, g = (x >>> 16) + (ve >>> 16) + ((y = (65535 & x) + (65535 & ve) + ((_ = (O >>> 16) + (Me >>> 16) + (($ = (65535 & O) + (65535 & Me)) >>> 16)) >>> 16)) >>> 16), this.h6h = g << 16 | 65535 & y, this.h6l = _ << 16 | 65535 & $, g = (G >>> 16) + (Fe >>> 16) + ((y = (65535 & G) + (65535 & Fe) + ((_ = (Q >>> 16) + (_e >>> 16) + (($ = (65535 & Q) + (65535 & _e)) >>> 16)) >>> 16)) >>> 16), this.h7h = g << 16 | 65535 & y, this.h7l = _ << 16 | 65535 & $;
    }, W.prototype.hex = function() {
      this.finalize();
      var P = this.h0h, F = this.h0l, H = this.h1h, te = this.h1l, p = this.h2h, $ = this.h2l, _ = this.h3h, y = this.h3l, g = this.h4h, v = this.h4l, E = this.h5h, A = this.h5l, L = this.h6h, j = this.h6l, J = this.h7h, X = this.h7l, re = this.bits, Z = w[P >> 28 & 15] + w[P >> 24 & 15] + w[P >> 20 & 15] + w[P >> 16 & 15] + w[P >> 12 & 15] + w[P >> 8 & 15] + w[P >> 4 & 15] + w[15 & P] + w[F >> 28 & 15] + w[F >> 24 & 15] + w[F >> 20 & 15] + w[F >> 16 & 15] + w[F >> 12 & 15] + w[F >> 8 & 15] + w[F >> 4 & 15] + w[15 & F] + w[H >> 28 & 15] + w[H >> 24 & 15] + w[H >> 20 & 15] + w[H >> 16 & 15] + w[H >> 12 & 15] + w[H >> 8 & 15] + w[H >> 4 & 15] + w[15 & H] + w[te >> 28 & 15] + w[te >> 24 & 15] + w[te >> 20 & 15] + w[te >> 16 & 15] + w[te >> 12 & 15] + w[te >> 8 & 15] + w[te >> 4 & 15] + w[15 & te] + w[p >> 28 & 15] + w[p >> 24 & 15] + w[p >> 20 & 15] + w[p >> 16 & 15] + w[p >> 12 & 15] + w[p >> 8 & 15] + w[p >> 4 & 15] + w[15 & p] + w[$ >> 28 & 15] + w[$ >> 24 & 15] + w[$ >> 20 & 15] + w[$ >> 16 & 15] + w[$ >> 12 & 15] + w[$ >> 8 & 15] + w[$ >> 4 & 15] + w[15 & $] + w[_ >> 28 & 15] + w[_ >> 24 & 15] + w[_ >> 20 & 15] + w[_ >> 16 & 15] + w[_ >> 12 & 15] + w[_ >> 8 & 15] + w[_ >> 4 & 15] + w[15 & _];
      return re >= 256 && (Z += w[y >> 28 & 15] + w[y >> 24 & 15] + w[y >> 20 & 15] + w[y >> 16 & 15] + w[y >> 12 & 15] + w[y >> 8 & 15] + w[y >> 4 & 15] + w[15 & y]), re >= 384 && (Z += w[g >> 28 & 15] + w[g >> 24 & 15] + w[g >> 20 & 15] + w[g >> 16 & 15] + w[g >> 12 & 15] + w[g >> 8 & 15] + w[g >> 4 & 15] + w[15 & g] + w[v >> 28 & 15] + w[v >> 24 & 15] + w[v >> 20 & 15] + w[v >> 16 & 15] + w[v >> 12 & 15] + w[v >> 8 & 15] + w[v >> 4 & 15] + w[15 & v] + w[E >> 28 & 15] + w[E >> 24 & 15] + w[E >> 20 & 15] + w[E >> 16 & 15] + w[E >> 12 & 15] + w[E >> 8 & 15] + w[E >> 4 & 15] + w[15 & E] + w[A >> 28 & 15] + w[A >> 24 & 15] + w[A >> 20 & 15] + w[A >> 16 & 15] + w[A >> 12 & 15] + w[A >> 8 & 15] + w[A >> 4 & 15] + w[15 & A]), re == 512 && (Z += w[L >> 28 & 15] + w[L >> 24 & 15] + w[L >> 20 & 15] + w[L >> 16 & 15] + w[L >> 12 & 15] + w[L >> 8 & 15] + w[L >> 4 & 15] + w[15 & L] + w[j >> 28 & 15] + w[j >> 24 & 15] + w[j >> 20 & 15] + w[j >> 16 & 15] + w[j >> 12 & 15] + w[j >> 8 & 15] + w[j >> 4 & 15] + w[15 & j] + w[J >> 28 & 15] + w[J >> 24 & 15] + w[J >> 20 & 15] + w[J >> 16 & 15] + w[J >> 12 & 15] + w[J >> 8 & 15] + w[J >> 4 & 15] + w[15 & J] + w[X >> 28 & 15] + w[X >> 24 & 15] + w[X >> 20 & 15] + w[X >> 16 & 15] + w[X >> 12 & 15] + w[X >> 8 & 15] + w[X >> 4 & 15] + w[15 & X]), Z;
    }, W.prototype.toString = W.prototype.hex, W.prototype.digest = function() {
      this.finalize();
      var P = this.h0h, F = this.h0l, H = this.h1h, te = this.h1l, p = this.h2h, $ = this.h2l, _ = this.h3h, y = this.h3l, g = this.h4h, v = this.h4l, E = this.h5h, A = this.h5l, L = this.h6h, j = this.h6l, J = this.h7h, X = this.h7l, re = this.bits, Z = [P >> 24 & 255, P >> 16 & 255, P >> 8 & 255, 255 & P, F >> 24 & 255, F >> 16 & 255, F >> 8 & 255, 255 & F, H >> 24 & 255, H >> 16 & 255, H >> 8 & 255, 255 & H, te >> 24 & 255, te >> 16 & 255, te >> 8 & 255, 255 & te, p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, 255 & p, $ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, 255 & $, _ >> 24 & 255, _ >> 16 & 255, _ >> 8 & 255, 255 & _];
      return re >= 256 && Z.push(y >> 24 & 255, y >> 16 & 255, y >> 8 & 255, 255 & y), re >= 384 && Z.push(g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, 255 & g, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, 255 & v, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, 255 & A), re == 512 && Z.push(L >> 24 & 255, L >> 16 & 255, L >> 8 & 255, 255 & L, j >> 24 & 255, j >> 16 & 255, j >> 8 & 255, 255 & j, J >> 24 & 255, J >> 16 & 255, J >> 8 & 255, 255 & J, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, 255 & X), Z;
    }, W.prototype.array = W.prototype.digest, W.prototype.arrayBuffer = function() {
      this.finalize();
      var P = this.bits, F = new ArrayBuffer(P / 8), H = new DataView(F);
      return H.setUint32(0, this.h0h), H.setUint32(4, this.h0l), H.setUint32(8, this.h1h), H.setUint32(12, this.h1l), H.setUint32(16, this.h2h), H.setUint32(20, this.h2l), H.setUint32(24, this.h3h), P >= 256 && H.setUint32(28, this.h3l), P >= 384 && (H.setUint32(32, this.h4h), H.setUint32(36, this.h4l), H.setUint32(40, this.h5h), H.setUint32(44, this.h5l)), P == 512 && (H.setUint32(48, this.h6h), H.setUint32(52, this.h6l), H.setUint32(56, this.h7h), H.setUint32(60, this.h7l)), F;
    }, W.prototype.clone = function() {
      var P = new W(this.bits, !1);
      return this.copyTo(P), P;
    }, W.prototype.copyTo = function(P) {
      var F = 0, H = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (F = 0; F < H.length; ++F)
        P[H[F]] = this[H[F]];
      for (F = 0; F < this.blocks.length; ++F)
        P.blocks[F] = this.blocks[F];
    }, V.prototype = new W(), V.prototype.finalize = function() {
      if (W.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var P = this.array();
        W.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(P), W.prototype.finalize.call(this);
      }
    }, V.prototype.clone = function() {
      var P = new V([], this.bits, !1);
      this.copyTo(P), P.inner = this.inner;
      for (var F = 0; F < this.oKeyPad.length; ++F)
        P.oKeyPad[F] = this.oKeyPad[F];
      return P;
    };
    var ee = q(512);
    ee.sha512 = ee, ee.sha384 = q(384), ee.sha512_256 = q(256), ee.sha512_224 = q(224), ee.sha512.hmac = z(512), ee.sha384.hmac = z(384), ee.sha512_256.hmac = z(256), ee.sha512_224.hmac = z(224), m ? o.exports = ee : (u.sha512 = ee.sha512, u.sha384 = ee.sha384, u.sha512_256 = ee.sha512_256, u.sha512_224 = ee.sha512_224);
  })();
})(sha512$1);
const elliptic = elliptic$1, BN = bn$1.exports, { sha256 } = sha256$1.exports, { sha512 } = sha512$1.exports, EC$2 = new elliptic.ec("secp256k1");
function toBytesInt32(o) {
  return new Uint8Array([(4278190080 & o) >> 24, (16711680 & o) >> 16, (65280 & o) >> 8, 255 & o]);
}
const one = new BN(1);
function Unmarshal(o) {
  const n = EC$2.n.bitLength() + 7 >> 3;
  if (EC$2.g.mul(10), (-2 & o[0]) != 2)
    return [null, null];
  if (o.length != 1 + n)
    return [null, null];
  const a = new BN(o.slice(1, 1 + n));
  try {
    const u = EC$2.curve.pointFromX(a);
    return [u.x, u.y];
  } catch {
    return [null, null];
  }
}
function H1(o) {
  let n = null, a = null;
  const u = EC$2.n.bitLength() + 7 >> 3;
  let c = 0;
  for (; n == null && c < 100; ) {
    const m = [2, ...sha512.array(new Uint8Array([...toBytesInt32(c), ...o]))];
    [n, a] = Unmarshal(m.slice(0, u + 1)), c++;
  }
  return EC$2.curve.point(n, a);
}
function H2(o) {
  const n = EC$2.n.bitLength() + 7 >> 3;
  let a = 0;
  for (; ; ) {
    const u = sha512.array(new Uint8Array([...toBytesInt32(a), ...o])), c = new BN(u.slice(0, n));
    if (c.cmp(EC$2.curve.n.sub(one)) == -1)
      return c.add(one);
    a++;
  }
}
function Evaluate(o, n) {
  const a = EC$2.keyFromPrivate(o), u = EC$2.genKeyPair().getPrivate(), c = H1(n), m = c.mul(o).encode(), d = EC$2.curve.g.mul(u), w = c.mul(u), S = H2([...EC$2.curve.g.encode(), ...c.encode(), ...a.getPublic().encode(), ...m, ...d.encode(), ...w.encode()]), T = u.sub(S.mul(a.getPrivate())).umod(EC$2.curve.n);
  return [sha256.array(new Uint8Array(m)), [...new Array(32 - S.byteLength()).fill(0), ...S.toArray(), ...new Array(32 - T.byteLength()).fill(0), ...T.toArray(), ...m]];
}
function ProofHoHash(o, n, a) {
  const u = EC$2.keyFromPublic(o);
  if (a.length !== 129)
    throw new Error("invalid vrf");
  const c = a.slice(0, 32), m = a.slice(32, 64), d = a.slice(64, 129), w = decodePoint(d);
  if (!w)
    throw new Error("invalid vrf");
  const S = EC$2.curve.g.mul(m), T = u.getPublic().mul(c), B = S.add(T), I = H1(n), C = I.mul(m), N = w.mul(c), q = C.add(N), D = H2([...EC$2.curve.g.encode(), ...I.encode(), ...u.getPublic().encode(), ...d, ...B.encode(), ...q.encode()]), z = [...new Array(32 - D.byteLength()).fill(0), ...D.toArray()];
  let W = !0;
  for (let V = 0; V < z.length; V++)
    c[V] !== z[V] && (W = !1);
  if (!W)
    throw new Error("invalid vrf");
  return sha256.array(new Uint8Array(d));
}
function decodePoint(o) {
  try {
    return EC$2.curve.decodePoint(o);
  } catch {
    return null;
  }
}
var vrfJs = { Evaluate, ProofHoHash }, StateCache = {};
function canBeCached(o) {
  return o.confirmationStatus === void 0 || o.confirmationStatus === "confirmed";
}
Object.defineProperty(StateCache, "__esModule", { value: !0 }), StateCache.canBeCached = void 0, StateCache.canBeCached = canBeCached;
var TagsParser$1 = {};
Object.defineProperty(TagsParser$1, "__esModule", { value: !0 }), TagsParser$1.TagsParser = void 0;
const SmartWeaveTags_1$2 = SmartWeaveTags, LoggerFactory_1$b = LoggerFactory$1;
class TagsParser {
  constructor() {
    this.logger = LoggerFactory_1$b.LoggerFactory.INST.create("TagsParser");
  }
  getInputTag(n, a) {
    if (TagsParser.hasMultipleInteractions(n)) {
      this.logger.debug("Interaction transaction is using multiple input tx tag format.");
      const u = n.tags.findIndex((m) => m.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID && m.value === a);
      if (n.tags.length - 1 === u)
        return void this.logger.warn("Wrong tags format: 'Contract' is the last tag");
      const c = n.tags[u + 1];
      return c.name !== SmartWeaveTags_1$2.SmartWeaveTags.INPUT ? void this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${c.name} was found`) : c;
    }
    return n.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INPUT);
  }
  isInteractWrite(n, a) {
    return n.tags.some((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE && u.value === a);
  }
  getInteractWritesContracts(n) {
    return n.tags.filter((a) => a.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE).map((a) => a.value);
  }
  getContractTag(n) {
    var a;
    return (a = n.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID)) === null || a === void 0 ? void 0 : a.value;
  }
  getContractsWithInputs(n) {
    const a = /* @__PURE__ */ new Map();
    return n.tags.filter((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).forEach((u) => {
      a.set(u.value, this.getInputTag(n, u.value));
    }), a;
  }
  static hasMultipleInteractions(n) {
    return n.tags.filter((a) => a.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).length > 1;
  }
}
TagsParser$1.TagsParser = TagsParser;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(DefaultStateEvaluator$1, "__esModule", { value: !0 }), DefaultStateEvaluator$1.DefaultStateEvaluator = void 0;
const vrf_js_1$1 = vrfJs, elliptic_1$1 = __importDefault$5(elliptic$1), SortKeyCache_1$1 = SortKeyCache, Benchmark_1$1 = Benchmark$1, LoggerFactory_1$a = LoggerFactory$1, utils_1$5 = utils$n, StateEvaluator_1$2 = StateEvaluator, StateCache_1 = StateCache, TagsParser_1 = TagsParser$1, EC$1 = new elliptic_1$1.default.ec("secp256k1");
class DefaultStateEvaluator {
  constructor(n, a = []) {
    this.arweave = n, this.executionContextModifiers = a, this.logger = LoggerFactory_1$a.LoggerFactory.INST.create("DefaultStateEvaluator"), this.tagsParser = new TagsParser_1.TagsParser();
  }
  async eval(n, a) {
    return this.doReadState(n.sortedInteractions, new StateEvaluator_1$2.EvalStateResult(n.contractDefinition.initState, {}, {}), n, a);
  }
  async doReadState(n, a, u, c) {
    var m;
    const { ignoreExceptions: d, stackTrace: w, internalWrites: S } = u.evaluationOptions, { contract: T, contractDefinition: B, sortedInteractions: I } = u;
    let C = a.state, N = null;
    const q = a.validity, D = a.errorMessages;
    u == null || u.handler.initState(C);
    const z = u.contract.callDepth();
    this.logger.info(`${(0, utils_1$5.indent)(z)}Evaluating state for ${B.txId} [${n.length} non-cached of ${I.length} all]`);
    let W = null, V = null;
    const ee = n.length;
    u.handler.initState(C);
    for (let F = 0; F < ee; F++) {
      const H = n[F], te = Benchmark_1$1.Benchmark.measure();
      if (N = H.sortKey, H.vrf && !this.verifyVrf(H.vrf, H.sortKey, this.arweave))
        throw new Error("Vrf verification failed.");
      if (this.logger.debug(`${(0, utils_1$5.indent)(z)}[${B.txId}][${H.id}][${H.block.height}]: ${n.indexOf(H) + 1}/${n.length} [of all:${I.length}]`), this.tagsParser.isInteractWrite(H, B.txId) && S) {
        const p = this.tagsParser.getContractTag(H);
        this.logger.debug(`${(0, utils_1$5.indent)(z)}Internal Write - Loading writing contract`, p);
        const $ = T.getCallStack().addInteractionData({ interaction: null, interactionTx: H, currentTx: c }), _ = u.warp.contract(p, u.contract, { callingInteraction: H, callType: "read" });
        await this.onContractCall(H, u, new StateEvaluator_1$2.EvalStateResult(C, q, D)), this.logger.debug(`${(0, utils_1$5.indent)(z)}Reading state of the calling contract at`, H.sortKey), await _.readState(H.sortKey, [...c || [], { contractTxId: B.txId, interactionTxId: H.id }]);
        const y = await this.internalWriteState(B.txId, H.sortKey);
        if (y !== null) {
          C = y.cachedValue.state, u == null || u.handler.initState(C), q[H.id] = y.cachedValue.validity[H.id], !((m = y.cachedValue.errorMessages) === null || m === void 0) && m[H.id] && (D[H.id] = y.cachedValue.errorMessages[H.id]);
          const g = new StateEvaluator_1$2.EvalStateResult(C, q, D);
          await this.onStateUpdate(H, u, g), (0, StateCache_1.canBeCached)(H) && (V = { tx: H, state: g });
        } else
          q[H.id] = !1;
        $.update({ cacheHit: !1, outputState: w.saveState ? C : void 0, executionTime: te.elapsed(!0), valid: q[H.id], errorMessage: W, gasUsed: 0 });
      } else {
        const p = this.tagsParser.getInputTag(H, u.contractDefinition.txId);
        if (!p) {
          this.logger.error(`${(0, utils_1$5.indent)(z)}Skipping tx - Input tag not found for ${H.id}`);
          continue;
        }
        const $ = this.parseInput(p);
        if (!$) {
          this.logger.error(`${(0, utils_1$5.indent)(z)}Skipping tx - invalid Input tag - ${H.id}`);
          continue;
        }
        const _ = { input: $, caller: H.owner.address }, y = { interaction: _, interactionTx: H, currentTx: c };
        this.logger.debug(`${(0, utils_1$5.indent)(z)}Interaction:`, _);
        const g = T.getCallStack().addInteractionData(y), v = await u.handler.handle(u, new StateEvaluator_1$2.EvalStateResult(C, q, D), y);
        if (W = v.errorMessage, v.type !== "ok" && (D[H.id] = W), this.logResult(v, H, u), this.logger.debug(`${(0, utils_1$5.indent)(z)}Interaction evaluation`, te.elapsed()), g.update({ cacheHit: !1, outputState: w.saveState ? C : void 0, executionTime: te.elapsed(!0), valid: q[H.id], errorMessage: W, gasUsed: v.gasUsed }), v.type === "exception" && d !== !0)
          throw new Error(`Exception while processing ${JSON.stringify(_)}:
${v.errorMessage}`);
        q[H.id] = v.type === "ok", C = v.state;
        const E = new StateEvaluator_1$2.EvalStateResult(C, q, D);
        (0, StateCache_1.canBeCached)(H) && (V = { tx: H, state: E }), await this.onStateUpdate(H, u, E);
      }
      for (const { modify: p } of this.executionContextModifiers)
        u = await p(C, u);
    }
    const P = new StateEvaluator_1$2.EvalStateResult(C, q, D);
    return V !== null && await this.onStateEvaluated(V.tx, u, V.state), new SortKeyCache_1$1.SortKeyCacheResult(N, P);
  }
  verifyVrf(n, a, u) {
    const c = EC$1.keyFromPublic(n.pubkey, "hex");
    let m;
    try {
      m = (0, vrf_js_1$1.ProofHoHash)(c.getPublic(), u.utils.stringToBuffer(a), u.utils.b64UrlToBuffer(n.proof));
    } catch {
      return !1;
    }
    return u.utils.bufferTob64Url(m) == n.index;
  }
  logResult(n, a, u) {
    n.type === "exception" && this.logger.error(`Executing of interaction: [${u.contractDefinition.txId} -> ${a.id}] threw exception:`, `${n.errorMessage}`), n.type === "error" && this.logger.warn(`Executing of interaction: [${u.contractDefinition.txId} -> ${a.id}] returned error:`, n.errorMessage);
  }
  parseInput(n) {
    try {
      return JSON.parse(n.value);
    } catch (a) {
      return this.logger.error(a), null;
    }
  }
}
DefaultStateEvaluator$1.DefaultStateEvaluator = DefaultStateEvaluator;
var LexicographicalInteractionsSorter = {}, WarpGatewayInteractionsLoader = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.WarpGatewayInteractionsLoader = o.SourceType = void 0;
  const n = Benchmark$1, a = LoggerFactory$1, u = utils$n;
  var c;
  (c = o.SourceType || (o.SourceType = {})).ARWEAVE = "arweave", c.WARP_SEQUENCER = "redstone-sequencer", o.WarpGatewayInteractionsLoader = class {
    constructor(m, d = null, w = null) {
      this.baseUrl = m, this.confirmationStatus = d, this.source = w, this.logger = a.LoggerFactory.INST.create("WarpGatewayInteractionsLoader"), this.baseUrl = (0, u.stripTrailingSlash)(m), Object.assign(this, d), this.source = w;
    }
    async load(m, d, w, S) {
      this.logger.debug("Loading interactions: for ", { contractId: m, fromSortKey: d, toSortKey: w });
      const T = [];
      let B = 0, I = 0, C = 0;
      const N = n.Benchmark.measure();
      do {
        const q = n.Benchmark.measure(), D = `${this.baseUrl}/gateway/v2/interactions-sort-key`, z = await fetch(`${D}?${new URLSearchParams({ contractId: m, ...d ? { from: d } : "", ...w ? { to: w } : "", page: (++B).toString(), fromSdk: "true", ...this.confirmationStatus && this.confirmationStatus.confirmed ? { confirmationStatus: "confirmed" } : "", ...this.confirmationStatus && this.confirmationStatus.notCorrupted ? { confirmationStatus: "not_corrupted" } : "", ...this.source ? { source: this.source } : "" })}`).then((W) => W.ok ? W.json() : Promise.reject(W)).catch((W) => {
          var V;
          throw !((V = W.body) === null || V === void 0) && V.message && this.logger.error(W.body.message), new Error(`Unable to retrieve transactions. Warp gateway responded with status ${W.status}.`);
        });
        this.logger.debug(`Loading interactions: page ${B} loaded in ${q.elapsed()}`), T.push(...z.interactions), I = z.paging.limit, C = z.paging.items, this.logger.debug(`Loaded interactions length: ${T.length}, from: ${d}, to: ${w}`);
      } while (C == I);
      return this.logger.debug("All loaded interactions:", { from: d, to: w, loaded: T.length, time: N.elapsed() }), T;
    }
    type() {
      return "warp";
    }
    clearCache() {
    }
  };
})(WarpGatewayInteractionsLoader), function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.LexicographicalInteractionsSorter = o.genesisSortKey = o.sortingLast = o.sortingFirst = void 0;
  const n = utils$p, a = LoggerFactory$1, u = WarpGatewayInteractionsLoader, c = "".padEnd(13, "0"), m = "".padEnd(13, "9"), d = "".padEnd(13, "0");
  o.sortingFirst = "".padEnd(64, "0"), o.sortingLast = "".padEnd(64, "z"), o.genesisSortKey = `${"".padStart(12, "0")},${c},${o.sortingFirst}`, o.LexicographicalInteractionsSorter = class {
    constructor(w) {
      this.arweave = w, this.logger = a.LoggerFactory.INST.create("LexicographicalInteractionsSorter");
    }
    async sort(w) {
      const S = [...w], T = S.map((B) => this.addSortKey(B));
      return await Promise.all(T), S.sort((B, I) => B.node.sortKey.localeCompare(I.node.sortKey));
    }
    async createSortKey(w, S, T, B = !1) {
      const I = this.arweave.utils.b64UrlToBuffer(w), C = this.arweave.utils.b64UrlToBuffer(S), N = this.arweave.utils.concatBuffers([I, C]), q = (0, n.arrayToHex)(await this.arweave.crypto.hash(N));
      return `${`${T}`.padStart(12, "0")},${B ? m : d},${q}`;
    }
    extractBlockHeight(w) {
      return w ? parseInt(w.split(",")[0]) : null;
    }
    async addSortKey(w) {
      const { node: S } = w;
      w.node.sortKey !== void 0 && w.node.source == u.SourceType.WARP_SEQUENCER ? this.logger.debug("Using sortKey from sequencer", w.node.sortKey) : w.node.sortKey = await this.createSortKey(S.block.id, S.id, S.block.height);
    }
    generateLastSortKey(w) {
      return `${`${w}`.padStart(12, "0")},${m},${o.sortingLast}`;
    }
  };
}(LexicographicalInteractionsSorter), Object.defineProperty(CacheableStateEvaluator$1, "__esModule", { value: !0 }), CacheableStateEvaluator$1.CacheableStateEvaluator = void 0;
const SortKeyCache_1 = SortKeyCache, LoggerFactory_1$9 = LoggerFactory$1, utils_1$4 = utils$n, StateEvaluator_1$1 = StateEvaluator, DefaultStateEvaluator_1 = DefaultStateEvaluator$1, LexicographicalInteractionsSorter_1$1 = LexicographicalInteractionsSorter;
class CacheableStateEvaluator extends DefaultStateEvaluator_1.DefaultStateEvaluator {
  constructor(n, a, u = []) {
    super(n, u), this.cache = a, this.cLogger = LoggerFactory_1$9.LoggerFactory.INST.create("CacheableStateEvaluator");
  }
  async eval(n, a) {
    var u, c, m, d;
    const w = n.cachedState;
    if (w && w.sortKey == n.requestedSortKey)
      return this.cLogger.info(`Exact cache hit for sortKey ${(u = n == null ? void 0 : n.contractDefinition) === null || u === void 0 ? void 0 : u.txId}:${w.sortKey}`), (c = n.handler) === null || c === void 0 || c.initState(w.cachedValue.state), w;
    const S = n.sortedInteractions, T = n.contractDefinition.txId;
    if (!T)
      throw new Error("Contract tx id not set in the execution context");
    for (const N of a || [])
      if (N.contractTxId === n.contractDefinition.txId) {
        const q = S.findIndex((D) => D.id === N.interactionTxId);
        q !== -1 && (this.cLogger.debug("Inf. Loop fix - removing interaction", { height: S[q].block.height, contractTxId: N.contractTxId, interactionTxId: N.interactionTxId, sortKey: S[q].sortKey }), S.splice(q));
      }
    if (S.length == 0) {
      if (this.cLogger.info(`No missing interactions ${T}`), w)
        return (m = n.handler) === null || m === void 0 || m.initState(w.cachedValue.state), w;
      {
        (d = n.handler) === null || d === void 0 || d.initState(n.contractDefinition.initState), this.cLogger.debug("Inserting initial state into cache");
        const N = new StateEvaluator_1$1.EvalStateResult(n.contractDefinition.initState, {}, {});
        return await this.cache.put(new SortKeyCache_1.CacheKey(T, LexicographicalInteractionsSorter_1$1.genesisSortKey), N), new SortKeyCache_1.SortKeyCacheResult(LexicographicalInteractionsSorter_1$1.genesisSortKey, N);
      }
    }
    const B = w == null ? n.contractDefinition.initState : w.cachedValue.state, I = w == null ? {} : w.cachedValue.validity, C = w == null ? {} : w.cachedValue.errorMessages;
    return this.cLogger.debug("Base state", B), await this.doReadState(S, new StateEvaluator_1$1.EvalStateResult(B, I, C || {}), n, a);
  }
  async onStateEvaluated(n, a, u) {
    const c = a.contractDefinition.txId;
    this.cLogger.debug(`${(0, utils_1$4.indent)(a.contract.callDepth())}onStateEvaluated: cache update for contract ${c} [${n.sortKey}]`), await this.putInCache(c, n, u);
  }
  async onStateUpdate(n, a, u, c = !1) {
    (a.evaluationOptions.updateCacheForEachInteraction || c) && (this.cLogger.debug(`onStateUpdate: cache update for contract ${a.contractDefinition.txId} [${n.sortKey}]`, { contract: a.contractDefinition.txId, state: u.state, sortKey: n.sortKey }), await this.putInCache(a.contractDefinition.txId, n, u));
  }
  async latestAvailableState(n, a) {
    if (this.cLogger.debug("Searching for", { contractTxId: n, sortKey: a }), a) {
      const u = await this.cache.getLessOrEqual(n, a);
      return u && this.cLogger.debug(`Latest available state at ${n}: ${u.sortKey}`), u;
    }
    return await this.cache.getLast(n);
  }
  async onInternalWriteStateUpdate(n, a, u) {
    this.cLogger.debug("Internal write state update:", { sortKey: n.sortKey, dry: n.dry, contractTxId: a, state: u.state }), await this.putInCache(a, n, u);
  }
  async onContractCall(n, a, u) {
    var c;
    if (((c = a.sortedInteractions) === null || c === void 0 ? void 0 : c.length) == 0)
      return;
    const m = a.sortedInteractions.indexOf(n);
    m < 1 || await this.putInCache(a.contractDefinition.txId, a.sortedInteractions[m - 1], u);
  }
  async putInCache(n, a, u) {
    if (a.dry || a.confirmationStatus !== void 0 && a.confirmationStatus !== "confirmed")
      return;
    const c = new StateEvaluator_1$1.EvalStateResult(u.state, u.validity, u.errorMessages || {});
    this.cLogger.debug("Putting into cache", { contractTxId: n, transaction: a.id, sortKey: a.sortKey, dry: a.dry, state: c.state, validity: c.validity }), await this.cache.put(new SortKeyCache_1.CacheKey(n, a.sortKey), c);
  }
  async syncState(n, a, u, c) {
    const m = new StateEvaluator_1$1.EvalStateResult(u, c, {});
    await this.cache.put(new SortKeyCache_1.CacheKey(n, a), m);
  }
  async dumpCache() {
    return await this.cache.dump();
  }
  async internalWriteState(n, a) {
    return await this.cache.get(n, a);
  }
  async hasContractCached(n) {
    return await this.cache.getLast(n) != null;
  }
  async lastCachedSortKey() {
    return await this.cache.getLastSortKey();
  }
  async allCachedContracts() {
    return await this.cache.allContracts();
  }
}
CacheableStateEvaluator$1.CacheableStateEvaluator = CacheableStateEvaluator;
var HandlerExecutorFactory$1 = {}, umd = { exports: {} };
(function(o, n) {
  var a = function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.default = void 0, u.demangle = z, u.instantiate = N, u.instantiateStreaming = D, u.instantiateSync = q;
    const c = () => {
      throw Error("Operation requires compiling with --exportRuntime");
    }, m = typeof BigUint64Array < "u", d = Symbol(), w = new TextDecoder("utf-16le", { fatal: !0 });
    function S(V, ee) {
      let P = new Uint32Array(V)[ee + -4 >>> 2] >>> 1;
      const F = new Uint16Array(V, ee, P);
      if (P <= 192)
        return String.fromCharCode(...F);
      try {
        return w.decode(F);
      } catch {
        let H = "", te = 0;
        for (; P - te > 1024; )
          H += String.fromCharCode(...F.subarray(te, te += 1024));
        return H + String.fromCharCode(...F.subarray(te));
      }
    }
    function T(V) {
      const ee = {};
      function P(H, te) {
        return H ? S(H.buffer, te) : "<yet unknown>";
      }
      const F = V.env = V.env || {};
      return F.abort = F.abort || function(H, te, p, $) {
        const _ = ee.memory || F.memory;
        throw Error(`abort: ${P(_, H)} at ${P(_, te)}:${p}:${$}`);
      }, F.trace = F.trace || function(H, te, ...p) {
        const $ = ee.memory || F.memory;
        console.log(`trace: ${P($, H)}${te ? " " : ""}${p.slice(0, te).join(", ")}`);
      }, F.seed = F.seed || Date.now, V.Math = V.Math || Math, V.Date = V.Date || Date, ee;
    }
    function B(V, ee) {
      const P = ee.exports, F = P.memory, H = P.table, te = P.__new || c, p = P.__pin || c, $ = P.__unpin || c, _ = P.__collect || c, y = P.__rtti_base, g = y ? (Z) => Z[y >>> 2] : c;
      function v(Z) {
        const ie = new Uint32Array(F.buffer);
        if ((Z >>>= 0) >= g(ie))
          throw Error(`invalid id: ${Z}`);
        return ie[(y + 4 >>> 2) + (Z << 1) + 1];
      }
      function E(Z) {
        const ie = function(oe) {
          const ue = new Uint32Array(F.buffer);
          if ((oe >>>= 0) >= g(ue))
            throw Error(`invalid id: ${oe}`);
          return ue[(y + 4 >>> 2) + (oe << 1)];
        }(Z);
        if (!(7 & ie))
          throw Error(`not an array: ${Z}, flags=${ie}`);
        return ie;
      }
      function A(Z) {
        return 31 - Math.clz32(Z >>> 6 & 31);
      }
      function L(Z, ie, oe) {
        const ue = F.buffer;
        if (oe)
          switch (Z) {
            case 2:
              return new Float32Array(ue);
            case 3:
              return new Float64Array(ue);
          }
        else
          switch (Z) {
            case 0:
              return new (ie ? Int8Array : Uint8Array)(ue);
            case 1:
              return new (ie ? Int16Array : Uint16Array)(ue);
            case 2:
              return new (ie ? Int32Array : Uint32Array)(ue);
            case 3:
              return new (ie ? BigInt64Array : BigUint64Array)(ue);
          }
        throw Error(`unsupported align: ${Z}`);
      }
      function j(Z) {
        const ie = new Uint32Array(F.buffer), oe = E(ie[Z + -8 >>> 2]), ue = A(oe);
        let se = 4 & oe ? Z : ie[Z + 4 >>> 2];
        const ce = 2 & oe ? ie[Z + 12 >>> 2] : ie[se + -4 >>> 2] >>> ue;
        return L(ue, 2048 & oe, 4096 & oe).subarray(se >>>= ue, se + ce);
      }
      function J(Z, ie, oe) {
        return new Z(X(Z, ie, oe));
      }
      function X(Z, ie, oe) {
        const ue = F.buffer, se = new Uint32Array(ue);
        return new Z(ue, se[oe + 4 >>> 2], se[oe + 8 >>> 2] >>> ie);
      }
      function re(Z, ie, oe) {
        V[`__get${ie}`] = J.bind(null, Z, oe), V[`__get${ie}View`] = X.bind(null, Z, oe);
      }
      return V.__new = te, V.__pin = p, V.__unpin = $, V.__collect = _, V.__newString = function(Z) {
        if (Z == null)
          return 0;
        const ie = Z.length, oe = te(ie << 1, 1), ue = new Uint16Array(F.buffer);
        for (var se = 0, ce = oe >>> 1; se < ie; ++se)
          ue[ce + se] = Z.charCodeAt(se);
        return oe;
      }, V.__newArrayBuffer = function(Z) {
        if (Z == null)
          return 0;
        const ie = new Uint8Array(Z), oe = te(ie.length, 0);
        return new Uint8Array(F.buffer).set(ie, oe), oe;
      }, V.__getString = function(Z) {
        if (!Z)
          return null;
        const ie = F.buffer;
        if (new Uint32Array(ie)[Z + -8 >>> 2] !== 1)
          throw Error(`not a string: ${Z}`);
        return S(ie, Z);
      }, V.__newArray = function(Z, ie = 0) {
        const oe = ie, ue = E(Z), se = A(ue), ce = typeof oe != "number", Se = ce ? oe.length : oe, he = te(Se << se, 4 & ue ? Z : 0);
        let $e;
        if (4 & ue)
          $e = he;
        else {
          p(he);
          const fe = te(2 & ue ? 16 : 12, Z);
          $(he);
          const le = new Uint32Array(F.buffer);
          le[fe + 0 >>> 2] = he, le[fe + 4 >>> 2] = he, le[fe + 8 >>> 2] = Se << se, 2 & ue && (le[fe + 12 >>> 2] = Se), $e = fe;
        }
        if (ce) {
          const fe = L(se, 2048 & ue, 4096 & ue), le = he >>> se;
          if (16384 & ue)
            for (let we = 0; we < Se; ++we)
              fe[le + we] = oe[we];
          else
            fe.set(oe, le);
        }
        return $e;
      }, V.__getArrayView = j, V.__getArray = function(Z) {
        const ie = j(Z), oe = ie.length, ue = new Array(oe);
        for (let se = 0; se < oe; se++)
          ue[se] = ie[se];
        return ue;
      }, V.__getArrayBuffer = function(Z) {
        const ie = F.buffer, oe = new Uint32Array(ie)[Z + -4 >>> 2];
        return ie.slice(Z, Z + oe);
      }, V.__getFunction = function(Z) {
        if (!H)
          throw Error("Operation requires compiling with --exportTable");
        const ie = new Uint32Array(F.buffer)[Z >>> 2];
        return H.get(ie);
      }, [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].forEach((Z) => {
        re(Z, Z.name, 31 - Math.clz32(Z.BYTES_PER_ELEMENT));
      }), m && [BigUint64Array, BigInt64Array].forEach((Z) => {
        re(Z, Z.name.slice(3), 3);
      }), V.__instanceof = function(Z, ie) {
        const oe = new Uint32Array(F.buffer);
        let ue = oe[Z + -8 >>> 2];
        if (ue <= g(oe))
          do {
            if (ue == ie)
              return !0;
            ue = v(ue);
          } while (ue);
        return !1;
      }, V.memory = V.memory || F, V.table = V.table || H, z(P, V);
    }
    function I(V) {
      return typeof Response < "u" && V instanceof Response;
    }
    function C(V) {
      return V instanceof WebAssembly.Module;
    }
    async function N(V, ee = {}) {
      if (I(V = await V))
        return D(V, ee);
      const P = C(V) ? V : await WebAssembly.compile(V), F = T(ee), H = await WebAssembly.instantiate(P, ee);
      return { module: P, instance: H, exports: B(F, H) };
    }
    function q(V, ee = {}) {
      const P = C(V) ? V : new WebAssembly.Module(V), F = T(ee), H = new WebAssembly.Instance(P, ee);
      return { module: P, instance: H, exports: B(F, H) };
    }
    async function D(V, ee = {}) {
      if (!WebAssembly.instantiateStreaming)
        return N(I(V = await V) ? V.arrayBuffer() : V, ee);
      const P = T(ee), F = await WebAssembly.instantiateStreaming(V, ee), H = B(P, F.instance);
      return { ...F, exports: H };
    }
    function z(V, ee = {}) {
      const P = V.__argumentsLength ? (F) => {
        V.__argumentsLength.value = F;
      } : V.__setArgumentsLength || V.__setargc || (() => {
      });
      for (let F of Object.keys(V)) {
        const H = V[F];
        let te = F.split("."), p = ee;
        for (; te.length > 1; ) {
          let y = te.shift();
          Object.hasOwn(p, y) || (p[y] = {}), p = p[y];
        }
        let $ = te[0], _ = $.indexOf("#");
        if (_ >= 0) {
          const y = $.substring(0, _), g = p[y];
          if (g === void 0 || !g.prototype) {
            const v = function(...E) {
              return v.wrap(v.prototype.constructor(0, ...E));
            };
            v.prototype = { valueOf() {
              return this[d];
            } }, v.wrap = function(E) {
              return Object.create(v.prototype, { [d]: { value: E, writable: !1 } });
            }, g && Object.getOwnPropertyNames(g).forEach((E) => Object.defineProperty(v, E, Object.getOwnPropertyDescriptor(g, E))), p[y] = v;
          }
          if ($ = $.substring(_ + 1), p = p[y].prototype, /^(get|set):/.test($)) {
            if (!Object.hasOwn(p, $ = $.substring(4))) {
              let v = V[F.replace("set:", "get:")], E = V[F.replace("get:", "set:")];
              Object.defineProperty(p, $, { get() {
                return v(this[d]);
              }, set(A) {
                E(this[d], A);
              }, enumerable: !0 });
            }
          } else
            $ === "constructor" ? (p[$] = function(...v) {
              return P(v.length), H(...v);
            }).original = H : (p[$] = function(...v) {
              return P(v.length), H(this[d], ...v);
            }).original = H;
        } else
          /^(get|set):/.test($) ? Object.hasOwn(p, $ = $.substring(4)) || Object.defineProperty(p, $, { get: V[F.replace("set:", "get:")], set: V[F.replace("get:", "set:")], enumerable: !0 }) : typeof H == "function" && H !== P ? (p[$] = (...y) => (P(y.length), H(...y))).original = H : p[$] = H;
      }
      return ee;
    }
    Object.hasOwn = Object.hasOwn || function(V, ee) {
      return Object.prototype.hasOwnProperty.call(V, ee);
    };
    var W = { instantiate: N, instantiateSync: q, instantiateStreaming: D, demangle: z };
    return u.default = W, "default" in u ? u.default : u;
  }({});
  o.exports = a;
})(umd);
var asWasmImports$1 = {};
Object.defineProperty(asWasmImports$1, "__esModule", { value: !0 }), asWasmImports$1.asWasmImports = void 0;
const LoggerFactory_1$8 = LoggerFactory$1, asWasmImports = (o, n) => {
  const a = LoggerFactory_1$8.LoggerFactory.INST.create("WASM:AS");
  return { metering: { usegas: o.useGas }, console: { "console.log": function(u) {
    a.debug(`${o.contract.id}: ${n.exports.__getString(u)}`);
  }, "console.logO": function(u, c) {
    a.debug(`${o.contract.id}: ${n.exports.__getString(u)}`, JSON.parse(n.exports.__getString(c)));
  } }, block: { "Block.height": function() {
    return o.block.height;
  }, "Block.indep_hash": function() {
    return n.exports.__newString(o.block.indep_hash);
  }, "Block.timestamp": function() {
    return o.block.timestamp;
  } }, transaction: { "Transaction.id": function() {
    return n.exports.__newString(o.transaction.id);
  }, "Transaction.owner": function() {
    return n.exports.__newString(o.transaction.owner);
  }, "Transaction.target": function() {
    return n.exports.__newString(o.transaction.target);
  } }, contract: { "Contract.id": function() {
    return n.exports.__newString(o.contract.id);
  }, "Contract.owner": function() {
    return n.exports.__newString(o.contract.owner);
  } }, api: { _readContractState: (u, c) => {
    const m = n.exports.__getString(c), d = (w = u, n.exports.table.get(w));
    var w;
    return console.log("Simulating read state of", m), setTimeout(() => {
      console.log("calling callback"), d(n.exports.__newString(JSON.stringify({ contractTxId: m })));
    }, 1e3);
  }, clearTimeout }, env: { abort(u, c, m, d) {
    const w = n.exports.__getString(u);
    throw a.error(`--------------------- Error message from AssemblyScript ----------------------
`), a.error("  " + w), a.error('    In file "' + n.exports.__getString(c) + '"'), a.error(`    on line ${m}, column ${d}.`), a.error(`------------------------------------------------------------------------------
`), new Error(w);
  } } };
};
asWasmImports$1.asWasmImports = asWasmImports;
var rustWasmImports$1 = {};
Object.defineProperty(rustWasmImports$1, "__esModule", { value: !0 }), rustWasmImports$1.rustWasmImports = void 0;
const LoggerFactory_1$7 = LoggerFactory$1, rustWasmImports = (o, n, a, u) => {
  const c = LoggerFactory_1$7.LoggerFactory.INST.create("WASM:Rust"), m = { metering: { usegas: o.useGas }, console: { log: function(v) {
    c.debug(`${o.contract.id}: ${v}`);
  } }, Block: { height: function() {
    return o.block.height;
  }, indep_hash: function() {
    return o.block.indep_hash;
  }, timestamp: function() {
    return o.block.timestamp;
  } }, Transaction: { id: function() {
    return o.transaction.id;
  }, owner: function() {
    return o.transaction.owner;
  }, target: function() {
    return o.transaction.target;
  } }, Contract: { id: function() {
    return o.contract.id;
  }, owner: function() {
    return o.contract.owner;
  } }, SmartWeave: { caller: function() {
    return o.caller;
  }, readContractState: async function(v) {
    return await o.contracts.readContractState(v);
  }, write: async function(v, E) {
    return await o.contracts.write(v, E);
  } }, Vrf: { value: function() {
    return o.vrf.value;
  }, randomInt: function(v) {
    return o.vrf.randomInt(v);
  } } }, d = { __wbg_log_: function(v, E) {
    m.console.log(N(v, E));
  }, __wbindgen_json_parse: function(v, E) {
    return z(JSON.parse(N(v, E)));
  }, __wbindgen_json_serialize: function(v, E) {
    const A = W(E);
    var L = F(JSON.stringify(A === void 0 ? null : A), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), j = V;
    te()[v / 4 + 1] = j, te()[v / 4 + 0] = L;
  }, __wbindgen_object_drop_ref: function(v) {
    p(v);
  }, __wbindgen_cb_drop: function(v) {
    const E = p(v).original;
    return E.cnt-- == 1 && (E.a = 0, !0);
  }, __wbg_readContractState: function(v, E) {
    return z(m.SmartWeave.readContractState(N(v, E)));
  }, __wbg_viewContractState: function(v, E) {
  }, __wbg_caller: function(v) {
    var E = F(m.SmartWeave.caller(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_write: function(v, E, A) {
    return z(m.SmartWeave.write(N(v, E), p(A)));
  }, __wbg_refreshState: function(v, E) {
  }, __wbg_indephash: function(v) {
    var E = F(m.Block.indep_hash(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_height: function() {
    return m.Block.height();
  }, __wbg_timestamp: function() {
    return m.Block.timestamp();
  }, __wbg_id: function(v) {
    var E = F(m.Transaction.id(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_contractOwner: function(v) {
    var E = F(m.Contract.owner(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_contractId: function(v) {
    var E = F(m.Contract.id(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_owner: function(v) {
    var E = F(m.Transaction.owner(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_target: function(v) {
    var E = F(m.Transaction.target(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_call: function() {
    return g(function(v, E, A) {
      return z(W(v).call(W(E), W(A)));
    }, arguments);
  }, __wbg_new: function(v, E) {
    try {
      var A = { a: v, b: E }, L = new Promise((j, J) => {
        const X = A.a;
        A.a = 0;
        try {
          return function(re, Z, ie, oe) {
            a.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(re, Z, z(ie), z(oe));
          }(X, A.b, j, J);
        } finally {
          A.a = X;
        }
      });
      return z(L);
    } finally {
      A.a = A.b = 0;
    }
  }, __wbg_resolve: function(v) {
    return z(Promise.resolve(W(v)));
  }, __wbg_then_a: function(v, E) {
    return z(W(v).then(W(E)));
  }, __wbg_then_5: function(v, E, A) {
    return z(W(v).then(W(E), W(A)));
  }, __wbindgen_debug_string: function(v, E) {
    var A = F($(W(E)), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), L = V;
    te()[v / 4 + 1] = L, te()[v / 4 + 0] = A;
  }, __wbindgen_throw: function(v, E) {
    throw new Error(N(v, E));
  }, __wbindgen_closure_wrapper: function(v, E, A) {
    var L = function(j, J, X, re) {
      const Z = { a: j, b: J, cnt: 1, dtor: X }, ie = (...oe) => {
        Z.cnt++;
        const ue = Z.a;
        Z.a = 0;
        try {
          return re(ue, Z.b, ...oe);
        } finally {
          --Z.cnt == 0 ? a.exports.__wbindgen_export_2.get(Z.dtor)(ue, Z.b) : Z.a = ue;
        }
      };
      return ie.original = Z, ie;
    }(v, E, u, _);
    return z(L);
  }, __wbindgen_string_new: function(v, E) {
    return z(N(v, E));
  }, __wbg_value: function(v) {
    var E = F(m.Vrf.value(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), A = V;
    te()[v / 4 + 1] = A, te()[v / 4 + 0] = E;
  }, __wbg_randomInt: function(v, E) {
    return m.Vrf.randomInt(E);
  } }, w = Object.keys(d);
  let S = n.reduce((v, E) => {
    const A = w.find((L) => E.startsWith(L));
    if (A === void 0)
      throw new Error(`Cannot find import mapping for ${E}`);
    return v[E] = d[A], v;
  }, {}), T = {};
  T.__wbindgen_placeholder__ = S;
  let B = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 });
  B.decode();
  let I = null;
  function C() {
    return I !== null && I.buffer === a.exports.memory.buffer || (I = new Uint8Array(a.exports.memory.buffer)), I;
  }
  function N(v, E) {
    return B.decode(C().subarray(v, v + E));
  }
  const q = new Array(32).fill(void 0);
  q.push(void 0, null, !0, !1);
  let D = q.length;
  function z(v) {
    D === q.length && q.push(q.length + 1);
    const E = D;
    return D = q[E], q[E] = v, E;
  }
  function W(v) {
    return q[v];
  }
  let V = 0, ee = new TextEncoder("utf-8");
  const P = typeof ee.encodeInto == "function" ? function(v, E) {
    return ee.encodeInto(v, E);
  } : function(v, E) {
    const A = ee.encode(v);
    return E.set(A), { read: v.length, written: A.length };
  };
  function F(v, E, A) {
    if (A === void 0) {
      const re = ee.encode(v), Z = E(re.length);
      return C().subarray(Z, Z + re.length).set(re), V = re.length, Z;
    }
    let L = v.length, j = E(L);
    const J = C();
    let X = 0;
    for (; X < L; X++) {
      const re = v.charCodeAt(X);
      if (re > 127)
        break;
      J[j + X] = re;
    }
    if (X !== L) {
      X !== 0 && (v = v.slice(X)), j = A(j, L, L = X + 3 * v.length);
      const re = C().subarray(j + X, j + L);
      X += P(v, re).written;
    }
    return V = X, j;
  }
  let H = null;
  function te() {
    return H !== null && H.buffer === a.exports.memory.buffer || (H = new Int32Array(a.exports.memory.buffer)), H;
  }
  function p(v) {
    const E = W(v);
    return function(A) {
      A < 36 || (q[A] = D, D = A);
    }(v), E;
  }
  function $(v) {
    const E = typeof v;
    if (E == "number" || E == "boolean" || v == null)
      return `${v}`;
    if (E == "string")
      return `"${v}"`;
    if (E == "symbol") {
      const j = v.description;
      return j == null ? "Symbol" : `Symbol(${j})`;
    }
    if (E == "function") {
      const j = v.name;
      return typeof j == "string" && j.length > 0 ? `Function(${j})` : "Function";
    }
    if (Array.isArray(v)) {
      const j = v.length;
      let J = "[";
      j > 0 && (J += $(v[0]));
      for (let X = 1; X < j; X++)
        J += ", " + $(v[X]);
      return J += "]", J;
    }
    const A = /\[object ([^\]]+)\]/.exec(toString.call(v));
    let L;
    if (!(A.length > 1))
      return toString.call(v);
    if (L = A[1], L == "Object")
      try {
        return "Object(" + JSON.stringify(v) + ")";
      } catch {
        return "Object";
      }
    return v instanceof Error ? `${v.name}: ${v.message}
${v.stack}` : L;
  }
  function _(v, E, A) {
    a.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(v, E, z(A));
  }
  S.handle = function(v) {
    return p(a.exports.handle(z(v)));
  };
  let y = 32;
  function g(v, E) {
    try {
      return v.apply(this, E);
    } catch (A) {
      a.exports.__wbindgen_exn_store(z(A));
    }
  }
  return S.initState = function(v) {
    try {
      a.exports.initState(function(E) {
        if (y == 1)
          throw new Error("out of js stack");
        return q[--y] = E, y;
      }(v));
    } finally {
      q[y++] = void 0;
    }
  }, S.currentState = function() {
    return p(a.exports.currentState());
  }, S.lang = function() {
    try {
      const A = a.exports.__wbindgen_add_to_stack_pointer(-16);
      a.exports.lang(A);
      var v = te()[A / 4 + 0], E = te()[A / 4 + 1];
      return N(v, E);
    } finally {
      a.exports.__wbindgen_add_to_stack_pointer(16), a.exports.__wbindgen_free(v, E);
    }
  }, S.type = function() {
    return a.exports.type();
  }, S.StateWrapper = class {
    __destroy_into_raw() {
      const v = this.ptr;
      return this.ptr = 0, v;
    }
    free() {
      const v = this.__destroy_into_raw();
      a.exports.__wbg_statewrapper_free(v);
    }
  }, T.metering = m.metering, { imports: T, exports: S };
};
rustWasmImports$1.rustWasmImports = rustWasmImports;
var goWasmImports = {};
Object.defineProperty(goWasmImports, "__esModule", { value: !0 }), goWasmImports.Go = void 0;
const LoggerFactory_1$6 = LoggerFactory$1, encoder = new TextEncoder(), decoder = new TextDecoder("utf-8");
let logLine = [], globalJsModule;
(function(o) {
  globalJsModule = o, globalJsModule.redstone = { go: {} };
}).call(commonjsGlobal, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
class Go {
  constructor(n) {
    this._callbackTimeouts = /* @__PURE__ */ new Map(), this._nextCallbackTimeoutID = 1;
    const a = LoggerFactory_1$6.LoggerFactory.INST.create("WASM:Go");
    let u = this;
    globalJsModule.redstone.go = { WasmModule: { registerWasmModule: function(C) {
      u._id = C, u.exports = globalJsModule[C], delete globalJsModule[C], globalJsModule.redstone.go[C] = {}, globalJsModule.redstone.go[C].imports = { console: { log: function(...N) {
        a.debug(N[0], ...N.slice(1));
      } }, Transaction: { id: function() {
        return n.transaction.id;
      }, owner: function() {
        return n.transaction.owner;
      }, target: function() {
        return n.transaction.target;
      } }, Block: { indep_hash: function() {
        return n.block.indep_hash;
      }, height: function() {
        return n.block.height;
      }, timestamp: function() {
        return n.block.timestamp;
      } }, Contract: { id: function() {
        return n.contract.id;
      }, owner: function() {
        return n.contract.owner;
      } }, SmartWeave: { readContractState: async function(N) {
        return await n.contracts.readContractState(N);
      } } };
    } } };
    const c = () => new DataView(this._inst.exports.memory.buffer), m = (C, N) => {
      c().setUint32(C + 0, N, !0), c().setUint32(C + 4, Math.floor(N / 4294967296), !0);
    }, d = (C) => {
      const N = c().getFloat64(C, !0);
      if (N === 0)
        return;
      if (!isNaN(N))
        return N;
      const q = c().getUint32(C, !0);
      return this._values[q];
    }, w = (C, N) => {
      if (typeof N == "number")
        return isNaN(N) ? (c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 0, !0)) : N === 0 ? (c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 1, !0)) : void c().setFloat64(C, N, !0);
      switch (N) {
        case void 0:
          return void c().setFloat64(C, 0, !0);
        case null:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 2, !0);
        case !0:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 3, !0);
        case !1:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 4, !0);
      }
      let D = this._ids.get(N);
      D === void 0 && (D = this._idPool.pop(), D === void 0 && (D = this._values.length), this._values[D] = N, this._goRefCounts[D] = 0, this._ids.set(N, D)), this._goRefCounts[D]++;
      let z = 1;
      switch (typeof N) {
        case "string":
          z = 2;
          break;
        case "symbol":
          z = 3;
          break;
        case "function":
          z = 4;
      }
      c().setUint32(C + 4, 2146959360 | z, !0), c().setUint32(C, D, !0);
    }, S = (C, N, q = null) => new Uint8Array(this._inst.exports.memory.buffer, C, N), T = (C, N, q) => {
      const D = new Array(N);
      for (let z = 0; z < N; z++)
        D[z] = d(C + 8 * z);
      return D;
    }, B = (C, N) => decoder.decode(new DataView(this._inst.exports.memory.buffer, C, N)), I = Date.now() - performance.now();
    this.importObject = { wasi_snapshot_preview1: { fd_write: function(C, N, q, D) {
      let z = 0;
      if (C == 1)
        for (let W = 0; W < q; W++) {
          let V = N + 8 * W, ee = c().getUint32(V + 0, !0), P = c().getUint32(V + 4, !0);
          z += P;
          for (let F = 0; F < P; F++) {
            let H = c().getUint8(ee + F);
            if (H != 13)
              if (H == 10) {
                let te = decoder.decode(new Uint8Array(logLine));
                logLine = [], console.log(te);
              } else
                logLine.push(H);
          }
        }
      else
        console.error("invalid file descriptor:", C);
      return c().setUint32(D, z, !0), 0;
    }, fd_close: () => 0, fd_fdstat_get: () => 0, fd_seek: () => 0, proc_exit: (C) => {
      if (!commonjsGlobal.process)
        throw "trying to exit with code " + C;
      process.exit(C);
    }, random_get: (C, N) => (crypto.getRandomValues(S(C, N, null)), 0) }, env: { "runtime.ticks": () => I + performance.now(), "runtime.sleepTicks": (C) => {
      setTimeout(this._inst.exports.go_scheduler, C);
    }, "syscall/js.finalizeRef": (C) => {
      const N = c().getUint32(C, !0);
      if (this._goRefCounts[N]--, this._goRefCounts[N] === 0) {
        const q = this._values[N];
        this._values[N] = null, this._ids.delete(q), this._idPool.push(N);
      }
    }, "syscall/js.stringVal": (C, N, q) => {
      const D = B(N, q);
      w(C, D);
    }, "syscall/js.valueGet": (C, N, q, D) => {
      let z = B(q, D), W = d(N), V = Reflect.get(W, z);
      w(C, V);
    }, "syscall/js.valueSet": (C, N, q, D) => {
      const z = d(C), W = B(N, q), V = d(D);
      Reflect.set(z, W, V);
    }, "syscall/js.valueDelete": (C, N, q) => {
      const D = d(C), z = B(N, q);
      Reflect.deleteProperty(D, z);
    }, "syscall/js.valueIndex": (C, N, q) => {
      w(C, Reflect.get(d(N), q));
    }, "syscall/js.valueSetIndex": (C, N, q) => {
      Reflect.set(d(C), N, d(q));
    }, "syscall/js.valueCall": (C, N, q, D, z, W, V) => {
      const ee = d(N), P = B(q, D), F = T(z, W);
      try {
        const H = Reflect.get(ee, P);
        w(C, Reflect.apply(H, ee, F)), c().setUint8(C + 8, 1);
      } catch (H) {
        w(C, H), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueInvoke": (C, N, q, D, z) => {
      try {
        const W = d(N), V = T(q, D);
        w(C, Reflect.apply(W, void 0, V)), c().setUint8(C + 8, 1);
      } catch (W) {
        w(C, W), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueNew": (C, N, q, D, z) => {
      const W = d(N), V = T(q, D);
      try {
        w(C, Reflect.construct(W, V)), c().setUint8(C + 8, 1);
      } catch (ee) {
        w(C, ee), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueLength": (C) => d(C).length, "syscall/js.valuePrepareString": (C, N) => {
      const q = String(d(N)), D = encoder.encode(q);
      w(C, D), m(C + 8, D.length);
    }, "syscall/js.valueLoadString": (C, N, q, D) => {
      const z = d(C);
      S(N, q, D).set(z);
    }, "syscall/js.valueInstanceOf": (C, N) => d(C) instanceof d(N), "syscall/js.copyBytesToGo": (C, N, q, D, z) => {
      let W = C, V = C + 4;
      const ee = S(N, q), P = d(z);
      if (!(P instanceof Uint8Array))
        return void c().setUint8(V, 0);
      const F = P.subarray(0, ee.length);
      ee.set(F), m(W, F.length), c().setUint8(V, 1);
    }, "syscall/js.copyBytesToJS": (C, N, q, D, z) => {
      let W = C, V = C + 4;
      const ee = d(N), P = S(q, D);
      if (!(ee instanceof Uint8Array))
        return void c().setUint8(V, 0);
      const F = P.subarray(0, ee.length);
      ee.set(F), m(W, F.length), c().setUint8(V, 1);
    } } };
  }
  async run(n) {
    for (this._inst = n, this._values = [NaN, 0, null, !0, !1, commonjsGlobal, this], this._goRefCounts = [], this._ids = /* @__PURE__ */ new Map(), this._idPool = [], this.exited = !1, new DataView(this._inst.exports.memory.buffer); ; ) {
      const a = new Promise((u) => {
        this._resolveCallbackPromise = () => {
          if (this.exited)
            throw new Error("bad callback: Go program has already exited");
          setTimeout(u, 0);
        };
      });
      if (this._inst.exports._start(), this.exited)
        break;
      await a;
    }
  }
  _resume() {
    if (this.exited)
      throw new Error("Go program has already exited");
    this._inst.exports.resume(), this.exited && this._resolveExitPromise();
  }
  _makeFuncWrapper(n) {
    const a = this;
    return function() {
      const u = { id: n, this: this, args: arguments };
      return a._pendingEvent = u, a._resume(), u.result;
    };
  }
  _resolveExitPromise() {
  }
}
goWasmImports.Go = Go;
var smartweaveGlobal = {};
Object.defineProperty(smartweaveGlobal, "__esModule", { value: !0 }), smartweaveGlobal.SmartWeaveGlobal = void 0;
class SmartWeaveGlobal {
  constructor(n, a, u) {
    this.gasUsed = 0, this.gasLimit = Number.MAX_SAFE_INTEGER, this.unsafeClient = n, this.arweave = { ar: n.ar, utils: n.utils, wallets: n.wallets, crypto: n.crypto }, this.evaluationOptions = u, this.contract = a, this.transaction = new Transaction(this), this.block = new Block(this), this.contracts = { readContractState: (c, m, d) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, viewContractState: (c, m) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, write: (c, m, d) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, refreshState: () => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    } }, this.vrf = new Vrf(this), this.useGas = this.useGas.bind(this), this.getBalance = this.getBalance.bind(this);
  }
  useGas(n) {
    if (n < 0)
      throw new Error("[RE:GNE] Gas number exception - gas < 0.");
    if (this.gasUsed += n, this.gasUsed > this.gasLimit)
      throw new Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
  }
  async getBalance(n, a) {
    if (!this._activeTx)
      throw new Error("Cannot read balance - active tx is not set.");
    if (!this.block.height)
      throw new Error("Cannot read balance - block height not set.");
    const u = a || this.block.height;
    return await fetch(`${this.evaluationOptions.walletBalanceUrl}block/height/${u}/wallet/${n}/balance`).then((c) => c.ok ? c.text() : Promise.reject(c)).catch((c) => {
      var m;
      throw new Error(`Unable to read wallet balance. ${c.status}. ${(m = c.body) === null || m === void 0 ? void 0 : m.message}`);
    });
  }
}
smartweaveGlobal.SmartWeaveGlobal = SmartWeaveGlobal;
class Transaction {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get id() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.id;
  }
  get owner() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.owner.address;
  }
  get target() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.recipient;
  }
  get tags() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.tags;
  }
  get quantity() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.quantity.winston;
  }
  get reward() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.fee.winston;
  }
}
class Block {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get height() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.height;
  }
  get indep_hash() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.id;
  }
  get timestamp() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current tx");
    return this.smartWeaveGlobal._activeTx.block.timestamp;
  }
}
class Vrf {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get data() {
    return this.smartWeaveGlobal._activeTx.vrf;
  }
  get value() {
    return this.smartWeaveGlobal._activeTx.vrf.bigint;
  }
  randomInt(n) {
    if (!Number.isInteger(n))
      throw new Error("Integer max value required for random integer generation");
    const a = BigInt(this.smartWeaveGlobal._activeTx.vrf.bigint) % BigInt(n) + BigInt(1);
    if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER)
      throw new Error("Random int cannot be cast to number");
    return Number(a);
  }
}
var JsHandlerApi$1 = {}, AbstractContractHandler$1 = {}, Contract = {};
Object.defineProperty(Contract, "__esModule", { value: !0 }), Contract.ContractError = void 0;
class ContractError$1 extends Error {
  constructor(n) {
    super(n), this.name = "ContractError";
  }
}
Contract.ContractError = ContractError$1, Object.defineProperty(AbstractContractHandler$1, "__esModule", { value: !0 }), AbstractContractHandler$1.AbstractContractHandler = void 0;
const Contract_1 = Contract, LoggerFactory_1$5 = LoggerFactory$1, utils_1$3 = utils$n;
class AbstractContractHandler {
  constructor(n, a) {
    this.swGlobal = n, this.contractDefinition = a, this.logger = LoggerFactory_1$5.LoggerFactory.INST.create("ContractHandler"), this.assignReadContractState = this.assignReadContractState.bind(this), this.assignViewContractState = this.assignViewContractState.bind(this), this.assignWrite = this.assignWrite.bind(this), this.assignRefreshState = this.assignRefreshState.bind(this);
  }
  async dispose() {
  }
  assignWrite(n, a) {
    this.swGlobal.contracts.write = async (u, c, m) => {
      if (!n.evaluationOptions.internalWrites)
        throw new Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
      const d = m == null ? n.evaluationOptions.throwOnInternalWriteError : m, w = { from: this.contractDefinition.txId, to: u, input: c };
      this.logger.debug("swGlobal.write call:", w);
      const S = n.warp.contract(u, n.contract, { callingInteraction: this.swGlobal._activeTx, callType: "write" }), T = await S.dryWriteFromTx(c, this.swGlobal._activeTx, [...a || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      this.logger.debug("Cache result?:", !this.swGlobal._activeTx.dry);
      const B = T.type !== "ok" && d && (!this.swGlobal._activeTx.dry || this.swGlobal._activeTx.dry && this.swGlobal._activeTx.strict), I = B ? `Internal write auto error for call [${JSON.stringify(w)}]: ${T.errorMessage}` : T.errorMessage;
      if (await n.warp.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, u, { state: T.state, validity: { ...T.originalValidity, [this.swGlobal._activeTx.id]: T.type == "ok" }, errorMessages: { ...T.originalErrorMessages, [this.swGlobal._activeTx.id]: I } }), B)
        throw new Contract_1.ContractError(I);
      return T;
    };
  }
  assignViewContractState(n) {
    this.swGlobal.contracts.viewContractState = async (a, u) => (this.logger.debug("swGlobal.viewContractState call:", { from: this.contractDefinition.txId, to: a, input: u }), await n.warp.contract(a, n.contract, { callingInteraction: this.swGlobal._activeTx, callType: "view" }).viewStateForTx(u, this.swGlobal._activeTx));
  }
  assignReadContractState(n, a, u, c) {
    this.swGlobal.contracts.readContractState = async (m, d) => {
      this.logger.debug("swGlobal.readContractState call:", { from: this.contractDefinition.txId, to: m, sortKey: c.sortKey, transaction: this.swGlobal.transaction.id });
      const { stateEvaluator: w } = n.warp, S = n.warp.contract(m, n.contract, { callingInteraction: c, callType: "read" });
      await w.onContractCall(c, n, u);
      const T = await S.readState(c.sortKey, [...a || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      return d ? (0, utils_1$3.deepCopy)(T) : (0, utils_1$3.deepCopy)(T.cachedValue.state);
    };
  }
  assignRefreshState(n) {
    this.swGlobal.contracts.refreshState = async () => {
      const a = n.warp.stateEvaluator, u = await a.latestAvailableState(this.swGlobal.contract.id, this.swGlobal._activeTx.sortKey);
      return u == null ? void 0 : u.cachedValue.state;
    };
  }
}
AbstractContractHandler$1.AbstractContractHandler = AbstractContractHandler, Object.defineProperty(JsHandlerApi$1, "__esModule", { value: !0 }), JsHandlerApi$1.JsHandlerApi = void 0;
const utils_1$2 = utils$n, AbstractContractHandler_1$1 = AbstractContractHandler$1;
class JsHandlerApi extends AbstractContractHandler_1$1.AbstractContractHandler {
  constructor(n, a, u) {
    super(n, a), this.contractFunction = u;
  }
  async handle(n, a, u) {
    const { timeoutId: c, timeoutPromise: m } = (0, utils_1$2.timeout)(n.evaluationOptions.maxInteractionEvaluationTimeSeconds);
    try {
      const { interaction: d, interactionTx: w, currentTx: S } = u, T = (0, utils_1$2.deepCopy)(a.state, n.evaluationOptions.useFastCopy);
      this.swGlobal._activeTx = w, this.swGlobal.caller = d.caller, this.assignReadContractState(n, S, a, w), this.assignViewContractState(n), this.assignWrite(n, S), this.assignRefreshState(n);
      const B = await Promise.race([m, this.contractFunction(T, d)]);
      if (B && (B.state !== void 0 || B.result !== void 0))
        return { type: "ok", result: B.result, state: B.state || a.state };
      throw new Error(`Unexpected result from contract: ${JSON.stringify(B)}`);
    } catch (d) {
      return d.name === "ContractError" ? { type: "error", errorMessage: d.message, state: a.state, result: null } : { type: "exception", errorMessage: `${d && d.stack || d && d.message || d}`, state: a.state, result: null };
    } finally {
      c !== null && clearTimeout(c);
    }
  }
  initState(n) {
  }
}
JsHandlerApi$1.JsHandlerApi = JsHandlerApi;
var WasmHandlerApi$1 = {}, safeStableStringify = { exports: {} };
(function(o, n) {
  const a = z();
  a.configure = z, a.stringify = a, a.default = a, n.stringify = a, n.configure = z, o.exports = a;
  const u = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/, c = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g, m = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "\\t", "\\n", "\\u000b", "\\f", "\\r", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f", "", "", '\\"', "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\"];
  function d(W) {
    if (W.length === 2) {
      const ee = W.charCodeAt(1);
      return `${W[0]}\\u${ee.toString(16)}`;
    }
    const V = W.charCodeAt(0);
    return m.length > V ? m[V] : `\\u${V.toString(16)}`;
  }
  function w(W) {
    if (W.length < 5e3 && !u.test(W))
      return W;
    if (W.length > 100)
      return W.replace(c, d);
    let V = "", ee = 0;
    for (let P = 0; P < W.length; P++) {
      const F = W.charCodeAt(P);
      if (F === 34 || F === 92 || F < 32)
        V += `${W.slice(ee, P)}${m[F]}`, ee = P + 1;
      else if (F >= 55296 && F <= 57343) {
        if (F <= 56319 && P + 1 < W.length) {
          const H = W.charCodeAt(P + 1);
          if (H >= 56320 && H <= 57343) {
            P++;
            continue;
          }
        }
        V += `${W.slice(ee, P)}\\u${F.toString(16)}`, ee = P + 1;
      }
    }
    return V += W.slice(ee), V;
  }
  function S(W) {
    if (W.length > 200)
      return W.sort();
    for (let V = 1; V < W.length; V++) {
      const ee = W[V];
      let P = V;
      for (; P !== 0 && W[P - 1] > ee; )
        W[P] = W[P - 1], P--;
      W[P] = ee;
    }
    return W;
  }
  const T = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
  function B(W) {
    return T.call(W) !== void 0 && W.length !== 0;
  }
  function I(W, V, ee) {
    W.length < ee && (ee = W.length);
    const P = V === "," ? "" : " ";
    let F = `"0":${P}${W[0]}`;
    for (let H = 1; H < ee; H++)
      F += `${V}"${H}":${P}${W[H]}`;
    return F;
  }
  function C(W, V) {
    if (W && Object.prototype.hasOwnProperty.call(W, V)) {
      var ee = W[V];
      if (typeof ee != "boolean")
        throw new TypeError(`The "${V}" argument must be of type boolean`);
    }
    return ee === void 0 || ee;
  }
  function N(W, V) {
    if (W && Object.prototype.hasOwnProperty.call(W, V)) {
      var ee = W[V];
      if (typeof ee != "number")
        throw new TypeError(`The "${V}" argument must be of type number`);
      if (!Number.isInteger(ee))
        throw new TypeError(`The "${V}" argument must be an integer`);
      if (ee < 1)
        throw new RangeError(`The "${V}" argument must be >= 1`);
    }
    return ee === void 0 ? 1 / 0 : ee;
  }
  function q(W) {
    return W === 1 ? "1 item" : `${W} items`;
  }
  function D(W) {
    const V = /* @__PURE__ */ new Set();
    for (const ee of W)
      typeof ee == "string" ? V.add(ee) : typeof ee == "number" && V.add(String(ee));
    return V;
  }
  function z(W) {
    const V = function(y) {
      if (y && Object.prototype.hasOwnProperty.call(y, "circularValue")) {
        var g = y.circularValue;
        if (typeof g == "string")
          return `"${g}"`;
        if (g == null)
          return g;
        if (g === Error || g === TypeError)
          return { toString() {
            throw new TypeError("Converting circular structure to JSON");
          } };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }(W), ee = C(W, "bigint"), P = C(W, "deterministic"), F = N(W, "maximumDepth"), H = N(W, "maximumBreadth");
    function te(y, g, v, E, A, L) {
      let j = g[y];
      switch (typeof j == "object" && j !== null && typeof j.toJSON == "function" && (j = j.toJSON(y)), j = E.call(g, y, j), typeof j) {
        case "string":
          return `"${w(j)}"`;
        case "object": {
          if (j === null)
            return "null";
          if (v.indexOf(j) !== -1)
            return V;
          let J = "", X = ",";
          const re = L;
          if (Array.isArray(j)) {
            if (j.length === 0)
              return "[]";
            if (F < v.length + 1)
              return '"[Array]"';
            v.push(j), A !== "" && (J += `
${L += A}`, X = `,
${L}`);
            const ce = Math.min(j.length, H);
            let Se = 0;
            for (; Se < ce - 1; Se++) {
              const $e = te(Se, j, v, E, A, L);
              J += $e !== void 0 ? $e : "null", J += X;
            }
            const he = te(Se, j, v, E, A, L);
            return J += he !== void 0 ? he : "null", j.length - 1 > H && (J += `${X}"... ${q(j.length - H - 1)} not stringified"`), A !== "" && (J += `
${re}`), v.pop(), `[${J}]`;
          }
          let Z = Object.keys(j);
          const ie = Z.length;
          if (ie === 0)
            return "{}";
          if (F < v.length + 1)
            return '"[Object]"';
          let oe = "", ue = "";
          A !== "" && (X = `,
${L += A}`, oe = " ");
          let se = Math.min(ie, H);
          B(j) && (J += I(j, X, H), Z = Z.slice(j.length), se -= j.length, ue = X), P && (Z = S(Z)), v.push(j);
          for (let ce = 0; ce < se; ce++) {
            const Se = Z[ce], he = te(Se, j, v, E, A, L);
            he !== void 0 && (J += `${ue}"${w(Se)}":${oe}${he}`, ue = X);
          }
          return ie > H && (J += `${ue}"...":${oe}"${q(ie - H)} not stringified"`, ue = X), A !== "" && ue.length > 1 && (J = `
${L}${J}
${re}`), v.pop(), `{${J}}`;
        }
        case "number":
          return isFinite(j) ? String(j) : "null";
        case "boolean":
          return j === !0 ? "true" : "false";
        case "bigint":
          return ee ? String(j) : void 0;
      }
    }
    function p(y, g, v, E, A, L) {
      switch (typeof g == "object" && g !== null && typeof g.toJSON == "function" && (g = g.toJSON(y)), typeof g) {
        case "string":
          return `"${w(g)}"`;
        case "object": {
          if (g === null)
            return "null";
          if (v.indexOf(g) !== -1)
            return V;
          const j = L;
          let J = "", X = ",";
          if (Array.isArray(g)) {
            if (g.length === 0)
              return "[]";
            if (F < v.length + 1)
              return '"[Array]"';
            v.push(g), A !== "" && (J += `
${L += A}`, X = `,
${L}`);
            const ie = Math.min(g.length, H);
            let oe = 0;
            for (; oe < ie - 1; oe++) {
              const se = p(oe, g[oe], v, E, A, L);
              J += se !== void 0 ? se : "null", J += X;
            }
            const ue = p(oe, g[oe], v, E, A, L);
            return J += ue !== void 0 ? ue : "null", g.length - 1 > H && (J += `${X}"... ${q(g.length - H - 1)} not stringified"`), A !== "" && (J += `
${j}`), v.pop(), `[${J}]`;
          }
          if (E.size === 0)
            return "{}";
          v.push(g);
          let re = "";
          A !== "" && (X = `,
${L += A}`, re = " ");
          let Z = "";
          for (const ie of E) {
            const oe = p(ie, g[ie], v, E, A, L);
            oe !== void 0 && (J += `${Z}"${w(ie)}":${re}${oe}`, Z = X);
          }
          return A !== "" && Z.length > 1 && (J = `
${L}${J}
${j}`), v.pop(), `{${J}}`;
        }
        case "number":
          return isFinite(g) ? String(g) : "null";
        case "boolean":
          return g === !0 ? "true" : "false";
        case "bigint":
          return ee ? String(g) : void 0;
      }
    }
    function $(y, g, v, E, A) {
      switch (typeof g) {
        case "string":
          return `"${w(g)}"`;
        case "object": {
          if (g === null)
            return "null";
          if (typeof g.toJSON == "function") {
            if (typeof (g = g.toJSON(y)) != "object")
              return $(y, g, v, E, A);
            if (g === null)
              return "null";
          }
          if (v.indexOf(g) !== -1)
            return V;
          const L = A;
          if (Array.isArray(g)) {
            if (g.length === 0)
              return "[]";
            if (F < v.length + 1)
              return '"[Array]"';
            v.push(g);
            let oe = `
${A += E}`;
            const ue = `,
${A}`, se = Math.min(g.length, H);
            let ce = 0;
            for (; ce < se - 1; ce++) {
              const he = $(ce, g[ce], v, E, A);
              oe += he !== void 0 ? he : "null", oe += ue;
            }
            const Se = $(ce, g[ce], v, E, A);
            return oe += Se !== void 0 ? Se : "null", g.length - 1 > H && (oe += `${ue}"... ${q(g.length - H - 1)} not stringified"`), oe += `
${L}`, v.pop(), `[${oe}]`;
          }
          let j = Object.keys(g);
          const J = j.length;
          if (J === 0)
            return "{}";
          if (F < v.length + 1)
            return '"[Object]"';
          const X = `,
${A += E}`;
          let re = "", Z = "", ie = Math.min(J, H);
          B(g) && (re += I(g, X, H), j = j.slice(g.length), ie -= g.length, Z = X), P && (j = S(j)), v.push(g);
          for (let oe = 0; oe < ie; oe++) {
            const ue = j[oe], se = $(ue, g[ue], v, E, A);
            se !== void 0 && (re += `${Z}"${w(ue)}": ${se}`, Z = X);
          }
          return J > H && (re += `${Z}"...": "${q(J - H)} not stringified"`, Z = X), Z !== "" && (re = `
${A}${re}
${L}`), v.pop(), `{${re}}`;
        }
        case "number":
          return isFinite(g) ? String(g) : "null";
        case "boolean":
          return g === !0 ? "true" : "false";
        case "bigint":
          return ee ? String(g) : void 0;
      }
    }
    function _(y, g, v) {
      switch (typeof g) {
        case "string":
          return `"${w(g)}"`;
        case "object": {
          if (g === null)
            return "null";
          if (typeof g.toJSON == "function") {
            if (typeof (g = g.toJSON(y)) != "object")
              return _(y, g, v);
            if (g === null)
              return "null";
          }
          if (v.indexOf(g) !== -1)
            return V;
          let E = "";
          if (Array.isArray(g)) {
            if (g.length === 0)
              return "[]";
            if (F < v.length + 1)
              return '"[Array]"';
            v.push(g);
            const X = Math.min(g.length, H);
            let re = 0;
            for (; re < X - 1; re++) {
              const ie = _(re, g[re], v);
              E += ie !== void 0 ? ie : "null", E += ",";
            }
            const Z = _(re, g[re], v);
            return E += Z !== void 0 ? Z : "null", g.length - 1 > H && (E += `,"... ${q(g.length - H - 1)} not stringified"`), v.pop(), `[${E}]`;
          }
          let A = Object.keys(g);
          const L = A.length;
          if (L === 0)
            return "{}";
          if (F < v.length + 1)
            return '"[Object]"';
          let j = "", J = Math.min(L, H);
          B(g) && (E += I(g, ",", H), A = A.slice(g.length), J -= g.length, j = ","), P && (A = S(A)), v.push(g);
          for (let X = 0; X < J; X++) {
            const re = A[X], Z = _(re, g[re], v);
            Z !== void 0 && (E += `${j}"${w(re)}":${Z}`, j = ",");
          }
          return L > H && (E += `${j}"...":"${q(L - H)} not stringified"`), v.pop(), `{${E}}`;
        }
        case "number":
          return isFinite(g) ? String(g) : "null";
        case "boolean":
          return g === !0 ? "true" : "false";
        case "bigint":
          return ee ? String(g) : void 0;
      }
    }
    return function(y, g, v) {
      if (arguments.length > 1) {
        let E = "";
        if (typeof v == "number" ? E = " ".repeat(Math.min(v, 10)) : typeof v == "string" && (E = v.slice(0, 10)), g != null) {
          if (typeof g == "function")
            return te("", { "": y }, [], g, E, "");
          if (Array.isArray(g))
            return p("", y, [], D(g), E, "");
        }
        if (E.length !== 0)
          return $("", y, [], E, "");
      }
      return _("", y, []);
    };
  }
})(safeStableStringify, safeStableStringify.exports);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(WasmHandlerApi$1, "__esModule", { value: !0 }), WasmHandlerApi$1.WasmHandlerApi = void 0;
const safe_stable_stringify_1 = __importDefault$4(safeStableStringify.exports), AbstractContractHandler_1 = AbstractContractHandler$1;
class WasmHandlerApi extends AbstractContractHandler_1.AbstractContractHandler {
  constructor(n, a, u) {
    super(n, a), this.wasmExports = u;
  }
  async handle(n, a, u) {
    try {
      const { interaction: c, interactionTx: m, currentTx: d } = u;
      return this.swGlobal._activeTx = m, this.swGlobal.caller = c.caller, this.swGlobal.gasLimit = n.evaluationOptions.gasLimit, this.swGlobal.gasUsed = 0, this.assignReadContractState(n, d, a, m), this.assignWrite(n, d), { type: "ok", result: await this.doHandle(c), state: this.doGetCurrentState(), gasUsed: this.swGlobal.gasUsed };
    } catch (c) {
      const m = { errorMessage: c.message, state: a.state, result: null };
      return c.message.startsWith("[RE:") ? (this.logger.fatal(c), { ...m, type: "exception" }) : { ...m, type: "error" };
    }
  }
  initState(n) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const a = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(n));
        this.wasmExports.initState(a);
        break;
      }
      case "rust":
        this.wasmExports.initState(n);
        break;
      case "go":
        this.wasmExports.initState((0, safe_stable_stringify_1.default)(n));
        break;
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  async doHandle(n) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const a = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(n.input)), u = this.wasmExports.handle(a), c = this.wasmExports.__getString(u);
        return JSON.parse(c);
      }
      case "rust": {
        let a = await this.wasmExports.handle(n.input);
        if (!a)
          return;
        if (Object.prototype.hasOwnProperty.call(a, "Ok"))
          return a.Ok;
        {
          let u;
          this.logger.debug("Error from rust", a.Err);
          let c = "";
          throw typeof a.Err == "string" || a.Err instanceof String ? u = a.Err : (u = Object.keys(a.Err)[0], c = " " + a.Err[u]), u == "RuntimeError" ? new Error(`[RE:RE]${c}`) : new Error(`[CE:${u}${c}]`);
        }
      }
      case "go": {
        const a = await this.wasmExports.handle((0, safe_stable_stringify_1.default)(n.input));
        return JSON.parse(a);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  doGetCurrentState() {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const n = this.wasmExports.currentState();
        return JSON.parse(this.wasmExports.__getString(n));
      }
      case "rust":
        return this.wasmExports.currentState();
      case "go": {
        const n = this.wasmExports.currentState();
        return JSON.parse(n);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
}
WasmHandlerApi$1.WasmHandlerApi = WasmHandlerApi;
var normalizeSource = {};
function normalizeContractSource(o, n) {
  const a = o.trim().split(`
`), u = a[0], c = a[a.length - 1];
  return (/\(\s*\(\)\s*=>\s*{/g.test(u) || /\s*\(\s*function\s*\(\)\s*{/g.test(u)) && /}\s*\)\s*\(\)\s*;/g.test(c) && (a.shift(), a.pop(), o = a.join(`
`)), o = o.replace(/export\s+async\s+function\s+handle/gmu, "async function handle").replace(/export\s+function\s+handle/gmu, "function handle"), n ? `
    ${o}
    module.exports = handle;` : `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${o};
    return handle;
  `;
}
Object.defineProperty(normalizeSource, "__esModule", { value: !0 }), normalizeSource.normalizeContractSource = void 0, normalizeSource.normalizeContractSource = normalizeContractSource;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(n, a);
  c && !("get" in c ? !n.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(o, u, c);
} : function(o, n, a, u) {
  u === void 0 && (u = a), o[u] = n[a];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var a in o)
      a !== "default" && Object.prototype.hasOwnProperty.call(o, a) && __createBinding(n, o, a);
  return __setModuleDefault(n, o), n;
}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(HandlerExecutorFactory$1, "__esModule", { value: !0 }), HandlerExecutorFactory$1.HandlerExecutorFactory = void 0;
const loader_1 = __importDefault$3(umd.exports), as_wasm_imports_1 = asWasmImports$1, rust_wasm_imports_1 = rustWasmImports$1, go_wasm_imports_1$1 = goWasmImports, bignumber_js_1 = __importDefault$3(bignumber.exports), vm2 = __importStar(require$$2$1), smartweave_global_1 = smartweaveGlobal, Benchmark_1 = Benchmark$1, LoggerFactory_1$4 = LoggerFactory$1, JsHandlerApi_1 = JsHandlerApi$1, WasmHandlerApi_1 = WasmHandlerApi$1, normalize_source_1 = normalizeSource, MemCache_1 = MemCache$1;
class ContractError extends Error {
  constructor(n) {
    super(n), this.name = "ContractError";
  }
}
class HandlerExecutorFactory {
  constructor(n) {
    this.arweave = n, this.logger = LoggerFactory_1$4.LoggerFactory.INST.create("HandlerExecutorFactory"), this.cache = new MemCache_1.MemCache();
  }
  async create(n, a) {
    const u = new smartweave_global_1.SmartWeaveGlobal(this.arweave, { id: n.txId, owner: n.owner }, a);
    if (n.contractType == "wasm") {
      this.logger.info("Creating handler for wasm contract", n.txId);
      const c = Benchmark_1.Benchmark.measure();
      let m, d = null;
      const w = generateResponse(n.srcBinary);
      switch (n.srcWasmLang) {
        case "assemblyscript": {
          const S = { exports: null };
          m = await loader_1.default.instantiateStreaming(w, (0, as_wasm_imports_1.asWasmImports)(u, S)), S.exports = m.exports;
          break;
        }
        case "rust": {
          const S = { exports: null, modifiedExports: { wasm_bindgen__convert__closures__invoke2_mut__: null, _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null } }, T = await getWasmModule(w, n.srcBinary), B = WebAssembly.Module.imports(T).filter((N) => N.module === "__wbindgen_placeholder__").map((N) => N.name), { imports: I, exports: C } = (0, rust_wasm_imports_1.rustWasmImports)(u, B, S, n.metadata.dtor);
          d = C, m = await WebAssembly.instantiate(T, I), S.exports = m.exports, Object.keys(m.exports).forEach((N) => {
            N.startsWith("wasm_bindgen__convert__closures__invoke2_mut__") && (S.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = m.exports[N]), N.startsWith("_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__") && (S.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = m.exports[N]);
          });
          break;
        }
        case "go": {
          const S = new go_wasm_imports_1$1.Go(u);
          S.importObject.metering = { usegas: function(B) {
            u.useGas(B);
          } };
          const T = await getWasmModule(w, n.srcBinary);
          m = await WebAssembly.instantiate(T, S.importObject), S.run(m), d = S.exports;
          break;
        }
        default:
          throw new Error(`Support for ${n.srcWasmLang} not implemented yet.`);
      }
      return this.logger.info(`WASM ${n.srcWasmLang} handler created in ${c.elapsed()}`), new WasmHandlerApi_1.WasmHandlerApi(u, n, d || m.exports);
    }
    {
      this.logger.info("Creating handler for js contract", n.txId);
      const c = (0, normalize_source_1.normalizeContractSource)(n.src, a.useVM2);
      if (!a.allowUnsafeClient && c.includes("SmartWeave.unsafeClient"))
        throw new Error("Using unsafeClient is not allowed by default. Use EvaluationOptions.allowUnsafeClient flag.");
      if (!a.allowBigInt && c.includes("BigInt"))
        throw new Error("Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.");
      if (a.useVM2) {
        const m = new vm2.VMScript(c), d = new vm2.NodeVM({ console: "off", sandbox: { SmartWeave: u, BigNumber: bignumber_js_1.default, logger: this.logger, ContractError, ContractAssert: function(w, S) {
          if (!w)
            throw new ContractError(S);
        } }, compiler: "javascript", eval: !1, wasm: !1, allowAsync: !0, wrapper: "commonjs" });
        return new JsHandlerApi_1.JsHandlerApi(u, n, d.run(m));
      }
      {
        const m = new Function(c)(u, bignumber_js_1.default, LoggerFactory_1$4.LoggerFactory.INST.create(u.contract.id));
        return new JsHandlerApi_1.JsHandlerApi(u, n, m);
      }
    }
  }
}
function generateResponse(o) {
  return new Response(o, { status: 200, statusText: "OK", headers: { "Content-Type": "application/wasm" } });
}
async function getWasmModule(o, n) {
  return WebAssembly.compileStreaming ? await WebAssembly.compileStreaming(o) : await WebAssembly.compile(n);
}
HandlerExecutorFactory$1.HandlerExecutorFactory = HandlerExecutorFactory;
var Warp = {}, DefaultCreateContract = {}, SourceImpl$1 = {}, redstoneWasmMetering = {}, redstoneWasmJsonToolkit = {}, wasm2json$1 = { exports: {} }, leb128$1 = {}, bn = { exports: {} };
(function(o, n) {
  function a(p, $) {
    if (!p)
      throw new Error($ || "Assertion failed");
  }
  function u(p, $) {
    p.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, p.prototype = new _(), p.prototype.constructor = p;
  }
  function c(p, $, _) {
    if (c.isBN(p))
      return p;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(p || 0, $ || 10, _ || "be"));
  }
  var m;
  typeof bn == "object" ? bn.exports = c : n.BN = c, c.BN = c, c.wordSize = 26;
  try {
    m = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(p, $) {
    var _ = p.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(p, $, _) {
    var y = d(p, _);
    return _ - 1 >= $ && (y |= d(p, _ - 1) << 4), y;
  }
  function S(p, $, _, y) {
    for (var g = 0, v = Math.min(p.length, _), E = $; E < v; E++) {
      var A = p.charCodeAt(E) - 48;
      g *= y, g += A >= 49 ? A - 49 + 10 : A >= 17 ? A - 17 + 10 : A;
    }
    return g;
  }
  c.isBN = function(p) {
    return p instanceof c || p !== null && typeof p == "object" && p.constructor.wordSize === c.wordSize && Array.isArray(p.words);
  }, c.max = function(p, $) {
    return p.cmp($) > 0 ? p : $;
  }, c.min = function(p, $) {
    return p.cmp($) < 0 ? p : $;
  }, c.prototype._init = function(p, $, _) {
    if (typeof p == "number")
      return this._initNumber(p, $, _);
    if (typeof p == "object")
      return this._initArray(p, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var y = 0;
    (p = p.toString().replace(/\s+/g, ""))[0] === "-" && (y++, this.negative = 1), y < p.length && ($ === 16 ? this._parseHex(p, y, _) : (this._parseBase(p, $, y), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(p, $, _) {
    p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [67108863 & p], this.length = 1) : p < 4503599627370496 ? (this.words = [67108863 & p, p / 67108864 & 67108863], this.length = 2) : (a(p < 9007199254740992), this.words = [67108863 & p, p / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(p, $, _) {
    if (a(typeof p.length == "number"), p.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v, E = 0;
    if (_ === "be")
      for (y = p.length - 1, g = 0; y >= 0; y -= 3)
        v = p[y] | p[y - 1] << 8 | p[y - 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    else if (_ === "le")
      for (y = 0, g = 0; y < p.length; y += 3)
        v = p[y] | p[y + 1] << 8 | p[y + 2] << 16, this.words[g] |= v << E & 67108863, this.words[g + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, g++);
    return this.strip();
  }, c.prototype._parseHex = function(p, $, _) {
    this.length = Math.ceil((p.length - $) / 6), this.words = new Array(this.length);
    for (var y = 0; y < this.length; y++)
      this.words[y] = 0;
    var g, v = 0, E = 0;
    if (_ === "be")
      for (y = p.length - 1; y >= $; y -= 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    else
      for (y = (p.length - $) % 2 == 0 ? $ + 1 : $; y < p.length; y += 2)
        g = w(p, $, y) << v, this.words[E] |= 67108863 & g, v >= 18 ? (v -= 18, E += 1, this.words[E] |= g >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(p, $, _) {
    this.words = [0], this.length = 1;
    for (var y = 0, g = 1; g <= 67108863; g *= $)
      y++;
    y--, g = g / $ | 0;
    for (var v = p.length - _, E = v % y, A = Math.min(v, v - E) + _, L = 0, j = _; j < A; j += y)
      L = S(p, j, j + y, $), this.imuln(g), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    if (E !== 0) {
      var J = 1;
      for (L = S(p, j, p.length, $), j = 0; j < E; j++)
        J *= $;
      this.imuln(J), this.words[0] + L < 67108864 ? this.words[0] += L : this._iaddn(L);
    }
    this.strip();
  }, c.prototype.copy = function(p) {
    p.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      p.words[$] = this.words[$];
    p.length = this.length, p.negative = this.negative, p.red = this.red;
  }, c.prototype.clone = function() {
    var p = new c(null);
    return this.copy(p), p;
  }, c.prototype._expand = function(p) {
    for (; this.length < p; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var T = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(p, $, _) {
    _.negative = $.negative ^ p.negative;
    var y = p.length + $.length | 0;
    _.length = y, y = y - 1 | 0;
    var g = 0 | p.words[0], v = 0 | $.words[0], E = g * v, A = 67108863 & E, L = E / 67108864 | 0;
    _.words[0] = A;
    for (var j = 1; j < y; j++) {
      for (var J = L >>> 26, X = 67108863 & L, re = Math.min(j, $.length - 1), Z = Math.max(0, j - p.length + 1); Z <= re; Z++) {
        var ie = j - Z | 0;
        J += (E = (g = 0 | p.words[ie]) * (v = 0 | $.words[Z]) + X) / 67108864 | 0, X = 67108863 & E;
      }
      _.words[j] = 0 | X, L = 0 | J;
    }
    return L !== 0 ? _.words[j] = 0 | L : _.length--, _.strip();
  }
  c.prototype.toString = function(p, $) {
    var _;
    if ($ = 0 | $ || 1, (p = p || 10) === 16 || p === "hex") {
      _ = "";
      for (var y = 0, g = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], A = (16777215 & (E << y | g)).toString(16);
        _ = (g = E >>> 24 - y & 16777215) != 0 || v !== this.length - 1 ? T[6 - A.length] + A + _ : A + _, (y += 2) >= 26 && (y -= 26, v--);
      }
      for (g !== 0 && (_ = g.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (p === (0 | p) && p >= 2 && p <= 36) {
      var L = B[p], j = I[p];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var X = J.modn(j).toString(p);
        _ = (J = J.idivn(j)).isZero() ? X + _ : T[L - X.length] + X + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var p = this.words[0];
    return this.length === 2 ? p += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(p, $) {
    return a(m !== void 0), this.toArrayLike(m, p, $);
  }, c.prototype.toArray = function(p, $) {
    return this.toArrayLike(Array, p, $);
  }, c.prototype.toArrayLike = function(p, $, _) {
    var y = this.byteLength(), g = _ || Math.max(1, y);
    a(y <= g, "byte array longer than desired length"), a(g > 0, "Requested array length <= 0"), this.strip();
    var v, E, A = $ === "le", L = new p(g), j = this.clone();
    if (A) {
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[E] = v;
      for (; E < g; E++)
        L[E] = 0;
    } else {
      for (E = 0; E < g - y; E++)
        L[E] = 0;
      for (E = 0; !j.isZero(); E++)
        v = j.andln(255), j.iushrn(8), L[g - E - 1] = v;
    }
    return L;
  }, Math.clz32 ? c.prototype._countBits = function(p) {
    return 32 - Math.clz32(p);
  } : c.prototype._countBits = function(p) {
    var $ = p, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(p) {
    if (p === 0)
      return 26;
    var $ = p, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var p = this.words[this.length - 1], $ = this._countBits(p);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var p = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (p += _, _ !== 26)
        break;
    }
    return p;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(p) {
    return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(p) {
    return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(p) {
    for (; this.length < p.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < p.length; $++)
      this.words[$] = this.words[$] | p.words[$];
    return this.strip();
  }, c.prototype.ior = function(p) {
    return a((this.negative | p.negative) == 0), this.iuor(p);
  }, c.prototype.or = function(p) {
    return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
  }, c.prototype.uor = function(p) {
    return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
  }, c.prototype.iuand = function(p) {
    var $;
    $ = this.length > p.length ? p : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & p.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(p) {
    return a((this.negative | p.negative) == 0), this.iuand(p);
  }, c.prototype.and = function(p) {
    return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
  }, c.prototype.uand = function(p) {
    return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
  }, c.prototype.iuxor = function(p) {
    var $, _;
    this.length > p.length ? ($ = this, _ = p) : ($ = p, _ = this);
    for (var y = 0; y < _.length; y++)
      this.words[y] = $.words[y] ^ _.words[y];
    if (this !== $)
      for (; y < $.length; y++)
        this.words[y] = $.words[y];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(p) {
    return a((this.negative | p.negative) == 0), this.iuxor(p);
  }, c.prototype.xor = function(p) {
    return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
  }, c.prototype.uxor = function(p) {
    return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
  }, c.prototype.inotn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = 0 | Math.ceil(p / 26), _ = p % 26;
    this._expand($), _ > 0 && $--;
    for (var y = 0; y < $; y++)
      this.words[y] = 67108863 & ~this.words[y];
    return _ > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(p) {
    return this.clone().inotn(p);
  }, c.prototype.setn = function(p, $) {
    a(typeof p == "number" && p >= 0);
    var _ = p / 26 | 0, y = p % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << y : this.words[_] & ~(1 << y), this.strip();
  }, c.prototype.iadd = function(p) {
    var $, _, y;
    if (this.negative !== 0 && p.negative === 0)
      return this.negative = 0, $ = this.isub(p), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && p.negative !== 0)
      return p.negative = 0, $ = this.isub(p), p.negative = 1, $._normSign();
    this.length > p.length ? (_ = this, y = p) : (_ = p, y = this);
    for (var g = 0, v = 0; v < y.length; v++)
      $ = (0 | _.words[v]) + (0 | y.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    for (; g !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + g, this.words[v] = 67108863 & $, g = $ >>> 26;
    if (this.length = _.length, g !== 0)
      this.words[this.length] = g, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(p) {
    var $;
    return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, $ = this.sub(p), p.negative ^= 1, $) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = p.sub(this), this.negative = 1, $) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
  }, c.prototype.isub = function(p) {
    if (p.negative !== 0) {
      p.negative = 0;
      var $ = this.iadd(p);
      return p.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
    var _, y, g = this.cmp(p);
    if (g === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    g > 0 ? (_ = this, y = p) : (_ = p, y = this);
    for (var v = 0, E = 0; E < y.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | y.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(p) {
    return this.clone().isub(p);
  };
  var N = function(p, $, _) {
    var y, g, v, E = p.words, A = $.words, L = _.words, j = 0, J = 0 | E[0], X = 8191 & J, re = J >>> 13, Z = 0 | E[1], ie = 8191 & Z, oe = Z >>> 13, ue = 0 | E[2], se = 8191 & ue, ce = ue >>> 13, Se = 0 | E[3], he = 8191 & Se, $e = Se >>> 13, fe = 0 | E[4], le = 8191 & fe, we = fe >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, b = l >>> 13, M = 0 | E[7], k = 8191 & M, x = M >>> 13, O = 0 | E[8], G = 8191 & O, Q = O >>> 13, ne = 0 | E[9], Y = 8191 & ne, ae = ne >>> 13, Ee = 0 | A[0], pe = 8191 & Ee, ye = Ee >>> 13, Le = 0 | A[1], ge = 8191 & Le, be = Le >>> 13, Re = 0 | A[2], me = 8191 & Re, Ae = Re >>> 13, He = 0 | A[3], ve = 8191 & He, Me = He >>> 13, Fe = 0 | A[4], _e = 8191 & Fe, Oe = Fe >>> 13, qe = 0 | A[5], Te = 8191 & qe, Pe = qe >>> 13, ze = 0 | A[6], xe = 8191 & ze, Ne = ze >>> 13, Ve = 0 | A[7], Be = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | A[8], Ie = 8191 & Je, je = Je >>> 13, Xe = 0 | A[9], Ce = 8191 & Xe, De = Xe >>> 13;
    _.negative = p.negative ^ $.negative, _.length = 19;
    var Ge = (j + (y = Math.imul(X, pe)) | 0) + ((8191 & (g = (g = Math.imul(X, ye)) + Math.imul(re, pe) | 0)) << 13) | 0;
    j = ((v = Math.imul(re, ye)) + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, y = Math.imul(ie, pe), g = (g = Math.imul(ie, ye)) + Math.imul(oe, pe) | 0, v = Math.imul(oe, ye);
    var Ke = (j + (y = y + Math.imul(X, ge) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, be) | 0) + Math.imul(re, ge) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, be) | 0) + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, y = Math.imul(se, pe), g = (g = Math.imul(se, ye)) + Math.imul(ce, pe) | 0, v = Math.imul(ce, ye), y = y + Math.imul(ie, ge) | 0, g = (g = g + Math.imul(ie, be) | 0) + Math.imul(oe, ge) | 0, v = v + Math.imul(oe, be) | 0;
    var Ye = (j + (y = y + Math.imul(X, me) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ae) | 0) + Math.imul(re, me) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ae) | 0) + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, y = Math.imul(he, pe), g = (g = Math.imul(he, ye)) + Math.imul($e, pe) | 0, v = Math.imul($e, ye), y = y + Math.imul(se, ge) | 0, g = (g = g + Math.imul(se, be) | 0) + Math.imul(ce, ge) | 0, v = v + Math.imul(ce, be) | 0, y = y + Math.imul(ie, me) | 0, g = (g = g + Math.imul(ie, Ae) | 0) + Math.imul(oe, me) | 0, v = v + Math.imul(oe, Ae) | 0;
    var Ze = (j + (y = y + Math.imul(X, ve) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Me) | 0) + Math.imul(re, ve) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Me) | 0) + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, y = Math.imul(le, pe), g = (g = Math.imul(le, ye)) + Math.imul(we, pe) | 0, v = Math.imul(we, ye), y = y + Math.imul(he, ge) | 0, g = (g = g + Math.imul(he, be) | 0) + Math.imul($e, ge) | 0, v = v + Math.imul($e, be) | 0, y = y + Math.imul(se, me) | 0, g = (g = g + Math.imul(se, Ae) | 0) + Math.imul(ce, me) | 0, v = v + Math.imul(ce, Ae) | 0, y = y + Math.imul(ie, ve) | 0, g = (g = g + Math.imul(ie, Me) | 0) + Math.imul(oe, ve) | 0, v = v + Math.imul(oe, Me) | 0;
    var Qe = (j + (y = y + Math.imul(X, _e) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Oe) | 0) + Math.imul(re, _e) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Oe) | 0) + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, y = Math.imul(de, pe), g = (g = Math.imul(de, ye)) + Math.imul(ke, pe) | 0, v = Math.imul(ke, ye), y = y + Math.imul(le, ge) | 0, g = (g = g + Math.imul(le, be) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, be) | 0, y = y + Math.imul(he, me) | 0, g = (g = g + Math.imul(he, Ae) | 0) + Math.imul($e, me) | 0, v = v + Math.imul($e, Ae) | 0, y = y + Math.imul(se, ve) | 0, g = (g = g + Math.imul(se, Me) | 0) + Math.imul(ce, ve) | 0, v = v + Math.imul(ce, Me) | 0, y = y + Math.imul(ie, _e) | 0, g = (g = g + Math.imul(ie, Oe) | 0) + Math.imul(oe, _e) | 0, v = v + Math.imul(oe, Oe) | 0;
    var et = (j + (y = y + Math.imul(X, Te) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Pe) | 0) + Math.imul(re, Te) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Pe) | 0) + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, y = Math.imul(h, pe), g = (g = Math.imul(h, ye)) + Math.imul(b, pe) | 0, v = Math.imul(b, ye), y = y + Math.imul(de, ge) | 0, g = (g = g + Math.imul(de, be) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, be) | 0, y = y + Math.imul(le, me) | 0, g = (g = g + Math.imul(le, Ae) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ae) | 0, y = y + Math.imul(he, ve) | 0, g = (g = g + Math.imul(he, Me) | 0) + Math.imul($e, ve) | 0, v = v + Math.imul($e, Me) | 0, y = y + Math.imul(se, _e) | 0, g = (g = g + Math.imul(se, Oe) | 0) + Math.imul(ce, _e) | 0, v = v + Math.imul(ce, Oe) | 0, y = y + Math.imul(ie, Te) | 0, g = (g = g + Math.imul(ie, Pe) | 0) + Math.imul(oe, Te) | 0, v = v + Math.imul(oe, Pe) | 0;
    var tt = (j + (y = y + Math.imul(X, xe) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ne) | 0) + Math.imul(re, xe) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ne) | 0) + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, y = Math.imul(k, pe), g = (g = Math.imul(k, ye)) + Math.imul(x, pe) | 0, v = Math.imul(x, ye), y = y + Math.imul(h, ge) | 0, g = (g = g + Math.imul(h, be) | 0) + Math.imul(b, ge) | 0, v = v + Math.imul(b, be) | 0, y = y + Math.imul(de, me) | 0, g = (g = g + Math.imul(de, Ae) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ae) | 0, y = y + Math.imul(le, ve) | 0, g = (g = g + Math.imul(le, Me) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Me) | 0, y = y + Math.imul(he, _e) | 0, g = (g = g + Math.imul(he, Oe) | 0) + Math.imul($e, _e) | 0, v = v + Math.imul($e, Oe) | 0, y = y + Math.imul(se, Te) | 0, g = (g = g + Math.imul(se, Pe) | 0) + Math.imul(ce, Te) | 0, v = v + Math.imul(ce, Pe) | 0, y = y + Math.imul(ie, xe) | 0, g = (g = g + Math.imul(ie, Ne) | 0) + Math.imul(oe, xe) | 0, v = v + Math.imul(oe, Ne) | 0;
    var rt = (j + (y = y + Math.imul(X, Be) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, Ue) | 0) + Math.imul(re, Be) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, Ue) | 0) + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, y = Math.imul(G, pe), g = (g = Math.imul(G, ye)) + Math.imul(Q, pe) | 0, v = Math.imul(Q, ye), y = y + Math.imul(k, ge) | 0, g = (g = g + Math.imul(k, be) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, be) | 0, y = y + Math.imul(h, me) | 0, g = (g = g + Math.imul(h, Ae) | 0) + Math.imul(b, me) | 0, v = v + Math.imul(b, Ae) | 0, y = y + Math.imul(de, ve) | 0, g = (g = g + Math.imul(de, Me) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Me) | 0, y = y + Math.imul(le, _e) | 0, g = (g = g + Math.imul(le, Oe) | 0) + Math.imul(we, _e) | 0, v = v + Math.imul(we, Oe) | 0, y = y + Math.imul(he, Te) | 0, g = (g = g + Math.imul(he, Pe) | 0) + Math.imul($e, Te) | 0, v = v + Math.imul($e, Pe) | 0, y = y + Math.imul(se, xe) | 0, g = (g = g + Math.imul(se, Ne) | 0) + Math.imul(ce, xe) | 0, v = v + Math.imul(ce, Ne) | 0, y = y + Math.imul(ie, Be) | 0, g = (g = g + Math.imul(ie, Ue) | 0) + Math.imul(oe, Be) | 0, v = v + Math.imul(oe, Ue) | 0;
    var nt = (j + (y = y + Math.imul(X, Ie) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, je) | 0) + Math.imul(re, Ie) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, je) | 0) + (g >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, y = Math.imul(Y, pe), g = (g = Math.imul(Y, ye)) + Math.imul(ae, pe) | 0, v = Math.imul(ae, ye), y = y + Math.imul(G, ge) | 0, g = (g = g + Math.imul(G, be) | 0) + Math.imul(Q, ge) | 0, v = v + Math.imul(Q, be) | 0, y = y + Math.imul(k, me) | 0, g = (g = g + Math.imul(k, Ae) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ae) | 0, y = y + Math.imul(h, ve) | 0, g = (g = g + Math.imul(h, Me) | 0) + Math.imul(b, ve) | 0, v = v + Math.imul(b, Me) | 0, y = y + Math.imul(de, _e) | 0, g = (g = g + Math.imul(de, Oe) | 0) + Math.imul(ke, _e) | 0, v = v + Math.imul(ke, Oe) | 0, y = y + Math.imul(le, Te) | 0, g = (g = g + Math.imul(le, Pe) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Pe) | 0, y = y + Math.imul(he, xe) | 0, g = (g = g + Math.imul(he, Ne) | 0) + Math.imul($e, xe) | 0, v = v + Math.imul($e, Ne) | 0, y = y + Math.imul(se, Be) | 0, g = (g = g + Math.imul(se, Ue) | 0) + Math.imul(ce, Be) | 0, v = v + Math.imul(ce, Ue) | 0, y = y + Math.imul(ie, Ie) | 0, g = (g = g + Math.imul(ie, je) | 0) + Math.imul(oe, Ie) | 0, v = v + Math.imul(oe, je) | 0;
    var it = (j + (y = y + Math.imul(X, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(X, De) | 0) + Math.imul(re, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(re, De) | 0) + (g >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, y = Math.imul(Y, ge), g = (g = Math.imul(Y, be)) + Math.imul(ae, ge) | 0, v = Math.imul(ae, be), y = y + Math.imul(G, me) | 0, g = (g = g + Math.imul(G, Ae) | 0) + Math.imul(Q, me) | 0, v = v + Math.imul(Q, Ae) | 0, y = y + Math.imul(k, ve) | 0, g = (g = g + Math.imul(k, Me) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Me) | 0, y = y + Math.imul(h, _e) | 0, g = (g = g + Math.imul(h, Oe) | 0) + Math.imul(b, _e) | 0, v = v + Math.imul(b, Oe) | 0, y = y + Math.imul(de, Te) | 0, g = (g = g + Math.imul(de, Pe) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Pe) | 0, y = y + Math.imul(le, xe) | 0, g = (g = g + Math.imul(le, Ne) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ne) | 0, y = y + Math.imul(he, Be) | 0, g = (g = g + Math.imul(he, Ue) | 0) + Math.imul($e, Be) | 0, v = v + Math.imul($e, Ue) | 0, y = y + Math.imul(se, Ie) | 0, g = (g = g + Math.imul(se, je) | 0) + Math.imul(ce, Ie) | 0, v = v + Math.imul(ce, je) | 0;
    var ot = (j + (y = y + Math.imul(ie, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(ie, De) | 0) + Math.imul(oe, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(oe, De) | 0) + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, y = Math.imul(Y, me), g = (g = Math.imul(Y, Ae)) + Math.imul(ae, me) | 0, v = Math.imul(ae, Ae), y = y + Math.imul(G, ve) | 0, g = (g = g + Math.imul(G, Me) | 0) + Math.imul(Q, ve) | 0, v = v + Math.imul(Q, Me) | 0, y = y + Math.imul(k, _e) | 0, g = (g = g + Math.imul(k, Oe) | 0) + Math.imul(x, _e) | 0, v = v + Math.imul(x, Oe) | 0, y = y + Math.imul(h, Te) | 0, g = (g = g + Math.imul(h, Pe) | 0) + Math.imul(b, Te) | 0, v = v + Math.imul(b, Pe) | 0, y = y + Math.imul(de, xe) | 0, g = (g = g + Math.imul(de, Ne) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ne) | 0, y = y + Math.imul(le, Be) | 0, g = (g = g + Math.imul(le, Ue) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, Ue) | 0, y = y + Math.imul(he, Ie) | 0, g = (g = g + Math.imul(he, je) | 0) + Math.imul($e, Ie) | 0, v = v + Math.imul($e, je) | 0;
    var at = (j + (y = y + Math.imul(se, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(se, De) | 0) + Math.imul(ce, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ce, De) | 0) + (g >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, y = Math.imul(Y, ve), g = (g = Math.imul(Y, Me)) + Math.imul(ae, ve) | 0, v = Math.imul(ae, Me), y = y + Math.imul(G, _e) | 0, g = (g = g + Math.imul(G, Oe) | 0) + Math.imul(Q, _e) | 0, v = v + Math.imul(Q, Oe) | 0, y = y + Math.imul(k, Te) | 0, g = (g = g + Math.imul(k, Pe) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Pe) | 0, y = y + Math.imul(h, xe) | 0, g = (g = g + Math.imul(h, Ne) | 0) + Math.imul(b, xe) | 0, v = v + Math.imul(b, Ne) | 0, y = y + Math.imul(de, Be) | 0, g = (g = g + Math.imul(de, Ue) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, Ue) | 0, y = y + Math.imul(le, Ie) | 0, g = (g = g + Math.imul(le, je) | 0) + Math.imul(we, Ie) | 0, v = v + Math.imul(we, je) | 0;
    var st = (j + (y = y + Math.imul(he, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(he, De) | 0) + Math.imul($e, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul($e, De) | 0) + (g >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, y = Math.imul(Y, _e), g = (g = Math.imul(Y, Oe)) + Math.imul(ae, _e) | 0, v = Math.imul(ae, Oe), y = y + Math.imul(G, Te) | 0, g = (g = g + Math.imul(G, Pe) | 0) + Math.imul(Q, Te) | 0, v = v + Math.imul(Q, Pe) | 0, y = y + Math.imul(k, xe) | 0, g = (g = g + Math.imul(k, Ne) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ne) | 0, y = y + Math.imul(h, Be) | 0, g = (g = g + Math.imul(h, Ue) | 0) + Math.imul(b, Be) | 0, v = v + Math.imul(b, Ue) | 0, y = y + Math.imul(de, Ie) | 0, g = (g = g + Math.imul(de, je) | 0) + Math.imul(ke, Ie) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (j + (y = y + Math.imul(le, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(le, De) | 0) + Math.imul(we, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(we, De) | 0) + (g >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, y = Math.imul(Y, Te), g = (g = Math.imul(Y, Pe)) + Math.imul(ae, Te) | 0, v = Math.imul(ae, Pe), y = y + Math.imul(G, xe) | 0, g = (g = g + Math.imul(G, Ne) | 0) + Math.imul(Q, xe) | 0, v = v + Math.imul(Q, Ne) | 0, y = y + Math.imul(k, Be) | 0, g = (g = g + Math.imul(k, Ue) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, Ue) | 0, y = y + Math.imul(h, Ie) | 0, g = (g = g + Math.imul(h, je) | 0) + Math.imul(b, Ie) | 0, v = v + Math.imul(b, je) | 0;
    var ct = (j + (y = y + Math.imul(de, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(de, De) | 0) + Math.imul(ke, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(ke, De) | 0) + (g >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, y = Math.imul(Y, xe), g = (g = Math.imul(Y, Ne)) + Math.imul(ae, xe) | 0, v = Math.imul(ae, Ne), y = y + Math.imul(G, Be) | 0, g = (g = g + Math.imul(G, Ue) | 0) + Math.imul(Q, Be) | 0, v = v + Math.imul(Q, Ue) | 0, y = y + Math.imul(k, Ie) | 0, g = (g = g + Math.imul(k, je) | 0) + Math.imul(x, Ie) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (j + (y = y + Math.imul(h, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(h, De) | 0) + Math.imul(b, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(b, De) | 0) + (g >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, y = Math.imul(Y, Be), g = (g = Math.imul(Y, Ue)) + Math.imul(ae, Be) | 0, v = Math.imul(ae, Ue), y = y + Math.imul(G, Ie) | 0, g = (g = g + Math.imul(G, je) | 0) + Math.imul(Q, Ie) | 0, v = v + Math.imul(Q, je) | 0;
    var ht = (j + (y = y + Math.imul(k, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(k, De) | 0) + Math.imul(x, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(x, De) | 0) + (g >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, y = Math.imul(Y, Ie), g = (g = Math.imul(Y, je)) + Math.imul(ae, Ie) | 0, v = Math.imul(ae, je);
    var dt = (j + (y = y + Math.imul(G, Ce) | 0) | 0) + ((8191 & (g = (g = g + Math.imul(G, De) | 0) + Math.imul(Q, Ce) | 0)) << 13) | 0;
    j = ((v = v + Math.imul(Q, De) | 0) + (g >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (j + (y = Math.imul(Y, Ce)) | 0) + ((8191 & (g = (g = Math.imul(Y, De)) + Math.imul(ae, Ce) | 0)) << 13) | 0;
    return j = ((v = Math.imul(ae, De)) + (g >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, L[0] = Ge, L[1] = Ke, L[2] = Ye, L[3] = Ze, L[4] = Qe, L[5] = et, L[6] = tt, L[7] = rt, L[8] = nt, L[9] = it, L[10] = ot, L[11] = at, L[12] = st, L[13] = ut, L[14] = ct, L[15] = ft, L[16] = ht, L[17] = dt, L[18] = pt, j !== 0 && (L[19] = j, _.length++), _;
  };
  function q(p, $, _) {
    return new D().mulp(p, $, _);
  }
  function D(p, $) {
    this.x = p, this.y = $;
  }
  Math.imul || (N = C), c.prototype.mulTo = function(p, $) {
    var _, y = this.length + p.length;
    return _ = this.length === 10 && p.length === 10 ? N(this, p, $) : y < 63 ? C(this, p, $) : y < 1024 ? function(g, v, E) {
      E.negative = v.negative ^ g.negative, E.length = g.length + v.length;
      for (var A = 0, L = 0, j = 0; j < E.length - 1; j++) {
        var J = L;
        L = 0;
        for (var X = 67108863 & A, re = Math.min(j, v.length - 1), Z = Math.max(0, j - g.length + 1); Z <= re; Z++) {
          var ie = j - Z, oe = (0 | g.words[ie]) * (0 | v.words[Z]), ue = 67108863 & oe;
          X = 67108863 & (ue = ue + X | 0), L += (J = (J = J + (oe / 67108864 | 0) | 0) + (ue >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[j] = X, A = J, J = L;
      }
      return A !== 0 ? E.words[j] = A : E.length--, E.strip();
    }(this, p, $) : q(this, p, $), _;
  }, D.prototype.makeRBT = function(p) {
    for (var $ = new Array(p), _ = c.prototype._countBits(p) - 1, y = 0; y < p; y++)
      $[y] = this.revBin(y, _, p);
    return $;
  }, D.prototype.revBin = function(p, $, _) {
    if (p === 0 || p === _ - 1)
      return p;
    for (var y = 0, g = 0; g < $; g++)
      y |= (1 & p) << $ - g - 1, p >>= 1;
    return y;
  }, D.prototype.permute = function(p, $, _, y, g, v) {
    for (var E = 0; E < v; E++)
      y[E] = $[p[E]], g[E] = _[p[E]];
  }, D.prototype.transform = function(p, $, _, y, g, v) {
    this.permute(v, p, $, _, y, g);
    for (var E = 1; E < g; E <<= 1)
      for (var A = E << 1, L = Math.cos(2 * Math.PI / A), j = Math.sin(2 * Math.PI / A), J = 0; J < g; J += A)
        for (var X = L, re = j, Z = 0; Z < E; Z++) {
          var ie = _[J + Z], oe = y[J + Z], ue = _[J + Z + E], se = y[J + Z + E], ce = X * ue - re * se;
          se = X * se + re * ue, ue = ce, _[J + Z] = ie + ue, y[J + Z] = oe + se, _[J + Z + E] = ie - ue, y[J + Z + E] = oe - se, Z !== A && (ce = L * X - j * re, re = L * re + j * X, X = ce);
        }
  }, D.prototype.guessLen13b = function(p, $) {
    var _ = 1 | Math.max($, p), y = 1 & _, g = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      g++;
    return 1 << g + 1 + y;
  }, D.prototype.conjugate = function(p, $, _) {
    if (!(_ <= 1))
      for (var y = 0; y < _ / 2; y++) {
        var g = p[y];
        p[y] = p[_ - y - 1], p[_ - y - 1] = g, g = $[y], $[y] = -$[_ - y - 1], $[_ - y - 1] = -g;
      }
  }, D.prototype.normalize13b = function(p, $) {
    for (var _ = 0, y = 0; y < $ / 2; y++) {
      var g = 8192 * Math.round(p[2 * y + 1] / $) + Math.round(p[2 * y] / $) + _;
      p[y] = 67108863 & g, _ = g < 67108864 ? 0 : g / 67108864 | 0;
    }
    return p;
  }, D.prototype.convert13b = function(p, $, _, y) {
    for (var g = 0, v = 0; v < $; v++)
      g += 0 | p[v], _[2 * v] = 8191 & g, g >>>= 13, _[2 * v + 1] = 8191 & g, g >>>= 13;
    for (v = 2 * $; v < y; ++v)
      _[v] = 0;
    a(g === 0), a((-8192 & g) == 0);
  }, D.prototype.stub = function(p) {
    for (var $ = new Array(p), _ = 0; _ < p; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(p, $, _) {
    var y = 2 * this.guessLen13b(p.length, $.length), g = this.makeRBT(y), v = this.stub(y), E = new Array(y), A = new Array(y), L = new Array(y), j = new Array(y), J = new Array(y), X = new Array(y), re = _.words;
    re.length = y, this.convert13b(p.words, p.length, E, y), this.convert13b($.words, $.length, j, y), this.transform(E, v, A, L, y, g), this.transform(j, v, J, X, y, g);
    for (var Z = 0; Z < y; Z++) {
      var ie = A[Z] * J[Z] - L[Z] * X[Z];
      L[Z] = A[Z] * X[Z] + L[Z] * J[Z], A[Z] = ie;
    }
    return this.conjugate(A, L, y), this.transform(A, L, re, v, y, g), this.conjugate(re, v, y), this.normalize13b(re, y), _.negative = p.negative ^ $.negative, _.length = p.length + $.length, _.strip();
  }, c.prototype.mul = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), this.mulTo(p, $);
  }, c.prototype.mulf = function(p) {
    var $ = new c(null);
    return $.words = new Array(this.length + p.length), q(this, p, $);
  }, c.prototype.imul = function(p) {
    return this.clone().mulTo(p, this);
  }, c.prototype.imuln = function(p) {
    a(typeof p == "number"), a(p < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var y = (0 | this.words[_]) * p, g = (67108863 & y) + (67108863 & $);
      $ >>= 26, $ += y / 67108864 | 0, $ += g >>> 26, this.words[_] = 67108863 & g;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(p) {
    return this.clone().imuln(p);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(p) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), A = 0; A < E.length; A++) {
        var L = A / 26 | 0, j = A % 26;
        E[A] = (v.words[L] & 1 << j) >>> j;
      }
      return E;
    }(p);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, y = 0; y < $.length && $[y] === 0; y++, _ = _.sqr())
      ;
    if (++y < $.length)
      for (var g = _.sqr(); y < $.length; y++, g = g.sqr())
        $[y] !== 0 && (_ = _.mul(g));
    return _;
  }, c.prototype.iushln = function(p) {
    a(typeof p == "number" && p >= 0);
    var $, _ = p % 26, y = (p - _) / 26, g = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & g, A = (0 | this.words[$]) - E << _;
        this.words[$] = A | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (y !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + y] = this.words[$];
      for ($ = 0; $ < y; $++)
        this.words[$] = 0;
      this.length += y;
    }
    return this.strip();
  }, c.prototype.ishln = function(p) {
    return a(this.negative === 0), this.iushln(p);
  }, c.prototype.iushrn = function(p, $, _) {
    var y;
    a(typeof p == "number" && p >= 0), y = $ ? ($ - $ % 26) / 26 : 0;
    var g = p % 26, v = Math.min((p - g) / 26, this.length), E = 67108863 ^ 67108863 >>> g << g, A = _;
    if (y -= v, y = Math.max(0, y), A) {
      for (var L = 0; L < v; L++)
        A.words[L] = this.words[L];
      A.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, L = 0; L < this.length; L++)
          this.words[L] = this.words[L + v];
      else
        this.words[0] = 0, this.length = 1;
    var j = 0;
    for (L = this.length - 1; L >= 0 && (j !== 0 || L >= y); L--) {
      var J = 0 | this.words[L];
      this.words[L] = j << 26 - g | J >>> g, j = J & E;
    }
    return A && j !== 0 && (A.words[A.length++] = j), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(p, $, _) {
    return a(this.negative === 0), this.iushrn(p, $, _);
  }, c.prototype.shln = function(p) {
    return this.clone().ishln(p);
  }, c.prototype.ushln = function(p) {
    return this.clone().iushln(p);
  }, c.prototype.shrn = function(p) {
    return this.clone().ishrn(p);
  }, c.prototype.ushrn = function(p) {
    return this.clone().iushrn(p);
  }, c.prototype.testn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    return !(this.length <= _ || !(this.words[_] & y));
  }, c.prototype.imaskn = function(p) {
    a(typeof p == "number" && p >= 0);
    var $ = p % 26, _ = (p - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var y = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= y;
    }
    return this.strip();
  }, c.prototype.maskn = function(p) {
    return this.clone().imaskn(p);
  }, c.prototype.iaddn = function(p) {
    return a(typeof p == "number"), a(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < p ? (this.words[0] = p - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
  }, c.prototype._iaddn = function(p) {
    this.words[0] += p;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(p) {
    if (a(typeof p == "number"), a(p < 67108864), p < 0)
      return this.iaddn(-p);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(p), this.negative = 1, this;
    if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(p) {
    return this.clone().iaddn(p);
  }, c.prototype.subn = function(p) {
    return this.clone().isubn(p);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(p, $, _) {
    var y, g, v = p.length + _;
    this._expand(v);
    var E = 0;
    for (y = 0; y < p.length; y++) {
      g = (0 | this.words[y + _]) + E;
      var A = (0 | p.words[y]) * $;
      E = ((g -= 67108863 & A) >> 26) - (A / 67108864 | 0), this.words[y + _] = 67108863 & g;
    }
    for (; y < this.length - _; y++)
      E = (g = (0 | this.words[y + _]) + E) >> 26, this.words[y + _] = 67108863 & g;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, y = 0; y < this.length; y++)
      E = (g = -(0 | this.words[y]) + E) >> 26, this.words[y] = 67108863 & g;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(p, $) {
    var _ = (this.length, p.length), y = this.clone(), g = p, v = 0 | g.words[g.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (g = g.ushln(_), y.iushln(_), v = 0 | g.words[g.length - 1]);
    var E, A = y.length - g.length;
    if ($ !== "mod") {
      (E = new c(null)).length = A + 1, E.words = new Array(E.length);
      for (var L = 0; L < E.length; L++)
        E.words[L] = 0;
    }
    var j = y.clone()._ishlnsubmul(g, 1, A);
    j.negative === 0 && (y = j, E && (E.words[A] = 1));
    for (var J = A - 1; J >= 0; J--) {
      var X = 67108864 * (0 | y.words[g.length + J]) + (0 | y.words[g.length + J - 1]);
      for (X = Math.min(X / v | 0, 67108863), y._ishlnsubmul(g, X, J); y.negative !== 0; )
        X--, y.negative = 0, y._ishlnsubmul(g, 1, J), y.isZero() || (y.negative ^= 1);
      E && (E.words[J] = X);
    }
    return E && E.strip(), y.strip(), $ !== "div" && _ !== 0 && y.iushrn(_), { div: E || null, mod: y };
  }, c.prototype.divmod = function(p, $, _) {
    return a(!p.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && p.negative === 0 ? (v = this.neg().divmod(p, $), $ !== "mod" && (y = v.div.neg()), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.iadd(p)), { div: y, mod: g }) : this.negative === 0 && p.negative !== 0 ? (v = this.divmod(p.neg(), $), $ !== "mod" && (y = v.div.neg()), { div: y, mod: v.mod }) : (this.negative & p.negative) != 0 ? (v = this.neg().divmod(p.neg(), $), $ !== "div" && (g = v.mod.neg(), _ && g.negative !== 0 && g.isub(p)), { div: v.div, mod: g }) : p.length > this.length || this.cmp(p) < 0 ? { div: new c(0), mod: this } : p.length === 1 ? $ === "div" ? { div: this.divn(p.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(p.words[0])) } : { div: this.divn(p.words[0]), mod: new c(this.modn(p.words[0])) } : this._wordDiv(p, $);
    var y, g, v;
  }, c.prototype.div = function(p) {
    return this.divmod(p, "div", !1).div;
  }, c.prototype.mod = function(p) {
    return this.divmod(p, "mod", !1).mod;
  }, c.prototype.umod = function(p) {
    return this.divmod(p, "mod", !0).mod;
  }, c.prototype.divRound = function(p) {
    var $ = this.divmod(p);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(p) : $.mod, y = p.ushrn(1), g = p.andln(1), v = _.cmp(y);
    return v < 0 || g === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(p) {
    a(p <= 67108863);
    for (var $ = (1 << 26) % p, _ = 0, y = this.length - 1; y >= 0; y--)
      _ = ($ * _ + (0 | this.words[y])) % p;
    return _;
  }, c.prototype.idivn = function(p) {
    a(p <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = y / p | 0, $ = y % p;
    }
    return this.strip();
  }, c.prototype.divn = function(p) {
    return this.clone().idivn(p);
  }, c.prototype.egcd = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y = new c(1), g = new c(0), v = new c(0), E = new c(1), A = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++A;
    for (var L = _.clone(), j = $.clone(); !$.isZero(); ) {
      for (var J = 0, X = 1; ($.words[0] & X) == 0 && J < 26; ++J, X <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (y.isOdd() || g.isOdd()) && (y.iadd(L), g.isub(j)), y.iushrn(1), g.iushrn(1);
      for (var re = 0, Z = 1; (_.words[0] & Z) == 0 && re < 26; ++re, Z <<= 1)
        ;
      if (re > 0)
        for (_.iushrn(re); re-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(L), E.isub(j)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), y.isub(v), g.isub(E)) : (_.isub($), v.isub(y), E.isub(g));
    }
    return { a: v, b: E, gcd: _.iushln(A) };
  }, c.prototype._invmp = function(p) {
    a(p.negative === 0), a(!p.isZero());
    var $ = this, _ = p.clone();
    $ = $.negative !== 0 ? $.umod(p) : $.clone();
    for (var y, g = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var A = 0, L = 1; ($.words[0] & L) == 0 && A < 26; ++A, L <<= 1)
        ;
      if (A > 0)
        for ($.iushrn(A); A-- > 0; )
          g.isOdd() && g.iadd(E), g.iushrn(1);
      for (var j = 0, J = 1; (_.words[0] & J) == 0 && j < 26; ++j, J <<= 1)
        ;
      if (j > 0)
        for (_.iushrn(j); j-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), g.isub(v)) : (_.isub($), v.isub(g));
    }
    return (y = $.cmpn(1) === 0 ? g : v).cmpn(0) < 0 && y.iadd(p), y;
  }, c.prototype.gcd = function(p) {
    if (this.isZero())
      return p.abs();
    if (p.isZero())
      return this.abs();
    var $ = this.clone(), _ = p.clone();
    $.negative = 0, _.negative = 0;
    for (var y = 0; $.isEven() && _.isEven(); y++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var g = $.cmp(_);
      if (g < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (g === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(y);
  }, c.prototype.invm = function(p) {
    return this.egcd(p).a.umod(p);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(p) {
    return this.words[0] & p;
  }, c.prototype.bincn = function(p) {
    a(typeof p == "number");
    var $ = p % 26, _ = (p - $) / 26, y = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= y, this;
    for (var g = y, v = _; g !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      g = (E += g) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return g !== 0 && (this.words[v] = g, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(p) {
    var $, _ = p < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (p = -p), a(p <= 67108863, "Number is too big");
      var y = 0 | this.words[0];
      $ = y === p ? 0 : y < p ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(p) {
    if (this.negative !== 0 && p.negative === 0)
      return -1;
    if (this.negative === 0 && p.negative !== 0)
      return 1;
    var $ = this.ucmp(p);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(p) {
    if (this.length > p.length)
      return 1;
    if (this.length < p.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var y = 0 | this.words[_], g = 0 | p.words[_];
      if (y !== g) {
        y < g ? $ = -1 : y > g && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(p) {
    return this.cmpn(p) === 1;
  }, c.prototype.gt = function(p) {
    return this.cmp(p) === 1;
  }, c.prototype.gten = function(p) {
    return this.cmpn(p) >= 0;
  }, c.prototype.gte = function(p) {
    return this.cmp(p) >= 0;
  }, c.prototype.ltn = function(p) {
    return this.cmpn(p) === -1;
  }, c.prototype.lt = function(p) {
    return this.cmp(p) === -1;
  }, c.prototype.lten = function(p) {
    return this.cmpn(p) <= 0;
  }, c.prototype.lte = function(p) {
    return this.cmp(p) <= 0;
  }, c.prototype.eqn = function(p) {
    return this.cmpn(p) === 0;
  }, c.prototype.eq = function(p) {
    return this.cmp(p) === 0;
  }, c.red = function(p) {
    return new H(p);
  }, c.prototype.toRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(p) {
    return this.red = p, this;
  }, c.prototype.forceRed = function(p) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(p);
  }, c.prototype.redAdd = function(p) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
  }, c.prototype.redIAdd = function(p) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
  }, c.prototype.redSub = function(p) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
  }, c.prototype.redISub = function(p) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
  }, c.prototype.redShl = function(p) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
  }, c.prototype.redMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
  }, c.prototype.redIMul = function(p) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(p) {
    return a(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function W(p, $) {
    this.name = p, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    W.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function ee() {
    W.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function P() {
    W.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function F() {
    W.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(p) {
    if (typeof p == "string") {
      var $ = c._prime(p);
      this.m = $.p, this.prime = $;
    } else
      a(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
  }
  function te(p) {
    H.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  W.prototype._tmp = function() {
    var p = new c(null);
    return p.words = new Array(Math.ceil(this.n / 13)), p;
  }, W.prototype.ireduce = function(p) {
    var $, _ = p;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var y = $ < this.n ? -1 : _.ucmp(this.p);
    return y === 0 ? (_.words[0] = 0, _.length = 1) : y > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, W.prototype.split = function(p, $) {
    p.iushrn(this.n, 0, $);
  }, W.prototype.imulK = function(p) {
    return p.imul(this.k);
  }, u(V, W), V.prototype.split = function(p, $) {
    for (var _ = 4194303, y = Math.min(p.length, 9), g = 0; g < y; g++)
      $.words[g] = p.words[g];
    if ($.length = y, p.length <= 9)
      return p.words[0] = 0, void (p.length = 1);
    var v = p.words[9];
    for ($.words[$.length++] = v & _, g = 10; g < p.length; g++) {
      var E = 0 | p.words[g];
      p.words[g - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, p.words[g - 10] = v, v === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
  }, V.prototype.imulK = function(p) {
    p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 0 | p.words[_];
      $ += 977 * y, p.words[_] = 67108863 & $, $ = 64 * y + ($ / 67108864 | 0);
    }
    return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
  }, u(ee, W), u(P, W), u(F, W), F.prototype.imulK = function(p) {
    for (var $ = 0, _ = 0; _ < p.length; _++) {
      var y = 19 * (0 | p.words[_]) + $, g = 67108863 & y;
      y >>>= 26, p.words[_] = g, $ = y;
    }
    return $ !== 0 && (p.words[p.length++] = $), p;
  }, c._prime = function(p) {
    if (z[p])
      return z[p];
    var $;
    if (p === "k256")
      $ = new V();
    else if (p === "p224")
      $ = new ee();
    else if (p === "p192")
      $ = new P();
    else {
      if (p !== "p25519")
        throw new Error("Unknown prime " + p);
      $ = new F();
    }
    return z[p] = $, $;
  }, H.prototype._verify1 = function(p) {
    a(p.negative === 0, "red works only with positives"), a(p.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(p, $) {
    a((p.negative | $.negative) == 0, "red works only with positives"), a(p.red && p.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(p) {
    return this.prime ? this.prime.ireduce(p)._forceRed(this) : p.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(p) {
    return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
  }, H.prototype.add = function(p, $) {
    this._verify2(p, $);
    var _ = p.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(p, $) {
    this._verify2(p, $);
    var _ = p.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(p, $) {
    this._verify2(p, $);
    var _ = p.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(p, $) {
    this._verify2(p, $);
    var _ = p.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(p, $) {
    return this._verify1(p), this.imod(p.ushln($));
  }, H.prototype.imul = function(p, $) {
    return this._verify2(p, $), this.imod(p.imul($));
  }, H.prototype.mul = function(p, $) {
    return this._verify2(p, $), this.imod(p.mul($));
  }, H.prototype.isqr = function(p) {
    return this.imul(p, p.clone());
  }, H.prototype.sqr = function(p) {
    return this.mul(p, p);
  }, H.prototype.sqrt = function(p) {
    if (p.isZero())
      return p.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(p, _);
    }
    for (var y = this.m.subn(1), g = 0; !y.isZero() && y.andln(1) === 0; )
      g++, y.iushrn(1);
    a(!y.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), A = this.m.subn(1).iushrn(1), L = this.m.bitLength();
    for (L = new c(2 * L * L).toRed(this); this.pow(L, A).cmp(E) !== 0; )
      L.redIAdd(E);
    for (var j = this.pow(L, y), J = this.pow(p, y.addn(1).iushrn(1)), X = this.pow(p, y), re = g; X.cmp(v) !== 0; ) {
      for (var Z = X, ie = 0; Z.cmp(v) !== 0; ie++)
        Z = Z.redSqr();
      a(ie < re);
      var oe = this.pow(j, new c(1).iushln(re - ie - 1));
      J = J.redMul(oe), j = oe.redSqr(), X = X.redMul(j), re = ie;
    }
    return J;
  }, H.prototype.invm = function(p) {
    var $ = p._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(p, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return p.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = p;
    for (var y = 2; y < _.length; y++)
      _[y] = this.mul(_[y - 1], p);
    var g = _[0], v = 0, E = 0, A = $.bitLength() % 26;
    for (A === 0 && (A = 26), y = $.length - 1; y >= 0; y--) {
      for (var L = $.words[y], j = A - 1; j >= 0; j--) {
        var J = L >> j & 1;
        g !== _[0] && (g = this.sqr(g)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || y === 0 && j === 0) && (g = this.mul(g, _[v]), E = 0, v = 0)) : E = 0;
      }
      A = 26;
    }
    return g;
  }, H.prototype.convertTo = function(p) {
    var $ = p.umod(this.m);
    return $ === p ? $.clone() : $;
  }, H.prototype.convertFrom = function(p) {
    var $ = p.clone();
    return $.red = null, $;
  }, c.mont = function(p) {
    return new te(p);
  }, u(te, H), te.prototype.convertTo = function(p) {
    return this.imod(p.ushln(this.shift));
  }, te.prototype.convertFrom = function(p) {
    var $ = this.imod(p.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(p, $) {
    if (p.isZero() || $.isZero())
      return p.words[0] = 0, p.length = 1, p;
    var _ = p.imul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(p, $) {
    if (p.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = p.mul($), y = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), g = _.isub(y).iushrn(this.shift), v = g;
    return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(p) {
    return this.imod(p._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(o, n) {
  var a = buffer$6, u = a.Buffer;
  function c(d, w) {
    for (var S in d)
      w[S] = d[S];
  }
  function m(d, w, S) {
    return u(d, w, S);
  }
  u.from && u.alloc && u.allocUnsafe && u.allocUnsafeSlow ? o.exports = a : (c(a, n), n.Buffer = m), m.prototype = Object.create(u.prototype), c(u, m), m.from = function(d, w, S) {
    if (typeof d == "number")
      throw new TypeError("Argument must not be a number");
    return u(d, w, S);
  }, m.alloc = function(d, w, S) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    var T = u(d);
    return w !== void 0 ? typeof S == "string" ? T.fill(w, S) : T.fill(w) : T.fill(0), T;
  }, m.allocUnsafe = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return u(d);
  }, m.allocUnsafeSlow = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return a.SlowBuffer(d);
  };
})(safeBuffer, safeBuffer.exports);
const Buffer$4 = safeBuffer.exports.Buffer;
var bufferPipe$1 = class {
  constructor(o = Buffer$4.from([])) {
    this.buffer = o;
  }
  read(o) {
    const n = this.buffer.subarray(0, o);
    return this.buffer = this.buffer.subarray(o), n;
  }
  write(o) {
    o = Buffer$4.from(o), this.buffer = Buffer$4.concat([this.buffer, o]);
  }
};
const Bn$1 = bn.exports, Pipe$2 = bufferPipe$1;
var unsigned = { encode: encode$1, decode: decode$1, read: read$1, readBn: readBn$1, write: write$1 };
function read$1(o) {
  return readBn$1(o).toString();
}
function readBn$1(o) {
  const n = new Bn$1(0);
  let a, u = 0;
  for (; a = o.read(1)[0], n.ior(new Bn$1(127 & a).shln(u)), a >> 7 != 0; )
    u += 7;
  return n;
}
function write$1(o, n) {
  const a = new Bn$1(o);
  for (; ; ) {
    const u = a.maskn(7).toNumber();
    if (a.ishrn(7), a.isZero()) {
      n.write([u]);
      break;
    }
    n.write([128 | u]);
  }
}
function encode$1(o) {
  const n = new Pipe$2();
  return write$1(o, n), n.buffer;
}
function decode$1(o) {
  return read$1(new Pipe$2(o));
}
const Bn = bn.exports, Pipe$1 = bufferPipe$1;
var signed = { encode, decode, write, read, readBn };
function read(o) {
  return readBn(o).toString();
}
function readBn(o) {
  const n = new Bn(0);
  let a, u = 0;
  for (; a = o.read(1)[0], n.ior(new Bn(127 & a).shln(u)), u += 7, a >> 7 != 0; )
    ;
  return 64 & a && n.setn(u), n.fromTwos(u);
}
function write(o, n) {
  let a = new Bn(o);
  const u = a.isNeg();
  for (u && (a = a.toTwos(a.bitLength() + 8)); ; ) {
    const m = a.maskn(7).toNumber();
    if (a.ishrn(7), c(a) && (64 & m) != 0 || a.isZero() && (64 & m) == 0) {
      n.write([m]);
      break;
    }
    n.write([128 | m]);
  }
  function c(m) {
    return u && m.toString(2).indexOf("0") < 0;
  }
}
function encode(o) {
  const n = new Pipe$1();
  return write(o, n), n.buffer;
}
function decode(o) {
  return read(new Pipe$1(o));
}
leb128$1.unsigned = unsigned, leb128$1.signed = signed;
const Buffer$3 = safeBuffer.exports.Buffer;
var bufferPipe = class {
  constructor(o = Buffer$3.from([])) {
    this.buffer = o, this._bytesRead = 0, this._bytesWrote = 0;
  }
  read(o) {
    this._bytesRead += o;
    const n = this.buffer.slice(0, o);
    return this.buffer = this.buffer.slice(o), n;
  }
  write(o) {
    o = Buffer$3.from(o), this._bytesWrote += o.length, this.buffer = Buffer$3.concat([this.buffer, o]);
  }
  get end() {
    return !this.buffer.length;
  }
  get bytesRead() {
    return this._bytesRead;
  }
  get bytesWrote() {
    return this._bytesWrote;
  }
};
const block = "block_type", loop = "block_type", br = "varuint32", br_if = "varuint32", br_table = "br_table", call = "varuint32", call_indirect = "call_indirect", get_local = "varuint32", set_local = "varuint32", tee_local = "varuint32", get_global = "varuint32", set_global = "varuint32", load = "memory_immediate", load8_s = "memory_immediate", load8_u = "memory_immediate", load16_s = "memory_immediate", load16_u = "memory_immediate", load32_s = "memory_immediate", load32_u = "memory_immediate", store = "memory_immediate", store8 = "memory_immediate", store16 = "memory_immediate", store32 = "memory_immediate", current_memory = "varuint1", grow_memory = "varuint1", i32 = "varint32", i64 = "varint64", f32 = "uint32", f64 = "uint64", require$$0$1 = { block, loop, if: "block_type", br, br_if, br_table, call, call_indirect, get_local, set_local, tee_local, get_global, set_global, load, load8_s, load8_u, load16_s, load16_u, load32_s, load32_u, store, store8, store16, store32, current_memory, grow_memory, i32, i64, f32, f64 }, leb$1 = leb128$1, Stream$1 = bufferPipe, OP_IMMEDIATES$1 = require$$0$1, _exports$1 = wasm2json$1.exports = (o, n) => {
  const a = new Stream$1(o);
  return _exports$1.parse(a, n);
}, LANGUAGE_TYPES$1 = _exports$1.LANGUAGE_TYPES = { 127: "i32", 126: "i64", 125: "f32", 124: "f64", 112: "anyFunc", 96: "func", 64: "block_type" }, EXTERNAL_KIND$1 = _exports$1.EXTERNAL_KIND = { 0: "function", 1: "table", 2: "memory", 3: "global" };
_exports$1.parsePreramble = (o) => {
  const n = { name: "preramble" };
  return n.magic = [...o.read(4)], n.version = [...o.read(4)], n;
}, _exports$1.parseSectionHeader = (o) => {
  const n = o.read(1)[0], a = leb$1.unsigned.readBn(o).toNumber();
  return { id: n, name: SECTION_IDS$1[n], size: a };
};
const OPCODES$1 = _exports$1.OPCODES = { 0: "unreachable", 1: "nop", 2: "block", 3: "loop", 4: "if", 5: "else", 11: "end", 12: "br", 13: "br_if", 14: "br_table", 15: "return", 16: "call", 17: "call_indirect", 26: "drop", 27: "select", 32: "get_local", 33: "set_local", 34: "tee_local", 35: "get_global", 36: "set_global", 40: "i32.load", 41: "i64.load", 42: "f32.load", 43: "f64.load", 44: "i32.load8_s", 45: "i32.load8_u", 46: "i32.load16_s", 47: "i32.load16_u", 48: "i64.load8_s", 49: "i64.load8_u", 50: "i64.load16_s", 51: "i64.load16_u", 52: "i64.load32_s", 53: "i64.load32_u", 54: "i32.store", 55: "i64.store", 56: "f32.store", 57: "f64.store", 58: "i32.store8", 59: "i32.store16", 60: "i64.store8", 61: "i64.store16", 62: "i64.store32", 63: "current_memory", 64: "grow_memory", 65: "i32.const", 66: "i64.const", 67: "f32.const", 68: "f64.const", 69: "i32.eqz", 70: "i32.eq", 71: "i32.ne", 72: "i32.lt_s", 73: "i32.lt_u", 74: "i32.gt_s", 75: "i32.gt_u", 76: "i32.le_s", 77: "i32.le_u", 78: "i32.ge_s", 79: "i32.ge_u", 80: "i64.eqz", 81: "i64.eq", 82: "i64.ne", 83: "i64.lt_s", 84: "i64.lt_u", 85: "i64.gt_s", 86: "i64.gt_u", 87: "i64.le_s", 88: "i64.le_u", 89: "i64.ge_s", 90: "i64.ge_u", 91: "f32.eq", 92: "f32.ne", 93: "f32.lt", 94: "f32.gt", 95: "f32.le", 96: "f32.ge", 97: "f64.eq", 98: "f64.ne", 99: "f64.lt", 100: "f64.gt", 101: "f64.le", 102: "f64.ge", 103: "i32.clz", 104: "i32.ctz", 105: "i32.popcnt", 106: "i32.add", 107: "i32.sub", 108: "i32.mul", 109: "i32.div_s", 110: "i32.div_u", 111: "i32.rem_s", 112: "i32.rem_u", 113: "i32.and", 114: "i32.or", 115: "i32.xor", 116: "i32.shl", 117: "i32.shr_s", 118: "i32.shr_u", 119: "i32.rotl", 120: "i32.rotr", 121: "i64.clz", 122: "i64.ctz", 123: "i64.popcnt", 124: "i64.add", 125: "i64.sub", 126: "i64.mul", 127: "i64.div_s", 128: "i64.div_u", 129: "i64.rem_s", 130: "i64.rem_u", 131: "i64.and", 132: "i64.or", 133: "i64.xor", 134: "i64.shl", 135: "i64.shr_s", 136: "i64.shr_u", 137: "i64.rotl", 138: "i64.rotr", 139: "f32.abs", 140: "f32.neg", 141: "f32.ceil", 142: "f32.floor", 143: "f32.trunc", 144: "f32.nearest", 145: "f32.sqrt", 146: "f32.add", 147: "f32.sub", 148: "f32.mul", 149: "f32.div", 150: "f32.min", 151: "f32.max", 152: "f32.copysign", 153: "f64.abs", 154: "f64.neg", 155: "f64.ceil", 156: "f64.floor", 157: "f64.trunc", 158: "f64.nearest", 159: "f64.sqrt", 160: "f64.add", 161: "f64.sub", 162: "f64.mul", 163: "f64.div", 164: "f64.min", 165: "f64.max", 166: "f64.copysign", 167: "i32.wrap/i64", 168: "i32.trunc_s/f32", 169: "i32.trunc_u/f32", 170: "i32.trunc_s/f64", 171: "i32.trunc_u/f64", 172: "i64.extend_s/i32", 173: "i64.extend_u/i32", 174: "i64.trunc_s/f32", 175: "i64.trunc_u/f32", 176: "i64.trunc_s/f64", 177: "i64.trunc_u/f64", 178: "f32.convert_s/i32", 179: "f32.convert_u/i32", 180: "f32.convert_s/i64", 181: "f32.convert_u/i64", 182: "f32.demote/f64", 183: "f64.convert_s/i32", 184: "f64.convert_u/i32", 185: "f64.convert_s/i64", 186: "f64.convert_u/i64", 187: "f64.promote/f32", 188: "i32.reinterpret/f32", 189: "i64.reinterpret/f64", 190: "f32.reinterpret/i32", 191: "f64.reinterpret/i64" }, SECTION_IDS$1 = _exports$1.SECTION_IDS = { 0: "custom", 1: "type", 2: "import", 3: "function", 4: "table", 5: "memory", 6: "global", 7: "export", 8: "start", 9: "element", 10: "code", 11: "data" };
_exports$1.immediataryParsers = { varuint1: (o) => o.read(1)[0], varuint32: (o) => leb$1.unsigned.read(o), varint32: (o) => leb$1.signed.read(o), varint64: (o) => leb$1.signed.read(o), uint32: (o) => [...o.read(4)], uint64: (o) => [...o.read(8)], block_type: (o) => {
  const n = o.read(1)[0];
  return LANGUAGE_TYPES$1[n];
}, br_table: (o) => {
  const n = { targets: [] }, a = leb$1.unsigned.readBn(o).toNumber();
  for (let u = 0; u < a; u++) {
    const c = leb$1.unsigned.readBn(o).toNumber();
    n.targets.push(c);
  }
  return n.defaultTarget = leb$1.unsigned.readBn(o).toNumber(), n;
}, call_indirect: (o) => {
  const n = {};
  return n.index = leb$1.unsigned.readBn(o).toNumber(), n.reserved = o.read(1)[0], n;
}, memory_immediate: (o) => {
  const n = {};
  return n.flags = leb$1.unsigned.readBn(o).toNumber(), n.offset = leb$1.unsigned.readBn(o).toNumber(), n;
} }, _exports$1.typeParsers = { function: (o) => leb$1.unsigned.readBn(o).toNumber(), table: (o) => {
  const n = {}, a = o.read(1)[0];
  return n.elementType = LANGUAGE_TYPES$1[a], n.limits = _exports$1.typeParsers.memory(o), n;
}, global: (o) => {
  const n = {};
  let a = o.read(1)[0];
  return n.contentType = LANGUAGE_TYPES$1[a], n.mutability = o.read(1)[0], n;
}, memory: (o) => {
  const n = {};
  return n.flags = leb$1.unsigned.readBn(o).toNumber(), n.intial = leb$1.unsigned.readBn(o).toNumber(), n.flags === 1 && (n.maximum = leb$1.unsigned.readBn(o).toNumber()), n;
}, initExpr: (o) => {
  const n = _exports$1.parseOp(o);
  return o.read(1), n;
} };
const sectionParsers = _exports$1.sectionParsers = { custom: (o, n) => {
  const a = { name: "custom" }, u = new Stream$1(o.read(n.size)), c = leb$1.unsigned.readBn(u).toNumber(), m = u.read(c);
  return a.sectionName = Buffer.from(m).toString(), a.payload = [...u.buffer], a;
}, type: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "type", entries: [] };
  for (let u = 0; u < n; u++) {
    let c = o.read(1)[0];
    const m = { form: LANGUAGE_TYPES$1[c], params: [] }, d = leb$1.unsigned.readBn(o).toNumber();
    for (let w = 0; w < d; w++) {
      const S = o.read(1)[0];
      m.params.push(LANGUAGE_TYPES$1[S]);
    }
    leb$1.unsigned.readBn(o).toNumber() && (c = o.read(1)[0], m.return_type = LANGUAGE_TYPES$1[c]), a.entries.push(m);
  }
  return a;
}, import: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "import", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = {}, m = leb$1.unsigned.readBn(o).toNumber();
    c.moduleStr = Buffer.from(o.read(m)).toString();
    const d = leb$1.unsigned.readBn(o).toNumber();
    c.fieldStr = Buffer.from(o.read(d)).toString();
    const w = o.read(1)[0];
    c.kind = EXTERNAL_KIND$1[w], c.type = _exports$1.typeParsers[c.kind](o), a.entries.push(c);
  }
  return a;
}, function: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "function", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = leb$1.unsigned.readBn(o).toNumber();
    a.entries.push(c);
  }
  return a;
}, table: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "table", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = _exports$1.typeParsers.table(o);
    a.entries.push(c);
  }
  return a;
}, memory: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "memory", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = _exports$1.typeParsers.memory(o);
    a.entries.push(c);
  }
  return a;
}, global: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "global", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = {};
    c.type = _exports$1.typeParsers.global(o), c.init = _exports$1.typeParsers.initExpr(o), a.entries.push(c);
  }
  return a;
}, export: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "export", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = leb$1.unsigned.readBn(o).toNumber(), m = {};
    m.field_str = Buffer.from(o.read(c)).toString();
    const d = o.read(1)[0];
    m.kind = EXTERNAL_KIND$1[d], m.index = leb$1.unsigned.readBn(o).toNumber(), a.entries.push(m);
  }
  return a;
}, start: (o) => {
  const n = { name: "start" };
  return n.index = leb$1.unsigned.readBn(o).toNumber(), n;
}, element: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "element", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = { elements: [] };
    c.index = leb$1.unsigned.readBn(o).toNumber(), c.offset = _exports$1.typeParsers.initExpr(o);
    const m = leb$1.unsigned.readBn(o).toNumber();
    for (let d = 0; d < m; d++) {
      const w = leb$1.unsigned.readBn(o).toNumber();
      c.elements.push(w);
    }
    a.entries.push(c);
  }
  return a;
}, code: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "code", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = { locals: [], code: [] };
    let m = leb$1.unsigned.readBn(o).toNumber();
    const d = o.bytesRead + m, w = leb$1.unsigned.readBn(o).toNumber();
    for (let S = 0; S < w; S++) {
      const T = {};
      T.count = leb$1.unsigned.readBn(o).toNumber();
      const B = o.read(1)[0];
      T.type = LANGUAGE_TYPES$1[B], c.locals.push(T);
    }
    for (; o.bytesRead < d; ) {
      const S = _exports$1.parseOp(o);
      c.code.push(S);
    }
    a.entries.push(c);
  }
  return a;
}, data: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), a = { name: "data", entries: [] };
  for (let u = 0; u < n; u++) {
    const c = {};
    c.index = leb$1.unsigned.readBn(o).toNumber(), c.offset = _exports$1.typeParsers.initExpr(o);
    const m = leb$1.unsigned.readBn(o).toNumber();
    c.data = [...o.read(m)], a.entries.push(c);
  }
  return a;
} };
_exports$1.parseOp = (o) => {
  const n = {}, a = o.read(1)[0], u = OPCODES$1[a];
  let [c, m] = u.split(".");
  m === void 0 ? m = c : n.return_type = c, n.name = m;
  const d = OP_IMMEDIATES$1[m === "const" ? c : m];
  return d && (n.immediates = _exports$1.immediataryParsers[d](o)), n;
}, _exports$1.parse = (o, n) => {
  const a = [_exports$1.parsePreramble(o)];
  for (; !o.end; ) {
    const u = _exports$1.parseSectionHeader(o);
    a.push(sectionParsers[u.name](o, u));
  }
  return a;
};
var json2wasm = { exports: {} }, npmBrowser = {}, buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(o) {
  const n = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = d, o.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, o.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function m(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, b) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return T(l);
    }
    return w(l, h, b);
  }
  function w(l, h, b) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | N(x, O);
        let Q = m(G);
        const ne = Q.write(x, O);
        return ne !== G && (Q = Q.slice(0, ne)), Q;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (le(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (le(l, ArrayBuffer) || l && le(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (le(l, SharedArrayBuffer) || l && le(l.buffer, SharedArrayBuffer)))
      return I(l, h, b);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const M = l.valueOf && l.valueOf();
    if (M != null && M !== l)
      return d.from(M, h, b);
    const k = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = m(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? m(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (k)
      return k;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, b);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function T(l) {
    return S(l), m(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), b = m(h);
    for (let M = 0; M < h; M += 1)
      b[M] = 255 & l[M];
    return b;
  }
  function I(l, h, b) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (b || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let M;
    return M = h === void 0 && b === void 0 ? new Uint8Array(l) : b === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, b), Object.setPrototypeOf(M, d.prototype), M;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function N(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || le(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const b = l.length, M = arguments.length > 2 && arguments[2] === !0;
    if (!M && b === 0)
      return 0;
    let k = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return b;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * b;
        case "hex":
          return b >>> 1;
        case "base64":
          return $e(l).length;
        default:
          if (k)
            return M ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), k = !0;
      }
  }
  function q(l, h, b) {
    let M = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((b === void 0 || b > this.length) && (b = this.length), b <= 0) || (b >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return g(this, h, b);
        case "utf8":
        case "utf-8":
          return p(this, h, b);
        case "ascii":
          return _(this, h, b);
        case "latin1":
        case "binary":
          return y(this, h, b);
        case "base64":
          return te(this, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, b);
        default:
          if (M)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), M = !0;
      }
  }
  function D(l, h, b) {
    const M = l[h];
    l[h] = l[b], l[b] = M;
  }
  function z(l, h, b, M, k) {
    if (l.length === 0)
      return -1;
    if (typeof b == "string" ? (M = b, b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648), we(b = +b) && (b = k ? 0 : l.length - 1), b < 0 && (b = l.length + b), b >= l.length) {
      if (k)
        return -1;
      b = l.length - 1;
    } else if (b < 0) {
      if (!k)
        return -1;
      b = 0;
    }
    if (typeof h == "string" && (h = d.from(h, M)), d.isBuffer(h))
      return h.length === 0 ? -1 : W(l, h, b, M, k);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? k ? Uint8Array.prototype.indexOf.call(l, h, b) : Uint8Array.prototype.lastIndexOf.call(l, h, b) : W(l, [h], b, M, k);
    throw new TypeError("val must be string, number or Buffer");
  }
  function W(l, h, b, M, k) {
    let x, O = 1, G = l.length, Q = h.length;
    if (M !== void 0 && ((M = String(M).toLowerCase()) === "ucs2" || M === "ucs-2" || M === "utf16le" || M === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, Q /= 2, b /= 2;
    }
    function ne(Y, ae) {
      return O === 1 ? Y[ae] : Y.readUInt16BE(ae * O);
    }
    if (k) {
      let Y = -1;
      for (x = b; x < G; x++)
        if (ne(l, x) === ne(h, Y === -1 ? 0 : x - Y)) {
          if (Y === -1 && (Y = x), x - Y + 1 === Q)
            return Y * O;
        } else
          Y !== -1 && (x -= x - Y), Y = -1;
    } else
      for (b + Q > G && (b = G - Q), x = b; x >= 0; x--) {
        let Y = !0;
        for (let ae = 0; ae < Q; ae++)
          if (ne(l, x + ae) !== ne(h, ae)) {
            Y = !1;
            break;
          }
        if (Y)
          return x;
      }
    return -1;
  }
  function V(l, h, b, M) {
    b = Number(b) || 0;
    const k = l.length - b;
    M ? (M = Number(M)) > k && (M = k) : M = k;
    const x = h.length;
    let O;
    for (M > x / 2 && (M = x / 2), O = 0; O < M; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[b + O] = G;
    }
    return O;
  }
  function ee(l, h, b, M) {
    return fe(he(h, l.length - b), l, b, M);
  }
  function P(l, h, b, M) {
    return fe(function(k) {
      const x = [];
      for (let O = 0; O < k.length; ++O)
        x.push(255 & k.charCodeAt(O));
      return x;
    }(h), l, b, M);
  }
  function F(l, h, b, M) {
    return fe($e(h), l, b, M);
  }
  function H(l, h, b, M) {
    return fe(function(k, x) {
      let O, G, Q;
      const ne = [];
      for (let Y = 0; Y < k.length && !((x -= 2) < 0); ++Y)
        O = k.charCodeAt(Y), G = O >> 8, Q = O % 256, ne.push(Q), ne.push(G);
      return ne;
    }(h, l.length - b), l, b, M);
  }
  function te(l, h, b) {
    return h === 0 && b === l.length ? n.fromByteArray(l) : n.fromByteArray(l.slice(h, b));
  }
  function p(l, h, b) {
    b = Math.min(l.length, b);
    const M = [];
    let k = h;
    for (; k < b; ) {
      const x = l[k];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (k + G <= b) {
        let Q, ne, Y, ae;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            Q = l[k + 1], (192 & Q) == 128 && (ae = (31 & x) << 6 | 63 & Q, ae > 127 && (O = ae));
            break;
          case 3:
            Q = l[k + 1], ne = l[k + 2], (192 & Q) == 128 && (192 & ne) == 128 && (ae = (15 & x) << 12 | (63 & Q) << 6 | 63 & ne, ae > 2047 && (ae < 55296 || ae > 57343) && (O = ae));
            break;
          case 4:
            Q = l[k + 1], ne = l[k + 2], Y = l[k + 3], (192 & Q) == 128 && (192 & ne) == 128 && (192 & Y) == 128 && (ae = (15 & x) << 18 | (63 & Q) << 12 | (63 & ne) << 6 | 63 & Y, ae > 65535 && ae < 1114112 && (O = ae));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, M.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), M.push(O), k += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", Q = 0;
      for (; Q < O; )
        G += String.fromCharCode.apply(String, x.slice(Q, Q += $));
      return G;
    }(M);
  }
  o.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, b) {
    return w(l, h, b);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, b) {
    return function(M, k, x) {
      return S(M), M <= 0 ? m(M) : k !== void 0 ? typeof x == "string" ? m(M).fill(k, x) : m(M).fill(k) : m(M);
    }(l, h, b);
  }, d.allocUnsafe = function(l) {
    return T(l);
  }, d.allocUnsafeSlow = function(l) {
    return T(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), le(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let b = l.length, M = h.length;
    for (let k = 0, x = Math.min(b, M); k < x; ++k)
      if (l[k] !== h[k]) {
        b = l[k], M = h[k];
        break;
      }
    return b < M ? -1 : M < b ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let b;
    if (h === void 0)
      for (h = 0, b = 0; b < l.length; ++b)
        h += l[b].length;
    const M = d.allocUnsafe(h);
    let k = 0;
    for (b = 0; b < l.length; ++b) {
      let x = l[b];
      if (le(x, Uint8Array))
        k + x.length > M.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(M, k)) : Uint8Array.prototype.set.call(M, x, k);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(M, k);
      }
      k += x.length;
    }
    return M;
  }, d.byteLength = N, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? p(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = o.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, b, M, k) {
    if (le(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), b === void 0 && (b = l ? l.length : 0), M === void 0 && (M = 0), k === void 0 && (k = this.length), h < 0 || b > l.length || M < 0 || k > this.length)
      throw new RangeError("out of range index");
    if (M >= k && h >= b)
      return 0;
    if (M >= k)
      return -1;
    if (h >= b)
      return 1;
    if (this === l)
      return 0;
    let x = (k >>>= 0) - (M >>>= 0), O = (b >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), Q = this.slice(M, k), ne = l.slice(h, b);
    for (let Y = 0; Y < G; ++Y)
      if (Q[Y] !== ne[Y]) {
        x = Q[Y], O = ne[Y];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, b) {
    return this.indexOf(l, h, b) !== -1;
  }, d.prototype.indexOf = function(l, h, b) {
    return z(this, l, h, b, !0);
  }, d.prototype.lastIndexOf = function(l, h, b) {
    return z(this, l, h, b, !1);
  }, d.prototype.write = function(l, h, b, M) {
    if (h === void 0)
      M = "utf8", b = this.length, h = 0;
    else if (b === void 0 && typeof h == "string")
      M = h, b = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(b) ? (b >>>= 0, M === void 0 && (M = "utf8")) : (M = b, b = void 0);
    }
    const k = this.length - h;
    if ((b === void 0 || b > k) && (b = k), l.length > 0 && (b < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    M || (M = "utf8");
    let x = !1;
    for (; ; )
      switch (M) {
        case "hex":
          return V(this, l, h, b);
        case "utf8":
        case "utf-8":
          return ee(this, l, h, b);
        case "ascii":
        case "latin1":
        case "binary":
          return P(this, l, h, b);
        case "base64":
          return F(this, l, h, b);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, b);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + M);
          M = ("" + M).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(127 & l[k]);
    return M;
  }
  function y(l, h, b) {
    let M = "";
    b = Math.min(l.length, b);
    for (let k = h; k < b; ++k)
      M += String.fromCharCode(l[k]);
    return M;
  }
  function g(l, h, b) {
    const M = l.length;
    (!h || h < 0) && (h = 0), (!b || b < 0 || b > M) && (b = M);
    let k = "";
    for (let x = h; x < b; ++x)
      k += We[l[x]];
    return k;
  }
  function v(l, h, b) {
    const M = l.slice(h, b);
    let k = "";
    for (let x = 0; x < M.length - 1; x += 2)
      k += String.fromCharCode(M[x] + 256 * M[x + 1]);
    return k;
  }
  function E(l, h, b) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > b)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function A(l, h, b, M, k, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > k || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (b + M > l.length)
      throw new RangeError("Index out of range");
  }
  function L(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x, x >>= 8, l[b++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, O >>= 8, l[b++] = O, b;
  }
  function j(l, h, b, M, k) {
    ue(h, M, k, l, b, 7);
    let x = Number(h & BigInt(4294967295));
    l[b + 7] = x, x >>= 8, l[b + 6] = x, x >>= 8, l[b + 5] = x, x >>= 8, l[b + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[b + 3] = O, O >>= 8, l[b + 2] = O, O >>= 8, l[b + 1] = O, O >>= 8, l[b] = O, b + 8;
  }
  function J(l, h, b, M, k, x) {
    if (b + M > l.length)
      throw new RangeError("Index out of range");
    if (b < 0)
      throw new RangeError("Index out of range");
  }
  function X(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 4), a.write(l, h, b, M, 23, 4), b + 4;
  }
  function re(l, h, b, M, k) {
    return h = +h, b >>>= 0, k || J(l, 0, b, 8), a.write(l, h, b, M, 52, 8), b + 8;
  }
  d.prototype.slice = function(l, h) {
    const b = this.length;
    (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (h = h === void 0 ? b : ~~h) < 0 ? (h += b) < 0 && (h = 0) : h > b && (h = b), h < l && (h = l);
    const M = this.subarray(l, h);
    return Object.setPrototypeOf(M, d.prototype), M;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return M;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l + --h], k = 1;
    for (; h > 0 && (k *= 256); )
      M += this[l + --h] * k;
    return M;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, k = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
    return BigInt(M) + (BigInt(k) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], k = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
    return (BigInt(M) << BigInt(32)) + BigInt(k);
  }), d.prototype.readIntLE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = this[l], k = 1, x = 0;
    for (; ++x < h && (k *= 256); )
      M += this[l + x] * k;
    return k *= 128, M >= k && (M -= Math.pow(2, 8 * h)), M;
  }, d.prototype.readIntBE = function(l, h, b) {
    l >>>= 0, h >>>= 0, b || E(l, h, this.length);
    let M = h, k = 1, x = this[l + --M];
    for (; M > 0 && (k *= 256); )
      x += this[l + --M] * k;
    return k *= 128, x >= k && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l] | this[l + 1] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const b = this[l + 1] | this[l] << 8;
    return 32768 & b ? 4294901760 | b : b;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
    return (BigInt(M) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    se(l >>>= 0, "offset");
    const h = this[l], b = this[l + 7];
    h !== void 0 && b !== void 0 || ce(l, this.length - 8);
    const M = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(M) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = 1, x = 0;
    for (this[h] = 255 & l; ++x < b && (k *= 256); )
      this[h + x] = l / k & 255;
    return h + b;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, b, M) {
    l = +l, h >>>= 0, b >>>= 0, M || A(this, l, h, b, Math.pow(2, 8 * b) - 1, 0);
    let k = b - 1, x = 1;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      this[h + k] = l / x & 255;
    return h + b;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++k < b && (x *= 256); )
      l < 0 && O === 0 && this[h + k - 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeIntBE = function(l, h, b, M) {
    if (l = +l, h >>>= 0, !M) {
      const G = Math.pow(2, 8 * b - 1);
      A(this, l, h, b, G - 1, -G);
    }
    let k = b - 1, x = 1, O = 0;
    for (this[h + k] = 255 & l; --k >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + k + 1] !== 0 && (O = 1), this[h + k] = (l / x >> 0) - O & 255;
    return h + b;
  }, d.prototype.writeInt8 = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, b) {
    return l = +l, h >>>= 0, b || A(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, b) {
    return X(this, l, h, !0, b);
  }, d.prototype.writeFloatBE = function(l, h, b) {
    return X(this, l, h, !1, b);
  }, d.prototype.writeDoubleLE = function(l, h, b) {
    return re(this, l, h, !0, b);
  }, d.prototype.writeDoubleBE = function(l, h, b) {
    return re(this, l, h, !1, b);
  }, d.prototype.copy = function(l, h, b, M) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (b || (b = 0), M || M === 0 || (M = this.length), h >= l.length && (h = l.length), h || (h = 0), M > 0 && M < b && (M = b), M === b || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (b < 0 || b >= this.length)
      throw new RangeError("Index out of range");
    if (M < 0)
      throw new RangeError("sourceEnd out of bounds");
    M > this.length && (M = this.length), l.length - h < M - b && (M = l.length - h + b);
    const k = M - b;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, b, M) : Uint8Array.prototype.set.call(l, this.subarray(b, M), h), k;
  }, d.prototype.fill = function(l, h, b, M) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (M = h, h = 0, b = this.length) : typeof b == "string" && (M = b, b = this.length), M !== void 0 && typeof M != "string")
        throw new TypeError("encoding must be a string");
      if (typeof M == "string" && !d.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (M === "utf8" && x < 128 || M === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < b)
      throw new RangeError("Out of range index");
    if (b <= h)
      return this;
    let k;
    if (h >>>= 0, b = b === void 0 ? this.length : b >>> 0, l || (l = 0), typeof l == "number")
      for (k = h; k < b; ++k)
        this[k] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, M), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (k = 0; k < b - h; ++k)
        this[k + h] = x[k % O];
    }
    return this;
  };
  const Z = {};
  function ie(l, h, b) {
    Z[l] = class extends b {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(M) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: M, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function oe(l) {
    let h = "", b = l.length;
    const M = l[0] === "-" ? 1 : 0;
    for (; b >= M + 4; b -= 3)
      h = `_${l.slice(b - 3, b)}${h}`;
    return `${l.slice(0, b)}${h}`;
  }
  function ue(l, h, b, M, k, x) {
    if (l > b || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${b}${O}`, new Z.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, Q) {
      se(G, "offset"), O[G] !== void 0 && O[G + Q] !== void 0 || ce(G, O.length - (Q + 1));
    })(M, k, x);
  }
  function se(l, h) {
    if (typeof l != "number")
      throw new Z.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function ce(l, h, b) {
    throw Math.floor(l) !== l ? (se(l, b), new Z.ERR_OUT_OF_RANGE(b || "offset", "an integer", l)) : h < 0 ? new Z.ERR_BUFFER_OUT_OF_BOUNDS() : new Z.ERR_OUT_OF_RANGE(b || "offset", `>= ${b ? 1 : 0} and <= ${h}`, l);
  }
  ie("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), ie("ERR_OUT_OF_RANGE", function(l, h, b) {
    let M = `The value of "${l}" is out of range.`, k = b;
    return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? k = oe(String(b)) : typeof b == "bigint" && (k = String(b), (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (k = oe(k)), k += "n"), M += ` It must be ${h}. Received ${k}`, M;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let b;
    h = h || 1 / 0;
    const M = l.length;
    let k = null;
    const x = [];
    for (let O = 0; O < M; ++O) {
      if (b = l.charCodeAt(O), b > 55295 && b < 57344) {
        if (!k) {
          if (b > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === M) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          k = b;
          continue;
        }
        if (b < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), k = b;
          continue;
        }
        b = 65536 + (k - 55296 << 10 | b - 56320);
      } else
        k && (h -= 3) > -1 && x.push(239, 191, 189);
      if (k = null, b < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(b);
      } else if (b < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(b >> 6 | 192, 63 & b | 128);
      } else if (b < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(b >> 12 | 224, b >> 6 & 63 | 128, 63 & b | 128);
      } else {
        if (!(b < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, 63 & b | 128);
      }
    }
    return x;
  }
  function $e(l) {
    return n.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function fe(l, h, b, M) {
    let k;
    for (k = 0; k < M && !(k + b >= h.length || k >= l.length); ++k)
      h[k + b] = l[k];
    return k;
  }
  function le(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let b = 0; b < 16; ++b) {
      const M = 16 * b;
      for (let k = 0; k < 16; ++k)
        h[M + k] = l[b] + l[k];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer), commonjsGlobal.fetch = window.fetch, npmBrowser.buffer = buffer.Buffer;
const Buffer$2 = npmBrowser.Buffer, leb = leb128$1, Stream = bufferPipe, OP_IMMEDIATES = require$$0$1, _exports = json2wasm.exports = (o) => _exports.generate(o).buffer, LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = { i32: 127, i64: 126, f32: 125, f64: 124, anyFunc: 112, func: 96, block_type: 64 }, EXTERNAL_KIND = _exports.EXTERNAL_KIND = { function: 0, table: 1, memory: 2, global: 3 }, SECTION_IDS = _exports.SECTION_IDS = { custom: 0, type: 1, import: 2, function: 3, table: 4, memory: 5, global: 6, export: 7, start: 8, element: 9, code: 10, data: 11 }, OPCODES = _exports.OPCODES = { unreachable: 0, nop: 1, block: 2, loop: 3, if: 4, else: 5, end: 11, br: 12, br_if: 13, br_table: 14, return: 15, call: 16, call_indirect: 17, drop: 26, select: 27, get_local: 32, set_local: 33, tee_local: 34, get_global: 35, set_global: 36, "i32.load": 40, "i64.load": 41, "f32.load": 42, "f64.load": 43, "i32.load8_s": 44, "i32.load8_u": 45, "i32.load16_s": 46, "i32.load16_u": 47, "i64.load8_s": 48, "i64.load8_u": 49, "i64.load16_s": 50, "i64.load16_u": 51, "i64.load32_s": 52, "i64.load32_u": 53, "i32.store": 54, "i64.store": 55, "f32.store": 56, "f64.store": 57, "i32.store8": 58, "i32.store16": 59, "i64.store8": 60, "i64.store16": 61, "i64.store32": 62, current_memory: 63, grow_memory: 64, "i32.const": 65, "i64.const": 66, "f32.const": 67, "f64.const": 68, "i32.eqz": 69, "i32.eq": 70, "i32.ne": 71, "i32.lt_s": 72, "i32.lt_u": 73, "i32.gt_s": 74, "i32.gt_u": 75, "i32.le_s": 76, "i32.le_u": 77, "i32.ge_s": 78, "i32.ge_u": 79, "i64.eqz": 80, "i64.eq": 81, "i64.ne": 82, "i64.lt_s": 83, "i64.lt_u": 84, "i64.gt_s": 85, "i64.gt_u": 86, "i64.le_s": 87, "i64.le_u": 88, "i64.ge_s": 89, "i64.ge_u": 90, "f32.eq": 91, "f32.ne": 92, "f32.lt": 93, "f32.gt": 94, "f32.le": 95, "f32.ge": 96, "f64.eq": 97, "f64.ne": 98, "f64.lt": 99, "f64.gt": 100, "f64.le": 101, "f64.ge": 102, "i32.clz": 103, "i32.ctz": 104, "i32.popcnt": 105, "i32.add": 106, "i32.sub": 107, "i32.mul": 108, "i32.div_s": 109, "i32.div_u": 110, "i32.rem_s": 111, "i32.rem_u": 112, "i32.and": 113, "i32.or": 114, "i32.xor": 115, "i32.shl": 116, "i32.shr_s": 117, "i32.shr_u": 118, "i32.rotl": 119, "i32.rotr": 120, "i64.clz": 121, "i64.ctz": 122, "i64.popcnt": 123, "i64.add": 124, "i64.sub": 125, "i64.mul": 126, "i64.div_s": 127, "i64.div_u": 128, "i64.rem_s": 129, "i64.rem_u": 130, "i64.and": 131, "i64.or": 132, "i64.xor": 133, "i64.shl": 134, "i64.shr_s": 135, "i64.shr_u": 136, "i64.rotl": 137, "i64.rotr": 138, "f32.abs": 139, "f32.neg": 140, "f32.ceil": 141, "f32.floor": 142, "f32.trunc": 143, "f32.nearest": 144, "f32.sqrt": 145, "f32.add": 146, "f32.sub": 147, "f32.mul": 148, "f32.div": 149, "f32.min": 150, "f32.max": 151, "f32.copysign": 152, "f64.abs": 153, "f64.neg": 154, "f64.ceil": 155, "f64.floor": 156, "f64.trunc": 157, "f64.nearest": 158, "f64.sqrt": 159, "f64.add": 160, "f64.sub": 161, "f64.mul": 162, "f64.div": 163, "f64.min": 164, "f64.max": 165, "f64.copysign": 166, "i32.wrap/i64": 167, "i32.trunc_s/f32": 168, "i32.trunc_u/f32": 169, "i32.trunc_s/f64": 170, "i32.trunc_u/f64": 171, "i64.extend_s/i32": 172, "i64.extend_u/i32": 173, "i64.trunc_s/f32": 174, "i64.trunc_u/f32": 175, "i64.trunc_s/f64": 176, "i64.trunc_u/f64": 177, "f32.convert_s/i32": 178, "f32.convert_u/i32": 179, "f32.convert_s/i64": 180, "f32.convert_u/i64": 181, "f32.demote/f64": 182, "f64.convert_s/i32": 183, "f64.convert_u/i32": 184, "f64.convert_s/i64": 185, "f64.convert_u/i64": 186, "f64.promote/f32": 187, "i32.reinterpret/f32": 188, "i64.reinterpret/f64": 189, "f32.reinterpret/i32": 190, "f64.reinterpret/i64": 191 };
_exports.typeGenerators = { function: (o, n) => {
  leb.unsigned.write(o, n);
}, table: (o, n) => {
  n.write([LANGUAGE_TYPES[o.elementType]]), _exports.typeGenerators.memory(o.limits, n);
}, global: (o, n) => {
  n.write([LANGUAGE_TYPES[o.contentType]]), n.write([o.mutability]);
}, memory: (o, n) => {
  leb.unsigned.write(Number(o.maximum !== void 0), n), leb.unsigned.write(o.intial, n), o.maximum !== void 0 && leb.unsigned.write(o.maximum, n);
}, initExpr: (o, n) => {
  _exports.generateOp(o, n), _exports.generateOp({ name: "end", type: "void" }, n);
} }, _exports.immediataryGenerators = { varuint1: (o, n) => (n.write([o]), n), varuint32: (o, n) => (leb.unsigned.write(o, n), n), varint32: (o, n) => (leb.signed.write(o, n), n), varint64: (o, n) => (leb.signed.write(o, n), n), uint32: (o, n) => (n.write(o), n), uint64: (o, n) => (n.write(o), n), block_type: (o, n) => (n.write([LANGUAGE_TYPES[o]]), n), br_table: (o, n) => {
  leb.unsigned.write(o.targets.length, n);
  for (let a of o.targets)
    leb.unsigned.write(a, n);
  return leb.unsigned.write(o.defaultTarget, n), n;
}, call_indirect: (o, n) => (leb.unsigned.write(o.index, n), n.write([o.reserved]), n), memory_immediate: (o, n) => (leb.unsigned.write(o.flags, n), leb.unsigned.write(o.offset, n), n) };
const entryGenerators = { type: (o, n = new Stream()) => {
  n.write([LANGUAGE_TYPES[o.form]]);
  const a = o.params.length;
  return leb.unsigned.write(a, n), a !== 0 && n.write(o.params.map((u) => LANGUAGE_TYPES[u])), n.write([o.return_type ? 1 : 0]), o.return_type && n.write([LANGUAGE_TYPES[o.return_type]]), n.buffer;
}, import: (o, n = new Stream()) => {
  leb.unsigned.write(o.moduleStr.length, n), n.write(o.moduleStr), leb.unsigned.write(o.fieldStr.length, n), n.write(o.fieldStr), n.write([EXTERNAL_KIND[o.kind]]), _exports.typeGenerators[o.kind](o.type, n);
}, function: (o, n = new Stream()) => (leb.unsigned.write(o, n), n.buffer), table: _exports.typeGenerators.table, global: (o, n = new Stream()) => (_exports.typeGenerators.global(o.type, n), _exports.typeGenerators.initExpr(o.init, n), n), memory: _exports.typeGenerators.memory, export: (o, n = new Stream()) => {
  const a = Buffer$2.from(o.field_str), u = a.length;
  return leb.unsigned.write(u, n), n.write(a), n.write([EXTERNAL_KIND[o.kind]]), leb.unsigned.write(o.index, n), n;
}, element: (o, n = new Stream()) => {
  leb.unsigned.write(o.index, n), _exports.typeGenerators.initExpr(o.offset, n), leb.unsigned.write(o.elements.length, n);
  for (let a of o.elements)
    leb.unsigned.write(a, n);
  return n;
}, code: (o, n = new Stream()) => {
  let a = new Stream();
  leb.unsigned.write(o.locals.length, a);
  for (let u of o.locals)
    leb.unsigned.write(u.count, a), a.write([LANGUAGE_TYPES[u.type]]);
  for (let u of o.code)
    _exports.generateOp(u, a);
  return leb.unsigned.write(a.bytesWrote, n), n.write(a.buffer), n;
}, data: (o, n = new Stream()) => (leb.unsigned.write(o.index, n), _exports.typeGenerators.initExpr(o.offset, n), leb.unsigned.write(o.data.length, n), n.write(o.data), n) };
_exports.entryGenerators = entryGenerators, _exports.generateSection = function(o, n = new Stream()) {
  const a = o.name, u = new Stream();
  if (n.write([SECTION_IDS[a]]), a === "custom")
    leb.unsigned.write(o.sectionName.length, u), u.write(o.sectionName), u.write(o.payload);
  else if (a === "start")
    leb.unsigned.write(o.index, u);
  else {
    leb.unsigned.write(o.entries.length, u);
    for (let c of o.entries)
      entryGenerators[a](c, u);
  }
  return leb.unsigned.write(u.bytesWrote, n), n.write(u.buffer), n;
}, _exports.generate = (o, n = new Stream()) => {
  const [a, ...u] = o;
  _exports.generatePreramble(a, n);
  for (let c of u)
    _exports.generateSection(c, n);
  return n;
}, _exports.generatePreramble = (o, n = new Stream()) => (n.write(o.magic), n.write(o.version), n), _exports.generateOp = (o, n = new Stream()) => {
  let a = o.name;
  o.return_type !== void 0 && (a = o.return_type + "." + a), n.write([OPCODES[a]]);
  const u = OP_IMMEDIATES[o.name === "const" ? o.return_type : o.name];
  return u && _exports.immediataryGenerators[u](o.immediates, n), n;
};
const immediates = require$$0$1;
var text2json = (o) => {
  const n = [], a = o.split(/\s|\n/);
  for (; a.length; ) {
    const u = a.shift(), c = {};
    let [m, d] = u.split(".");
    d === void 0 ? d = m : c.return_type = m, c.name = d;
    const w = immediates[c.name === "const" ? c.return_type : c.name];
    w && (c.immediates = immediataryParser(w, a)), n.push(c);
  }
  return n;
};
function immediataryParser(o, n) {
  const a = {};
  switch (o) {
    case "br_table":
      const u = [];
      for (; ; ) {
        let c = n[0];
        if (isNaN(c))
          break;
        n.shift(), u.push(c);
      }
      return u;
    case "call_indirect":
      return a.index = n.shift(), a.reserved = 0, a;
    case "memory_immediate":
      return a.flags = n.shift(), a.offset = n.shift(), a;
    default:
      return n.shift();
  }
}
const Buffer$1 = npmBrowser.Buffer, leb128 = leb128$1.unsigned, wasm2json = wasm2json$1.exports, Pipe = bufferPipe, SECTIONS = ["custom", "type", "import", "function", "table", "memory", "global", "export", "start", "element", "code", "data"];
var iterator = class {
  constructor(o) {
    this._wasm = o, this._sections = [], this._modified = !1;
  }
  get wasm() {
    return this._modified && (this._wasm = Buffer$1.concat(this._sections.concat(this._pipe.buffer)), this._modified = !1), this._wasm;
  }
  *[Symbol.iterator]() {
    for (this._pipe = new Pipe(this._wasm), this._sections = [this._pipe.read(8)]; !this._pipe.end; ) {
      const o = this._pipe.bytesRead, n = this._pipe.read(1)[0], a = Number(leb128.read(this._pipe)), u = this._pipe.read(a), c = this._pipe.bytesRead, m = this._wasm.slice(o, c), d = this._sections.push(m) - 1;
      yield new Section(n, u, this, d);
    }
  }
  _update(o, n) {
    this._modified = !0, this._sections[o] = n;
  }
};
class Section {
  constructor(n, a, u, c) {
    this._it = u, this._index = c, this.type = SECTIONS[n], this._type = n, this._section = a;
    const m = new Pipe(a);
    this.type !== "custom" && (this.count = Number(leb128.read(m))), this._body = m.buffer;
  }
  toJSON() {
    return wasm2json.sectionParsers[this.type](new Pipe(this._section));
  }
  appendEntries(n) {
    this.count += n.length, this._body = Buffer$1.concat([this._body].concat(n));
    const a = Buffer$1.concat([leb128.encode(this.count), this._body]);
    this._it._update(this._index, Buffer$1.concat([Buffer$1.from([this._type]), leb128.encode(a.length), a]));
  }
}
redstoneWasmJsonToolkit.wasm2json = wasm2json$1.exports, redstoneWasmJsonToolkit.json2wasm = json2wasm.exports, redstoneWasmJsonToolkit.text2json = text2json, redstoneWasmJsonToolkit.Iterator = iterator;
const start = 0, type = { params: { DEFAULT: 0 }, return_type: { DEFAULT: 0 } }, code = { locals: { DEFAULT: 1 }, code: { get_local: 120, set_local: 120, tee_local: 120, get_global: 120, set_global: 120, load8_s: 120, load8_u: 120, load16_s: 120, load16_u: 120, load32_s: 120, load32_u: 120, load: 120, store8: 120, store16: 120, store32: 120, store: 120, grow_memory: 1e4, current_memory: 100, nop: 1, block: 1, loop: 1, if: 1, then: 90, else: 90, br: 90, br_if: 90, br_table: 120, return: 90, call: 90, call_indirect: 1e4, const: 1, add: 45, sub: 45, mul: 45, div_s: 36e3, div_u: 36e3, rem_s: 36e3, rem_u: 36e3, and: 45, or: 45, xor: 45, shl: 67, shr_u: 67, shr_s: 67, rotl: 90, rotr: 90, eq: 45, eqz: 45, ne: 45, lt_s: 45, lt_u: 45, le_s: 45, le_u: 45, gt_s: 45, gt_u: 45, ge_s: 45, ge_u: 45, clz: 45, ctz: 45, popcnt: 45, drop: 120, select: 120, unreachable: 1 } }, data = 0, require$$2 = { start, type, import: 0, code, data };
(function(o) {
  const n = redstoneWasmJsonToolkit, a = n.text2json, u = json2wasm.exports.SECTION_IDS, c = require$$2;
  function m(w, S = {}, T = 0) {
    let B = 0;
    if (T = S.DEFAULT !== void 0 ? S.DEFAULT : 0, Array.isArray(w))
      w.forEach((I) => {
        B += m(I, S);
      });
    else if (typeof w == "object")
      for (const I in w) {
        const C = S[I];
        C && (B += m(w[I], C, T));
      }
    else
      B = S[w] === void 0 ? T : S[w];
    return B;
  }
  function d(w, S, T, B, I) {
    function C(V, ee) {
      return a(`${B}.const ${V} call ${ee}`);
    }
    function N(V, ee) {
      V.name === "call" && V.immediates >= ee && (V.immediates = (++V.immediates).toString());
    }
    const q = /* @__PURE__ */ new Set(["grow_memory", "end", "br", "br_table", "br_if", "if", "else", "return", "loop"]), D = C(0, 0).reduce((V, ee) => V + m(ee.name, S.code), 0);
    let z = w.code.slice(), W = [];
    for (I += m(w.locals, S.local); z.length; ) {
      let V = 0;
      for (; ; ) {
        const ee = z[V++];
        if (N(ee, T), I += m(ee.name, S.code), q.has(ee.name))
          break;
      }
      I !== 0 && (I += D, W = W.concat(C(I, T))), W = W.concat(z.slice(0, V)), z = z.slice(V), I = 0;
    }
    return w.code = W, w;
  }
  o.meterJSON = (w, S) => {
    function T(P, F) {
      return P.find((H) => H.name === F);
    }
    function B(P, F) {
      const H = u[F];
      for (let te in P) {
        const p = P[te], $ = u[p.name];
        if ($ && H < $)
          return void P.splice(te, 0, { name: F, entries: [] });
      }
    }
    let I, C, N = 0, { costTable: q, moduleStr: D, fieldStr: z, meterType: W } = S;
    q || (q = c), D || (D = "metering"), z || (z = "usegas"), W || (W = "i32"), T(w, "type") || B(w, "type"), T(w, "import") || B(w, "import");
    const V = { moduleStr: D, fieldStr: z, kind: "function" }, ee = { form: "func", params: [W] };
    w = w.slice(0);
    for (let P of w)
      switch (P = Object.assign(P), P.name) {
        case "type":
          V.type = P.entries.push(ee) - 1, C = P;
          break;
        case "function":
          I = P;
          break;
        case "import":
          for (const F of P.entries) {
            if (F.moduleStr === D && F.fieldStr === z)
              throw new Error("importing metering function is not allowed");
            F.kind === "function" && N++;
          }
          P.entries.push(V);
          break;
        case "export":
          for (const F of P.entries)
            F.kind === "function" && F.index >= N && F.index++;
          break;
        case "element":
          for (const F of P.entries)
            F.elements = F.elements.map((H) => H >= N ? ++H : H);
          break;
        case "start":
          P.index >= N && P.index++;
          break;
        case "code":
          for (const F in P.entries) {
            const H = P.entries[F], te = I.entries[F], p = m(C.entries[te], q.type);
            d(H, q.code, N, W, p);
          }
      }
    return w;
  }, o.meterWASM = (w, S = {}) => {
    let T = n.wasm2json(w);
    return T = o.meterJSON(T, S), n.json2wasm(T);
  };
})(redstoneWasmMetering);
var wasmBindgenTools = {};
function matchMutClosureDtor(o) {
  return o.match(/(const|var) ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/)[2];
}
Object.defineProperty(wasmBindgenTools, "__esModule", { value: !0 }), wasmBindgenTools.matchMutClosureDtor = void 0, wasmBindgenTools.matchMutClosureDtor = matchMutClosureDtor;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(SourceImpl$1, "__esModule", { value: !0 }), SourceImpl$1.SourceImpl = void 0;
const redstone_wasm_metering_1 = __importDefault$2(redstoneWasmMetering), go_wasm_imports_1 = goWasmImports, fs_1 = __importDefault$2(require$$2$1), wasm_bindgen_tools_1 = wasmBindgenTools, SmartWeaveTags_1$1 = SmartWeaveTags, LoggerFactory_1$3 = LoggerFactory$1, redstone_isomorphic_1$1 = npmBrowser$1, wasmTypeMapping = /* @__PURE__ */ new Map([[1, "assemblyscript"], [2, "rust"], [3, "go"]]);
class SourceImpl {
  constructor(n) {
    this.arweave = n, this.logger = LoggerFactory_1$3.LoggerFactory.INST.create("Source");
  }
  async save(n, a, u = !1) {
    this.logger.debug("Creating new contract source");
    const { src: c, wasmSrcCodeDir: m, wasmGlueCode: d } = n, w = c instanceof redstone_isomorphic_1$1.Buffer ? "wasm" : "js";
    let S, T = null, B = null;
    const I = {}, C = [];
    if (w == "wasm") {
      const z = redstone_wasm_metering_1.default.meterWASM(c, { meterType: "i32" });
      C.push(z);
      const W = await WebAssembly.compile(c), V = WebAssembly.Module.imports(W);
      let ee;
      if (this.isGoModule(V)) {
        const F = new go_wasm_imports_1.Go(null), H = new WebAssembly.Instance(W, F.importObject);
        F.run(H), ee = F.exports.lang(), B = F.exports.version();
      } else {
        const F = await WebAssembly.instantiate(c, dummyImports(V));
        if (!F.instance.exports.lang)
          throw new Error('No info about source type in wasm binary. Did you forget to export "lang" function?');
        if (ee = F.instance.exports.lang(), B = F.instance.exports.version(), !wasmTypeMapping.has(ee))
          throw new Error(`Unknown wasm source type ${ee}`);
      }
      if (T = wasmTypeMapping.get(ee), m == null)
        throw new Error("No path to original wasm contract source code");
      const P = await this.zipContents(m);
      if (C.push(P), T == "rust") {
        if (!d)
          throw new Error("No path to generated wasm-bindgen js code");
        const F = fs_1.default.readFileSync(d, "utf-8"), H = (0, wasm_bindgen_tools_1.matchMutClosureDtor)(F);
        I.dtor = parseInt(H), C.push(redstone_isomorphic_1$1.Buffer.from(F));
      }
    }
    const N = w == "wasm" ? this.joinBuffers(C) : c;
    S = typeof a == "function" ? await this.arweave.createTransaction({ data: N }) : await this.arweave.createTransaction({ data: N }, a), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_NAME, "SmartWeaveContractSource"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_VERSION, "0.3.0"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.SDK, "Warp"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.CONTENT_TYPE, w == "js" ? "application/javascript" : "application/wasm"), w == "wasm" && (S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG, T), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG_VERSION, B), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_META, JSON.stringify(I))), typeof a == "function" ? await a(S) : await this.arweave.transactions.sign(S, a), this.logger.debug("Posting transaction with source");
    let q, D = !0;
    if (u || (q = await this.arweave.transactions.post(S), D = q.status === 200 || q.status === 208), D)
      return S;
    throw new Error(`Unable to write Contract Source. Arweave responded with status ${q.status}: ${q.statusText}`);
  }
  isGoModule(n) {
    return n.some((a) => a.module == "env" && a.name.startsWith("syscall/js"));
  }
  joinBuffers(n) {
    const a = n.length, u = [];
    return u.push(redstone_isomorphic_1$1.Buffer.from(a.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|")), n.forEach((c) => {
      u.push(redstone_isomorphic_1$1.Buffer.from(c.length.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|"));
    }), u.push(...n), u.reduce((c, m) => redstone_isomorphic_1$1.Buffer.concat([c, m]));
  }
  async zipContents(n) {
    const a = require$$2$1, u = new require$$2$1.WritableStreamBuffer({ initialSize: 1024e3, incrementAmount: 1024e3 }), c = a("zip", { zlib: { level: 9 } });
    return c.on("error", function(m) {
      throw m;
    }), c.pipe(u), c.directory(n.toString(), n.toString()), await c.finalize(), u.end(), u.getContents();
  }
}
function dummyImports(o) {
  const n = {};
  return o.forEach((a) => {
    Object.prototype.hasOwnProperty.call(n, a.module) || (n[a.module] = {}), n[a.module][a.name] = function() {
    };
  }), n;
}
var hasRequiredDefaultCreateContract;
function requireDefaultCreateContract() {
  if (hasRequiredDefaultCreateContract)
    return DefaultCreateContract;
  hasRequiredDefaultCreateContract = 1, Object.defineProperty(DefaultCreateContract, "__esModule", { value: !0 }), DefaultCreateContract.DefaultCreateContract = void 0;
  const o = SmartWeaveTags, n = requireWarpFactory(), a = LoggerFactory$1, u = SourceImpl$1;
  return DefaultCreateContract.DefaultCreateContract = class {
    constructor(c, m) {
      this.arweave = c, this.warp = m, this.logger = a.LoggerFactory.INST.create("DefaultCreateContract"), this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
    }
    async deploy(c, m) {
      const { wallet: d, initState: w, tags: S, transfer: T, data: B } = c, I = m == null ? this.warp.definitionLoader.type() == "warp" : !m, C = new u.SourceImpl(this.arweave), N = await C.save(c, d, I);
      return this.logger.debug("Creating new contract"), await this.deployFromSourceTx({ srcTxId: N.id, wallet: d, initState: w, tags: S, transfer: T, data: B }, !I, N);
    }
    async deployFromSourceTx(c, m, d = null) {
      this.logger.debug("Creating new contract from src tx");
      const { wallet: w, srcTxId: S, initState: T, tags: B, transfer: I, data: C } = c, N = m == null ? this.warp.definitionLoader.type() == "warp" : !m;
      let q, D, z = await this.arweave.createTransaction({ data: (C == null ? void 0 : C.body) || T }, w);
      if (+(I == null ? void 0 : I.winstonQty) > 0 && I.target.length && (this.logger.debug("Creating additional transaction with AR transfer", I), z = await this.arweave.createTransaction({ data: (C == null ? void 0 : C.body) || T, target: I.target, quantity: I.winstonQty }, w)), B == null ? void 0 : B.length)
        for (const W of B)
          z.addTag(W.name.toString(), W.value.toString());
      if (z.addTag(o.SmartWeaveTags.APP_NAME, "SmartWeaveContract"), z.addTag(o.SmartWeaveTags.APP_VERSION, "0.3.0"), z.addTag(o.SmartWeaveTags.CONTRACT_SRC_TX_ID, S), z.addTag(o.SmartWeaveTags.SDK, "RedStone"), C ? (z.addTag(o.SmartWeaveTags.CONTENT_TYPE, C["Content-Type"]), z.addTag(o.SmartWeaveTags.INIT_STATE, T)) : z.addTag(o.SmartWeaveTags.CONTENT_TYPE, "application/json"), await this.arweave.transactions.sign(z, w), N) {
        const W = await this.post(z, d);
        this.logger.debug(W), q = !0;
      } else
        D = await this.arweave.transactions.post(z), q = D.status === 200 || D.status === 208;
      if (q)
        return { contractTxId: z.id, srcTxId: S };
      throw new Error(`Unable to write Contract. Arweave responded with status ${D.status}: ${D.statusText}`);
    }
    async post(c, m = null) {
      let d = { contractTx: c };
      m && (d = { ...d, srcTx: m });
      const w = await fetch(`${n.WARP_GW_URL}/gateway/contracts/deploy`, { method: "POST", body: JSON.stringify(d), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } });
      if (w.ok)
        return w.json();
      throw new Error(`Error while posting contract. Sequencer responded with status ${w.status} ${w.statusText}`);
    }
  }, DefaultCreateContract;
}
SourceImpl$1.SourceImpl = SourceImpl;
var HandlerBasedContract = {}, ContractCallRecord$1 = {};
Object.defineProperty(ContractCallRecord$1, "__esModule", { value: !0 }), ContractCallRecord$1.InteractionOutput = ContractCallRecord$1.InteractionInput = ContractCallRecord$1.InteractionCall = ContractCallRecord$1.ContractCallRecord = void 0;
const utils_1$1 = utils$n;
class ContractCallRecord {
  constructor(n, a, u = null) {
    this.contractTxId = n, this.depth = a, this.innerCallType = u, this.interactions = {}, this.id = (0, utils_1$1.isomorphicRandomUUID)();
  }
  addInteractionData(n) {
    const { interaction: a, interactionTx: u } = n, c = InteractionCall.create(new InteractionInput(u.id, u.sortKey, u.block.height, u.block.timestamp, a == null ? void 0 : a.caller, a == null ? void 0 : a.input.function, a == null ? void 0 : a.input, u.dry, {}));
    return this.interactions[u.id] = c, c;
  }
  getInteraction(n) {
    return this.interactions[n];
  }
  print() {
    return JSON.stringify(this, null, 2);
  }
}
ContractCallRecord$1.ContractCallRecord = ContractCallRecord;
class InteractionCall {
  constructor(n) {
    this.interactionInput = n;
  }
  static create(n) {
    return new InteractionCall(n);
  }
  update(n) {
    this.interactionOutput = n;
  }
}
ContractCallRecord$1.InteractionCall = InteractionCall;
class InteractionInput {
  constructor(n, a, u, c, m, d, w, S, T = {}) {
    this.txId = n, this.sortKey = a, this.blockHeight = u, this.blockTimestamp = c, this.caller = m, this.functionName = d, this.functionArguments = w, this.dryWrite = S, this.foreignContractCalls = T;
  }
}
ContractCallRecord$1.InteractionInput = InteractionInput;
class InteractionOutput {
  constructor(n, a, u, c, m = "", d) {
    this.cacheHit = n, this.outputState = a, this.executionTime = u, this.valid = c, this.errorMessage = m, this.gasUsed = d;
  }
}
ContractCallRecord$1.InteractionOutput = InteractionOutput;
var createInteractionTx$1 = {};
Object.defineProperty(createInteractionTx$1, "__esModule", { value: !0 }), createInteractionTx$1.unpackTags = createInteractionTx$1.createDummyTx = createInteractionTx$1.createInteractionTx = void 0;
const SmartWeaveTags_1 = SmartWeaveTags;
async function createInteractionTx(o, n, a, u, c, m = "", d = "0", w = !1, S) {
  const T = { data: Math.random().toString().slice(-4) };
  m && m.length && (T.target = m.toString(), d && +d > 0 && (T.quantity = d.toString())), w && (T.reward = "72600854", T.last_tx = "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO"), S && S.length && (T.reward = S);
  const B = await o.createTransaction(T);
  if (!u)
    throw new Error(`Input should be a truthy value: ${JSON.stringify(u)}`);
  if (c && c.length)
    for (const I of c)
      B.addTag(I.name.toString(), I.value.toString());
  return B.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, "SmartWeaveAction"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, "0.3.0"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, "Warp"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID, a), B.addTag(SmartWeaveTags_1.SmartWeaveTags.INPUT, JSON.stringify(u)), n && await n(B), B;
}
function createDummyTx(o, n, a) {
  const u = unpackTags(o);
  return { id: o.id, owner: { address: n, key: "" }, recipient: o.target, tags: u, fee: { winston: o.reward, ar: "" }, quantity: { winston: o.quantity, ar: "" }, block: { id: a.indep_hash, height: a.height, timestamp: a.timestamp, previous: null }, dry: !0, anchor: null, signature: null, data: null, parent: null, bundledIn: null };
}
function unpackTags(o) {
  const n = o.get("tags"), a = [];
  for (const u of n)
    try {
      const c = u.get("name", { decode: !0, string: !0 }), m = u.get("value", { decode: !0, string: !0 });
      a.push({ name: c, value: m });
    } catch {
    }
  return a;
}
createInteractionTx$1.createInteractionTx = createInteractionTx, createInteractionTx$1.createDummyTx = createDummyTx, createInteractionTx$1.unpackTags = unpackTags;
var CreateContract = {};
Object.defineProperty(CreateContract, "__esModule", { value: !0 }), CreateContract.emptyTransfer = void 0, CreateContract.emptyTransfer = { target: "", winstonQty: "0" };
var InnerWritesEvaluator$1 = {};
Object.defineProperty(InnerWritesEvaluator$1, "__esModule", { value: !0 }), InnerWritesEvaluator$1.InnerWritesEvaluator = void 0;
class InnerWritesEvaluator {
  eval(n) {
    const a = [];
    return Object.keys(n.interactions).forEach((u) => {
      const c = n.interactions[u];
      this.evalForeignCalls(n.contractTxId, c, a);
    }), a;
  }
  evalForeignCalls(n, a, u) {
    Object.keys(a.interactionInput.foreignContractCalls).forEach((c) => {
      const m = a.interactionInput.foreignContractCalls[c];
      Object.keys(m.interactions).forEach((d) => {
        const w = m.interactions[d];
        w.interactionInput.dryWrite && !u.includes(m.contractTxId) && n !== m.contractTxId && u.push(m.contractTxId), this.evalForeignCalls(n, w, u);
      });
    });
  }
}
InnerWritesEvaluator$1.InnerWritesEvaluator = InnerWritesEvaluator;
var vrf = {}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(vrf, "__esModule", { value: !0 }), vrf.generateMockVrf = void 0;
const elliptic_1 = __importDefault$1(elliptic$1), vrf_js_1 = vrfJs, utils_1 = utils$n, EC = new elliptic_1.default.ec("secp256k1"), key = EC.genKeyPair(), pubKeyS = key.getPublic(!0, "hex");
function generateMockVrf(o, n) {
  const a = n.utils.stringToBuffer(o), [u, c] = (0, vrf_js_1.Evaluate)(key.getPrivate().toArray(), a);
  return { index: n.utils.bufferTob64Url(u), proof: n.utils.bufferTob64Url(c), bigint: (0, utils_1.bufToBn)(u).toString(), pubkey: pubKeyS };
}
var hasRequiredHandlerBasedContract;
function requireHandlerBasedContract() {
  if (hasRequiredHandlerBasedContract)
    return HandlerBasedContract;
  hasRequiredHandlerBasedContract = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(P, F, H, te) {
    te === void 0 && (te = H);
    var p = Object.getOwnPropertyDescriptor(F, H);
    p && !("get" in p ? !F.__esModule : p.writable || p.configurable) || (p = { enumerable: !0, get: function() {
      return F[H];
    } }), Object.defineProperty(P, te, p);
  } : function(P, F, H, te) {
    te === void 0 && (te = H), P[te] = F[H];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(P, F) {
    Object.defineProperty(P, "default", { enumerable: !0, value: F });
  } : function(P, F) {
    P.default = F;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(P) {
    if (P && P.__esModule)
      return P;
    var F = {};
    if (P != null)
      for (var H in P)
        H !== "default" && Object.prototype.hasOwnProperty.call(P, H) && o(F, P, H);
    return n(F, P), F;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(HandlerBasedContract, "__esModule", { value: !0 }), HandlerBasedContract.HandlerBasedContract = void 0;
  const c = u(safeStableStringify.exports), m = a(require$$2$1), d = ContractCallRecord$1, w = LexicographicalInteractionsSorter, S = StateEvaluator, T = SmartWeaveTags, B = createInteractionTx$1, I = Benchmark$1, C = LoggerFactory$1, N = Evolve$1, q = requireArweaveWrapper(), D = utils$n, z = CreateContract, W = SourceImpl$1, V = InnerWritesEvaluator$1, ee = vrf;
  return HandlerBasedContract.HandlerBasedContract = class {
    constructor(P, F, H = null, te = null) {
      var p, $;
      if (this._contractTxId = P, this.warp = F, this._parentContract = H, this._innerCallData = te, this.logger = C.LoggerFactory.INST.create("HandlerBasedContract"), this._evaluationOptions = new S.DefaultEvaluationOptions(), this._innerWritesEvaluator = new V.InnerWritesEvaluator(), this._benchmarkStats = null, this.waitForConfirmation = this.waitForConfirmation.bind(this), this._arweaveWrapper = new q.ArweaveWrapper(F.arweave), this._sorter = new w.LexicographicalInteractionsSorter(F.arweave), H != null) {
        this._evaluationOptions = H.evaluationOptions(), this._callDepth = H.callDepth() + 1;
        const _ = H.getCallStack().getInteraction(te.callingInteraction.id);
        if (this._callDepth > this._evaluationOptions.maxCallDepth)
          throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(_.interactionInput)}`);
        if (this.logger.debug("Calling interaction", { id: te.callingInteraction.id, sortKey: te.callingInteraction.sortKey, type: te.callType }), (($ = (p = _.interactionInput) === null || p === void 0 ? void 0 : p.foreignContractCalls[P]) === null || $ === void 0 ? void 0 : $.innerCallType) === "write" && te.callType === "read")
          throw new Error("Calling a readContractState after performing an inner write is wrong - instead use a state from the result of an internal write.");
        const y = new d.ContractCallRecord(P, this._callDepth, te == null ? void 0 : te.callType);
        _.interactionInput.foreignContractCalls[P] = y, this._callStack = y, this._rootSortKey = H.rootSortKey;
      } else
        this._callDepth = 0, this._callStack = new d.ContractCallRecord(P, 0), this._rootSortKey = null;
      this.getCallStack = this.getCallStack.bind(this);
    }
    async readState(P, F, H) {
      var te, p, $;
      this.logger.info("Read state for", { contractTxId: this._contractTxId, currentTx: F, sortKeyOrBlockHeight: P });
      const _ = I.Benchmark.measure();
      if (this.maybeResetRootContract(), this._parentContract != null && P == null)
        throw new Error("SortKey MUST be always set for non-root contract calls");
      const { stateEvaluator: y } = this.warp, g = typeof P == "number" ? this._sorter.generateLastSortKey(P) : P, v = await this.createExecutionContext(this._contractTxId, g, !1, H);
      this.logger.info("Execution Context", { srcTxId: (te = v.contractDefinition) === null || te === void 0 ? void 0 : te.srcTxId, missingInteractions: (p = v.sortedInteractions) === null || p === void 0 ? void 0 : p.length, cachedSortKey: ($ = v.cachedState) === null || $ === void 0 ? void 0 : $.sortKey }), _.stop();
      const E = I.Benchmark.measure(), A = await y.eval(v, F || []);
      E.stop();
      const L = _.elapsed(!0) + E.elapsed(!0);
      return this._benchmarkStats = { gatewayCommunication: _.elapsed(!0), stateEvaluation: E.elapsed(!0), total: L }, this.logger.info("Benchmark", { "Gateway communication  ": _.elapsed(), "Contract evaluation    ": E.elapsed(), "Total:                 ": `${L.toFixed(0)}ms` }), A;
    }
    async viewState(P, F = [], H = z.emptyTransfer) {
      return this.logger.info("View state for", this._contractTxId), await this.callContract(P, void 0, void 0, F, H);
    }
    async viewStateForTx(P, F) {
      return this.logger.info(`View state for ${this._contractTxId}`, F), await this.callContractForTx(P, F);
    }
    async dryWrite(P, F, H, te) {
      return this.logger.info("Dry-write for", this._contractTxId), await this.callContract(P, F, void 0, H, te);
    }
    async dryWriteFromTx(P, F, H) {
      return this.logger.info(`Dry-write from transaction ${F.id} for ${this._contractTxId}`), await this.callContractForTx(P, F, H || []);
    }
    async writeInteraction(P, F) {
      if (this.logger.info("Write interaction", { input: P, options: F }), !this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: H, interactionsLoader: te, environment: p } = this.warp, $ = (F == null ? void 0 : F.tags) || [], _ = (F == null ? void 0 : F.transfer) || z.emptyTransfer, y = (F == null ? void 0 : F.strict) === !0, g = (F == null ? void 0 : F.vrf) === !0, v = (F == null ? void 0 : F.disableBundling) === !0, E = F == null ? void 0 : F.reward, A = te.type() == "warp" && !v;
      if (A && _.target != z.emptyTransfer.target && _.winstonQty != z.emptyTransfer.winstonQty)
        throw new Error("Ar Transfers are not allowed for bundled interactions");
      if (g && !A && p === "mainnet")
        throw new Error("Vrf generation is only available for bundle interaction");
      if (A)
        return await this.bundleInteraction(P, { tags: $, strict: y, vrf: g });
      {
        const L = await this.createInteraction(P, $, _, y, !1, g && p !== "mainnet", E), j = await H.transactions.post(L);
        if (j.status !== 200)
          return this.logger.error("Error while posting transaction", j), null;
        if (this._evaluationOptions.waitForConfirmation) {
          this.logger.info("Waiting for confirmation of", L.id);
          const J = I.Benchmark.measure();
          await this.waitForConfirmation(L.id), this.logger.info("Transaction confirmed after", J.elapsed());
        }
        return this.warp.environment == "local" && this._evaluationOptions.mineArLocalBlocks && await this.warp.testing.mineBlock(), { originalTxId: L.id };
      }
    }
    async bundleInteraction(P, F) {
      this.logger.info("Bundle interaction input", P);
      const H = await this.createInteraction(P, F.tags, z.emptyTransfer, F.strict, !0, F.vrf);
      return { bundlrResponse: await fetch(`${this._evaluationOptions.bundlerUrl}gateway/sequencer/register`, { method: "POST", body: JSON.stringify(H), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((p) => (this.logger.debug(p), p.ok ? p.json() : Promise.reject(p))).catch((p) => {
        var $;
        throw this.logger.error(p), !(($ = p.body) === null || $ === void 0) && $.message && this.logger.error(p.body.message), new Error(`Unable to bundle interaction: ${JSON.stringify(p)}`);
      }), originalTxId: H.id };
    }
    async createInteraction(P, F, H, te, p = !1, $ = !1, _) {
      if (this._evaluationOptions.internalWrites) {
        const y = await this.callContract(P, void 0, void 0, F, H, te, $);
        if (te && y.type !== "ok")
          throw Error(`Cannot create interaction: ${y.errorMessage}`);
        const g = this.getCallStack(), v = this._innerWritesEvaluator.eval(g);
        this.logger.debug("Input", P), this.logger.debug("Callstack", g.print()), v.forEach((E) => {
          F.push({ name: T.SmartWeaveTags.INTERACT_WRITE, value: E });
        }), this.logger.debug("Tags with inner calls", F);
      } else if (te) {
        const y = await this.callContract(P, void 0, void 0, F, H, te, $);
        if (y.type !== "ok")
          throw Error(`Cannot create interaction: ${y.errorMessage}`);
      }
      return $ && F.push({ name: T.SmartWeaveTags.REQUEST_VRF, value: "true" }), await (0, B.createInteractionTx)(this.warp.arweave, this.signer, this._contractTxId, P, F, H.target, H.winstonQty, p, _);
    }
    txId() {
      return this._contractTxId;
    }
    getCallStack() {
      return this._callStack;
    }
    connect(P) {
      return this.signer = typeof P == "function" ? P : async (F) => {
        await this.warp.arweave.transactions.sign(F, P);
      }, this;
    }
    setEvaluationOptions(P) {
      return this._evaluationOptions = { ...this._evaluationOptions, ...P }, this;
    }
    async waitForConfirmation(P) {
      const { arweave: F } = this.warp, H = await F.transactions.getStatus(P);
      if (H.confirmed !== null)
        return this.logger.info(`Transaction ${P} confirmed`, H), H;
      this.logger.info(`Transaction ${P} not yet confirmed. Waiting another 20 seconds before next check.`), await (0, D.sleep)(2e4), await this.waitForConfirmation(P);
    }
    async createExecutionContext(P, F, H = !1, te) {
      var p;
      const { definitionLoader: $, interactionsLoader: _, executorFactory: y, stateEvaluator: g } = this.warp, v = I.Benchmark.measure(), E = await g.latestAvailableState(P, F);
      this.logger.debug("cache lookup", v.elapsed()), v.reset();
      const A = N.Evolve.evolvedSrcTxId((p = E == null ? void 0 : E.cachedValue) === null || p === void 0 ? void 0 : p.state);
      let L, j, J;
      return this.logger.debug("Cached state", E, F), E && E.sortKey == F ? (this.logger.debug("State fully cached, not loading interactions."), (H || A) && (j = await $.load(P, A), L = await y.create(j, this._evaluationOptions))) : ([j, J] = await Promise.all([$.load(P, A), te ? Promise.resolve(te) : await _.load(P, E == null ? void 0 : E.sortKey, this.getToSortKey(F), this._evaluationOptions)]), E != null && E.sortKey && (J = J.filter((X) => X.sortKey.localeCompare(E == null ? void 0 : E.sortKey) > 0)), F && (J = J.filter((X) => X.sortKey.localeCompare(F) <= 0)), this.logger.debug("contract and interactions load", v.elapsed()), this._parentContract == null && J.length && (this._rootSortKey = J[J.length - 1].sortKey), L = await y.create(j, this._evaluationOptions)), { warp: this.warp, contract: this, contractDefinition: j, sortedInteractions: J, evaluationOptions: this._evaluationOptions, handler: L, cachedState: E, requestedSortKey: F };
    }
    getToSortKey(P) {
      var F;
      return !((F = this._parentContract) === null || F === void 0) && F.rootSortKey ? P ? this._parentContract.rootSortKey.localeCompare(P) > 0 ? this._parentContract.rootSortKey : P : this._parentContract.rootSortKey : P;
    }
    async createExecutionContextFromTx(P, F) {
      const H = F.owner.address, te = F.sortKey;
      return { ...await this.createExecutionContext(P, te, !0), caller: H };
    }
    maybeResetRootContract() {
      this._parentContract == null && (this.logger.debug("Clearing call stack for the root contract"), this._callStack = new d.ContractCallRecord(this.txId(), 0), this._rootSortKey = null, this.warp.interactionsLoader.clearCache());
    }
    async callContract(P, F, H, te = [], p = z.emptyTransfer, $ = !1, _ = !1) {
      this.logger.info("Call contract input", P), this.maybeResetRootContract(), this.signer || this.logger.warn("Wallet not set.");
      const { arweave: y, stateEvaluator: g } = this.warp;
      let v = await this.createExecutionContext(this._contractTxId, H, !0);
      const E = this.warp.environment == "mainnet" ? await this._arweaveWrapper.warpGwBlock() : await y.blocks.getCurrent();
      let A;
      if (F)
        A = F;
      else if (this.signer) {
        const Z = await y.createTransaction({ data: Math.random().toString().slice(-4), reward: "72600854", last_tx: "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO" });
        await this.signer(Z), A = await y.wallets.ownerToAddress(Z.owner);
      } else
        A = "";
      this.logger.info("effectiveCaller", A), v = { ...v, caller: A };
      const L = await g.eval(v, []);
      this.logger.info("Current state", L.cachedValue.state);
      const j = { input: P, caller: v.caller };
      this.logger.debug("interaction", j);
      const J = await (0, B.createInteractionTx)(y, this.signer, this._contractTxId, P, te, p.target, p.winstonQty, !0), X = (0, B.createDummyTx)(J, v.caller, E);
      this.logger.debug("Creating sortKey for", { blockId: X.block.id, id: X.id, height: X.block.height }), X.sortKey = await this._sorter.createSortKey(X.block.id, X.id, X.block.height, !0), X.strict = $, _ && (X.vrf = (0, ee.generateMockVrf)(X.sortKey, y));
      const re = await this.evalInteraction({ interaction: j, interactionTx: X, currentTx: [] }, v, L.cachedValue);
      return re.type !== "ok" && this.logger.fatal("Error while interacting with contract", { type: re.type, error: re.errorMessage }), re;
    }
    async callContractForTx(P, F, H) {
      this.maybeResetRootContract();
      const te = await this.createExecutionContextFromTx(this._contractTxId, F), p = await this.warp.stateEvaluator.eval(te, H);
      this.logger.debug("callContractForTx - evalStateResult", { result: p.cachedValue.state, txId: this._contractTxId });
      const $ = { interaction: { input: P, caller: this._parentContract.txId() }, interactionTx: F, currentTx: H }, _ = await this.evalInteraction($, te, p.cachedValue);
      return _.originalValidity = p.cachedValue.validity, _.originalErrorMessages = p.cachedValue.errorMessages, _;
    }
    async evalInteraction(P, F, H) {
      const te = this.getCallStack().addInteractionData(P), p = I.Benchmark.measure(), $ = await F.handler.handle(F, H, P);
      return te.update({ cacheHit: !1, outputState: this._evaluationOptions.stackTrace.saveState ? $.state : void 0, executionTime: p.elapsed(!0), valid: $.type === "ok", errorMessage: $.errorMessage, gasUsed: $.gasUsed }), $;
    }
    parent() {
      return this._parentContract;
    }
    callDepth() {
      return this._callDepth;
    }
    evaluationOptions() {
      return this._evaluationOptions;
    }
    lastReadStateStats() {
      return this._benchmarkStats;
    }
    stateHash(P) {
      const F = (0, c.default)(P), H = m.createHash("sha256");
      return H.update(F), H.digest("hex");
    }
    async syncState(P, F) {
      const { stateEvaluator: H } = this.warp, te = await fetch(`${P}?${new URLSearchParams({ id: this._contractTxId, ...F })}`).then((p) => p.ok ? p.json() : Promise.reject(p)).catch((p) => {
        var $, _;
        throw !(($ = p.body) === null || $ === void 0) && $.message && this.logger.error(p.body.message), new Error(`Unable to retrieve state. ${p.status}: ${(_ = p.body) === null || _ === void 0 ? void 0 : _.message}`);
      });
      return await H.syncState(this._contractTxId, te.sortKey, te.state, te.validity), this;
    }
    async evolve(P, F) {
      return await this.writeInteraction({ function: "evolve", value: P }, F);
    }
    async save(P) {
      if (!this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: F } = this.warp;
      return (await new W.SourceImpl(F).save(P, this.signer)).id;
    }
    get rootSortKey() {
      return this._rootSortKey;
    }
  }, HandlerBasedContract;
}
vrf.generateMockVrf = generateMockVrf;
var PstContractImpl = {}, hasRequiredPstContractImpl;
function requirePstContractImpl() {
  if (hasRequiredPstContractImpl)
    return PstContractImpl;
  hasRequiredPstContractImpl = 1, Object.defineProperty(PstContractImpl, "__esModule", { value: !0 }), PstContractImpl.PstContractImpl = void 0;
  const o = requireHandlerBasedContract();
  class n extends o.HandlerBasedContract {
    async currentBalance(u) {
      const c = await this.viewState({ function: "balance", target: u });
      if (c.type !== "ok")
        throw Error(c.errorMessage);
      return c.result;
    }
    async currentState() {
      return (await super.readState()).cachedValue.state;
    }
    async transfer(u, c) {
      return await this.writeInteraction({ function: "transfer", ...u }, c);
    }
  }
  return PstContractImpl.PstContractImpl = n, PstContractImpl;
}
var MigrationTool$1 = {}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(MigrationTool$1, "__esModule", { value: !0 }), MigrationTool$1.MigrationTool = void 0;
const LexicographicalInteractionsSorter_1 = LexicographicalInteractionsSorter, StateEvaluator_1 = StateEvaluator, knex_1 = __importDefault(require$$2$1), LoggerFactory_1$2 = LoggerFactory$1;
class MigrationTool {
  constructor(n, a) {
    this.arweave = n, this.levelDb = a, this.logger = LoggerFactory_1$2.LoggerFactory.INST.create("MigrationTool"), this.sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(n);
  }
  async migrateSqlite(n) {
    this.logger.info(`Migrating from sqlite ${n} to leveldb.`);
    const a = (0, knex_1.default)({ client: "sqlite3", connection: { filename: n }, useNullAsDefault: !0 }), u = await a.select(["contract_id", "height", "state"]).from("states").max("height").groupBy(["contract_id"]);
    this.logger.info(`Migrating ${u == null ? void 0 : u.length} contracts' state`);
    const c = [];
    for (const m of u) {
      const d = m.contract_id, w = m.height, S = JSON.parse(m.state), T = this.sorter.generateLastSortKey(parseInt(w));
      this.logger.debug(`Migrating ${d} at height ${w}: ${T}`), await this.levelDb.put({ contractTxId: d, sortKey: T }, new StateEvaluator_1.EvalStateResult(S.state, S.validity, {})), c.push({ contractTxId: d, height: w, sortKey: T });
    }
    return this.logger.info("Migration done."), c;
  }
}
MigrationTool$1.MigrationTool = MigrationTool;
var Testing$1 = {};
Object.defineProperty(Testing$1, "__esModule", { value: !0 }), Testing$1.Testing = void 0;
class Testing {
  constructor(n) {
    this.arweave = n;
  }
  async mineBlock() {
    this.validateEnv(), await this.arweave.api.get("mine");
  }
  async generateWallet() {
    this.validateEnv();
    const n = await this.arweave.wallets.generate();
    return await this.addFunds(n), { jwk: n, address: await this.arweave.wallets.jwkToAddress(n) };
  }
  async addFunds(n) {
    const a = await this.arweave.wallets.getAddress(n);
    await this.arweave.api.get(`/mint/${a}/1000000000000000`);
  }
  validateEnv() {
    if (this.arweave.api.getConfig().host.includes("arweave"))
      throw new Error("Testing features are not available in a non testing environment");
  }
}
Testing$1.Testing = Testing;
var WarpBuilder = {}, DebuggableExecutorFactor = {};
Object.defineProperty(DebuggableExecutorFactor, "__esModule", { value: !0 }), DebuggableExecutorFactor.DebuggableExecutorFactory = void 0;
class DebuggableExecutorFactory {
  constructor(n, a) {
    this.baseImplementation = n, this.sourceCode = a;
  }
  async create(n, a) {
    return Object.prototype.hasOwnProperty.call(this.sourceCode, n.txId) && (n = { ...n, src: this.sourceCode[n.txId] }), await this.baseImplementation.create(n, a);
  }
}
DebuggableExecutorFactor.DebuggableExecutorFactory = DebuggableExecutorFactory;
var ArweaveGatewayInteractionsLoader = {}, hasRequiredArweaveGatewayInteractionsLoader;
function requireArweaveGatewayInteractionsLoader() {
  if (hasRequiredArweaveGatewayInteractionsLoader)
    return ArweaveGatewayInteractionsLoader;
  hasRequiredArweaveGatewayInteractionsLoader = 1, Object.defineProperty(ArweaveGatewayInteractionsLoader, "__esModule", { value: !0 }), ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = ArweaveGatewayInteractionsLoader.bundledTxsFilter = void 0;
  const o = SmartWeaveTags, n = Benchmark$1, a = LoggerFactory$1, u = requireArweaveWrapper(), c = utils$n, m = LexicographicalInteractionsSorter, d = vrf;
  function w(T) {
    var B, I;
    return !(!((B = T.node.parent) === null || B === void 0) && B.id) && !(!((I = T.node.bundledIn) === null || I === void 0) && I.id);
  }
  ArweaveGatewayInteractionsLoader.bundledTxsFilter = w;
  class S {
    constructor(B, I) {
      this.arweave = B, this.environment = I, this.logger = a.LoggerFactory.INST.create("ArweaveGatewayInteractionsLoader"), this.arweaveWrapper = new u.ArweaveWrapper(B), this.sorter = new m.LexicographicalInteractionsSorter(B);
    }
    async load(B, I, C, N) {
      this.logger.debug("Loading interactions for", { contractId: B, fromSortKey: I, toSortKey: C });
      const q = this.sorter.extractBlockHeight(I), D = this.sorter.extractBlockHeight(C), z = { tags: [{ name: o.SmartWeaveTags.APP_NAME, values: ["SmartWeaveAction"] }, { name: o.SmartWeaveTags.CONTRACT_TX_ID, values: [B] }], blockFilter: { min: q, max: D }, first: 100 }, W = n.Benchmark.measure();
      let V = await this.loadPages(z);
      if (W.stop(), N.internalWrites) {
        const F = { tags: [{ name: o.SmartWeaveTags.INTERACT_WRITE, values: [B] }], blockFilter: { min: q, max: D }, first: 100 }, H = await this.loadPages(F);
        this.logger.debug("Inner writes interactions length:", H.length), V = V.concat(H);
      }
      V = V.filter((F) => F.node.block && F.node.block.id && F.node.block.height);
      let ee = await this.sorter.sort(V);
      I && C ? ee = ee.filter((F) => F.node.sortKey.localeCompare(I) > 0 && F.node.sortKey.localeCompare(C) <= 0) : I && !C ? ee = ee.filter((F) => F.node.sortKey.localeCompare(I) > 0) : !I && C && (ee = ee.filter((F) => F.node.sortKey.localeCompare(C) <= 0)), this.logger.debug("All loaded interactions:", { from: I, to: C, loaded: ee.length, time: W.elapsed() });
      const P = this.environment === "local" || this.environment === "testnet";
      return ee.map((F) => {
        const H = F.node;
        return P && H.tags.some((te) => te.name == o.SmartWeaveTags.REQUEST_VRF && te.value === "true") && (H.vrf = (0, d.generateMockVrf)(H.sortKey, this.arweave)), H;
      });
    }
    async loadPages(B) {
      let I = await this.getNextPage(B);
      const C = I.edges.filter((N) => w(N));
      for (; I.pageInfo.hasNextPage; ) {
        const N = I.edges[99].cursor;
        B = { ...B, after: N }, I = await this.getNextPage(B), C.push(...I.edges.filter((q) => w(q)));
      }
      return C;
    }
    async getNextPage(B) {
      const I = n.Benchmark.measure();
      let C = await this.arweaveWrapper.gql(S.query, B);
      for (this.logger.debug("GQL page load:", I.elapsed()); C.status === 403; )
        this.logger.warn(`GQL rate limiting, waiting ${S._30seconds}ms before next try.`), await (0, c.sleep)(S._30seconds), C = await this.arweaveWrapper.gql(S.query, B);
      if (C.status !== 200)
        throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${C.status}.`);
      if (C.data.errors)
        throw this.logger.error(C.data.errors), new Error("Error while loading interaction transactions");
      return C.data.data.transactions;
    }
    type() {
      return "arweave";
    }
    clearCache() {
    }
  }
  return ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = S, S.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`, S._30seconds = 3e4, ArweaveGatewayInteractionsLoader;
}
var CacheableInteractionsLoader$1 = {};
Object.defineProperty(CacheableInteractionsLoader$1, "__esModule", { value: !0 }), CacheableInteractionsLoader$1.CacheableInteractionsLoader = void 0;
const LoggerFactory_1$1 = LoggerFactory$1;
class CacheableInteractionsLoader {
  constructor(n) {
    this.delegate = n, this.logger = LoggerFactory_1$1.LoggerFactory.INST.create("CacheableInteractionsLoader"), this.interactionsCache = /* @__PURE__ */ new Map();
  }
  async load(n, a, u, c) {
    if (this.logger.debug("Loading interactions for", { contractTxId: n, fromSortKey: a, toSortKey: u }), this.interactionsCache.has(n)) {
      const m = this.interactionsCache.get(n);
      if (m != null && m.length) {
        const d = m[m.length - 1].sortKey;
        if (d.localeCompare(u) < 0) {
          const w = await this.delegate.load(n, d, u, c), S = m.concat(w);
          return this.interactionsCache.set(n, S), S;
        }
      }
      return m;
    }
    {
      const m = await this.delegate.load(n, a, u, c);
      return m.length && this.interactionsCache.set(n, m), m;
    }
  }
  type() {
    return this.delegate.type();
  }
  clearCache() {
    this.interactionsCache.clear();
  }
}
CacheableInteractionsLoader$1.CacheableInteractionsLoader = CacheableInteractionsLoader;
var WarpGatewayContractDefinitionLoader = {}, WasmSrc$1 = {};
function readBlobAsArrayBuffer(o) {
  return o.arrayBuffer ? o.arrayBuffer() : new Promise((n, a) => {
    const u = new FileReader();
    u.addEventListener("loadend", () => {
      n(u.result);
    }), u.addEventListener("error", a), u.readAsArrayBuffer(o);
  });
}
async function readBlobAsUint8Array(o) {
  const n = await readBlobAsArrayBuffer(o);
  return new Uint8Array(n);
}
function isBlob(o) {
  return typeof Blob < "u" && o instanceof Blob;
}
function isSharedArrayBuffer(o) {
  return typeof SharedArrayBuffer < "u" && o instanceof SharedArrayBuffer;
}
const isNode = typeof process < "u" && process.versions && process.versions.node !== void 0 && process.versions.electron === void 0;
function isTypedArraySameAsArrayBuffer(o) {
  return o.byteOffset === 0 && o.byteLength === o.buffer.byteLength;
}
class ArrayBufferReader {
  constructor(n) {
    this.typedArray = n instanceof ArrayBuffer || isSharedArrayBuffer(n) ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  }
  async getLength() {
    return this.typedArray.byteLength;
  }
  async read(n, a) {
    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + n, a);
  }
}
class BlobReader {
  constructor(n) {
    this.blob = n;
  }
  async getLength() {
    return this.blob.size;
  }
  async read(n, a) {
    const u = this.blob.slice(n, n + a), c = await readBlobAsArrayBuffer(u);
    return new Uint8Array(c);
  }
  async sliceAsBlob(n, a, u = "") {
    return this.blob.slice(n, n + a, u);
  }
}
class HTTPRangeReader {
  constructor(n) {
    this.url = n;
  }
  async getLength() {
    if (this.length === void 0) {
      const n = await fetch(this.url, { method: "HEAD" });
      if (!n.ok)
        throw new Error(`failed http request ${this.url}, status: ${n.status}: ${n.statusText}`);
      if (this.length = parseInt(n.headers.get("content-length")), Number.isNaN(this.length))
        throw Error("could not get length");
    }
    return this.length;
  }
  async read(n, a) {
    if (a === 0)
      return new Uint8Array(0);
    const u = await fetch(this.url, { headers: { Range: `bytes=${n}-${n + a - 1}` } });
    if (!u.ok)
      throw new Error(`failed http request ${this.url}, status: ${u.status} offset: ${n} size: ${a}: ${u.statusText}`);
    const c = await u.arrayBuffer();
    return new Uint8Array(c);
  }
}
function inflate(o, n) {
  var a = Uint8Array;
  if (o[0] == 3 && o[1] == 0)
    return n || new a(0);
  var u = _bitsF, c = _bitsE, m = _decodeTiny, d = _get17, w = n == null;
  w && (n = new a(o.length >>> 2 << 3));
  for (var S, T, B = 0, I = 0, C = 0, N = 0, q = 0, D = 0, z = 0, W = 0, V = 0; B == 0; )
    if (B = u(o, V, 1), I = u(o, V + 1, 2), V += 3, I != 0) {
      if (w && (n = _check(n, W + (1 << 17))), I == 1 && (S = U.flmap, T = U.fdmap, D = 511, z = 31), I == 2) {
        C = c(o, V, 5) + 257, N = c(o, V + 5, 5) + 1, q = c(o, V + 10, 4) + 4, V += 14;
        for (var ee = 0; ee < 38; ee += 2)
          U.itree[ee] = 0, U.itree[ee + 1] = 0;
        var P = 1;
        for (ee = 0; ee < q; ee++) {
          var F = c(o, V + 3 * ee, 3);
          U.itree[1 + (U.ordr[ee] << 1)] = F, F > P && (P = F);
        }
        V += 3 * q, makeCodes(U.itree, P), codes2map(U.itree, P, U.imap), S = U.lmap, T = U.dmap, V = m(U.imap, (1 << P) - 1, C + N, o, V, U.ttree);
        var H = _copyOut(U.ttree, 0, C, U.ltree);
        D = (1 << H) - 1;
        var te = _copyOut(U.ttree, C, N, U.dtree);
        z = (1 << te) - 1, makeCodes(U.ltree, H), codes2map(U.ltree, H, S), makeCodes(U.dtree, te), codes2map(U.dtree, te, T);
      }
      for (; ; ) {
        var p = S[d(o, V) & D];
        V += 15 & p;
        var $ = p >>> 4;
        if ($ >>> 8 == 0)
          n[W++] = $;
        else {
          if ($ == 256)
            break;
          var _ = W + $ - 254;
          if ($ > 264) {
            var y = U.ldef[$ - 257];
            _ = W + (y >>> 3) + c(o, V, 7 & y), V += 7 & y;
          }
          var g = T[d(o, V) & z];
          V += 15 & g;
          var v = g >>> 4, E = U.ddef[v], A = (E >>> 4) + u(o, V, 15 & E);
          for (V += 15 & E, w && (n = _check(n, W + (1 << 17))); W < _; )
            n[W] = n[W++ - A], n[W] = n[W++ - A], n[W] = n[W++ - A], n[W] = n[W++ - A];
          W = _;
        }
      }
    } else {
      (7 & V) != 0 && (V += 8 - (7 & V));
      var L = 4 + (V >>> 3), j = o[L - 4] | o[L - 3] << 8;
      w && (n = _check(n, W + j)), n.set(new a(o.buffer, o.byteOffset + L, j), W), V = L + j << 3, W += j;
    }
  return n.length == W ? n : n.slice(0, W);
}
function _check(o, n) {
  var a = o.length;
  if (n <= a)
    return o;
  var u = new Uint8Array(Math.max(a << 1, n));
  return u.set(o, 0), u;
}
function _decodeTiny(o, n, a, u, c, m) {
  for (var d = _bitsE, w = _get17, S = 0; S < a; ) {
    var T = o[w(u, c) & n];
    c += 15 & T;
    var B = T >>> 4;
    if (B <= 15)
      m[S] = B, S++;
    else {
      var I = 0, C = 0;
      B == 16 ? (C = 3 + d(u, c, 2), c += 2, I = m[S - 1]) : B == 17 ? (C = 3 + d(u, c, 3), c += 3) : B == 18 && (C = 11 + d(u, c, 7), c += 7);
      for (var N = S + C; S < N; )
        m[S] = I, S++;
    }
  }
  return c;
}
function _copyOut(o, n, a, u) {
  for (var c = 0, m = 0, d = u.length >>> 1; m < a; ) {
    var w = o[m + n];
    u[m << 1] = 0, u[1 + (m << 1)] = w, w > c && (c = w), m++;
  }
  for (; m < d; )
    u[m << 1] = 0, u[1 + (m << 1)] = 0, m++;
  return c;
}
function makeCodes(o, n) {
  for (var a, u, c, m, d = o.length, w = U.bl_count, S = 0; S <= n; S++)
    w[S] = 0;
  for (S = 1; S < d; S += 2)
    w[o[S]]++;
  var T = U.next_code;
  for (a = 0, w[0] = 0, u = 1; u <= n; u++)
    a = a + w[u - 1] << 1, T[u] = a;
  for (c = 0; c < d; c += 2)
    (m = o[c + 1]) != 0 && (o[c] = T[m], T[m]++);
}
function codes2map(o, n, a) {
  for (var u = o.length, c = U.rev15, m = 0; m < u; m += 2)
    if (o[m + 1] != 0)
      for (var d = m >> 1, w = o[m + 1], S = d << 4 | w, T = n - w, B = o[m] << T, I = B + (1 << T); B != I; )
        a[c[B] >>> 15 - n] = S, B++;
}
function revCodes(o, n) {
  for (var a = U.rev15, u = 15 - n, c = 0; c < o.length; c += 2) {
    var m = o[c] << n - o[c + 1];
    o[c] = a[m] >>> u;
  }
}
function _bitsE(o, n, a) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8) >>> (7 & n) & (1 << a) - 1;
}
function _bitsF(o, n, a) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8 | o[2 + (n >>> 3)] << 16) >>> (7 & n) & (1 << a) - 1;
}
function _get17(o, n) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8 | o[2 + (n >>> 3)] << 16) >>> (7 & n);
}
const U = (u16 = Uint16Array, u32 = Uint32Array, { next_code: new u16(16), bl_count: new u16(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new u16(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new u32(32), flmap: new u16(512), fltree: [], fdmap: new u16(32), fdtree: [], lmap: new u16(32768), ltree: [], ttree: [], dmap: new u16(32768), dtree: [], imap: new u16(512), itree: [], rev15: new u16(32768), lhst: new u32(286), dhst: new u32(30), ihst: new u32(19), lits: new u32(15e3), strt: new u16(65536), prev: new u16(32768) });
var u16, u32;
(function() {
  for (var o = 0; o < 32768; o++) {
    var n = o;
    n = (4278255360 & (n = (4042322160 & (n = (3435973836 & (n = (2863311530 & n) >>> 1 | (1431655765 & n) << 1)) >>> 2 | (858993459 & n) << 2)) >>> 4 | (252645135 & n) << 4)) >>> 8 | (16711935 & n) << 8, U.rev15[o] = (n >>> 16 | n << 16) >>> 17;
  }
  function a(u, c, m) {
    for (; c-- != 0; )
      u.push(0, m);
  }
  for (o = 0; o < 32; o++)
    U.ldef[o] = U.of0[o] << 3 | U.exb[o], U.ddef[o] = U.df0[o] << 4 | U.dxb[o];
  a(U.fltree, 144, 8), a(U.fltree, 112, 9), a(U.fltree, 24, 7), a(U.fltree, 8, 8), makeCodes(U.fltree, 9), codes2map(U.fltree, 9, U.flmap), revCodes(U.fltree, 9), a(U.fdtree, 32, 5), makeCodes(U.fdtree, 5), codes2map(U.fdtree, 5, U.fdmap), revCodes(U.fdtree, 5), a(U.itree, 19, 0), a(U.ltree, 286, 0), a(U.dtree, 30, 0), a(U.ttree, 320, 0);
})();
const crc = { table: function() {
  for (var o = new Uint32Array(256), n = 0; n < 256; n++) {
    for (var a = n, u = 0; u < 8; u++)
      1 & a ? a = 3988292384 ^ a >>> 1 : a >>>= 1;
    o[n] = a;
  }
  return o;
}(), update: function(o, n, a, u) {
  for (var c = 0; c < u; c++)
    o = crc.table[255 & (o ^ n[a + c])] ^ o >>> 8;
  return o;
}, crc: function(o, n, a) {
  return 4294967295 ^ crc.update(4294967295, o, n, a);
} };
function inflateRaw(o, n) {
  return inflate(o, n);
}
const config = { numWorkers: 1, workerURL: "", useWorkers: !1 };
let nextId = 0, numWorkers = 0, canUseWorkers = !0;
const workers = [], availableWorkers = [], waitingForWorkerQueue = [], currentlyProcessingIdToRequestMap = /* @__PURE__ */ new Map();
function handleResult(o) {
  makeWorkerAvailable(o.target);
  const { id: n, error: a, data: u } = o.data, c = currentlyProcessingIdToRequestMap.get(n);
  currentlyProcessingIdToRequestMap.delete(n), a ? c.reject(a) : c.resolve(u);
}
function startWorker(o) {
  return new Promise((n, a) => {
    const u = new Worker(o);
    u.onmessage = (c) => {
      c.data === "start" ? (u.onerror = void 0, u.onmessage = void 0, n(u)) : a(new Error(`unexpected message: ${c.data}`));
    }, u.onerror = a;
  });
}
function dynamicRequire(o, n) {
  return o.require(n);
}
const workerHelper = function() {
  if (isNode) {
    const { Worker: o } = dynamicRequire(module, "worker_threads");
    return { createWorker: async (n) => new o(n), addEventListener(n, a) {
      n.on("message", (u) => {
        a({ target: n, data: u });
      });
    }, async terminate(n) {
      await n.terminate();
    } };
  }
  return { async createWorker(o) {
    try {
      return await startWorker(o);
    } catch {
      console.warn("could not load worker:", o);
    }
    let n;
    try {
      const a = await fetch(o, { mode: "cors" });
      if (!a.ok)
        throw new Error(`could not load: ${o}`);
      n = await a.text(), o = URL.createObjectURL(new Blob([n], { type: "application/javascript" }));
      const u = await startWorker(o);
      return config.workerURL = o, u;
    } catch {
      console.warn("could not load worker via fetch:", o);
    }
    if (n !== void 0)
      try {
        o = `data:application/javascript;base64,${btoa(n)}`;
        const a = await startWorker(o);
        return config.workerURL = o, a;
      } catch {
        console.warn("could not load worker via dataURI");
      }
    throw console.warn("workers will not be used"), new Error("can not start workers");
  }, addEventListener(o, n) {
    o.addEventListener("message", n);
  }, async terminate(o) {
    o.terminate();
  } };
}();
function makeWorkerAvailable(o) {
  availableWorkers.push(o), processWaitingForWorkerQueue();
}
async function getAvailableWorker() {
  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {
    ++numWorkers;
    try {
      const o = await workerHelper.createWorker(config.workerURL);
      workers.push(o), availableWorkers.push(o), workerHelper.addEventListener(o, handleResult);
    } catch {
      canUseWorkers = !1;
    }
  }
  return availableWorkers.pop();
}
function inflateRawLocal(o, n, a, u) {
  const c = new Uint8Array(n);
  inflateRaw(o, c), u(a ? new Blob([c], { type: a }) : c.buffer);
}
async function processWaitingForWorkerQueue() {
  if (waitingForWorkerQueue.length !== 0) {
    if (config.useWorkers && canUseWorkers) {
      const o = await getAvailableWorker();
      if (canUseWorkers) {
        if (o) {
          if (waitingForWorkerQueue.length === 0)
            return void makeWorkerAvailable(o);
          const { id: n, src: a, uncompressedSize: u, type: c, resolve: m, reject: d } = waitingForWorkerQueue.shift();
          currentlyProcessingIdToRequestMap.set(n, { id: n, resolve: m, reject: d });
          const w = [];
          o.postMessage({ type: "inflate", data: { id: n, type: c, src: a, uncompressedSize: u } }, w);
        }
        return;
      }
    }
    for (; waitingForWorkerQueue.length; ) {
      const { src: o, uncompressedSize: n, type: a, resolve: u } = waitingForWorkerQueue.shift();
      let c = o;
      isBlob(o) && (c = await readBlobAsUint8Array(o)), inflateRawLocal(c, n, a, u);
    }
  }
}
function setOptions(o) {
  config.workerURL = o.workerURL || config.workerURL, o.workerURL && (config.useWorkers = !0), config.useWorkers = o.useWorkers !== void 0 ? o.useWorkers : config.useWorkers, config.numWorkers = o.numWorkers || config.numWorkers;
}
function inflateRawAsync(o, n, a) {
  return new Promise((u, c) => {
    waitingForWorkerQueue.push({ src: o, uncompressedSize: n, type: a, resolve: u, reject: c, id: nextId++ }), processWaitingForWorkerQueue();
  });
}
function clearArray(o) {
  o.splice(0, o.length);
}
async function cleanup() {
  for (const o of workers)
    await workerHelper.terminate(o);
  clearArray(workers), clearArray(availableWorkers), clearArray(waitingForWorkerQueue), currentlyProcessingIdToRequestMap.clear(), numWorkers = 0, canUseWorkers = !0;
}
function dosDateTimeToDate(o, n) {
  return new Date(1980 + (o >> 9 & 127), (o >> 5 & 15) - 1, 31 & o, n >> 11 & 31, n >> 5 & 63, 2 * (31 & n), 0);
}
class ZipEntry {
  constructor(n, a) {
    this._reader = n, this._rawEntry = a, this.name = a.name, this.nameBytes = a.nameBytes, this.size = a.uncompressedSize, this.compressedSize = a.compressedSize, this.comment = a.comment, this.commentBytes = a.commentBytes, this.compressionMethod = a.compressionMethod, this.lastModDate = dosDateTimeToDate(a.lastModFileDate, a.lastModFileTime), this.isDirectory = a.uncompressedSize === 0 && a.name.endsWith("/"), this.encrypted = !!(1 & a.generalPurposeBitFlag), this.externalFileAttributes = a.externalFileAttributes, this.versionMadeBy = a.versionMadeBy;
  }
  async blob(n = "application/octet-stream") {
    return await readEntryDataAsBlob(this._reader, this._rawEntry, n);
  }
  async arrayBuffer() {
    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);
  }
  async text() {
    const n = await this.arrayBuffer();
    return decodeBuffer(new Uint8Array(n));
  }
  async json() {
    const n = await this.text();
    return JSON.parse(n);
  }
}
const EOCDR_WITHOUT_COMMENT_SIZE = 22, MAX_COMMENT_SIZE = 65535, EOCDR_SIGNATURE = 101010256, ZIP64_EOCDR_SIGNATURE = 101075792;
async function readAs(o, n, a) {
  return await o.read(n, a);
}
async function readAsBlobOrTypedArray(o, n, a, u) {
  return o.sliceAsBlob ? await o.sliceAsBlob(n, a, u) : await o.read(n, a);
}
const crc$1 = { unsigned: () => 0 };
function getUint16LE(o, n) {
  return o[n] + 256 * o[n + 1];
}
function getUint32LE(o, n) {
  return o[n] + 256 * o[n + 1] + 65536 * o[n + 2] + 16777216 * o[n + 3];
}
function getUint64LE(o, n) {
  return getUint32LE(o, n) + 4294967296 * getUint32LE(o, n + 4);
}
const utf8Decoder = new TextDecoder();
function decodeBuffer(o, n) {
  return isSharedArrayBuffer(o.buffer) && (o = new Uint8Array(o)), utf8Decoder.decode(o);
}
async function findEndOfCentralDirector(o, n) {
  const a = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, n), u = n - a, c = await readAs(o, u, a);
  for (let m = a - EOCDR_WITHOUT_COMMENT_SIZE; m >= 0; --m) {
    if (getUint32LE(c, m) !== EOCDR_SIGNATURE)
      continue;
    const d = new Uint8Array(c.buffer, c.byteOffset + m, c.byteLength - m), w = getUint16LE(d, 4);
    if (w !== 0)
      throw new Error(`multi-volume zip files are not supported. This is volume: ${w}`);
    const S = getUint16LE(d, 10), T = getUint32LE(d, 12), B = getUint32LE(d, 16), I = getUint16LE(d, 20), C = d.length - EOCDR_WITHOUT_COMMENT_SIZE;
    if (I !== C)
      throw new Error(`invalid comment length. expected: ${C}, actual: ${I}`);
    const N = new Uint8Array(d.buffer, d.byteOffset + 22, I), q = decodeBuffer(N);
    return S === 65535 || B === 4294967295 ? await readZip64CentralDirectory(o, u + m, q, N) : await readEntries(o, B, T, S, q, N);
  }
  throw new Error("could not find end of central directory. maybe not zip file");
}
const END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 117853008;
async function readZip64CentralDirectory(o, n, a, u) {
  const c = n - 20, m = await readAs(o, c, 20);
  if (getUint32LE(m, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory locator signature");
  const d = getUint64LE(m, 8), w = await readAs(o, d, 56);
  if (getUint32LE(w, 0) !== ZIP64_EOCDR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory record signature");
  const S = getUint64LE(w, 32), T = getUint64LE(w, 40);
  return readEntries(o, getUint64LE(w, 48), T, S, a, u);
}
const CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 33639248;
async function readEntries(o, n, a, u, c, m) {
  let d = 0;
  const w = await readAs(o, n, a), S = [];
  for (let T = 0; T < u; ++T) {
    const B = w.subarray(d, d + 46), I = getUint32LE(B, 0);
    if (I !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE)
      throw new Error(`invalid central directory file header signature: 0x${I.toString(16)}`);
    const C = { versionMadeBy: getUint16LE(B, 4), versionNeededToExtract: getUint16LE(B, 6), generalPurposeBitFlag: getUint16LE(B, 8), compressionMethod: getUint16LE(B, 10), lastModFileTime: getUint16LE(B, 12), lastModFileDate: getUint16LE(B, 14), crc32: getUint32LE(B, 16), compressedSize: getUint32LE(B, 20), uncompressedSize: getUint32LE(B, 24), fileNameLength: getUint16LE(B, 28), extraFieldLength: getUint16LE(B, 30), fileCommentLength: getUint16LE(B, 32), internalFileAttributes: getUint16LE(B, 36), externalFileAttributes: getUint32LE(B, 38), relativeOffsetOfLocalHeader: getUint32LE(B, 42) };
    if (64 & C.generalPurposeBitFlag)
      throw new Error("strong encryption is not supported");
    d += 46;
    const N = w.subarray(d, d + C.fileNameLength + C.extraFieldLength + C.fileCommentLength);
    C.nameBytes = N.slice(0, C.fileNameLength), C.name = decodeBuffer(C.nameBytes);
    const q = C.fileNameLength + C.extraFieldLength, D = N.slice(C.fileNameLength, q);
    C.extraFields = [];
    let z = 0;
    for (; z < D.length - 3; ) {
      const V = getUint16LE(D, z + 0), ee = z + 4, P = ee + getUint16LE(D, z + 2);
      if (P > D.length)
        throw new Error("extra field length exceeds extra field buffer size");
      C.extraFields.push({ id: V, data: D.slice(ee, P) }), z = P;
    }
    if (C.commentBytes = N.slice(q, q + C.fileCommentLength), C.comment = decodeBuffer(C.commentBytes), d += N.length, C.uncompressedSize === 4294967295 || C.compressedSize === 4294967295 || C.relativeOffsetOfLocalHeader === 4294967295) {
      const V = C.extraFields.find((F) => F.id === 1);
      if (!V)
        throw new Error("expected zip64 extended information extra field");
      const ee = V.data;
      let P = 0;
      if (C.uncompressedSize === 4294967295) {
        if (P + 8 > ee.length)
          throw new Error("zip64 extended information extra field does not include uncompressed size");
        C.uncompressedSize = getUint64LE(ee, P), P += 8;
      }
      if (C.compressedSize === 4294967295) {
        if (P + 8 > ee.length)
          throw new Error("zip64 extended information extra field does not include compressed size");
        C.compressedSize = getUint64LE(ee, P), P += 8;
      }
      if (C.relativeOffsetOfLocalHeader === 4294967295) {
        if (P + 8 > ee.length)
          throw new Error("zip64 extended information extra field does not include relative header offset");
        C.relativeOffsetOfLocalHeader = getUint64LE(ee, P), P += 8;
      }
    }
    const W = C.extraFields.find((V) => V.id === 28789 && V.data.length >= 6 && V.data[0] === 1 && getUint32LE(V.data, 1), crc$1.unsigned(C.nameBytes));
    if (W && (C.fileName = decodeBuffer(W.data.slice(5))), C.compressionMethod === 0) {
      let V = C.uncompressedSize;
      if ((1 & C.generalPurposeBitFlag) != 0 && (V += 12), C.compressedSize !== V)
        throw new Error(`compressed size mismatch for stored file: ${C.compressedSize} != ${V}`);
    }
    S.push(C);
  }
  return { zip: { comment: c, commentBytes: m }, entries: S.map((T) => new ZipEntry(o, T)) };
}
async function readEntryDataHeader(o, n) {
  if (1 & n.generalPurposeBitFlag)
    throw new Error("encrypted entries not supported");
  const a = await readAs(o, n.relativeOffsetOfLocalHeader, 30), u = await o.getLength(), c = getUint32LE(a, 0);
  if (c !== 67324752)
    throw new Error(`invalid local file header signature: 0x${c.toString(16)}`);
  const m = getUint16LE(a, 26), d = getUint16LE(a, 28), w = n.relativeOffsetOfLocalHeader + a.length + m + d;
  let S;
  if (n.compressionMethod === 0)
    S = !1;
  else {
    if (n.compressionMethod !== 8)
      throw new Error(`unsupported compression method: ${n.compressionMethod}`);
    S = !0;
  }
  const T = w, B = T + n.compressedSize;
  if (n.compressedSize !== 0 && B > u)
    throw new Error(`file data overflows file bounds: ${T} +  ${n.compressedSize}  > ${u}`);
  return { decompress: S, fileDataStart: T };
}
async function readEntryDataAsArrayBuffer(o, n) {
  const { decompress: a, fileDataStart: u } = await readEntryDataHeader(o, n);
  if (!a) {
    const m = await readAs(o, u, n.compressedSize);
    return isTypedArraySameAsArrayBuffer(m) ? m.buffer : m.slice().buffer;
  }
  const c = await readAsBlobOrTypedArray(o, u, n.compressedSize);
  return await inflateRawAsync(c, n.uncompressedSize);
}
async function readEntryDataAsBlob(o, n, a) {
  const { decompress: u, fileDataStart: c } = await readEntryDataHeader(o, n);
  if (!u) {
    const d = await readAsBlobOrTypedArray(o, c, n.compressedSize, a);
    return isBlob(d) ? d : new Blob([isSharedArrayBuffer(d.buffer) ? new Uint8Array(d) : d], { type: a });
  }
  const m = await readAsBlobOrTypedArray(o, c, n.compressedSize);
  return await inflateRawAsync(m, n.uncompressedSize, a);
}
function setOptions$1(o) {
  setOptions(o);
}
async function unzipRaw(o) {
  let n;
  if (typeof Blob < "u" && o instanceof Blob)
    n = new BlobReader(o);
  else if (o instanceof ArrayBuffer || o && o.buffer && o.buffer instanceof ArrayBuffer)
    n = new ArrayBufferReader(o);
  else if (isSharedArrayBuffer(o) || isSharedArrayBuffer(o.buffer))
    n = new ArrayBufferReader(o);
  else if (typeof o == "string") {
    const u = await fetch(o);
    if (!u.ok)
      throw new Error(`failed http request ${o}, status: ${u.status}: ${u.statusText}`);
    const c = await u.blob();
    n = new BlobReader(c);
  } else {
    if (typeof o.getLength != "function" || typeof o.read != "function")
      throw new Error("unsupported source type");
    n = o;
  }
  const a = await n.getLength();
  if (a > Number.MAX_SAFE_INTEGER)
    throw new Error(`file too large. size: ${a}. Only file sizes up 4503599627370496 bytes are supported`);
  return await findEndOfCentralDirector(n, a);
}
async function unzip(o) {
  const { zip: n, entries: a } = await unzipRaw(o);
  return { zip: n, entries: Object.fromEntries(a.map((u) => [u.name, u])) };
}
function cleanup$1() {
  cleanup();
}
const unzipit_module = Object.freeze(Object.defineProperty({ __proto__: null, HTTPRangeReader, cleanup: cleanup$1, setOptions: setOptions$1, unzip, unzipRaw }, Symbol.toStringTag, { value: "Module" })), require$$0 = getAugmentedNamespace(unzipit_module);
Object.defineProperty(WasmSrc$1, "__esModule", { value: !0 }), WasmSrc$1.WasmSrc = void 0;
const unzipit_1 = require$$0, redstone_isomorphic_1 = npmBrowser$1, LoggerFactory_1 = LoggerFactory$1;
class WasmSrc {
  constructor(n) {
    this.src = n, this.logger = LoggerFactory_1.LoggerFactory.INST.create("WasmSrc"), this.splitted = this.splitBuffer(n), this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
  }
  wasmBinary() {
    return this.splitted[0];
  }
  async sourceCode() {
    const { entries: n } = await (0, unzipit_1.unzip)(this.splitted[1]), a = /* @__PURE__ */ new Map();
    for (const [u, c] of Object.entries(n)) {
      if (c.isDirectory)
        continue;
      const m = await c.text();
      a.set(u, m);
    }
    return a;
  }
  additionalCode() {
    return this.splitted.length == 2 ? null : this.splitted[2].toString();
  }
  splitBuffer(n) {
    let a = "";
    const u = parseInt(n.toString("utf8", 0, 1));
    this.logger.debug(`Number of elements: ${u}`);
    const c = n.length;
    let m = 0, d = 0;
    for (let T = 2; T < c; T++) {
      const B = n.toString("utf8", T, T + 1);
      if (B == "|" && m++, m == u) {
        d = T + 1;
        break;
      }
      a += B;
    }
    this.logger.debug("Parsed:", { header: a, dataStart: d });
    const w = a.split("|").map((T) => parseInt(T));
    this.logger.debug("Lengths", w);
    const S = [];
    for (const T of w) {
      const B = redstone_isomorphic_1.Buffer.alloc(T), I = d + T;
      n.copy(B, 0, d, I), d = I, S.push(B);
    }
    return S;
  }
}
var hasRequiredWarpGatewayContractDefinitionLoader, hasRequiredWarpBuilder, hasRequiredWarp, hasRequiredWarpFactory, hasRequiredArweaveWrapper, hasRequiredContractDefinitionLoader;
function requireWarpGatewayContractDefinitionLoader() {
  if (hasRequiredWarpGatewayContractDefinitionLoader)
    return WarpGatewayContractDefinitionLoader;
  hasRequiredWarpGatewayContractDefinitionLoader = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(WarpGatewayContractDefinitionLoader, "__esModule", { value: !0 }), WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = void 0;
  const n = requireContractDefinitionLoader(), a = npmBrowser$1, u = o(requireTransaction()), c = SmartWeaveTags, m = utils$p, d = Benchmark$1, w = LoggerFactory$1, S = requireArweaveWrapper(), T = utils$n, B = WasmSrc$1, I = memoryLevel, C = browser;
  return WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = class {
    constructor(N, q, D) {
      if (this.baseUrl = N, this.rLogger = w.LoggerFactory.INST.create("WarpGatewayContractDefinitionLoader"), this.baseUrl = (0, T.stripTrailingSlash)(N), this.contractDefinitionLoader = new n.ContractDefinitionLoader(q), this.arweaveWrapper = new S.ArweaveWrapper(q), D.inMemory)
        this.db = new I.MemoryLevel({ valueEncoding: "json" });
      else {
        if (!D.dbLocation)
          throw new Error("LevelDb cache configuration error - no db location specified");
        const z = D.dbLocation;
        this.db = new C.Level(`${z}/contracts`, { valueEncoding: "json" });
      }
    }
    async load(N, q) {
      let D = N;
      q && (D += `_${q}`);
      let z = null;
      try {
        z = await this.db.get(D);
      } catch (ee) {
        if (ee.code != "LEVEL_NOT_FOUND")
          throw ee;
        z = null;
      }
      if (z)
        return this.rLogger.debug("WarpGatewayContractDefinitionLoader: Hit from cache!"), z.contractType == "wasm" && (z.srcBinary = a.Buffer.from(z.srcBinary.data)), z;
      const W = d.Benchmark.measure(), V = await this.doLoad(N, q);
      return this.rLogger.info(`Contract definition loaded in: ${W.elapsed()}`), await this.db.put(D, V), V;
    }
    async doLoad(N, q) {
      try {
        const D = await fetch(`${this.baseUrl}/gateway/contract?txId=${N}${q ? `&srcTxId=${q}` : ""}`).then((z) => z.ok ? z.json() : Promise.reject(z)).catch((z) => {
          var W, V;
          throw !((W = z.body) === null || W === void 0) && W.message && this.rLogger.error(z.body.message), new Error(`Unable to retrieve contract data. Warp gateway responded with status ${z.status}:${(V = z.body) === null || V === void 0 ? void 0 : V.message}`);
        });
        if (D.srcBinary == null || D.srcBinary instanceof a.Buffer || (D.srcBinary = a.Buffer.from(D.srcBinary.data)), D.srcBinary) {
          const z = new B.WasmSrc(D.srcBinary);
          let W;
          D.srcBinary = z.wasmBinary(), W = D.srcTx ? new u.default({ ...D.srcTx }) : await this.arweaveWrapper.tx(D.srcTxId);
          const V = JSON.parse((0, m.getTag)(W, c.SmartWeaveTags.WASM_META));
          D.metadata = V;
        }
        return D.contractType = D.src ? "js" : "wasm", D;
      } catch (D) {
        return this.rLogger.warn("Falling back to default contracts loader", D), await this.contractDefinitionLoader.doLoad(N, q);
      }
    }
    async loadContractSource(N) {
      return await this.contractDefinitionLoader.loadContractSource(N);
    }
    type() {
      return "warp";
    }
  }, WarpGatewayContractDefinitionLoader;
}
function requireWarpBuilder() {
  if (hasRequiredWarpBuilder)
    return WarpBuilder;
  hasRequiredWarpBuilder = 1, Object.defineProperty(WarpBuilder, "__esModule", { value: !0 }), WarpBuilder.WarpBuilder = void 0;
  const o = DebuggableExecutorFactor, n = requireArweaveGatewayInteractionsLoader(), a = CacheableInteractionsLoader$1, u = requireContractDefinitionLoader(), c = requireWarpGatewayContractDefinitionLoader(), m = WarpGatewayInteractionsLoader, d = requireWarp();
  return WarpBuilder.WarpBuilder = class {
    constructor(w, S, T = "custom") {
      this._arweave = w, this._cache = S, this._environment = T;
    }
    setDefinitionLoader(w) {
      return this._definitionLoader = w, this;
    }
    setInteractionsLoader(w) {
      return this._interactionsLoader = w, this;
    }
    setExecutorFactory(w) {
      return this._executorFactory = w, this;
    }
    setStateEvaluator(w) {
      return this._stateEvaluator = w, this;
    }
    overwriteSource(w) {
      if (this._executorFactory == null)
        throw new Error("Set base ExecutorFactory first");
      return this._executorFactory = new o.DebuggableExecutorFactory(this._executorFactory, w), this.build();
    }
    useWarpGateway(w, S) {
      return this._interactionsLoader = new a.CacheableInteractionsLoader(new m.WarpGatewayInteractionsLoader(w.address, w.confirmationStatus, w.source)), this._definitionLoader = new c.WarpGatewayContractDefinitionLoader(w.address, this._arweave, S), this;
    }
    useArweaveGateway() {
      return this._definitionLoader = new u.ContractDefinitionLoader(this._arweave), this._interactionsLoader = new a.CacheableInteractionsLoader(new n.ArweaveGatewayInteractionsLoader(this._arweave, this._environment)), this;
    }
    build() {
      return new d.Warp(this._arweave, this._cache, this._definitionLoader, this._interactionsLoader, this._executorFactory, this._stateEvaluator, this._environment);
    }
  }, WarpBuilder;
}
function requireWarp() {
  if (hasRequiredWarp)
    return Warp;
  hasRequiredWarp = 1, Object.defineProperty(Warp, "__esModule", { value: !0 }), Warp.Warp = void 0;
  const o = requireDefaultCreateContract(), n = requireHandlerBasedContract(), a = requirePstContractImpl(), u = MigrationTool$1, c = Testing$1, m = requireWarpBuilder();
  return Warp.Warp = class {
    constructor(d, w, S, T, B, I, C = "custom") {
      this.arweave = d, this.levelDb = w, this.definitionLoader = S, this.interactionsLoader = T, this.executorFactory = B, this.stateEvaluator = I, this.environment = C, this.createContract = new o.DefaultCreateContract(d, this), this.migrationTool = new u.MigrationTool(d, w), this.testing = new c.Testing(d);
    }
    static builder(d, w, S) {
      return new m.WarpBuilder(d, w, S);
    }
    contract(d, w, S) {
      return new n.HandlerBasedContract(d, this, w, S);
    }
    pst(d) {
      return new a.PstContractImpl(d, this);
    }
  }, Warp;
}
function requireWarpFactory() {
  return hasRequiredWarpFactory || (hasRequiredWarpFactory = 1, function(o) {
    var n = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
      return B && B.__esModule ? B : { default: B };
    };
    Object.defineProperty(o, "__esModule", { value: !0 }), o.WarpFactory = o.defaultCacheOptions = o.DEFAULT_LEVEL_DB_LOCATION = o.defaultWarpGwOptions = o.WARP_GW_URL = void 0;
    const a = n(web), u = LevelDbCache$1, c = MemCache$1, m = CacheableExecutorFactory$1, d = Evolve$1, w = CacheableStateEvaluator$1, S = HandlerExecutorFactory$1, T = requireWarp();
    o.WARP_GW_URL = "https://d1o5nlqr4okus2.cloudfront.net", o.defaultWarpGwOptions = { confirmationStatus: { notCorrupted: !0 }, source: null, address: o.WARP_GW_URL }, o.DEFAULT_LEVEL_DB_LOCATION = "./cache/warp", o.defaultCacheOptions = { inMemory: !1, dbLocation: o.DEFAULT_LEVEL_DB_LOCATION }, o.WarpFactory = class {
      static forLocal(B = 1984, I = a.default.init({ host: "localhost", port: B, protocol: "http" }), C = { ...o.defaultCacheOptions, inMemory: !0 }) {
        return this.customArweaveGw(I, C, "local");
      }
      static forTestnet(B = a.default.init({ host: "testnet.redstone.tools", port: 443, protocol: "https" }), I = o.defaultCacheOptions) {
        return this.customArweaveGw(B, I, "testnet");
      }
      static forMainnet(B = o.defaultCacheOptions, I = !1, C = a.default.init({ host: "arweave.net", port: 443, protocol: "https" })) {
        return I ? this.customArweaveGw(C, B, "mainnet") : this.customWarpGw(C, o.defaultWarpGwOptions, B, "mainnet");
      }
      static custom(B, I, C) {
        const N = new u.LevelDbCache({ ...I, dbLocation: `${I.dbLocation}/state` }), q = new m.CacheableExecutorFactory(B, new S.HandlerExecutorFactory(B), new c.MemCache()), D = new w.CacheableStateEvaluator(B, N, [new d.Evolve()]);
        return T.Warp.builder(B, N, C).setExecutorFactory(q).setStateEvaluator(D);
      }
      static customArweaveGw(B, I = o.defaultCacheOptions, C) {
        return this.custom(B, I, C).useArweaveGateway().build();
      }
      static customWarpGw(B, I = o.defaultWarpGwOptions, C = o.defaultCacheOptions, N) {
        return this.custom(B, C, N).useWarpGateway(I, C).build();
      }
    };
  }(WarpFactory)), WarpFactory;
}
function requireArweaveWrapper() {
  if (hasRequiredArweaveWrapper)
    return ArweaveWrapper;
  hasRequiredArweaveWrapper = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(ArweaveWrapper, "__esModule", { value: !0 }), ArweaveWrapper.ArweaveWrapper = void 0;
  const n = o(web), a = o(requireTransaction()), u = npmBrowser$1, c = requireWarpFactory(), m = LoggerFactory$1;
  return ArweaveWrapper.ArweaveWrapper = class {
    constructor(d) {
      this.arweave = d, this.logger = m.LoggerFactory.INST.create("ArweaveWrapper"), this.baseUrl = `${d.api.config.protocol}://${d.api.config.host}:${d.api.config.port}`, this.logger.debug("baseurl", this.baseUrl);
    }
    async warpGwInfo() {
      return await this.doFetchInfo(`${c.WARP_GW_URL}/gateway/arweave/info`);
    }
    async warpGwBlock() {
      return this.logger.debug("Calling warp gw block info"), await this.doFetchInfo(`${c.WARP_GW_URL}/gateway/arweave/block`);
    }
    async info() {
      return await this.doFetchInfo(`${this.baseUrl}/info`);
    }
    async gql(d, w) {
      try {
        const S = JSON.stringify({ query: d, variables: w });
        return { data: await fetch(`${this.baseUrl}/graphql`, { method: "POST", body: S, headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((B) => B.ok ? B.json() : Promise.reject(B)).catch((B) => {
          var I, C;
          throw !((I = B.body) === null || I === void 0) && I.message && this.logger.error(B.body.message), new Error(`Unable to retrieve gql page. ${B.status}: ${(C = B.body) === null || C === void 0 ? void 0 : C.message}`);
        }), status: 200 };
      } catch (S) {
        throw this.logger.error("Error while loading gql", S), S;
      }
    }
    async tx(d) {
      const w = await fetch(`${this.baseUrl}/tx/${d}`).then((S) => S.ok ? S.json() : Promise.reject(S)).catch((S) => {
        var T, B;
        throw !((T = S.body) === null || T === void 0) && T.message && this.logger.error(S.body.message), new Error(`Unable to retrieve tx ${d}. ${S.status}. ${(B = S.body) === null || B === void 0 ? void 0 : B.message}`);
      });
      return new a.default({ ...w });
    }
    async txData(d) {
      const w = await fetch(`${this.baseUrl}/${d}`);
      if (w.ok) {
        const S = await w.arrayBuffer();
        return u.Buffer.from(S);
      }
      {
        this.logger.warn(`Unable to load data from arweave.net/${d} endpoint, falling back to arweave.js`);
        const S = await this.arweave.transactions.getData(d, { decode: !0 });
        return u.Buffer.from(S);
      }
    }
    async txDataString(d) {
      const w = await this.txData(d);
      return n.default.utils.bufferToString(w);
    }
    async doFetchInfo(d) {
      try {
        return await fetch(d).then((S) => S.ok ? S.json() : Promise.reject(S)).catch((S) => {
          var T, B;
          throw !((T = S.body) === null || T === void 0) && T.message && this.logger.error(S.body.message), new Error(`Unable to retrieve info. ${S.status}: ${(B = S.body) === null || B === void 0 ? void 0 : B.message}`);
        });
      } catch (w) {
        throw this.logger.error("Error while loading info", w), w;
      }
    }
  }, ArweaveWrapper;
}
function requireContractDefinitionLoader() {
  if (hasRequiredContractDefinitionLoader)
    return ContractDefinitionLoader;
  hasRequiredContractDefinitionLoader = 1, Object.defineProperty(ContractDefinitionLoader, "__esModule", { value: !0 }), ContractDefinitionLoader.ContractDefinitionLoader = void 0;
  const o = SmartWeaveTags, n = utils$p, a = Benchmark$1, u = LoggerFactory$1, c = requireArweaveWrapper(), m = WasmSrc$1, d = ["application/javascript", "application/wasm"];
  return ContractDefinitionLoader.ContractDefinitionLoader = class {
    constructor(w) {
      this.arweave = w, this.logger = u.LoggerFactory.INST.create("ContractDefinitionLoader"), this.arweaveWrapper = new c.ArweaveWrapper(w);
    }
    async load(w, S) {
      const T = a.Benchmark.measure(), B = await this.doLoad(w, S);
      return this.logger.info(`Contract definition loaded in: ${T.elapsed()}`), B;
    }
    async doLoad(w, S) {
      const T = a.Benchmark.measure(), B = await this.arweaveWrapper.tx(w), I = await this.arweave.wallets.ownerToAddress(B.owner);
      this.logger.debug("Contract tx and owner", T.elapsed()), T.reset();
      const C = S || (0, n.getTag)(B, o.SmartWeaveTags.CONTRACT_SRC_TX_ID), N = (0, n.getTag)(B, o.SmartWeaveTags.MIN_FEE);
      this.logger.debug("Tags decoding", T.elapsed()), T.reset();
      const q = await this.evalInitialState(B);
      this.logger.debug("init state", q);
      const D = JSON.parse(await this.evalInitialState(B));
      this.logger.debug("Parsing src and init state", T.elapsed());
      const { src: z, srcBinary: W, srcWasmLang: V, contractType: ee, metadata: P, srcTx: F } = await this.loadContractSource(C);
      return { txId: w, srcTxId: C, src: z, srcBinary: W, srcWasmLang: V, initState: D, minFee: N, owner: I, contractType: ee, metadata: P, contractTx: B.toJSON(), srcTx: F };
    }
    async loadContractSource(w) {
      const S = a.Benchmark.measure(), T = await this.arweaveWrapper.tx(w), B = (0, n.getTag)(T, o.SmartWeaveTags.CONTENT_TYPE);
      if (!d.includes(B))
        throw new Error(`Contract source content type ${B} not supported`);
      const I = B == "application/javascript" ? "js" : "wasm", C = I == "js" ? await this.arweaveWrapper.txDataString(w) : await this.arweaveWrapper.txData(w);
      let N, q, D;
      if (I == "wasm") {
        if (q = new m.WasmSrc(C), N = (0, n.getTag)(T, o.SmartWeaveTags.WASM_LANG), !N)
          throw new Error(`Wasm lang not set for wasm contract src ${w}`);
        D = JSON.parse((0, n.getTag)(T, o.SmartWeaveTags.WASM_META));
      }
      return this.logger.debug("Contract src tx load", S.elapsed()), S.reset(), { src: I == "js" ? C : null, srcBinary: I == "wasm" ? q.wasmBinary() : null, srcWasmLang: N, contractType: I, metadata: D, srcTx: T.toJSON() };
    }
    async evalInitialState(w) {
      if ((0, n.getTag)(w, o.SmartWeaveTags.INIT_STATE))
        return (0, n.getTag)(w, o.SmartWeaveTags.INIT_STATE);
      if ((0, n.getTag)(w, o.SmartWeaveTags.INIT_STATE_TX)) {
        const S = (0, n.getTag)(w, o.SmartWeaveTags.INIT_STATE_TX);
        return this.arweaveWrapper.txDataString(S);
      }
      return this.arweaveWrapper.txDataString(w.id);
    }
    type() {
      return "arweave";
    }
  }, ContractDefinitionLoader;
}
WasmSrc$1.WasmSrc = WasmSrc;
var ExecutionContextModifier = {};
Object.defineProperty(ExecutionContextModifier, "__esModule", { value: !0 });
var ExecutionContext = {};
Object.defineProperty(ExecutionContext, "__esModule", { value: !0 });
var ContractDefinition = {};
Object.defineProperty(ContractDefinition, "__esModule", { value: !0 }), ContractDefinition.ContractMetadata = void 0;
class ContractMetadata {
}
ContractDefinition.ContractMetadata = ContractMetadata;
var PstContract = {};
Object.defineProperty(PstContract, "__esModule", { value: !0 });
var Source = {};
Object.defineProperty(Source, "__esModule", { value: !0 });
var gqlResult = {};
Object.defineProperty(gqlResult, "__esModule", { value: !0 }), function(o) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(u, c, m, d) {
    d === void 0 && (d = m);
    var w = Object.getOwnPropertyDescriptor(c, m);
    w && !("get" in w ? !c.__esModule : w.writable || w.configurable) || (w = { enumerable: !0, get: function() {
      return c[m];
    } }), Object.defineProperty(u, d, w);
  } : function(u, c, m, d) {
    d === void 0 && (d = m), u[d] = c[m];
  }), a = commonjsGlobal && commonjsGlobal.__exportStar || function(u, c) {
    for (var m in u)
      m === "default" || Object.prototype.hasOwnProperty.call(c, m) || n(c, u, m);
  };
  Object.defineProperty(o, "__esModule", { value: !0 }), a(ConsoleLogger$1, o), a(ConsoleLoggerFactory$1, o), a(WarpLogger, o), a(LoggerFactory$1, o), a(LoggerSettings, o), a(Benchmark$1, o), a(DefinitionLoader, o), a(ExecutorFactory, o), a(InteractionsLoader, o), a(InteractionsSorter, o), a(StateEvaluator, o), a(requireContractDefinitionLoader(), o), a(requireWarpGatewayContractDefinitionLoader(), o), a(requireArweaveGatewayInteractionsLoader(), o), a(WarpGatewayInteractionsLoader, o), a(CacheableInteractionsLoader$1, o), a(DefaultStateEvaluator$1, o), a(CacheableStateEvaluator$1, o), a(HandlerExecutorFactory$1, o), a(LexicographicalInteractionsSorter, o), a(TagsParser$1, o), a(normalizeSource, o), a(StateCache, o), a(WasmSrc$1, o), a(AbstractContractHandler$1, o), a(JsHandlerApi$1, o), a(WasmHandlerApi$1, o), a(ExecutionContextModifier, o), a(SmartWeaveTags, o), a(ExecutionContext, o), a(ContractDefinition, o), a(ContractCallRecord$1, o), a(requireWarpFactory(), o), a(requireWarp(), o), a(requireWarpBuilder(), o), a(Contract, o), a(requireHandlerBasedContract(), o), a(PstContract, o), a(requirePstContractImpl(), o), a(InnerWritesEvaluator$1, o), a(Source, o), a(SourceImpl$1, o), a(requireDefaultCreateContract(), o), a(CreateContract, o), a(gqlResult, o), a(smartweaveGlobal, o), a(errors, o), a(utils$p, o), a(createInteractionTx$1, o), a(utils$n, o), a(requireArweaveWrapper(), o);
}(cjs);
const index = getDefaultExportFromCjs(cjs), index$1 = _mergeNamespaces({ __proto__: null, default: index }, [cjs]);
export {
  DIDAr as default
};

function _mergeNamespaces(n, o) {
  for (var a = 0; a < o.length; a++) {
    const u = o[a];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const c in u)
        if (c !== "default" && !(c in n)) {
          const p = Object.getOwnPropertyDescriptor(u, c);
          p && Object.defineProperty(n, c, p.get ? p : { enumerable: !0, get: () => u[c] });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function noop$2() {
}
const identity$1 = (n) => n;
function assign(n, o) {
  for (const a in o)
    n[a] = o[a];
  return n;
}
function run$1(n) {
  return n();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(n) {
  n.forEach(run$1);
}
function is_function(n) {
  return typeof n == "function";
}
function safe_not_equal(n, o) {
  return n != n ? o == o : n !== o || n && typeof n == "object" || typeof n == "function";
}
function is_empty(n) {
  return Object.keys(n).length === 0;
}
function subscribe(n, ...o) {
  if (n == null)
    return noop$2;
  const a = n.subscribe(...o);
  return a.unsubscribe ? () => a.unsubscribe() : a;
}
function component_subscribe(n, o, a) {
  n.$$.on_destroy.push(subscribe(o, a));
}
function create_slot(n, o, a, u) {
  if (n) {
    const c = get_slot_context(n, o, a, u);
    return n[0](c);
  }
}
function get_slot_context(n, o, a, u) {
  return n[1] && u ? assign(a.ctx.slice(), n[1](u(o))) : a.ctx;
}
function get_slot_changes(n, o, a, u) {
  if (n[2] && u) {
    const c = n[2](u(a));
    if (o.dirty === void 0)
      return c;
    if (typeof c == "object") {
      const p = [], d = Math.max(o.dirty.length, c.length);
      for (let w = 0; w < d; w += 1)
        p[w] = o.dirty[w] | c[w];
      return p;
    }
    return o.dirty | c;
  }
  return o.dirty;
}
function update_slot_base(n, o, a, u, c, p) {
  if (c) {
    const d = get_slot_context(o, a, u, p);
    n.p(d, c);
  }
}
function get_all_dirty_from_scope(n) {
  if (n.ctx.length > 32) {
    const o = [], a = n.ctx.length / 32;
    for (let u = 0; u < a; u++)
      o[u] = -1;
    return o;
  }
  return -1;
}
function null_to_empty(n) {
  return n == null ? "" : n;
}
function set_store_value(n, o, a) {
  return n.set(a), o;
}
const is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (n) => requestAnimationFrame(n) : noop$2;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(n) {
  tasks.forEach((o) => {
    o.c(n) || (tasks.delete(o), o.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop$1(n) {
  let o;
  return tasks.size === 0 && raf(run_tasks), { promise: new Promise((a) => {
    tasks.add(o = { c: n, f: a });
  }), abort() {
    tasks.delete(o);
  } };
}
function append(n, o) {
  n.appendChild(o);
}
function append_styles(n, o, a) {
  const u = get_root_for_style(n);
  if (!u.getElementById(o)) {
    const c = element("style");
    c.id = o, c.textContent = a, append_stylesheet(u, c);
  }
}
function get_root_for_style(n) {
  if (!n)
    return document;
  const o = n.getRootNode ? n.getRootNode() : n.ownerDocument;
  return o && o.host ? o : n.ownerDocument;
}
function append_empty_stylesheet(n) {
  const o = element("style");
  return append_stylesheet(get_root_for_style(n), o), o.sheet;
}
function append_stylesheet(n, o) {
  return append(n.head || n, o), o.sheet;
}
function insert(n, o, a) {
  n.insertBefore(o, a || null);
}
function detach(n) {
  n.parentNode.removeChild(n);
}
function destroy_each(n, o) {
  for (let a = 0; a < n.length; a += 1)
    n[a] && n[a].d(o);
}
function element(n) {
  return document.createElement(n);
}
function text(n) {
  return document.createTextNode(n);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(n, o, a, u) {
  return n.addEventListener(o, a, u), () => n.removeEventListener(o, a, u);
}
function stop_propagation(n) {
  return function(o) {
    return o.stopPropagation(), n.call(this, o);
  };
}
function attr(n, o, a) {
  a == null ? n.removeAttribute(o) : n.getAttribute(o) !== a && n.setAttribute(o, a);
}
function children(n) {
  return Array.from(n.childNodes);
}
function set_data(n, o) {
  o = "" + o, n.wholeText !== o && (n.data = o);
}
function set_style(n, o, a, u) {
  a === null ? n.style.removeProperty(o) : n.style.setProperty(o, a, u ? "important" : "");
}
function toggle_class(n, o, a) {
  n.classList[a ? "add" : "remove"](o);
}
function custom_event(n, o, { bubbles: a = !1, cancelable: u = !1 } = {}) {
  const c = document.createEvent("CustomEvent");
  return c.initCustomEvent(n, a, u, o), c;
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0, current_component;
function hash$3(n) {
  let o = 5381, a = n.length;
  for (; a--; )
    o = (o << 5) - o ^ n.charCodeAt(a);
  return o >>> 0;
}
function create_style_information(n, o) {
  const a = { stylesheet: append_empty_stylesheet(o), rules: {} };
  return managed_styles.set(n, a), a;
}
function create_rule(n, o, a, u, c, p, d, w = 0) {
  const S = 16.666 / u;
  let k = `{
`;
  for (let z = 0; z <= 1; z += S) {
    const F = o + (a - o) * p(z);
    k += 100 * z + `%{${d(F, 1 - F)}}
`;
  }
  const B = k + `100% {${d(a, 1 - a)}}
}`, I = `__svelte_${hash$3(B)}_${w}`, C = get_root_for_style(n), { stylesheet: P, rules: q } = managed_styles.get(C) || create_style_information(C, n);
  q[I] || (q[I] = !0, P.insertRule(`@keyframes ${I} ${B}`, P.cssRules.length));
  const D = n.style.animation || "";
  return n.style.animation = `${D ? `${D}, ` : ""}${I} ${u}ms linear ${c}ms 1 both`, active += 1, I;
}
function delete_rule(n, o) {
  const a = (n.style.animation || "").split(", "), u = a.filter(o ? (p) => p.indexOf(o) < 0 : (p) => p.indexOf("__svelte") === -1), c = a.length - u.length;
  c && (n.style.animation = u.join(", "), active -= c, active || clear_rules());
}
function clear_rules() {
  raf(() => {
    active || (managed_styles.forEach((n) => {
      const { ownerNode: o } = n.stylesheet;
      o && detach(o);
    }), managed_styles.clear());
  });
}
function set_current_component(n) {
  current_component = n;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(n) {
  get_current_component().$$.on_mount.push(n);
}
function createEventDispatcher() {
  const n = get_current_component();
  return (o, a, { cancelable: u = !1 } = {}) => {
    const c = n.$$.callbacks[o];
    if (c) {
      const p = custom_event(o, a, { cancelable: u });
      return c.slice().forEach((d) => {
        d.call(n, p);
      }), !p.defaultPrevented;
    }
    return !0;
  };
}
function setContext(n, o) {
  return get_current_component().$$.context.set(n, o), o;
}
function getContext(n) {
  return get_current_component().$$.context.get(n);
}
const dirty_components = [], binding_callbacks = [], render_callbacks = [], flush_callbacks = [], resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(n) {
  render_callbacks.push(n);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0, promise$1;
function flush() {
  const n = current_component;
  do {
    for (; flushidx < dirty_components.length; ) {
      const o = dirty_components[flushidx];
      flushidx++, set_current_component(o), update$1(o.$$);
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let o = 0; o < render_callbacks.length; o += 1) {
      const a = render_callbacks[o];
      seen_callbacks.has(a) || (seen_callbacks.add(a), a());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(n);
}
function update$1(n) {
  if (n.fragment !== null) {
    n.update(), run_all(n.before_update);
    const o = n.dirty;
    n.dirty = [-1], n.fragment && n.fragment.p(n.ctx, o), n.after_update.forEach(add_render_callback);
  }
}
function wait() {
  return promise$1 || (promise$1 = Promise.resolve(), promise$1.then(() => {
    promise$1 = null;
  })), promise$1;
}
function dispatch(n, o, a) {
  n.dispatchEvent(custom_event(`${o ? "intro" : "outro"}${a}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = { r: 0, c: [], p: outros };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(n, o) {
  n && n.i && (outroing.delete(n), n.i(o));
}
function transition_out(n, o, a, u) {
  if (n && n.o) {
    if (outroing.has(n))
      return;
    outroing.add(n), outros.c.push(() => {
      outroing.delete(n), u && (a && n.d(1), u());
    }), n.o(o);
  } else
    u && u();
}
const null_transition = { duration: 0 };
function create_out_transition(n, o, a) {
  let u, c = o(n, a), p = !0;
  const d = outros;
  function w() {
    const { delay: S = 0, duration: k = 300, easing: B = identity$1, tick: I = noop$2, css: C } = c || null_transition;
    C && (u = create_rule(n, 1, 0, k, S, B, C));
    const P = now() + S, q = P + k;
    add_render_callback(() => dispatch(n, !1, "start")), loop$1((D) => {
      if (p) {
        if (D >= q)
          return I(0, 1), dispatch(n, !1, "end"), --d.r || run_all(d.c), !1;
        if (D >= P) {
          const z = B((D - P) / k);
          I(1 - z, z);
        }
      }
      return p;
    });
  }
  return d.r += 1, is_function(c) ? wait().then(() => {
    c = c(), w();
  }) : w(), { end(S) {
    S && c.tick && c.tick(1, 0), p && (u && delete_rule(n, u), p = !1);
  } };
}
function create_bidirectional_transition(n, o, a, u) {
  let c = o(n, a), p = u ? 0 : 1, d = null, w = null, S = null;
  function k() {
    S && delete_rule(n, S);
  }
  function B(C, P) {
    const q = C.b - p;
    return P *= Math.abs(q), { a: p, b: C.b, d: q, duration: P, start: C.start, end: C.start + P, group: C.group };
  }
  function I(C) {
    const { delay: P = 0, duration: q = 300, easing: D = identity$1, tick: z = noop$2, css: F } = c || null_transition, V = { start: now() + P, b: C };
    C || (V.group = outros, outros.r += 1), d || w ? w = V : (F && (k(), S = create_rule(n, p, C, q, P, D, F)), C && z(0, 1), d = B(V, q), add_render_callback(() => dispatch(n, C, "start")), loop$1((Z) => {
      if (w && Z > w.start && (d = B(w, q), w = null, dispatch(n, d.b, "start"), F && (k(), S = create_rule(n, p, d.b, d.duration, 0, D, c.css))), d) {
        if (Z >= d.end)
          z(p = d.b, 1 - p), dispatch(n, d.b, "end"), w || (d.b ? k() : --d.group.r || run_all(d.group.c)), d = null;
        else if (Z >= d.start) {
          const N = Z - d.start;
          p = d.a + d.d * D(N / d.duration), z(p, 1 - p);
        }
      }
      return !(!d && !w);
    }));
  }
  return { run(C) {
    is_function(c) ? wait().then(() => {
      c = c(), I(C);
    }) : I(C);
  }, end() {
    k(), d = w = null;
  } };
}
function get_spread_update(n, o) {
  const a = {}, u = {}, c = { $$scope: 1 };
  let p = n.length;
  for (; p--; ) {
    const d = n[p], w = o[p];
    if (w) {
      for (const S in d)
        S in w || (u[S] = 1);
      for (const S in w)
        c[S] || (a[S] = w[S], c[S] = 1);
      n[p] = w;
    } else
      for (const S in d)
        c[S] = 1;
  }
  for (const d in u)
    d in a || (a[d] = void 0);
  return a;
}
function get_spread_object(n) {
  return typeof n == "object" && n !== null ? n : {};
}
function create_component(n) {
  n && n.c();
}
function mount_component(n, o, a, u) {
  const { fragment: c, on_mount: p, on_destroy: d, after_update: w } = n.$$;
  c && c.m(o, a), u || add_render_callback(() => {
    const S = p.map(run$1).filter(is_function);
    d ? d.push(...S) : run_all(S), n.$$.on_mount = [];
  }), w.forEach(add_render_callback);
}
function destroy_component(n, o) {
  const a = n.$$;
  a.fragment !== null && (run_all(a.on_destroy), a.fragment && a.fragment.d(o), a.on_destroy = a.fragment = null, a.ctx = []);
}
function make_dirty(n, o) {
  n.$$.dirty[0] === -1 && (dirty_components.push(n), schedule_update(), n.$$.dirty.fill(0)), n.$$.dirty[o / 31 | 0] |= 1 << o % 31;
}
function init$1(n, o, a, u, c, p, d, w = [-1]) {
  const S = current_component;
  set_current_component(n);
  const k = n.$$ = { fragment: null, ctx: null, props: p, update: noop$2, not_equal: c, bound: blank_object(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(o.context || (S ? S.$$.context : [])), callbacks: blank_object(), dirty: w, skip_bound: !1, root: o.target || S.$$.root };
  d && d(k.root);
  let B = !1;
  if (k.ctx = a ? a(n, o.props || {}, (I, C, ...P) => {
    const q = P.length ? P[0] : C;
    return k.ctx && c(k.ctx[I], k.ctx[I] = q) && (!k.skip_bound && k.bound[I] && k.bound[I](q), B && make_dirty(n, I)), C;
  }) : [], k.update(), B = !0, run_all(k.before_update), k.fragment = !!u && u(k.ctx), o.target) {
    if (o.hydrate) {
      const I = children(o.target);
      k.fragment && k.fragment.l(I), I.forEach(detach);
    } else
      k.fragment && k.fragment.c();
    o.intro && transition_in(n.$$.fragment), mount_component(n, o.target, o.anchor, o.customElement), flush();
  }
  set_current_component(S);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$2;
  }
  $on(o, a) {
    const u = this.$$.callbacks[o] || (this.$$.callbacks[o] = []);
    return u.push(a), () => {
      const c = u.indexOf(a);
      c !== -1 && u.splice(c, 1);
    };
  }
  $set(o) {
    this.$$set && !is_empty(o) && (this.$$.skip_bound = !0, this.$$set(o), this.$$.skip_bound = !1);
  }
}
const id = null, controller = null, verificationMethod = [], authentication = ["#key-0", "#key-1"], assertionMethod = [], keyAgreement = [], capabilityInvocation = [], capabilityDelegation = [], service = [], initialState = { "@context": ["https://www.w3.org/ns/did/v1", "https://w3id.org/security/suites/ed25519-2018/v1"], id, controller, verificationMethod, authentication, assertionMethod, keyAgreement, capabilityInvocation, capabilityDelegation, service }, contractSrc = `export async function handle(state, action) {\r
	const input = action.input;\r
	const caller = action.caller;\r
\r
	function setVerificatioMethod() {\r
		if (input.verificationMethod) {\r
			if (!Array.isArray(input.verificationMethod) || input.verificationMethod.length === 0) {\r
				throw new ContractError('verificationMethod must be an array with at least one method');\r
			}\r
			state.verificationMethod = input.verificationMethod;\r
		}\r
	}\r
\r
	async function assertController() {\r
		let flattenedAddresses;\r
		try {\r
			// Need to read the state of each of the controllers' dids and get the Arweave addresses and compare it to the caller value\r
			const promises = state.controller.map(async (did) => await getDidArweaveAddresses(did));\r
			const addresses = await Promise.all(promises);\r
			flattenedAddresses = addresses.flat();\r
		} catch (error) {\r
			throw new ContractError('Invalid controller');\r
		}\r
\r
		// check if caller is listed in the array of state.controllers\r
		if (!flattenedAddresses.includes(caller)) {\r
			throw new ContractError('Caller is not a controller of this DID');\r
		}\r
	}\r
\r
	async function getDidArweaveAddresses(did) {\r
		// remove did:ar*: from the start of the did string\r
		const contractId = did.replace(/^did:ar(.*?):/, '');\r
\r
		// check if contractId match this contract\r
		let didDoc =\r
			contractId == SmartWeave.contract.id\r
				? state\r
				: await SmartWeave.contracts.readContractState(contractId);\r
\r
		// get all publicKeyJwk.kty === "RSA" from verificationMethod\r
		const promises = didDoc.verificationMethod\r
			.filter((method) => method.publicKeyJwk.kty === 'RSA')\r
			.map(\r
				async (method) => await SmartWeave.arweave.wallets.ownerToAddress(method.publicKeyJwk.n)\r
			);\r
\r
		return await Promise.all(promises);\r
	}\r
\r
	if (input.function === 'update') {\r
		// Intialize = 1st update, only if caller is Contract owner\r
		if (!state.id && caller === SmartWeave.contract.owner) {\r
			if (!input?.id?.startsWith('did:ar') || !input.verificationMethod.length) {\r
				throw new ContractError('Invalid ID or missing verificationMethod');\r
			}\r
			state.id = input.id;\r
			state.controller = input?.controller || [input.id];\r
			setVerificatioMethod(); // initialize verificationMethods\r
		}\r
\r
		// after initial update, any controller can make updates\r
		await assertController(state, caller);\r
\r
		setVerificatioMethod();\r
\r
		state.controller = input?.controller || state.controller; // array allows for multiple controllers, see: https://w3c.github.io/did-core/#independent-control\r
		state.authentication = input?.authentication || state.authentication;\r
		state.assertionMethod = input?.assertionMethod || state.assertionMethod;\r
		state.keyAgreement = input?.keyAgreement || state.keyAgreement;\r
		state.capabilityInvocation = input?.capabilityInvocation || state.capabilityInvocation;\r
		state.capabilityDelegation = input?.capabilityDelegation || state.capabilityDelegation;\r
		state.service = input?.service || state.service;\r
	}\r
\r
	return { state };\r
}\r
`;
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function getAugmentedNamespace(n) {
  var o = n.default;
  if (typeof o == "function") {
    var a = function() {
      return o.apply(this, arguments);
    };
    a.prototype = o.prototype;
  } else
    a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(n).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(n, u);
    Object.defineProperty(a, u, c.get ? c : { enumerable: !0, get: function() {
      return n[u];
    } });
  }), a;
}
var base64 = {}, __extends = commonjsGlobal && commonjsGlobal.__extends || (extendStatics = function(n, o) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, u) {
    a.__proto__ = u;
  } || function(a, u) {
    for (var c in u)
      u.hasOwnProperty(c) && (a[c] = u[c]);
  }, extendStatics(n, o);
}, function(n, o) {
  function a() {
    this.constructor = n;
  }
  extendStatics(n, o), n.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());
}), extendStatics;
Object.defineProperty(base64, "__esModule", { value: !0 });
var INVALID_BYTE = 256, Coder = function() {
  function n(o) {
    o === void 0 && (o = "="), this._paddingCharacter = o;
  }
  return n.prototype.encodedLength = function(o) {
    return this._paddingCharacter ? (o + 2) / 3 * 4 | 0 : (8 * o + 5) / 6 | 0;
  }, n.prototype.encode = function(o) {
    for (var a = "", u = 0; u < o.length - 2; u += 3) {
      var c = o[u] << 16 | o[u + 1] << 8 | o[u + 2];
      a += this._encodeByte(c >>> 18 & 63), a += this._encodeByte(c >>> 12 & 63), a += this._encodeByte(c >>> 6 & 63), a += this._encodeByte(c >>> 0 & 63);
    }
    var p = o.length - u;
    return p > 0 && (c = o[u] << 16 | (p === 2 ? o[u + 1] << 8 : 0), a += this._encodeByte(c >>> 18 & 63), a += this._encodeByte(c >>> 12 & 63), a += p === 2 ? this._encodeByte(c >>> 6 & 63) : this._paddingCharacter || "", a += this._paddingCharacter || ""), a;
  }, n.prototype.maxDecodedLength = function(o) {
    return this._paddingCharacter ? o / 4 * 3 | 0 : (6 * o + 7) / 8 | 0;
  }, n.prototype.decodedLength = function(o) {
    return this.maxDecodedLength(o.length - this._getPaddingLength(o));
  }, n.prototype.decode = function(o) {
    if (o.length === 0)
      return new Uint8Array(0);
    for (var a = this._getPaddingLength(o), u = o.length - a, c = new Uint8Array(this.maxDecodedLength(u)), p = 0, d = 0, w = 0, S = 0, k = 0, B = 0, I = 0; d < u - 4; d += 4)
      S = this._decodeChar(o.charCodeAt(d + 0)), k = this._decodeChar(o.charCodeAt(d + 1)), B = this._decodeChar(o.charCodeAt(d + 2)), I = this._decodeChar(o.charCodeAt(d + 3)), c[p++] = S << 2 | k >>> 4, c[p++] = k << 4 | B >>> 2, c[p++] = B << 6 | I, w |= S & INVALID_BYTE, w |= k & INVALID_BYTE, w |= B & INVALID_BYTE, w |= I & INVALID_BYTE;
    if (d < u - 1 && (S = this._decodeChar(o.charCodeAt(d)), k = this._decodeChar(o.charCodeAt(d + 1)), c[p++] = S << 2 | k >>> 4, w |= S & INVALID_BYTE, w |= k & INVALID_BYTE), d < u - 2 && (B = this._decodeChar(o.charCodeAt(d + 2)), c[p++] = k << 4 | B >>> 2, w |= B & INVALID_BYTE), d < u - 3 && (I = this._decodeChar(o.charCodeAt(d + 3)), c[p++] = B << 6 | I, w |= I & INVALID_BYTE), w !== 0)
      throw new Error("Base64Coder: incorrect characters for decoding");
    return c;
  }, n.prototype._encodeByte = function(o) {
    var a = o;
    return a += 65, a += 25 - o >>> 8 & 6, a += 51 - o >>> 8 & -75, a += 61 - o >>> 8 & -15, a += 62 - o >>> 8 & 3, String.fromCharCode(a);
  }, n.prototype._decodeChar = function(o) {
    var a = INVALID_BYTE;
    return a += (42 - o & o - 44) >>> 8 & -INVALID_BYTE + o - 43 + 62, a += (46 - o & o - 48) >>> 8 & -INVALID_BYTE + o - 47 + 63, a += (47 - o & o - 58) >>> 8 & -INVALID_BYTE + o - 48 + 52, (a += (64 - o & o - 91) >>> 8 & -INVALID_BYTE + o - 65 + 0) + ((96 - o & o - 123) >>> 8 & -INVALID_BYTE + o - 97 + 26);
  }, n.prototype._getPaddingLength = function(o) {
    var a = 0;
    if (this._paddingCharacter) {
      for (var u = o.length - 1; u >= 0 && o[u] === this._paddingCharacter; u--)
        a++;
      if (o.length < 4 || a > 2)
        throw new Error("Base64Coder: incorrect padding");
    }
    return a;
  }, n;
}();
base64.Coder = Coder;
var stdCoder = new Coder();
function encode$4(n) {
  return stdCoder.encode(n);
}
function decode$2(n) {
  return stdCoder.decode(n);
}
base64.encode = encode$4, base64.decode = decode$2;
var URLSafeCoder = function(n) {
  function o() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return __extends(o, n), o.prototype._encodeByte = function(a) {
    var u = a;
    return u += 65, u += 25 - a >>> 8 & 6, u += 51 - a >>> 8 & -75, u += 61 - a >>> 8 & -13, u += 62 - a >>> 8 & 49, String.fromCharCode(u);
  }, o.prototype._decodeChar = function(a) {
    var u = INVALID_BYTE;
    return u += (44 - a & a - 46) >>> 8 & -INVALID_BYTE + a - 45 + 62, u += (94 - a & a - 96) >>> 8 & -INVALID_BYTE + a - 95 + 63, u += (47 - a & a - 58) >>> 8 & -INVALID_BYTE + a - 48 + 52, (u += (64 - a & a - 91) >>> 8 & -INVALID_BYTE + a - 65 + 0) + ((96 - a & a - 123) >>> 8 & -INVALID_BYTE + a - 97 + 26);
  }, o;
}(Coder);
base64.URLSafeCoder = URLSafeCoder;
var urlSafeCoder = new URLSafeCoder();
function encodeURLSafe(n) {
  return urlSafeCoder.encode(n);
}
var encodeURLSafe_1 = base64.encodeURLSafe = encodeURLSafe;
function decodeURLSafe(n) {
  return urlSafeCoder.decode(n);
}
base64.decodeURLSafe = decodeURLSafe, base64.encodedLength = function(n) {
  return stdCoder.encodedLength(n);
}, base64.maxDecodedLength = function(n) {
  return stdCoder.maxDecodedLength(n);
}, base64.decodedLength = function(n) {
  return stdCoder.decodedLength(n);
};
const SRC_TX = "SoPGF6d-5oLy6-uKpJD2J2tT0ytM9LsXWbP5YQnVT6Q";
function DidArFactory({ warp: n, wallet: o }) {
  return { warp: n, wallet: o, create, read: read$2, update };
}
async function init({ local: n = !1, wallet: o = "use_wallet", warp: a = null } = { local: !1, wallet: "use_wallet", warp: null }) {
  const { WarpFactory: u } = await Promise.resolve().then(() => index$1);
  return DidArFactory({ warp: a = a || (n ? u.forLocal() : u.forMainnet()), wallet: o });
}
async function create({ RSAPublicKey: n, Ed25519PublicKey: o, srcTx: a = SRC_TX } = {}) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const u = [{ name: "DID-AR", value: "true" }], { contractTxId: c, srcTxId: p } = a ? await this.warp.createContract.deployFromSourceTx({ wallet: this.wallet, initState: JSON.stringify(initialState), srcTxId: a, tags: u }) : await this.warp.createContract.deploy({ wallet: this.wallet, initState: JSON.stringify(initialState), src: contractSrc, tags: u }), d = this.warp.environment == "mainnet" ? `did:ar:${c}` : `did:arlocal:${c}`, w = await generateVerificationMethods({ did: d, publicKeys: [n, o] });
  return await this.update({ id: d, controller: [d], verificationMethod: w }), d;
}
async function update({ id: n, ...o }) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const a = n.replace(/^did:ar(.*?):/, ""), u = this.warp.contract(a);
  u.connect(this.wallet);
  try {
    await u.writeInteraction({ ...o, id: n, function: "update" });
  } catch (c) {
    console.error(c);
  }
}
async function read$2(n) {
  if (!this.warp || !this.wallet)
    throw new Error("warp and wallet required in parent object");
  const o = n.replace(/^did:ar(.*?):/, "");
  return (await this.warp.contract(o).readState()).cachedValue.state;
}
async function generateVerificationMethods({ did: n, publicKeys: o }) {
  const a = [];
  for (let u = 0; u < o.length; u++) {
    const c = o[u], p = `${n}#key-${u}`, d = isRSAKey(c) ? generateRSAVerificationMethod({ did: n, id: p, key: c }) : generateEd25519VerificationMethod({ did: n, id: p, key: c });
    a.push(d);
  }
  return a;
}
function generateRSAVerificationMethod({ did: n, id: o, key: a }) {
  return { id: o, type: "JsonWebKey2020", controller: n, publicKeyJwk: { kty: "RSA", e: "AQAB", n: a.n, kid: (a == null ? void 0 : a.kid) || o } };
}
function generateEd25519VerificationMethod({ did: n, id: o, key: a }) {
  return { id: o, type: "JsonWebKey2020", controller: n, publicKeyJwk: { kty: "OKP", crv: "Ed25519", x: encodeURLSafe_1(new Uint8Array(a)) } };
}
function isRSAKey(n) {
  return n.kty === "RSA";
}
function _catch(n, o) {
  try {
    var a = n();
  } catch (u) {
    return o(u);
  }
  return a && a.then ? a.then(void 0, o) : a;
}
function inMemoryCache() {
  const n = /* @__PURE__ */ new Map();
  return function(o, a) {
    try {
      let c = function(d) {
        if (u)
          return d;
        const w = n.get(o.didUrl);
        return w !== void 0 ? w : Promise.resolve(a()).then(function(S) {
          var k;
          return ((k = S.didResolutionMetadata) == null ? void 0 : k.error) !== "notFound" && n.set(o.didUrl, S), S;
        });
      }, u;
      const p = function() {
        if (o.params && o.params["no-cache"] === "true")
          return Promise.resolve(a()).then(function(d) {
            return u = 1, d;
          });
      }();
      return Promise.resolve(p && p.then ? p.then(c) : c(p));
    } catch (u) {
      return Promise.reject(u);
    }
  };
}
function noCache(n, o) {
  return o();
}
const PCT_ENCODED = "(?:%[0-9a-fA-F]{2})", ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`, METHOD = "([a-z0-9]+)", METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`, PARAM_CHAR = "[a-zA-Z0-9_.:%-]", PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`, PARAMS = `((${PARAM})*)`, PATH = "(/[^#?]*)?", QUERY = "([?][^#]*)?", FRAGMENT = "(#.*)?", DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
function parse$1(n) {
  if (n === "" || !n)
    return null;
  const o = n.match(DID_MATCHER);
  if (o) {
    const a = { did: `did:${o[1]}:${o[2]}`, method: o[1], id: o[2], didUrl: n };
    if (o[4]) {
      const u = o[4].slice(1).split(";");
      a.params = {};
      for (const c of u) {
        const p = c.split("=");
        a.params[p[0]] = p[1];
      }
    }
    return o[6] && (a.path = o[6]), o[7] && (a.query = o[7].slice(1)), o[8] && (a.fragment = o[8].slice(1)), a;
  }
  return null;
}
const EMPTY_RESULT = { didResolutionMetadata: {}, didDocument: null, didDocumentMetadata: {} };
function wrapLegacyResolver(n) {
  return function(o, a, u) {
    try {
      return Promise.resolve(_catch(function() {
        return Promise.resolve(n(o, a, u)).then(function(c) {
          return { ...EMPTY_RESULT, didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: c };
        });
      }, function(c) {
        return { ...EMPTY_RESULT, didResolutionMetadata: { error: "notFound", message: c.toString() } };
      }));
    } catch (c) {
      return Promise.reject(c);
    }
  };
}
class Resolver {
  constructor(o = {}, a = {}) {
    this.registry = void 0, this.cache = void 0, this.registry = o, this.cache = a.cache === !0 ? inMemoryCache() : a.cache || noCache, a.legacyResolvers && Object.keys(a.legacyResolvers).map((u) => {
      this.registry[u] || (this.registry[u] = wrapLegacyResolver(a.legacyResolvers[u]));
    });
  }
  resolve(o, a = {}) {
    try {
      const u = this, c = parse$1(o);
      if (c === null)
        return Promise.resolve({ ...EMPTY_RESULT, didResolutionMetadata: { error: "invalidDid" } });
      const p = u.registry[c.method];
      return p ? Promise.resolve(u.cache(c, () => p(c.did, c, u, a))) : Promise.resolve({ ...EMPTY_RESULT, didResolutionMetadata: { error: "unsupportedDidMethod" } });
    } catch (u) {
      return Promise.reject(u);
    }
  }
}
function getResolver() {
  return { ar: async function(n, o, a, u) {
    const { WarpFactory: c } = await Promise.resolve().then(() => index$1);
    let p = c.forMainnet();
    return { didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: (await p.contract(o.id).readState()).cachedValue.state, didDocumentMetadata: {} };
  }, arlocal: async function(n, o, a, u) {
    const { WarpFactory: c } = await Promise.resolve().then(() => index$1);
    let p = c.forLocal();
    return { didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: (await p.contract(o.id).readState()).cachedValue.state, didDocumentMetadata: {} };
  } };
}
const subscriber_queue = [];
function readable(n, o) {
  return { subscribe: writable(n, o).subscribe };
}
function writable(n, o = noop$2) {
  let a;
  const u = /* @__PURE__ */ new Set();
  function c(p) {
    if (safe_not_equal(n, p) && (n = p, a)) {
      const d = !subscriber_queue.length;
      for (const w of u)
        w[1](), subscriber_queue.push(w, n);
      if (d) {
        for (let w = 0; w < subscriber_queue.length; w += 2)
          subscriber_queue[w][0](subscriber_queue[w + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  return { set: c, update: function(p) {
    c(p(n));
  }, subscribe: function(p, d = noop$2) {
    const w = [p, d];
    return u.add(w), u.size === 1 && (a = o(c) || noop$2), p(n), () => {
      u.delete(w), u.size === 0 && (a(), a = null);
    };
  } };
}
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (n, o, a) => o in n ? __defProp(n, o, { enumerable: !0, configurable: !0, writable: !0, value: a }) : n[o] = a, __spreadValues = (n, o) => {
  for (var a in o || (o = {}))
    __hasOwnProp.call(o, a) && __defNormalProp(n, a, o[a]);
  if (__getOwnPropSymbols)
    for (var a of __getOwnPropSymbols(o))
      __propIsEnum.call(o, a) && __defNormalProp(n, a, o[a]);
  return n;
};
const STATE = {};
function useState(n, o) {
  const a = getContext(STATE), u = typeof n == "function" ? n(a) : n, c = __spreadValues(__spreadValues({}, a), u);
  return o != null && o.expandable && (c.isParentExpanded = c.expanded), setContext(STATE, c), a;
}
function add_css$8(n) {
  append_styles(n, "svelte-1qd6nto", ".container.svelte-1qd6nto{display:inline-block;transform:translate(calc(0px - var(--li-identation)), -50%);position:absolute;top:50%;padding-right:100%}.arrow.svelte-1qd6nto{transform-origin:25% 50%;position:relative;line-height:1.1em;font-size:0.75em;margin-left:0;transition:150ms;color:var(--arrow-color);user-select:none;font-family:'Courier New', Courier, monospace;display:block}.expanded.svelte-1qd6nto{transform:rotateZ(90deg) translateX(-3px)}");
}
function create_if_block$8(n) {
  let o, a, u, c;
  return { c() {
    o = element("span"), a = element("span"), a.textContent = "\u25B6", attr(a, "class", "arrow svelte-1qd6nto"), toggle_class(a, "expanded", n[2]), attr(o, "class", "container svelte-1qd6nto");
  }, m(p, d) {
    insert(p, o, d), append(o, a), u || (c = listen(o, "click", n[4]), u = !0);
  }, p(p, d) {
    4 & d && toggle_class(a, "expanded", p[2]);
  }, d(p) {
    p && detach(o), u = !1, c();
  } };
}
function create_fragment$i(n) {
  let o, a = n[1] && create_if_block$8(n);
  return { c() {
    a && a.c(), o = empty();
  }, m(u, c) {
    a && a.m(u, c), insert(u, o, c);
  }, p(u, [c]) {
    u[1] ? a ? a.p(u, c) : (a = create_if_block$8(u), a.c(), a.m(o.parentNode, o)) : a && (a.d(1), a = null);
  }, i: noop$2, o: noop$2, d(u) {
    a && a.d(u), u && detach(o);
  } };
}
function instance$i(n, o, a) {
  let u, c, p = noop$2, d = () => (p(), p = subscribe(k, (B) => a(2, c = B)), k);
  n.$$.on_destroy.push(() => p());
  const { expanded: w, expandable: S } = useState();
  component_subscribe(n, S, (B) => a(1, u = B));
  let { expanded: k = w } = o;
  return d(), n.$$set = (B) => {
    "expanded" in B && d(a(0, k = B.expanded));
  }, [k, u, c, S, (B) => {
    B.stopPropagation(), set_store_value(k, c = !c, c);
  }];
}
class JSONArrow extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$i, create_fragment$i, safe_not_equal, { expanded: 0 }, add_css$8);
  }
}
function create_fragment$h(n) {
  let o;
  const a = n[1].default, u = create_slot(a, n, n[0], null);
  return { c() {
    u && u.c();
  }, m(c, p) {
    u && u.m(c, p), o = !0;
  }, p(c, [p]) {
    u && u.p && (!o || 1 & p) && update_slot_base(u, a, c, c[0], o ? get_slot_changes(a, c[0], p, null) : get_all_dirty_from_scope(c[0]), null);
  }, i(c) {
    o || (transition_in(u, c), o = !0);
  }, o(c) {
    transition_out(u, c), o = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function instance$h(n, o, a) {
  let { $$slots: u = {}, $$scope: c } = o;
  return useState({ displayMode: "summary" }), n.$$set = (p) => {
    "$$scope" in p && a(0, c = p.$$scope);
  }, [c, u];
}
class Summary extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$h, create_fragment$h, safe_not_equal, {});
  }
}
function create_fragment$g(n) {
  let o;
  const a = n[3].default, u = create_slot(a, n, n[2], null);
  return { c() {
    u && u.c();
  }, m(c, p) {
    u && u.m(c, p), o = !0;
  }, p(c, [p]) {
    u && u.p && (!o || 4 & p) && update_slot_base(u, a, c, c[2], o ? get_slot_changes(a, c[2], p, null) : get_all_dirty_from_scope(c[2]), null);
  }, i(c) {
    o || (transition_in(u, c), o = !0);
  }, o(c) {
    transition_out(u, c), o = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function instance$g(n, o, a) {
  let { $$slots: u = {}, $$scope: c } = o, { expanded: p } = o, { key: d } = o;
  const w = writable(!1);
  return useState(({ keyPath: S, level: k }) => (d !== "[[Entries]]" && (S = [...S, d], k += 1), { keyPath: S, level: k, expanded: p, expandable: w })), n.$$set = (S) => {
    "expanded" in S && a(0, p = S.expanded), "key" in S && a(1, d = S.key), "$$scope" in S && a(2, c = S.$$scope);
  }, [p, d, c, u];
}
class Expandable extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$g, create_fragment$g, safe_not_equal, { expanded: 0, key: 1 });
  }
}
function add_css$7(n) {
  append_styles(n, "svelte-19drypg", ".root.svelte-19drypg{display:inline-block;position:relative}.indent.svelte-19drypg{padding-left:var(--li-identation)}.label.svelte-19drypg{position:relative}");
}
function get_each_context$2(n, o, a) {
  const u = n.slice();
  return u[19] = o[a], u[21] = a, u;
}
const get_item_value_slot_changes = (n) => ({ key: 1 & n }), get_item_value_slot_context = (n) => ({ key: n[19], index: n[21] }), get_item_key_slot_changes = (n) => ({ key: 1 & n }), get_item_key_slot_context = (n) => ({ key: n[19], index: n[21] }), get_preview_slot_changes = (n) => ({}), get_preview_slot_context = (n) => ({}), get_summary_slot_changes = (n) => ({}), get_summary_slot_context = (n) => ({});
function create_else_block$6(n) {
  let o, a, u, c, p, d, w, S, k = n[6] && create_if_block_3$2(n);
  u = new Summary({ props: { $$slots: { default: [create_default_slot_1] }, $$scope: { ctx: n } } });
  let B = n[4] && create_if_block_1$2$1(n);
  return { c() {
    o = element("span"), k && k.c(), a = space(), create_component(u.$$.fragment), c = space(), B && B.c(), p = empty(), attr(o, "class", "root svelte-19drypg");
  }, m(I, C) {
    insert(I, o, C), k && k.m(o, null), append(o, a), mount_component(u, o, null), insert(I, c, C), B && B.m(I, C), insert(I, p, C), d = !0, w || (S = listen(o, "click", n[9]), w = !0);
  }, p(I, C) {
    I[6] && k.p(I, C);
    const P = {};
    8192 & C && (P.$$scope = { dirty: C, ctx: I }), u.$set(P), I[4] ? B ? (B.p(I, C), 16 & C && transition_in(B, 1)) : (B = create_if_block_1$2$1(I), B.c(), transition_in(B, 1), B.m(p.parentNode, p)) : B && (group_outros(), transition_out(B, 1, 1, () => {
      B = null;
    }), check_outros());
  }, i(I) {
    d || (transition_in(k), transition_in(u.$$.fragment, I), transition_in(B), d = !0);
  }, o(I) {
    transition_out(k), transition_out(u.$$.fragment, I), transition_out(B), d = !1;
  }, d(I) {
    I && detach(o), k && k.d(), destroy_component(u), I && detach(c), B && B.d(I), I && detach(p), w = !1, S();
  } };
}
function create_if_block$7(n) {
  let o;
  const a = n[11].summary, u = create_slot(a, n, n[13], get_summary_slot_context);
  return { c() {
    u && u.c();
  }, m(c, p) {
    u && u.m(c, p), o = !0;
  }, p(c, p) {
    u && u.p && (!o || 8192 & p) && update_slot_base(u, a, c, c[13], o ? get_slot_changes(a, c[13], p, get_summary_slot_changes) : get_all_dirty_from_scope(c[13]), get_summary_slot_context);
  }, i(c) {
    o || (transition_in(u, c), o = !0);
  }, o(c) {
    transition_out(u, c), o = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block_3$2(n) {
  let o, a;
  return o = new JSONArrow({ props: { expanded: n[7] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p: noop$2, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_default_slot_1(n) {
  let o;
  const a = n[11].preview, u = create_slot(a, n, n[13], get_preview_slot_context);
  return { c() {
    u && u.c();
  }, m(c, p) {
    u && u.m(c, p), o = !0;
  }, p(c, p) {
    u && u.p && (!o || 8192 & p) && update_slot_base(u, a, c, c[13], o ? get_slot_changes(a, c[13], p, get_preview_slot_changes) : get_all_dirty_from_scope(c[13]), get_preview_slot_context);
  }, i(c) {
    o || (transition_in(u, c), o = !0);
  }, o(c) {
    transition_out(u, c), o = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block_1$2$1(n) {
  let o, a, u, c, p = n[0], d = [];
  for (let S = 0; S < p.length; S += 1)
    d[S] = create_each_block$2(get_each_context$2(n, p, S));
  const w = (S) => transition_out(d[S], 1, 1, () => {
    d[S] = null;
  });
  return { c() {
    o = element("ul");
    for (let S = 0; S < d.length; S += 1)
      d[S].c();
  }, m(S, k) {
    insert(S, o, k);
    for (let B = 0; B < d.length; B += 1)
      d[B].m(o, null);
    a = !0, u || (c = listen(o, "click", stop_propagation(n[9])), u = !0);
  }, p(S, k) {
    if (8223 & k) {
      let B;
      for (p = S[0], B = 0; B < p.length; B += 1) {
        const I = get_each_context$2(S, p, B);
        d[B] ? (d[B].p(I, k), transition_in(d[B], 1)) : (d[B] = create_each_block$2(I), d[B].c(), transition_in(d[B], 1), d[B].m(o, null));
      }
      for (group_outros(), B = p.length; B < d.length; B += 1)
        w(B);
      check_outros();
    }
  }, i(S) {
    if (!a) {
      for (let k = 0; k < p.length; k += 1)
        transition_in(d[k]);
      a = !0;
    }
  }, o(S) {
    d = d.filter(Boolean);
    for (let k = 0; k < d.length; k += 1)
      transition_out(d[k]);
    a = !1;
  }, d(S) {
    S && detach(o), destroy_each(d, S), u = !1, c();
  } };
}
function create_if_block_2$2(n) {
  let o;
  return { c() {
    o = element("span"), o.textContent = ":", attr(o, "class", "operator");
  }, m(a, u) {
    insert(a, o, u);
  }, d(a) {
    a && detach(o);
  } };
}
function create_default_slot$1$1(n) {
  let o, a, u, c, p, d, w = !n[1] || n[1](n[19]);
  a = new JSONArrow({});
  const S = n[11].item_key, k = create_slot(S, n, n[13], get_item_key_slot_context);
  let B = w && create_if_block_2$2();
  function I() {
    return n[12](n[21]);
  }
  const C = n[11].item_value, P = create_slot(C, n, n[13], get_item_value_slot_context);
  return { c() {
    o = element("span"), create_component(a.$$.fragment), k && k.c(), B && B.c(), u = space(), P && P.c(), attr(o, "class", "label svelte-19drypg");
  }, m(q, D) {
    insert(q, o, D), mount_component(a, o, null), k && k.m(o, null), B && B.m(o, null), append(o, u), P && P.m(q, D), c = !0, p || (d = listen(o, "click", I), p = !0);
  }, p(q, D) {
    n = q, k && k.p && (!c || 8193 & D) && update_slot_base(k, S, n, n[13], c ? get_slot_changes(S, n[13], D, get_item_key_slot_changes) : get_all_dirty_from_scope(n[13]), get_item_key_slot_context), 3 & D && (w = !n[1] || n[1](n[19])), w ? B || (B = create_if_block_2$2(), B.c(), B.m(o, u)) : B && (B.d(1), B = null), P && P.p && (!c || 8193 & D) && update_slot_base(P, C, n, n[13], c ? get_slot_changes(C, n[13], D, get_item_value_slot_changes) : get_all_dirty_from_scope(n[13]), get_item_value_slot_context);
  }, i(q) {
    c || (transition_in(a.$$.fragment, q), transition_in(k, q), transition_in(P, q), c = !0);
  }, o(q) {
    transition_out(a.$$.fragment, q), transition_out(k, q), transition_out(P, q), c = !1;
  }, d(q) {
    q && detach(o), destroy_component(a), k && k.d(q), B && B.d(), P && P.d(q), p = !1, d();
  } };
}
function create_each_block$2(n) {
  let o, a, u, c, p, d;
  return a = new Expandable({ props: { key: n[2](n[19]), expanded: n[3][n[21]], $$slots: { default: [create_default_slot$1$1] }, $$scope: { ctx: n } } }), { c() {
    o = element("li"), create_component(a.$$.fragment), u = space(), attr(o, "class", "svelte-19drypg"), toggle_class(o, "indent", n[4]);
  }, m(w, S) {
    insert(w, o, S), mount_component(a, o, null), append(o, u), c = !0, p || (d = listen(o, "click", stop_propagation(click_handler_1)), p = !0);
  }, p(w, S) {
    const k = {};
    5 & S && (k.key = w[2](w[19])), 8 & S && (k.expanded = w[3][w[21]]), 8203 & S && (k.$$scope = { dirty: S, ctx: w }), a.$set(k), 16 & S && toggle_class(o, "indent", w[4]);
  }, i(w) {
    c || (transition_in(a.$$.fragment, w), c = !0);
  }, o(w) {
    transition_out(a.$$.fragment, w), c = !1;
  }, d(w) {
    w && detach(o), destroy_component(a), p = !1, d();
  } };
}
function create_fragment$f(n) {
  let o, a, u, c;
  const p = [create_if_block$7, create_else_block$6], d = [];
  return o = n[5] === "summary" ? 0 : 1, a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(w, S) {
    d[o].m(w, S), insert(w, u, S), c = !0;
  }, p(w, [S]) {
    a.p(w, S);
  }, i(w) {
    c || (transition_in(a), c = !0);
  }, o(w) {
    transition_out(a), c = !1;
  }, d(w) {
    d[o].d(w), w && detach(u);
  } };
}
const click_handler_1 = () => {
};
function instance$f(n, o, a) {
  let u, c, p, { $$slots: d = {}, $$scope: w } = o, { keys: S } = o, { shouldShowColon: k } = o, { expandKey: B = (N) => N } = o, { defaultExpanded: I = !1 } = o;
  const { isParentExpanded: C, displayMode: P, root: q, expanded: D, expandable: z, keyPath: F, level: V, shouldExpandNode: Z } = useState({ root: !1 }, { expandable: !0 });
  if (component_subscribe(n, D, (N) => a(4, c = N)), component_subscribe(n, z, (N) => a(14, p = N)), set_store_value(z, p = !0, p), P !== "summary") {
    if (!I) {
      const N = Z({ keyPath: F, level: V });
      N !== void 0 && (I = N);
    }
    onMount(() => C.subscribe((N) => {
      N ? D.set(I) : D.set(!1);
    }));
  }
  return n.$$set = (N) => {
    "keys" in N && a(0, S = N.keys), "shouldShowColon" in N && a(1, k = N.shouldShowColon), "expandKey" in N && a(2, B = N.expandKey), "defaultExpanded" in N && a(10, I = N.defaultExpanded), "$$scope" in N && a(13, w = N.$$scope);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(3, u = S.map(() => writable(!1)));
  }, [S, k, B, u, c, P, q, D, z, function() {
    set_store_value(D, c = !c, c);
  }, I, d, (N) => u[N].update((W) => !W), w];
}
class JSONNested extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$f, create_fragment$f, safe_not_equal, { keys: 0, shouldShowColon: 1, expandKey: 2, defaultExpanded: 10 }, add_css$7);
  }
}
function add_css$6(n) {
  append_styles(n, "svelte-150ffaa", ".comma.svelte-150ffaa{margin-left:-0.5em;margin-right:0.5em}");
}
function get_each_context$1(n, o, a) {
  const u = n.slice();
  return u[7] = o[a], u[9] = a, u;
}
const get_item_slot_changes = (n) => ({ item: 1 & n }), get_item_slot_context = (n) => ({ item: n[7], index: n[9] });
function create_if_block_3$1(n) {
  let o, a, u = n[2] && create_if_block_4(n);
  return { c() {
    u && u.c(), o = element("span"), a = text(n[3]), attr(o, "class", "operator");
  }, m(c, p) {
    u && u.m(c, p), insert(c, o, p), append(o, a);
  }, p(c, p) {
    c[2] ? u ? u.p(c, p) : (u = create_if_block_4(c), u.c(), u.m(o.parentNode, o)) : u && (u.d(1), u = null), 8 & p && set_data(a, c[3]);
  }, d(c) {
    u && u.d(c), c && detach(o);
  } };
}
function create_if_block_4(n) {
  let o, a;
  return { c() {
    o = element("span"), a = text(n[2]), attr(o, "class", "label");
  }, m(u, c) {
    insert(u, o, c), append(o, a);
  }, p(u, c) {
    4 & c && set_data(a, u[2]);
  }, d(u) {
    u && detach(o);
  } };
}
function create_if_block_2$1$1(n) {
  let o;
  return { c() {
    o = element("span"), o.textContent = ",", attr(o, "class", "comma operator svelte-150ffaa");
  }, m(a, u) {
    insert(a, o, u);
  }, d(a) {
    a && detach(o);
  } };
}
function create_each_block$1(n) {
  let o, a, u;
  const c = n[6].item, p = create_slot(c, n, n[5], get_item_slot_context);
  let d = n[9] < n[0].length - 1 && create_if_block_2$1$1();
  return { c() {
    p && p.c(), o = space(), d && d.c(), a = empty();
  }, m(w, S) {
    p && p.m(w, S), insert(w, o, S), d && d.m(w, S), insert(w, a, S), u = !0;
  }, p(w, S) {
    p && p.p && (!u || 33 & S) && update_slot_base(p, c, w, w[5], u ? get_slot_changes(c, w[5], S, get_item_slot_changes) : get_all_dirty_from_scope(w[5]), get_item_slot_context), w[9] < w[0].length - 1 ? d || (d = create_if_block_2$1$1(), d.c(), d.m(a.parentNode, a)) : d && (d.d(1), d = null);
  }, i(w) {
    u || (transition_in(p, w), u = !0);
  }, o(w) {
    transition_out(p, w), u = !1;
  }, d(w) {
    p && p.d(w), w && detach(o), d && d.d(w), w && detach(a);
  } };
}
function create_if_block_1$1$1(n) {
  let o, a, u;
  return { c() {
    o = element("span"), o.textContent = ",", a = space(), u = element("span"), u.textContent = "\u2026", attr(o, "class", "comma operator svelte-150ffaa"), attr(u, "class", "operator");
  }, m(c, p) {
    insert(c, o, p), insert(c, a, p), insert(c, u, p);
  }, d(c) {
    c && detach(o), c && detach(a), c && detach(u);
  } };
}
function create_if_block$6(n) {
  let o, a;
  return { c() {
    o = element("span"), a = text(n[4]), attr(o, "class", "operator");
  }, m(u, c) {
    insert(u, o, c), append(o, a);
  }, p(u, c) {
    16 & c && set_data(a, u[4]);
  }, d(u) {
    u && detach(o);
  } };
}
function create_fragment$e(n) {
  let o, a, u, c, p, d = n[3] && create_if_block_3$1(n), w = n[0], S = [];
  for (let C = 0; C < w.length; C += 1)
    S[C] = create_each_block$1(get_each_context$1(n, w, C));
  const k = (C) => transition_out(S[C], 1, 1, () => {
    S[C] = null;
  });
  let B = n[1] && create_if_block_1$1$1(), I = n[4] && create_if_block$6(n);
  return { c() {
    d && d.c(), o = space();
    for (let C = 0; C < S.length; C += 1)
      S[C].c();
    a = space(), B && B.c(), u = space(), I && I.c(), c = empty();
  }, m(C, P) {
    d && d.m(C, P), insert(C, o, P);
    for (let q = 0; q < S.length; q += 1)
      S[q].m(C, P);
    insert(C, a, P), B && B.m(C, P), insert(C, u, P), I && I.m(C, P), insert(C, c, P), p = !0;
  }, p(C, [P]) {
    if (C[3] ? d ? d.p(C, P) : (d = create_if_block_3$1(C), d.c(), d.m(o.parentNode, o)) : d && (d.d(1), d = null), 33 & P) {
      let q;
      for (w = C[0], q = 0; q < w.length; q += 1) {
        const D = get_each_context$1(C, w, q);
        S[q] ? (S[q].p(D, P), transition_in(S[q], 1)) : (S[q] = create_each_block$1(D), S[q].c(), transition_in(S[q], 1), S[q].m(a.parentNode, a));
      }
      for (group_outros(), q = w.length; q < S.length; q += 1)
        k(q);
      check_outros();
    }
    C[1] ? B || (B = create_if_block_1$1$1(), B.c(), B.m(u.parentNode, u)) : B && (B.d(1), B = null), C[4] ? I ? I.p(C, P) : (I = create_if_block$6(C), I.c(), I.m(c.parentNode, c)) : I && (I.d(1), I = null);
  }, i(C) {
    if (!p) {
      for (let P = 0; P < w.length; P += 1)
        transition_in(S[P]);
      p = !0;
    }
  }, o(C) {
    S = S.filter(Boolean);
    for (let P = 0; P < S.length; P += 1)
      transition_out(S[P]);
    p = !1;
  }, d(C) {
    d && d.d(C), C && detach(o), destroy_each(S, C), C && detach(a), B && B.d(C), C && detach(u), I && I.d(C), C && detach(c);
  } };
}
function instance$e(n, o, a) {
  let { $$slots: u = {}, $$scope: c } = o, { list: p } = o, { hasMore: d } = o, { label: w } = o, { prefix: S } = o, { postfix: k } = o;
  return n.$$set = (B) => {
    "list" in B && a(0, p = B.list), "hasMore" in B && a(1, d = B.hasMore), "label" in B && a(2, w = B.label), "prefix" in B && a(3, S = B.prefix), "postfix" in B && a(4, k = B.postfix), "$$scope" in B && a(5, c = B.$$scope);
  }, [p, d, w, S, k, c, u];
}
class PreviewList extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$e, create_fragment$e, safe_not_equal, { list: 0, hasMore: 1, label: 2, prefix: 3, postfix: 4 }, add_css$6);
  }
}
function create_summary_slot$8(n) {
  let o;
  return { c() {
    o = element("span"), o.textContent = "{\u2026}", attr(o, "class", "label");
  }, m(a, u) {
    insert(a, o, u);
  }, p: noop$2, d(a) {
    a && detach(o);
  } };
}
function create_item_slot$5(n) {
  let o, a, u, c, p, d = n[4] + "";
  return c = new JSONNode({ props: { value: n[0][n[4]] } }), { c() {
    o = element("span"), a = text(d), u = element("span"), u.textContent = ": ", create_component(c.$$.fragment), attr(o, "class", "property"), attr(u, "class", "operator");
  }, m(w, S) {
    insert(w, o, S), append(o, a), insert(w, u, S), mount_component(c, w, S), p = !0;
  }, p(w, S) {
    (!p || 16 & S) && d !== (d = w[4] + "") && set_data(a, d);
    const k = {};
    17 & S && (k.value = w[0][w[4]]), c.$set(k);
  }, i(w) {
    p || (transition_in(c.$$.fragment, w), p = !0);
  }, o(w) {
    transition_out(c.$$.fragment, w), p = !1;
  }, d(w) {
    w && detach(o), w && detach(u), destroy_component(c, w);
  } };
}
function create_preview_slot$8(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[2], hasMore: n[2].length < n[1].length, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$5, ({ item: u }) => ({ 4: u }), ({ item: u }) => u ? 16 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    4 & c && (p.list = u[2]), 6 & c && (p.hasMore = u[2].length < u[1].length), 49 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot$8(n) {
  let o, a, u = n[3] + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    8 & p && u !== (u = c[3] + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_item_value_slot$8(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[3]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    9 & c && (p.value = u[0][u[3]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$d(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[1], $$slots: { item_value: [create_item_value_slot$8, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot$8, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot$8], summary: [create_summary_slot$8] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    2 & c && (p.keys = u[1]), 47 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function instance$d(n, o, a) {
  let u, c, { value: p } = o;
  return n.$$set = (d) => {
    "value" in d && a(0, p = d.value);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(1, u = Object.getOwnPropertyNames(p)), 2 & n.$$.dirty && a(2, c = u.slice(0, 5));
  }, [p, u, c];
}
class JSONObjectNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$d, create_fragment$d, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$7(n) {
  let o, a, u, c, p = n[0].length + "";
  return { c() {
    o = element("span"), a = text("Array("), u = text(p), c = text(")"), attr(o, "class", "label");
  }, m(d, w) {
    insert(d, o, w), append(o, a), append(o, u), append(o, c);
  }, p(d, w) {
    1 & w && p !== (p = d[0].length + "") && set_data(u, p);
  }, d(d) {
    d && detach(o);
  } };
}
function create_item_slot$4(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[4] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    16 & c && (p.value = u[4]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_preview_slot$7(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[1], hasMore: n[1].length < n[0].length, label: "(" + n[0].length + ") ", prefix: "[", postfix: "]", $$slots: { item: [create_item_slot$4, ({ item: u }) => ({ 4: u }), ({ item: u }) => u ? 16 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    2 & c && (p.list = u[1]), 3 & c && (p.hasMore = u[1].length < u[0].length), 1 & c && (p.label = "(" + u[0].length + ") "), 48 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot$7(n) {
  let o, a, u = String(n[3]) + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    8 & p && u !== (u = String(c[3]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_item_value_slot$7(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[3]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    9 & c && (p.value = u[0][u[3]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$c(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[2], $$slots: { item_value: [create_item_value_slot$7, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot$7, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot$7], summary: [create_summary_slot$7] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    4 & c && (p.keys = u[2]), 43 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function instance$c(n, o, a) {
  let u, c, { value: p } = o;
  return n.$$set = (d) => {
    "value" in d && a(0, p = d.value);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(2, u = Object.getOwnPropertyNames(p)), 1 & n.$$.dirty && a(1, c = p.slice(0, 5));
  }, [p, c, u];
}
class JSONArrayNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$c, create_fragment$c, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$6(n) {
  let o, a, u, c, p, d = n[3].length + "";
  return { c() {
    o = element("span"), a = text(n[1]), u = text("("), c = text(d), p = text(")"), attr(o, "class", "label");
  }, m(w, S) {
    insert(w, o, S), append(o, a), append(o, u), append(o, c), append(o, p);
  }, p(w, S) {
    2 & S && set_data(a, w[1]), 8 & S && d !== (d = w[3].length + "") && set_data(c, d);
  }, d(w) {
    w && detach(o);
  } };
}
function create_item_slot$3(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[8] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    256 & c && (p.value = u[8]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_preview_slot$6(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[4], hasMore: n[4].length < n[2].length, label: `${n[1]}(${n[3].length}) `, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$3, ({ item: u }) => ({ 8: u }), ({ item: u }) => u ? 256 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    16 & c && (p.list = u[4]), 20 & c && (p.hasMore = u[4].length < u[2].length), 10 & c && (p.label = `${u[1]}(${u[3].length}) `), 768 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot_1$1(n) {
  let o, a, u, c = n[6] + "";
  return { c() {
    o = element("span"), a = text(c), attr(o, "class", u = n[6] === ENTRIES$1 ? "internal" : "property");
  }, m(p, d) {
    insert(p, o, d), append(o, a);
  }, p(p, d) {
    64 & d && c !== (c = p[6] + "") && set_data(a, c), 64 & d && u !== (u = p[6] === ENTRIES$1 ? "internal" : "property") && attr(o, "class", u);
  }, d(p) {
    p && detach(o);
  } };
}
function create_else_block$5(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[6]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    65 & c && (p.value = u[0][u[6]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block$5(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[3], defaultExpanded: !0, $$slots: { item_value: [create_item_value_slot_1$1, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot$6, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    8 & c && (p.keys = u[3]), 644 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot$6(n) {
  let o, a, u = n[7] + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    128 & p && u !== (u = c[7] + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_item_value_slot_1$1(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[2][n[7]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    132 & c && (p.value = u[2][u[7]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_value_slot$6(n) {
  let o, a, u, c;
  const p = [create_if_block$5, create_else_block$5], d = [];
  function w(S, k) {
    return S[6] === ENTRIES$1 ? 0 : 1;
  }
  return o = w(n), a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(S, k) {
    d[o].m(S, k), insert(S, u, k), c = !0;
  }, p(S, k) {
    let B = o;
    o = w(S), o === B ? d[o].p(S, k) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[o], a ? a.p(S, k) : (a = d[o] = p[o](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[o].d(S), S && detach(u);
  } };
}
function create_fragment$b(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: [ENTRIES$1, "size"], shouldShowColon: n[5], $$slots: { item_value: [create_item_value_slot$6, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], item_key: [create_item_key_slot_1$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], preview: [create_preview_slot$6], summary: [create_summary_slot$6] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    607 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
const ENTRIES$1 = "[[Entries]]";
function instance$b(n, o, a) {
  let u, { value: c } = o, { nodeType: p } = o, d = [], w = [];
  return n.$$set = (S) => {
    "value" in S && a(0, c = S.value), "nodeType" in S && a(1, p = S.nodeType);
  }, n.$$.update = () => {
    if (1 & n.$$.dirty) {
      let S = [], k = [], B = 0;
      for (const I of c)
        S.push(B++), k.push(I);
      a(3, d = S), a(2, w = k);
    }
    4 & n.$$.dirty && a(4, u = w.slice(0, 5));
  }, [c, p, w, d, u, (S) => S !== ENTRIES$1];
}
class JSONIterableArrayNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$b, create_fragment$b, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function create_summary_slot$5(n) {
  let o, a, u, c, p = n[2].length + "";
  return { c() {
    o = element("span"), a = text("Map("), u = text(p), c = text(")"), attr(o, "color", "label");
  }, m(d, w) {
    insert(d, o, w), append(o, a), append(o, u), append(o, c);
  }, p(d, w) {
    4 & w && p !== (p = d[2].length + "") && set_data(u, p);
  }, d(d) {
    d && detach(o);
  } };
}
function create_item_slot$2(n) {
  let o, a, u, c;
  return o = new JSONNode({ props: { value: n[10] } }), u = new JSONNode({ props: { value: n[0].get(n[10]) } }), { c() {
    create_component(o.$$.fragment), a = element("span"), a.textContent = " => ", create_component(u.$$.fragment), attr(a, "class", "operator");
  }, m(p, d) {
    mount_component(o, p, d), insert(p, a, d), mount_component(u, p, d), c = !0;
  }, p(p, d) {
    const w = {};
    1024 & d && (w.value = p[10]), o.$set(w);
    const S = {};
    1025 & d && (S.value = p[0].get(p[10])), u.$set(S);
  }, i(p) {
    c || (transition_in(o.$$.fragment, p), transition_in(u.$$.fragment, p), c = !0);
  }, o(p) {
    transition_out(o.$$.fragment, p), transition_out(u.$$.fragment, p), c = !1;
  }, d(p) {
    destroy_component(o, p), p && detach(a), destroy_component(u, p);
  } };
}
function create_preview_slot_1(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[4], hasMore: n[4].length < n[0].size, label: `Map(${n[2].length}) `, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$2, ({ item: u }) => ({ 10: u }), ({ item: u }) => u ? 1024 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    16 & c && (p.list = u[4]), 17 & c && (p.hasMore = u[4].length < u[0].size), 4 & c && (p.label = `Map(${u[2].length}) `), 3073 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot_2(n) {
  let o, a, u, c = n[7] + "";
  return { c() {
    o = element("span"), a = text(c), attr(o, "class", u = n[7] === ENTRIES ? "internal" : "property");
  }, m(p, d) {
    insert(p, o, d), append(o, a);
  }, p(p, d) {
    128 & d && c !== (c = p[7] + "") && set_data(a, c), 128 & d && u !== (u = p[7] === ENTRIES ? "internal" : "property") && attr(o, "class", u);
  }, d(p) {
    p && detach(o);
  } };
}
function create_else_block$4(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[7]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    129 & c && (p.value = u[0][u[7]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block$4(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[1], expandKey: n[5], defaultExpanded: !0, $$slots: { item_value: [create_item_value_slot_1, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], item_key: [create_item_key_slot_1, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    2 & c && (p.keys = u[1]), 4 & c && (p.expandKey = u[5]), 2316 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot_1(n) {
  let o, a, u = n[8] + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    256 & p && u !== (u = c[8] + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_preview_slot$5(n) {
  let o, a, u, c, p, d;
  return a = new JSONNode({ props: { value: n[2][n[8]] } }), c = new JSONNode({ props: { value: n[3][n[8]] } }), { c() {
    o = element("span"), o.textContent = "{ ", create_component(a.$$.fragment), u = element("span"), u.textContent = " => ", create_component(c.$$.fragment), p = element("span"), p.textContent = " }", attr(o, "class", "operator"), attr(u, "class", "operator"), attr(p, "class", "operator");
  }, m(w, S) {
    insert(w, o, S), mount_component(a, w, S), insert(w, u, S), mount_component(c, w, S), insert(w, p, S), d = !0;
  }, p(w, S) {
    const k = {};
    260 & S && (k.value = w[2][w[8]]), a.$set(k);
    const B = {};
    264 & S && (B.value = w[3][w[8]]), c.$set(B);
  }, i(w) {
    d || (transition_in(a.$$.fragment, w), transition_in(c.$$.fragment, w), d = !0);
  }, o(w) {
    transition_out(a.$$.fragment, w), transition_out(c.$$.fragment, w), d = !1;
  }, d(w) {
    w && detach(o), destroy_component(a, w), w && detach(u), destroy_component(c, w), w && detach(p);
  } };
}
function create_item_key_slot$5(n) {
  let o, a, u = n[9] + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    512 & p && u !== (u = c[9] + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_item_value_slot_2(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[9] === "key" ? n[2][n[8]] : n[3][n[8]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    780 & c && (p.value = u[9] === "key" ? u[2][u[8]] : u[3][u[8]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_value_slot_1(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: ["key", "value"], $$slots: { item_value: [create_item_value_slot_2, ({ key: u }) => ({ 9: u }), ({ key: u }) => u ? 512 : 0], item_key: [create_item_key_slot$5, ({ key: u }) => ({ 9: u }), ({ key: u }) => u ? 512 : 0], preview: [create_preview_slot$5] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    2828 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_value_slot$5(n) {
  let o, a, u, c;
  const p = [create_if_block$4, create_else_block$4], d = [];
  function w(S, k) {
    return S[7] === ENTRIES ? 0 : 1;
  }
  return o = w(n), a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(S, k) {
    d[o].m(S, k), insert(S, u, k), c = !0;
  }, p(S, k) {
    let B = o;
    o = w(S), o === B ? d[o].p(S, k) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[o], a ? a.p(S, k) : (a = d[o] = p[o](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[o].d(S), S && detach(u);
  } };
}
function create_fragment$a(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: [ENTRIES, "size"], shouldShowColon: n[6], $$slots: { item_value: [create_item_value_slot$5, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot_2, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], preview: [create_preview_slot_1], summary: [create_summary_slot$5] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    2207 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
const ENTRIES = "[[Entries]]";
function instance$a(n, o, a) {
  let u, { value: c } = o;
  useState();
  let p = [], d = [], w = [];
  return n.$$set = (S) => {
    "value" in S && a(0, c = S.value);
  }, n.$$.update = () => {
    if (1 & n.$$.dirty) {
      let S = [], k = [], B = [], I = 0;
      for (const C of c)
        S.push(I++), k.push(C[0]), B.push(C[1]);
      a(1, p = S), a(2, d = k), a(3, w = B);
    }
    1 & n.$$.dirty && a(4, u = Array.from(c.keys()).slice(0, 5));
  }, [c, p, d, w, u, (S) => d[S], (S) => S !== ENTRIES];
}
class JSONIterableMapNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$a, create_fragment$a, safe_not_equal, { value: 0 });
  }
}
function add_css$5(n) {
  append_styles(n, "svelte-l95iub", ".Date.svelte-l95iub{color:var(--date-color)}.BigInt.svelte-l95iub{color:var(--number-color)}.Number.svelte-l95iub{color:var(--number-color)}.Boolean.svelte-l95iub{color:var(--boolean-color)}.Null.svelte-l95iub{color:var(--null-color)}.Undefined.svelte-l95iub{color:var(--undefined-color)}.Symbol.svelte-l95iub{color:var(--symbol-color)}");
}
function create_fragment$9(n) {
  let o, a, u;
  return { c() {
    o = element("span"), a = text(n[0]), attr(o, "class", u = null_to_empty(n[1]) + " svelte-l95iub");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, [p]) {
    1 & p && set_data(a, c[0]), 2 & p && u !== (u = null_to_empty(c[1]) + " svelte-l95iub") && attr(o, "class", u);
  }, i: noop$2, o: noop$2, d(c) {
    c && detach(o);
  } };
}
function instance$9(n, o, a) {
  let { value: u, nodeType: c } = o;
  return n.$$set = (p) => {
    "value" in p && a(0, u = p.value), "nodeType" in p && a(1, c = p.nodeType);
  }, [u, c];
}
class JSONValueNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$9, create_fragment$9, safe_not_equal, { value: 0, nodeType: 1 }, add_css$5);
  }
}
function add_css$4(n) {
  append_styles(n, "svelte-1u08yw6", ".indent.svelte-1u08yw6{padding-left:var(--li-identation)}");
}
function get_each_context$3(n, o, a) {
  const u = n.slice();
  u[6] = o[a], u[9] = a;
  const c = u[9] < u[0].length - 1;
  return u[7] = c, u;
}
function create_else_block$3(n) {
  let o, a, u;
  return a = new JSONNode({ props: { value: n[0][0] + "\u2026" } }), { c() {
    o = element("span"), create_component(a.$$.fragment);
  }, m(c, p) {
    insert(c, o, p), mount_component(a, o, null), u = !0;
  }, p(c, p) {
    const d = {};
    1 & p && (d.value = c[0][0] + "\u2026"), a.$set(d);
  }, i(c) {
    u || (transition_in(a.$$.fragment, c), u = !0);
  }, o(c) {
    transition_out(a.$$.fragment, c), u = !1;
  }, d(c) {
    c && detach(o), destroy_component(a);
  } };
}
function create_if_block$3$1(n) {
  let o, a, u = n[0], c = [];
  for (let d = 0; d < u.length; d += 1)
    c[d] = create_each_block$3(get_each_context$3(n, u, d));
  const p = (d) => transition_out(c[d], 1, 1, () => {
    c[d] = null;
  });
  return { c() {
    for (let d = 0; d < c.length; d += 1)
      c[d].c();
    o = empty();
  }, m(d, w) {
    for (let S = 0; S < c.length; S += 1)
      c[S].m(d, w);
    insert(d, o, w), a = !0;
  }, p(d, w) {
    if (1 & w) {
      let S;
      for (u = d[0], S = 0; S < u.length; S += 1) {
        const k = get_each_context$3(d, u, S);
        c[S] ? (c[S].p(k, w), transition_in(c[S], 1)) : (c[S] = create_each_block$3(k), c[S].c(), transition_in(c[S], 1), c[S].m(o.parentNode, o));
      }
      for (group_outros(), S = u.length; S < c.length; S += 1)
        p(S);
      check_outros();
    }
  }, i(d) {
    if (!a) {
      for (let w = 0; w < u.length; w += 1)
        transition_in(c[w]);
      a = !0;
    }
  }, o(d) {
    c = c.filter(Boolean);
    for (let w = 0; w < c.length; w += 1)
      transition_out(c[w]);
    a = !1;
  }, d(d) {
    destroy_each(c, d), d && detach(o);
  } };
}
function create_each_block$3(n) {
  let o, a, u, c, p, d, w = n[7] ? " +" : "";
  return a = new JSONNode({ props: { value: n[6] + (n[7] ? "\\n" : "") } }), { c() {
    o = element("span"), create_component(a.$$.fragment), u = element("span"), c = text(w), p = element("br"), attr(u, "class", "operator"), attr(o, "class", "svelte-1u08yw6"), toggle_class(o, "indent", n[9] > 0);
  }, m(S, k) {
    insert(S, o, k), mount_component(a, o, null), append(o, u), append(u, c), insert(S, p, k), d = !0;
  }, p(S, k) {
    const B = {};
    1 & k && (B.value = S[6] + (S[7] ? "\\n" : "")), a.$set(B), (!d || 1 & k) && w !== (w = S[7] ? " +" : "") && set_data(c, w);
  }, i(S) {
    d || (transition_in(a.$$.fragment, S), d = !0);
  }, o(S) {
    transition_out(a.$$.fragment, S), d = !1;
  }, d(S) {
    S && detach(o), destroy_component(a), S && detach(p);
  } };
}
function create_fragment$8(n) {
  let o, a, u, c, p, d;
  const w = [create_if_block$3$1, create_else_block$3], S = [];
  function k(B, I) {
    return B[1] ? 0 : 1;
  }
  return a = k(n), u = S[a] = w[a](n), { c() {
    o = element("span"), u.c();
  }, m(B, I) {
    insert(B, o, I), S[a].m(o, null), c = !0, p || (d = listen(o, "click", n[4]), p = !0);
  }, p(B, [I]) {
    let C = a;
    a = k(B), a === C ? S[a].p(B, I) : (group_outros(), transition_out(S[C], 1, 1, () => {
      S[C] = null;
    }), check_outros(), u = S[a], u ? u.p(B, I) : (u = S[a] = w[a](B), u.c()), transition_in(u, 1), u.m(o, null));
  }, i(B) {
    c || (transition_in(u), c = !0);
  }, o(B) {
    transition_out(u), c = !1;
  }, d(B) {
    B && detach(o), S[a].d(), p = !1, d();
  } };
}
function instance$8(n, o, a) {
  let u, c, { stack: p } = o;
  const { expanded: d, expandable: w } = useState();
  return component_subscribe(n, d, (S) => a(1, c = S)), component_subscribe(n, w, (S) => a(5, u = S)), set_store_value(w, u = !0, u), n.$$set = (S) => {
    "stack" in S && a(0, p = S.stack);
  }, [p, c, d, w, () => set_store_value(d, c = !c, c)];
}
class ErrorStack extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$8, create_fragment$8, safe_not_equal, { stack: 0 }, add_css$4);
  }
}
function create_summary_slot$4(n) {
  let o, a, u, c = String(n[0].message) + "";
  return { c() {
    o = element("span"), a = text("Error: "), u = text(c), attr(o, "class", "label");
  }, m(p, d) {
    insert(p, o, d), append(o, a), append(o, u);
  }, p(p, d) {
    1 & d && c !== (c = String(p[0].message) + "") && set_data(u, c);
  }, d(p) {
    p && detach(o);
  } };
}
function create_preview_slot$4(n) {
  let o, a, u, c = String(n[0].message) + "";
  return { c() {
    o = element("span"), a = text("Error: "), u = text(c), attr(o, "class", "label");
  }, m(p, d) {
    insert(p, o, d), append(o, a), append(o, u);
  }, p(p, d) {
    1 & d && c !== (c = String(p[0].message) + "") && set_data(u, c);
  }, d(p) {
    p && detach(o);
  } };
}
function create_item_key_slot$4(n) {
  let o, a, u = n[2] + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "property");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    4 & p && u !== (u = c[2] + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_else_block$2(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[2]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    5 & c && (p.value = u[0][u[2]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block$2$1(n) {
  let o, a;
  return o = new ErrorStack({ props: { stack: n[1] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    2 & c && (p.stack = u[1]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_value_slot$4(n) {
  let o, a, u, c;
  const p = [create_if_block$2$1, create_else_block$2], d = [];
  function w(S, k) {
    return S[2] === "stack" ? 0 : 1;
  }
  return o = w(n), a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(S, k) {
    d[o].m(S, k), insert(S, u, k), c = !0;
  }, p(S, k) {
    let B = o;
    o = w(S), o === B ? d[o].p(S, k) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[o], a ? a.p(S, k) : (a = d[o] = p[o](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[o].d(S), S && detach(u);
  } };
}
function create_fragment$7(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: ["message", "stack"], $$slots: { item_value: [create_item_value_slot$4, ({ key: u }) => ({ 2: u }), ({ key: u }) => u ? 4 : 0], item_key: [create_item_key_slot$4, ({ key: u }) => ({ 2: u }), ({ key: u }) => u ? 4 : 0], preview: [create_preview_slot$4], summary: [create_summary_slot$4] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    15 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function instance$7(n, o, a) {
  let u, { value: c } = o;
  return n.$$set = (p) => {
    "value" in p && a(0, c = p.value);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(1, u = c.stack.split(`
`));
  }, [c, u];
}
class ErrorNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$7, create_fragment$7, safe_not_equal, { value: 0 });
  }
}
function objType(n) {
  const o = Object.prototype.toString.call(n).slice(8, -1);
  return o === "Object" ? typeof n[Symbol.iterator] == "function" ? "Iterable" : n.constructor.name : o;
}
function add_css$3$1(n) {
  append_styles(n, "svelte-1fvwa9c", "span.svelte-1fvwa9c{color:var(--string-color);word-break:break-all;word-wrap:break-word}");
}
function create_else_block$1$1(n) {
  let o, a, u, c;
  return { c() {
    o = element("span"), a = text('"'), u = text(n[0]), c = text('"'), attr(o, "class", "svelte-1fvwa9c");
  }, m(p, d) {
    insert(p, o, d), append(o, a), append(o, u), append(o, c);
  }, p(p, d) {
    1 & d && set_data(u, p[0]);
  }, d(p) {
    p && detach(o);
  } };
}
function create_if_block$1$1(n) {
  let o, a, u, c, p = n[0].slice(0, 30) + (n[0].length > 30 ? "\u2026" : "");
  return { c() {
    o = element("span"), a = text('"'), u = text(p), c = text('"'), attr(o, "class", "svelte-1fvwa9c");
  }, m(d, w) {
    insert(d, o, w), append(o, a), append(o, u), append(o, c);
  }, p(d, w) {
    1 & w && p !== (p = d[0].slice(0, 30) + (d[0].length > 30 ? "\u2026" : "")) && set_data(u, p);
  }, d(d) {
    d && detach(o);
  } };
}
function create_fragment$6(n) {
  let o, a = (n[1] === "summary" ? create_if_block$1$1 : create_else_block$1$1)(n);
  return { c() {
    a.c(), o = empty();
  }, m(u, c) {
    a.m(u, c), insert(u, o, c);
  }, p(u, [c]) {
    a.p(u, c);
  }, i: noop$2, o: noop$2, d(u) {
    a.d(u), u && detach(o);
  } };
}
function instance$6(n, o, a) {
  let u, { value: c } = o;
  const p = { "\n": "\\n", "	": "\\t", "\r": "\\r" }, { displayMode: d } = useState();
  return n.$$set = (w) => {
    "value" in w && a(2, c = w.value);
  }, n.$$.update = () => {
    4 & n.$$.dirty && a(0, u = c.replace(/[\n\t\r]/g, (w) => p[w]));
  }, [u, d, c];
}
class JSONStringNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$6, create_fragment$6, safe_not_equal, { value: 2 }, add_css$3$1);
  }
}
function add_css$2$1(n) {
  append_styles(n, "svelte-1eamqdt", ".i.svelte-1eamqdt{font-style:italic}.fn.svelte-1eamqdt,.i.svelte-1eamqdt{color:var(--function-color)}");
}
function create_summary_slot$3(n) {
  let o;
  return { c() {
    o = element("span"), o.textContent = "\u0192", attr(o, "class", "i svelte-1eamqdt");
  }, m(a, u) {
    insert(a, o, u);
  }, d(a) {
    a && detach(o);
  } };
}
function create_if_block_3$3(n) {
  let o, a, u = getPreview1(n[2]) + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "fn i svelte-1eamqdt");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    4 & p && u !== (u = getPreview1(c[2]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_if_block_2$3(n) {
  let o, a, u = getPreview2(n[2]) + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "i svelte-1eamqdt");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    4 & p && u !== (u = getPreview2(c[2]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_preview_slot$3(n) {
  let o, a, u = !n[2].isArrow && create_if_block_3$3(n), c = !n[2].isClass && create_if_block_2$3(n);
  return { c() {
    u && u.c(), o = empty(), c && c.c(), a = empty();
  }, m(p, d) {
    u && u.m(p, d), insert(p, o, d), c && c.m(p, d), insert(p, a, d);
  }, p(p, d) {
    p[2].isArrow ? u && (u.d(1), u = null) : u ? u.p(p, d) : (u = create_if_block_3$3(p), u.c(), u.m(o.parentNode, o)), p[2].isClass ? c && (c.d(1), c = null) : c ? c.p(p, d) : (c = create_if_block_2$3(p), c.c(), c.m(a.parentNode, a));
  }, d(p) {
    u && u.d(p), p && detach(o), c && c.d(p), p && detach(a);
  } };
}
function create_item_key_slot$3(n) {
  let o, a, u, c = n[7] + "";
  return { c() {
    o = element("span"), a = text(c), attr(o, "class", u = n[7] === FUNCTION || n[7] === PROTO ? "internal" : "property");
  }, m(p, d) {
    insert(p, o, d), append(o, a);
  }, p(p, d) {
    128 & d && c !== (c = p[7] + "") && set_data(a, c), 128 & d && u !== (u = p[7] === FUNCTION || p[7] === PROTO ? "internal" : "property") && attr(o, "class", u);
  }, d(p) {
    p && detach(o);
  } };
}
function create_else_block$7(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[3](n[7]) } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    128 & c && (p.value = u[3](u[7])), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block_1$3(n) {
  let o, a;
  return o = new JSONObjectNode({ props: { value: n[3](n[7]) } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    128 & c && (p.value = u[3](u[7])), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block$9(n) {
  let o, a;
  return { c() {
    o = element("span"), a = text(n[0]), attr(o, "class", "i svelte-1eamqdt");
  }, m(u, c) {
    insert(u, o, c), append(o, a);
  }, p(u, c) {
    1 & c && set_data(a, u[0]);
  }, i: noop$2, o: noop$2, d(u) {
    u && detach(o);
  } };
}
function create_item_value_slot$3(n) {
  let o, a, u, c;
  const p = [create_if_block$9, create_if_block_1$3, create_else_block$7], d = [];
  function w(S, k) {
    return S[7] === FUNCTION ? 0 : S[7] === "prototype" ? 1 : 2;
  }
  return o = w(n), a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(S, k) {
    d[o].m(S, k), insert(S, u, k), c = !0;
  }, p(S, k) {
    let B = o;
    o = w(S), o === B ? d[o].p(S, k) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[o], a ? a.p(S, k) : (a = d[o] = p[o](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[o].d(S), S && detach(u);
  } };
}
function create_fragment$5(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[1], $$slots: { item_value: [create_item_value_slot$3, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], item_key: [create_item_key_slot$3, ({ key: u }) => ({ 7: u }), ({ key: u }) => u ? 128 : 0], preview: [create_preview_slot$3], summary: [create_summary_slot$3] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    2 & c && (p.keys = u[1]), 389 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
const FUNCTION = "[[Function]]", PROTO = "[[Prototype]]";
function getPreview1({ isGenerator: n, isAsync: o, isClass: a }) {
  return a ? `class ${a}` : (o ? "async " : "") + "\u0192" + (n ? "*" : "");
}
function getPreview2({ isAsync: n, isArrow: o, fnName: a, args: u }) {
  return (o && n ? "async" : "") + " " + (a != null ? a : "") + u + (o ? " => \u2026" : "");
}
function toString$3(n) {
  try {
    return n.toString();
  } catch {
    switch (n.constructor.name) {
      case "AsyncFunction":
        return "async function () {}";
      case "AsyncGeneratorFunction":
        return "async function * () {}";
      case "GeneratorFunction:":
        return "function * () {}";
      default:
        return "function () {}";
    }
  }
}
function instance$5(n, o, a) {
  let u, c, p, { value: d } = o;
  function w(S) {
    return S === PROTO ? d.__proto__ : d[S];
  }
  return n.$$set = (S) => {
    "value" in S && a(4, d = S.value);
  }, n.$$.update = () => {
    16 & n.$$.dirty && a(0, u = toString$3(d)), 1 & n.$$.dirty && a(2, c = function(S) {
      const k = S.match(/^(?:(async)\s+)?(?:function)?(\*)?\s*([^(]+)?(\([^)]*\))\s*(=>)?/), B = k == null ? void 0 : k[1], I = k == null ? void 0 : k[2], C = k == null ? void 0 : k[3], P = k == null ? void 0 : k[4], q = k == null ? void 0 : k[5], D = S.match(/^class\s+([^\s]+)/);
      return { args: P, isAsync: B, isGenerator: I, fnName: C, isArrow: q, isClass: D == null ? void 0 : D[1] };
    }(u));
  }, a(1, p = ["length", "name", "prototype", FUNCTION, PROTO].filter(function(S) {
    return S === FUNCTION || w(S);
  })), [u, p, c, w, d];
}
class JSONFunctionNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$5, create_fragment$5, safe_not_equal, { value: 4 }, add_css$2$1);
  }
}
function create_summary_slot$2(n) {
  let o, a, u, c, p, d = n[3] ? "writable(" : "readable(";
  return u = new JSONNode({ props: { value: n[2] } }), { c() {
    o = element("span"), a = text(d), create_component(u.$$.fragment), c = text(")"), attr(o, "class", "label");
  }, m(w, S) {
    insert(w, o, S), append(o, a), mount_component(u, o, null), append(o, c), p = !0;
  }, p(w, S) {
    (!p || 8 & S) && d !== (d = w[3] ? "writable(" : "readable(") && set_data(a, d);
    const k = {};
    4 & S && (k.value = w[2]), u.$set(k);
  }, i(w) {
    p || (transition_in(u.$$.fragment, w), p = !0);
  }, o(w) {
    transition_out(u.$$.fragment, w), p = !1;
  }, d(w) {
    w && detach(o), destroy_component(u);
  } };
}
function create_item_slot$1(n) {
  let o, a, u, c, p, d = n[9] + "";
  return c = new JSONNode({ props: { value: n[0][n[9]] } }), { c() {
    o = element("span"), a = text(d), u = element("span"), u.textContent = ": ", create_component(c.$$.fragment), attr(o, "class", "property"), attr(u, "class", "operator");
  }, m(w, S) {
    insert(w, o, S), append(o, a), insert(w, u, S), mount_component(c, w, S), p = !0;
  }, p(w, S) {
    (!p || 512 & S) && d !== (d = w[9] + "") && set_data(a, d);
    const k = {};
    513 & S && (k.value = w[0][w[9]]), c.$set(k);
  }, i(w) {
    p || (transition_in(c.$$.fragment, w), p = !0);
  }, o(w) {
    transition_out(c.$$.fragment, w), p = !1;
  }, d(w) {
    w && detach(o), w && detach(u), destroy_component(c, w);
  } };
}
function create_preview_slot$2(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[4], hasMore: n[4].length < n[1].length, prefix: "{", postfix: "}", $$slots: { item: [create_item_slot$1, ({ item: u }) => ({ 9: u }), ({ item: u }) => u ? 512 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    16 & c && (p.list = u[4]), 18 & c && (p.hasMore = u[4].length < u[1].length), 1537 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot$2(n) {
  let o, a, u, c = n[8] + "";
  return { c() {
    o = element("span"), a = text(c), attr(o, "class", u = n[8] === STORE_VALUE ? "internal" : "property");
  }, m(p, d) {
    insert(p, o, d), append(o, a);
  }, p(p, d) {
    256 & d && c !== (c = p[8] + "") && set_data(a, c), 256 & d && u !== (u = p[8] === STORE_VALUE ? "internal" : "property") && attr(o, "class", u);
  }, d(p) {
    p && detach(o);
  } };
}
function create_item_value_slot$2(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[6](n[8]) } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    256 & c && (p.value = u[6](u[8])), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$4$1(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[5], $$slots: { item_value: [create_item_value_slot$2, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], item_key: [create_item_key_slot$2, ({ key: u }) => ({ 8: u }), ({ key: u }) => u ? 256 : 0], preview: [create_preview_slot$2], summary: [create_summary_slot$2] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    32 & c && (p.keys = u[5]), 1311 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
const STORE_VALUE = "$value";
function instance$4$1(n, o, a) {
  let u, c, p, d, w, S, k = noop$2, B = () => (k(), k = subscribe(I, (C) => a(7, S = C)), I);
  n.$$.on_destroy.push(() => k());
  let { value: I } = o;
  return B(), n.$$set = (C) => {
    "value" in C && B(a(0, I = C.value));
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(1, u = Object.getOwnPropertyNames(I)), 2 & n.$$.dirty && a(5, c = [STORE_VALUE, ...u]), 2 & n.$$.dirty && a(4, p = u.slice(0, 5)), 128 & n.$$.dirty && a(2, d = S), 1 & n.$$.dirty && a(3, w = typeof I.set == "function");
  }, [I, u, d, w, p, c, function(C) {
    return C === STORE_VALUE ? d : I[C];
  }, S];
}
class JSONSvelteStoreNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$4$1, create_fragment$4$1, safe_not_equal, { value: 0 });
  }
}
function create_summary_slot$1(n) {
  let o, a, u, c, p, d = n[0].length + "";
  return { c() {
    o = element("span"), a = text(n[1]), u = text("("), c = text(d), p = text(")"), attr(o, "class", "label");
  }, m(w, S) {
    insert(w, o, S), append(o, a), append(o, u), append(o, c), append(o, p);
  }, p(w, S) {
    2 & S && set_data(a, w[1]), 1 & S && d !== (d = w[0].length + "") && set_data(c, d);
  }, d(w) {
    w && detach(o);
  } };
}
function create_item_slot(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[7] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    128 & c && (p.value = u[7]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_preview_slot$1(n) {
  let o, a;
  return o = new PreviewList({ props: { list: n[2], hasMore: n[2].length < n[0].length, label: n[1] + "(" + n[0].length + ") ", prefix: "[", postfix: "]", $$slots: { item: [create_item_slot, ({ item: u }) => ({ 7: u }), ({ item: u }) => u ? 128 : 0] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    4 & c && (p.list = u[2]), 5 & c && (p.hasMore = u[2].length < u[0].length), 3 & c && (p.label = u[1] + "(" + u[0].length + ") "), 384 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_item_key_slot$1(n) {
  let o, a, u, c = String(n[6]) + "";
  return { c() {
    o = element("span"), a = text(c), attr(o, "class", u = n[4].includes(n[6]) ? "internal" : "property");
  }, m(p, d) {
    insert(p, o, d), append(o, a);
  }, p(p, d) {
    64 & d && c !== (c = String(p[6]) + "") && set_data(a, c), 64 & d && u !== (u = p[4].includes(p[6]) ? "internal" : "property") && attr(o, "class", u);
  }, d(p) {
    p && detach(o);
  } };
}
function create_item_value_slot$1(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[5](n[6]) } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    64 & c && (p.value = u[5](u[6])), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$3$1(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[3], $$slots: { item_value: [create_item_value_slot$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], item_key: [create_item_key_slot$1, ({ key: u }) => ({ 6: u }), ({ key: u }) => u ? 64 : 0], preview: [create_preview_slot$1], summary: [create_summary_slot$1] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    8 & c && (p.keys = u[3]), 327 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
const TO_STRING_TAG = "Symbol(Symbol.toStringTag)";
function instance$3$1(n, o, a) {
  let u, c, { value: p } = o, { nodeType: d } = o;
  const w = ["buffer", "byteLength", "byteOffset", "length", TO_STRING_TAG];
  return n.$$set = (S) => {
    "value" in S && a(0, p = S.value), "nodeType" in S && a(1, d = S.nodeType);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(3, u = [...Object.getOwnPropertyNames(p), ...w]), 1 & n.$$.dirty && a(2, c = p.slice(0, 5));
  }, [p, d, c, u, w, function(S) {
    return S === TO_STRING_TAG ? p[Symbol.toStringTag] : p[S];
  }];
}
class TypedArrayNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$3$1, create_fragment$3$1, safe_not_equal, { value: 0, nodeType: 1 });
  }
}
function add_css$1$1(n) {
  append_styles(n, "svelte-17k1wqt", ".regex.svelte-17k1wqt{color:var(--regex-color)}");
}
function create_summary_slot(n) {
  let o, a;
  return { c() {
    o = element("span"), a = text(n[1]), attr(o, "class", "regex svelte-17k1wqt");
  }, m(u, c) {
    insert(u, o, c), append(o, a);
  }, p(u, c) {
    2 & c && set_data(a, u[1]);
  }, d(u) {
    u && detach(o);
  } };
}
function create_preview_slot(n) {
  let o, a;
  return { c() {
    o = element("span"), a = text(n[1]), attr(o, "class", "regex svelte-17k1wqt");
  }, m(u, c) {
    insert(u, o, c), append(o, a);
  }, p(u, c) {
    2 & c && set_data(a, u[1]);
  }, d(u) {
    u && detach(o);
  } };
}
function create_item_key_slot(n) {
  let o, a, u = String(n[3]) + "";
  return { c() {
    o = element("span"), a = text(u), attr(o, "class", "internal");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    8 & p && u !== (u = String(c[3]) + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_item_value_slot(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0][n[3]] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    9 & c && (p.value = u[0][u[3]]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$2$1(n) {
  let o, a;
  return o = new JSONNested({ props: { keys: n[2], $$slots: { item_value: [create_item_value_slot, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], item_key: [create_item_key_slot, ({ key: u }) => ({ 3: u }), ({ key: u }) => u ? 8 : 0], preview: [create_preview_slot], summary: [create_summary_slot] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, [c]) {
    const p = {};
    27 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function instance$2$1(n, o, a) {
  let u, { value: c } = o;
  return n.$$set = (p) => {
    "value" in p && a(0, c = p.value);
  }, n.$$.update = () => {
    1 & n.$$.dirty && a(1, u = c.toString());
  }, [c, u, ["lastIndex", "dotAll", "flags", "global", "hasIndices", "ignoreCase", "multiline", "source", "sticky", "unicode"]];
}
class RegExpNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$2$1, create_fragment$2$1, safe_not_equal, { value: 0 }, add_css$1$1);
  }
}
function create_fragment$1$1(n) {
  let o, a, u;
  const c = [{ value: n[0] }, n[1]];
  var p = n[2];
  function d(w) {
    let S = {};
    for (let k = 0; k < c.length; k += 1)
      S = assign(S, c[k]);
    return { props: S };
  }
  return p && (o = new p(d())), { c() {
    o && create_component(o.$$.fragment), a = empty();
  }, m(w, S) {
    o && mount_component(o, w, S), insert(w, a, S), u = !0;
  }, p(w, [S]) {
    const k = 3 & S ? get_spread_update(c, [1 & S && { value: w[0] }, 2 & S && get_spread_object(w[1])]) : {};
    if (p !== (p = w[2])) {
      if (o) {
        group_outros();
        const B = o;
        transition_out(B.$$.fragment, 1, 0, () => {
          destroy_component(B, 1);
        }), check_outros();
      }
      p ? (o = new p(d()), create_component(o.$$.fragment), transition_in(o.$$.fragment, 1), mount_component(o, a.parentNode, a)) : o = null;
    } else
      p && o.$set(k);
  }, i(w) {
    u || (o && transition_in(o.$$.fragment, w), u = !0);
  }, o(w) {
    o && transition_out(o.$$.fragment, w), u = !1;
  }, d(w) {
    w && detach(a), o && destroy_component(o, w);
  } };
}
function instance$1$1(n, o, a) {
  let u, c, p, { value: d } = o;
  const w = writable();
  return component_subscribe(n, w, (S) => a(4, p = S)), n.$$set = (S) => {
    "value" in S && a(0, d = S.value);
  }, n.$$.update = () => {
    1 & n.$$.dirty && set_store_value(w, p = objType(d), p), 17 & n.$$.dirty && a(2, [u, c] = function(S, k) {
      switch (S) {
        case "Object":
          return typeof k.subscribe == "function" ? [JSONSvelteStoreNode] : [JSONObjectNode];
        case "Error":
          return [ErrorNode];
        case "Array":
          return [JSONArrayNode];
        case "Map":
          return [JSONIterableMapNode];
        case "Iterable":
        case "Set":
          return [JSONIterableArrayNode, { nodeType: S }];
        case "Number":
          return [JSONValueNode, { nodeType: S }];
        case "String":
          return [JSONStringNode];
        case "Boolean":
          return [JSONValueNode, { nodeType: S, value: k ? "true" : "false" }];
        case "Date":
          return [JSONValueNode, { nodeType: S, value: k.toISOString() }];
        case "Null":
          return [JSONValueNode, { nodeType: S, value: "null" }];
        case "Undefined":
          return [JSONValueNode, { nodeType: S, value: "undefined" }];
        case "Function":
        case "AsyncFunction":
        case "AsyncGeneratorFunction":
        case "GeneratorFunction":
          return [JSONFunctionNode];
        case "Symbol":
          return [JSONValueNode, { nodeType: S, value: k.toString() }];
        case "BigInt":
          return [JSONValueNode, { nodeType: S, value: String(k) + "n" }];
        case "ArrayBuffer":
          return [JSONValueNode, { nodeType: S, value: `ArrayBuffer(${k.byteLength})` }];
        case "BigInt64Array":
        case "BigUint64Array":
        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Uint16Array":
        case "Uint32Array":
          return [TypedArrayNode, { nodeType: S }];
        case "RegExp":
          return [RegExpNode];
        default:
          return [JSONValueNode, { nodeType: S, value: `<${S}>` }];
      }
    }(p, d), u, (a(1, c), a(4, p), a(0, d)));
  }, [d, c, u, w, p];
}
class JSONNode extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$1$1, create_fragment$1$1, safe_not_equal, { value: 0 });
  }
}
function getShouldExpandNode({ defaultExpandedPaths: n, defaultExpandedLevel: o }) {
  const a = n.map((u) => u.split("."));
  return function({ keyPath: u, level: c }) {
    return c <= o || function(p) {
      e:
        for (const d of a) {
          if (p.length > d.length)
            continue;
          const w = Math.min(p.length, d.length);
          for (let S = 0; S < w; S++)
            if (d[S] !== "*" && d[S] !== String(p[S]))
              continue e;
          return !0;
        }
      return !1;
    }(u);
  };
}
function add_css$9(n) {
  append_styles(n, "svelte-16cw61f", "ul.svelte-16cw61f{--string-color:var(--json-tree-string-color, #cb3f41);--symbol-color:var(--json-tree-symbol-color, #cb3f41);--boolean-color:var(--json-tree-boolean-color, #112aa7);--function-color:var(--json-tree-function-color, #112aa7);--number-color:var(--json-tree-number-color, #3029cf);--label-color:var(--json-tree-label-color, #871d8f);--property-color:var(--json-tree-property-color, #000000);--arrow-color:var(--json-tree-arrow-color, #727272);--operator-color:var(--json-tree-operator-color, #727272);--null-color:var(--json-tree-null-color, #8d8d8d);--undefined-color:var(--json-tree-undefined-color, #8d8d8d);--date-color:var(--json-tree-date-color, #8d8d8d);--internal-color:var(--json-tree-internal-color, grey);--regex-color:var(--json-tree-regex-color, var(--string-color));--li-identation:var(--json-tree-li-indentation, 1em);--li-line-height:var(--json-tree-li-line-height, 1.3);font-size:var(--json-tree-font-size, 12px);font-family:var(--json-tree-font-family, 'Courier New', Courier, monospace)}ul.svelte-16cw61f li{line-height:var(--li-line-height);display:var(--li-display, list-item);list-style:none}ul.svelte-16cw61f,ul.svelte-16cw61f ul{padding:0;margin:0}ul.svelte-16cw61f{margin-left:var(--li-identation)}ul.svelte-16cw61f{cursor:default}ul.svelte-16cw61f .label{color:var(--label-color)}ul.svelte-16cw61f .property{color:var(--property-color)}ul.svelte-16cw61f .internal{color:var(--internal-color)}ul.svelte-16cw61f .operator{color:var(--operator-color)}");
}
function create_default_slot$3(n) {
  let o, a;
  return o = new JSONNode({ props: { value: n[0] } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    1 & c && (p.value = u[0]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_fragment$j(n) {
  let o, a, u;
  return a = new Expandable({ props: { key: "$", expanded: n[1], $$slots: { default: [create_default_slot$3] }, $$scope: { ctx: n } } }), { c() {
    o = element("ul"), create_component(a.$$.fragment), attr(o, "class", "svelte-16cw61f");
  }, m(c, p) {
    insert(c, o, p), mount_component(a, o, null), u = !0;
  }, p(c, [p]) {
    const d = {};
    33 & p && (d.$$scope = { dirty: p, ctx: c }), a.$set(d);
  }, i(c) {
    u || (transition_in(a.$$.fragment, c), u = !0);
  }, o(c) {
    transition_out(a.$$.fragment, c), u = !1;
  }, d(c) {
    c && detach(o), destroy_component(a);
  } };
}
function instance$j(n, o, a) {
  let u, { value: c } = o, { defaultExpandedPaths: p = [] } = o, { defaultExpandedLevel: d = 0 } = o;
  const w = writable(!0);
  return useState({ expanded: w, isParentExpanded: readable(!0), root: !0, shouldExpandNode: (S) => u(S), level: 0, keyPath: [] }), n.$$set = (S) => {
    "value" in S && a(0, c = S.value), "defaultExpandedPaths" in S && a(2, p = S.defaultExpandedPaths), "defaultExpandedLevel" in S && a(3, d = S.defaultExpandedLevel);
  }, n.$$.update = () => {
    12 & n.$$.dirty && (u = getShouldExpandNode({ defaultExpandedPaths: p, defaultExpandedLevel: d }));
  }, [c, w, p, d];
}
class Root extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$j, create_fragment$j, safe_not_equal, { value: 0, defaultExpandedPaths: 2, defaultExpandedLevel: 3 }, add_css$9);
  }
}
function cubicOut(n) {
  const o = n - 1;
  return o * o * o + 1;
}
function quintOut(n) {
  return --n * n * n * n * n + 1;
}
function fade(n, { delay: o = 0, duration: a = 400, easing: u = identity$1 } = {}) {
  const c = +getComputedStyle(n).opacity;
  return { delay: o, duration: a, easing: u, css: (p) => "opacity: " + p * c };
}
function fly(n, { delay: o = 0, duration: a = 400, easing: u = cubicOut, x: c = 0, y: p = 0, opacity: d = 0 } = {}) {
  const w = getComputedStyle(n), S = +w.opacity, k = w.transform === "none" ? "" : w.transform, B = S * (1 - d);
  return { delay: o, duration: a, easing: u, css: (I, C) => `
			transform: ${k} translate(${(1 - I) * c}px, ${(1 - I) * p}px);
			opacity: ${S - B * C}` };
}
function add_css$3(n) {
  append_styles(n, "svelte-9hnxox", ".Clipboard.svelte-9hnxox{margin:0 0.5em;word-break:break-all}.Clipboard-Container.svelte-9hnxox{display:flex;cursor:pointer}");
}
const get_default_slot_changes = (n) => ({}), get_default_slot_context = (n) => ({ copy: n[2] });
function create_else_block$1(n) {
  let o;
  return { c() {
    o = element("span"), o.textContent = "\u{1F4CB}", attr(o, "class", "text-xl"), attr(o, "title", "Copy to clipboard");
  }, m(a, u) {
    insert(a, o, u);
  }, p: noop$2, i: noop$2, o: noop$2, d(a) {
    a && detach(o);
  } };
}
function create_if_block$3(n) {
  let o, a, u;
  return { c() {
    o = element("div"), o.textContent = "\u2714\uFE0FCopied";
  }, m(c, p) {
    insert(c, o, p), u = !0;
  }, p(c, p) {
  }, i(c) {
    u || (a && a.end(1), u = !0);
  }, o(c) {
    a = create_out_transition(o, fade, { duration }), u = !1;
  }, d(c) {
    c && detach(o), c && a && a.end();
  } };
}
function create_fragment$4(n) {
  let o, a, u, c, p, d, w, S;
  const k = n[5].default, B = create_slot(k, n, n[4], get_default_slot_context), I = [create_if_block$3, create_else_block$1], C = [];
  function P(q, D) {
    return q[1] ? 0 : 1;
  }
  return c = P(n), p = C[c] = I[c](n), { c() {
    o = element("div"), a = element("div"), B && B.c(), u = space(), p.c(), attr(a, "class", "Clipboard svelte-9hnxox"), attr(o, "class", "Clipboard-Container svelte-9hnxox");
  }, m(q, D) {
    insert(q, o, D), append(o, a), B && B.m(a, null), n[6](a), append(o, u), C[c].m(o, null), d = !0, w || (S = [listen(o, "click", n[2]), listen(o, "keypress", n[2])], w = !0);
  }, p(q, [D]) {
    B && B.p && (!d || 16 & D) && update_slot_base(B, k, q, q[4], d ? get_slot_changes(k, q[4], D, get_default_slot_changes) : get_all_dirty_from_scope(q[4]), get_default_slot_context);
    let z = c;
    c = P(q), c === z ? C[c].p(q, D) : (group_outros(), transition_out(C[z], 1, 1, () => {
      C[z] = null;
    }), check_outros(), p = C[c], p ? p.p(q, D) : (p = C[c] = I[c](q), p.c()), transition_in(p, 1), p.m(o, null));
  }, i(q) {
    d || (transition_in(B, q), transition_in(p), d = !0);
  }, o(q) {
    transition_out(B, q), transition_out(p), d = !1;
  }, d(q) {
    q && detach(o), B && B.d(q), n[6](null), C[c].d(), w = !1, run_all(S);
  } };
}
let duration = 2e3;
function instance$4(n, o, a) {
  let u, c, { $$slots: p = {}, $$scope: d } = o, { value: w = null } = o;
  return n.$$set = (S) => {
    "value" in S && a(3, w = S.value), "$$scope" in S && a(4, d = S.$$scope);
  }, [u, c, async function() {
    var S = navigator.clipboard.writeText(u.innerHTML);
    await S, a(3, w = S), a(1, c = !0), setTimeout(() => a(1, c = !1), 1);
  }, w, d, p, function(S) {
    binding_callbacks[S ? "unshift" : "push"](() => {
      u = S, a(0, u);
    });
  }];
}
class Clipboard extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$4, create_fragment$4, safe_not_equal, { value: 3 }, add_css$3);
  }
}
function add_css$2(n) {
  append_styles(n, "svelte-bo07e1", `.m-4.svelte-bo07e1{margin:1rem
}.flex.svelte-bo07e1{display:flex
}.flex-1.svelte-bo07e1{flex:1 1 0%
}.cursor-pointer.svelte-bo07e1{cursor:pointer
}.flex-row.svelte-bo07e1{flex-direction:row
}.overflow-hidden.svelte-bo07e1{overflow:hidden
}.rounded-lg.svelte-bo07e1{border-radius:0.5rem
}.rounded-xl.svelte-bo07e1{border-radius:0.75rem
}.border.svelte-bo07e1{border-width:1px
}.bg-\\[\\#42b983\\].svelte-bo07e1{--tw-bg-opacity:1;background-color:rgb(66 185 131 / var(--tw-bg-opacity))
}.p-4.svelte-bo07e1{padding:1rem
}.pr-4.svelte-bo07e1{padding-right:1rem
}.font-semibold.svelte-bo07e1{font-weight:600
}.font-normal.svelte-bo07e1{font-weight:400
}.text-white.svelte-bo07e1{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))
}.text-blue-700.svelte-bo07e1{--tw-text-opacity:1;color:rgb(29 78 216 / var(--tw-text-opacity))
}.shadow-lg.svelte-bo07e1{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
}`);
}
const get_timestamp_slot_changes = (n) => ({}), get_timestamp_slot_context = (n) => ({});
function create_default_slot$2(n) {
  let o;
  const a = n[4].default, u = create_slot(a, n, n[6], null);
  return { c() {
    u && u.c();
  }, m(c, p) {
    u && u.m(c, p), o = !0;
  }, p(c, p) {
    u && u.p && (!o || 64 & p) && update_slot_base(u, a, c, c[6], o ? get_slot_changes(a, c[6], p, null) : get_all_dirty_from_scope(c[6]), null);
  }, i(c) {
    o || (transition_in(u, c), o = !0);
  }, o(c) {
    transition_out(u, c), o = !1;
  }, d(c) {
    u && u.d(c);
  } };
}
function create_if_block$2(n) {
  let o, a, u, c, p, d, w, S = !n[0].startsWith("did:arlocal"), k = S && create_if_block_2$1(n), B = n[2] && create_if_block_1$2(n);
  return { c() {
    o = element("details"), a = element("summary"), u = text(`Full DID Document\r
				`), k && k.c(), c = space(), B && B.c(), attr(o, "class", "cursor-pointer overflow-hidden svelte-bo07e1");
  }, m(I, C) {
    insert(I, o, C), append(o, a), append(a, u), k && k.m(a, null), append(o, c), B && B.m(o, null), o.open = n[2], p = !0, d || (w = listen(o, "toggle", n[5]), d = !0);
  }, p(I, C) {
    1 & C && (S = !I[0].startsWith("did:arlocal")), S ? k ? k.p(I, C) : (k = create_if_block_2$1(I), k.c(), k.m(a, null)) : k && (k.d(1), k = null), I[2] ? B ? (B.p(I, C), 4 & C && transition_in(B, 1)) : (B = create_if_block_1$2(I), B.c(), transition_in(B, 1), B.m(o, null)) : B && (group_outros(), transition_out(B, 1, 1, () => {
      B = null;
    }), check_outros()), 4 & C && (o.open = I[2]);
  }, i(I) {
    p || (transition_in(B), p = !0);
  }, o(I) {
    transition_out(B), p = !1;
  }, d(I) {
    I && detach(o), k && k.d(), B && B.d(), d = !1, w();
  } };
}
function create_if_block_2$1(n) {
  let o, a, u;
  return { c() {
    o = element("a"), a = text("\u{1F517} View Blockchain Explorer"), attr(o, "class", "text-blue-700 svelte-bo07e1"), attr(o, "target", "_blank"), attr(o, "rel", "noopener noreferrer"), attr(o, "href", u = "https://sonar.warp.cc/#/app/contract/" + n[0].replace(/.*?:/g, ""));
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    1 & p && u !== (u = "https://sonar.warp.cc/#/app/contract/" + c[0].replace(/.*?:/g, "")) && attr(o, "href", u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_if_block_1$2(n) {
  let o, a, u, c, p;
  return a = new Root({ props: { value: n[1], defaultExpandedLevel: 1 } }), { c() {
    o = element("div"), u = element("div"), create_component(a.$$.fragment), set_style(u, "display", "contents"), set_style(u, "--json-tree-font-size", ".8em"), set_style(u, "--json-tree-string-color", "#42b983"), set_style(u, "--json-tree-label-color", "#cfcfcf");
  }, m(d, w) {
    insert(d, o, w), append(o, u), mount_component(a, u, null), p = !0;
  }, p(d, w) {
    n = d;
    const S = {};
    2 & w && (S.value = n[1]), a.$set(S);
  }, i(d) {
    p || (transition_in(a.$$.fragment, d), add_render_callback(() => {
      c || (c = create_bidirectional_transition(o, fly, { delay: 0, duration: 300, x: 0, y: -100, opacity: 0.25, easing: quintOut }, !0)), c.run(1);
    }), p = !0);
  }, o(d) {
    transition_out(a.$$.fragment, d), c || (c = create_bidirectional_transition(o, fly, { delay: 0, duration: 300, x: 0, y: -100, opacity: 0.25, easing: quintOut }, !1)), c.run(0), p = !1;
  }, d(d) {
    d && detach(o), destroy_component(a), d && c && c.end();
  } };
}
function create_fragment$3(n) {
  var C, P;
  let o, a, u, c, p, d, w, S;
  c = new Clipboard({ props: { $$slots: { default: [create_default_slot$2] }, $$scope: { ctx: n } } });
  const k = n[4].timestamp, B = create_slot(k, n, n[6], get_timestamp_slot_context);
  let I = n[1] && ((P = (C = n[1]) == null ? void 0 : C.verificationMethod) == null ? void 0 : P.length) && create_if_block$2(n);
  return { c() {
    o = element("div"), a = element("div"), u = element("div"), create_component(c.$$.fragment), p = space(), d = element("div"), B && B.c(), w = space(), I && I.c(), attr(u, "class", "flex-1 pr-4 svelte-bo07e1"), attr(d, "class", "flex-0 pr-4 svelte-bo07e1"), attr(a, "class", "flex flex-row m-4 p-4 bg-[#42b983] text-white font-normal rounded-lg svelte-bo07e1"), attr(o, "class", "m-4 p-4 border rounded-xl shadow-lg font-semibold svelte-bo07e1");
  }, m(q, D) {
    insert(q, o, D), append(o, a), append(a, u), mount_component(c, u, null), append(a, p), append(a, d), B && B.m(d, null), append(o, w), I && I.m(o, null), S = !0;
  }, p(q, [D]) {
    var F, V;
    const z = {};
    64 & D && (z.$$scope = { dirty: D, ctx: q }), c.$set(z), B && B.p && (!S || 64 & D) && update_slot_base(B, k, q, q[6], S ? get_slot_changes(k, q[6], D, get_timestamp_slot_changes) : get_all_dirty_from_scope(q[6]), get_timestamp_slot_context), q[1] && ((V = (F = q[1]) == null ? void 0 : F.verificationMethod) == null ? void 0 : V.length) ? I ? (I.p(q, D), 2 & D && transition_in(I, 1)) : (I = create_if_block$2(q), I.c(), transition_in(I, 1), I.m(o, null)) : I && (group_outros(), transition_out(I, 1, 1, () => {
      I = null;
    }), check_outros());
  }, i(q) {
    S || (transition_in(c.$$.fragment, q), transition_in(B, q), transition_in(I), S = !0);
  }, o(q) {
    transition_out(c.$$.fragment, q), transition_out(B, q), transition_out(I), S = !1;
  }, d(q) {
    q && detach(o), destroy_component(c), B && B.d(q), I && I.d();
  } };
}
function instance$3(n, o, a) {
  let u, c, { $$slots: p = {}, $$scope: d } = o, { did: w } = o, S = !1;
  async function k() {
    return console.log("resolving ", w), a(1, c = (await u.resolve(w)).didDocument), c || setTimeout(() => {
      k();
    }, 5e3), c;
  }
  return onMount(async () => {
    const B = getResolver();
    a(3, u = new Resolver(B));
  }), n.$$set = (B) => {
    "did" in B && a(0, w = B.did), "$$scope" in B && a(6, d = B.$$scope);
  }, n.$$.update = () => {
    9 & n.$$.dirty && u && w && k();
  }, [w, c, S, u, p, function() {
    S = this.open, a(2, S);
  }, d];
}
class ResolveDID extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$3, create_fragment$3, safe_not_equal, { did: 0 }, add_css$2);
  }
}
var axios$6 = { exports: {} }, axios$5 = { exports: {} }, bind$5 = function(n, o) {
  return function() {
    for (var a = new Array(arguments.length), u = 0; u < a.length; u++)
      a[u] = arguments[u];
    return n.apply(o, a);
  };
}, bind$4 = bind$5, toString$2 = Object.prototype.toString, kindOf$1 = (cache = /* @__PURE__ */ Object.create(null), function(n) {
  var o = toString$2.call(n);
  return cache[o] || (cache[o] = o.slice(8, -1).toLowerCase());
}), cache;
function kindOfTest$1(n) {
  return n = n.toLowerCase(), function(o) {
    return kindOf$1(o) === n;
  };
}
function isArray$5(n) {
  return Array.isArray(n);
}
function isUndefined$1(n) {
  return n === void 0;
}
function isBuffer$4(n) {
  return n !== null && !isUndefined$1(n) && n.constructor !== null && !isUndefined$1(n.constructor) && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
}
var isArrayBuffer$1 = kindOfTest$1("ArrayBuffer");
function isArrayBufferView$1(n) {
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(n) : n && n.buffer && isArrayBuffer$1(n.buffer);
}
function isString$1(n) {
  return typeof n == "string";
}
function isNumber$1(n) {
  return typeof n == "number";
}
function isObject$8(n) {
  return n !== null && typeof n == "object";
}
function isPlainObject$1(n) {
  if (kindOf$1(n) !== "object")
    return !1;
  var o = Object.getPrototypeOf(n);
  return o === null || o === Object.prototype;
}
var isDate$1 = kindOfTest$1("Date"), isFile$1 = kindOfTest$1("File"), isBlob$2 = kindOfTest$1("Blob"), isFileList$1 = kindOfTest$1("FileList");
function isFunction$4(n) {
  return toString$2.call(n) === "[object Function]";
}
function isStream$1(n) {
  return isObject$8(n) && isFunction$4(n.pipe);
}
function isFormData$1(n) {
  var o = "[object FormData]";
  return n && (typeof FormData == "function" && n instanceof FormData || toString$2.call(n) === o || isFunction$4(n.toString) && n.toString() === o);
}
var isURLSearchParams$1 = kindOfTest$1("URLSearchParams");
function trim$1(n) {
  return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv$1() {
  return (typeof navigator > "u" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window < "u" && typeof document < "u";
}
function forEach$1(n, o) {
  if (n != null)
    if (typeof n != "object" && (n = [n]), isArray$5(n))
      for (var a = 0, u = n.length; a < u; a++)
        o.call(null, n[a], a, n);
    else
      for (var c in n)
        Object.prototype.hasOwnProperty.call(n, c) && o.call(null, n[c], c, n);
}
function merge$1() {
  var n = {};
  function o(c, p) {
    isPlainObject$1(n[p]) && isPlainObject$1(c) ? n[p] = merge$1(n[p], c) : isPlainObject$1(c) ? n[p] = merge$1({}, c) : isArray$5(c) ? n[p] = c.slice() : n[p] = c;
  }
  for (var a = 0, u = arguments.length; a < u; a++)
    forEach$1(arguments[a], o);
  return n;
}
function extend$1(n, o, a) {
  return forEach$1(o, function(u, c) {
    n[c] = a && typeof u == "function" ? bind$4(u, a) : u;
  }), n;
}
function stripBOM$1(n) {
  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;
}
function inherits$b(n, o, a, u) {
  n.prototype = Object.create(o.prototype, u), n.prototype.constructor = n, a && Object.assign(n.prototype, a);
}
function toFlatObject$1(n, o, a) {
  var u, c, p, d = {};
  o = o || {};
  do {
    for (c = (u = Object.getOwnPropertyNames(n)).length; c-- > 0; )
      d[p = u[c]] || (o[p] = n[p], d[p] = !0);
    n = Object.getPrototypeOf(n);
  } while (n && (!a || a(n, o)) && n !== Object.prototype);
  return o;
}
function endsWith$1(n, o, a) {
  n = String(n), (a === void 0 || a > n.length) && (a = n.length), a -= o.length;
  var u = n.indexOf(o, a);
  return u !== -1 && u === a;
}
function toArray$2(n) {
  if (!n)
    return null;
  var o = n.length;
  if (isUndefined$1(o))
    return null;
  for (var a = new Array(o); o-- > 0; )
    a[o] = n[o];
  return a;
}
var isTypedArray$4 = (TypedArray = typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array), function(n) {
  return TypedArray && n instanceof TypedArray;
}), TypedArray, utils$O = { isArray: isArray$5, isArrayBuffer: isArrayBuffer$1, isBuffer: isBuffer$4, isFormData: isFormData$1, isArrayBufferView: isArrayBufferView$1, isString: isString$1, isNumber: isNumber$1, isObject: isObject$8, isPlainObject: isPlainObject$1, isUndefined: isUndefined$1, isDate: isDate$1, isFile: isFile$1, isBlob: isBlob$2, isFunction: isFunction$4, isStream: isStream$1, isURLSearchParams: isURLSearchParams$1, isStandardBrowserEnv: isStandardBrowserEnv$1, forEach: forEach$1, merge: merge$1, extend: extend$1, trim: trim$1, stripBOM: stripBOM$1, inherits: inherits$b, toFlatObject: toFlatObject$1, kindOf: kindOf$1, kindOfTest: kindOfTest$1, endsWith: endsWith$1, toArray: toArray$2, isTypedArray: isTypedArray$4, isFileList: isFileList$1 }, utils$N = utils$O;
function encode$3(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$3 = function(n, o, a) {
  if (!o)
    return n;
  var u;
  if (a)
    u = a(o);
  else if (utils$N.isURLSearchParams(o))
    u = o.toString();
  else {
    var c = [];
    utils$N.forEach(o, function(d, w) {
      d != null && (utils$N.isArray(d) ? w += "[]" : d = [d], utils$N.forEach(d, function(S) {
        utils$N.isDate(S) ? S = S.toISOString() : utils$N.isObject(S) && (S = JSON.stringify(S)), c.push(encode$3(w) + "=" + encode$3(S));
      }));
    }), u = c.join("&");
  }
  if (u) {
    var p = n.indexOf("#");
    p !== -1 && (n = n.slice(0, p)), n += (n.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return n;
}, utils$M = utils$O;
function InterceptorManager$3() {
  this.handlers = [];
}
InterceptorManager$3.prototype.use = function(n, o, a) {
  return this.handlers.push({ fulfilled: n, rejected: o, synchronous: !!a && a.synchronous, runWhen: a ? a.runWhen : null }), this.handlers.length - 1;
}, InterceptorManager$3.prototype.eject = function(n) {
  this.handlers[n] && (this.handlers[n] = null);
}, InterceptorManager$3.prototype.forEach = function(n) {
  utils$M.forEach(this.handlers, function(o) {
    o !== null && n(o);
  });
};
var InterceptorManager_1$1 = InterceptorManager$3, utils$L = utils$O, normalizeHeaderName$3 = function(n, o) {
  utils$L.forEach(n, function(a, u) {
    u !== o && u.toUpperCase() === o.toUpperCase() && (n[o] = a, delete n[u]);
  });
}, utils$K = utils$O;
function AxiosError$5(n, o, a, u, c) {
  Error.call(this), this.message = n, this.name = "AxiosError", o && (this.code = o), a && (this.config = a), u && (this.request = u), c && (this.response = c);
}
utils$K.inherits(AxiosError$5, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
} });
var prototype$1 = AxiosError$5.prototype, descriptors$1 = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(n) {
  descriptors$1[n] = { value: n };
}), Object.defineProperties(AxiosError$5, descriptors$1), Object.defineProperty(prototype$1, "isAxiosError", { value: !0 }), AxiosError$5.from = function(n, o, a, u, c, p) {
  var d = Object.create(prototype$1);
  return utils$K.toFlatObject(n, d, function(w) {
    return w !== Error.prototype;
  }), AxiosError$5.call(d, n.message, o, a, u, c), d.name = n.name, p && Object.assign(d, p), d;
};
var AxiosError_1$1 = AxiosError$5, transitional$1 = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, utils$J = utils$O;
function toFormData$3(n, o) {
  o = o || new FormData();
  var a = [];
  function u(c) {
    return c === null ? "" : utils$J.isDate(c) ? c.toISOString() : utils$J.isArrayBuffer(c) || utils$J.isTypedArray(c) ? typeof Blob == "function" ? new Blob([c]) : Buffer.from(c) : c;
  }
  return function c(p, d) {
    if (utils$J.isPlainObject(p) || utils$J.isArray(p)) {
      if (a.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + d);
      a.push(p), utils$J.forEach(p, function(w, S) {
        if (!utils$J.isUndefined(w)) {
          var k, B = d ? d + "." + S : S;
          if (w && !d && typeof w == "object") {
            if (utils$J.endsWith(S, "{}"))
              w = JSON.stringify(w);
            else if (utils$J.endsWith(S, "[]") && (k = utils$J.toArray(w)))
              return void k.forEach(function(I) {
                !utils$J.isUndefined(I) && o.append(B, u(I));
              });
          }
          c(w, B);
        }
      }), a.pop();
    } else
      o.append(d, u(p));
  }(n), o;
}
var toFormData_1$1 = toFormData$3, settle$1, hasRequiredSettle$1, cookies$1, hasRequiredCookies$1;
function requireSettle$1() {
  if (hasRequiredSettle$1)
    return settle$1;
  hasRequiredSettle$1 = 1;
  var n = AxiosError_1$1;
  return settle$1 = function(o, a, u) {
    var c = u.config.validateStatus;
    u.status && c && !c(u.status) ? a(new n("Request failed with status code " + u.status, [n.ERR_BAD_REQUEST, n.ERR_BAD_RESPONSE][Math.floor(u.status / 100) - 4], u.config, u.request, u)) : o(u);
  };
}
function requireCookies$1() {
  if (hasRequiredCookies$1)
    return cookies$1;
  hasRequiredCookies$1 = 1;
  var n = utils$O;
  return cookies$1 = n.isStandardBrowserEnv() ? { write: function(o, a, u, c, p, d) {
    var w = [];
    w.push(o + "=" + encodeURIComponent(a)), n.isNumber(u) && w.push("expires=" + new Date(u).toGMTString()), n.isString(c) && w.push("path=" + c), n.isString(p) && w.push("domain=" + p), d === !0 && w.push("secure"), document.cookie = w.join("; ");
  }, read: function(o) {
    var a = document.cookie.match(new RegExp("(^|;\\s*)(" + o + ")=([^;]*)"));
    return a ? decodeURIComponent(a[3]) : null;
  }, remove: function(o) {
    this.write(o, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } }, cookies$1;
}
var isAbsoluteURL$3 = function(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}, combineURLs$3 = function(n, o) {
  return o ? n.replace(/\/+$/, "") + "/" + o.replace(/^\/+/, "") : n;
}, isAbsoluteURL$2 = isAbsoluteURL$3, combineURLs$2 = combineURLs$3, buildFullPath$3 = function(n, o) {
  return n && !isAbsoluteURL$2(o) ? combineURLs$2(n, o) : o;
}, parseHeaders$1, hasRequiredParseHeaders$1, isURLSameOrigin$1, hasRequiredIsURLSameOrigin$1, CanceledError_1$1, hasRequiredCanceledError$1, parseProtocol$1, hasRequiredParseProtocol$1, xhr$1, hasRequiredXhr$1, _null$1, hasRequired_null$1;
function requireParseHeaders$1() {
  if (hasRequiredParseHeaders$1)
    return parseHeaders$1;
  hasRequiredParseHeaders$1 = 1;
  var n = utils$O, o = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
  return parseHeaders$1 = function(a) {
    var u, c, p, d = {};
    return a && n.forEach(a.split(`
`), function(w) {
      if (p = w.indexOf(":"), u = n.trim(w.substr(0, p)).toLowerCase(), c = n.trim(w.substr(p + 1)), u) {
        if (d[u] && o.indexOf(u) >= 0)
          return;
        d[u] = u === "set-cookie" ? (d[u] ? d[u] : []).concat([c]) : d[u] ? d[u] + ", " + c : c;
      }
    }), d;
  }, parseHeaders$1;
}
function requireIsURLSameOrigin$1() {
  if (hasRequiredIsURLSameOrigin$1)
    return isURLSameOrigin$1;
  hasRequiredIsURLSameOrigin$1 = 1;
  var n = utils$O;
  return isURLSameOrigin$1 = n.isStandardBrowserEnv() ? function() {
    var o, a = /(msie|trident)/i.test(navigator.userAgent), u = document.createElement("a");
    function c(p) {
      var d = p;
      return a && (u.setAttribute("href", d), d = u.href), u.setAttribute("href", d), { href: u.href, protocol: u.protocol ? u.protocol.replace(/:$/, "") : "", host: u.host, search: u.search ? u.search.replace(/^\?/, "") : "", hash: u.hash ? u.hash.replace(/^#/, "") : "", hostname: u.hostname, port: u.port, pathname: u.pathname.charAt(0) === "/" ? u.pathname : "/" + u.pathname };
    }
    return o = c(window.location.href), function(p) {
      var d = n.isString(p) ? c(p) : p;
      return d.protocol === o.protocol && d.host === o.host;
    };
  }() : function() {
    return !0;
  };
}
function requireCanceledError$1() {
  if (hasRequiredCanceledError$1)
    return CanceledError_1$1;
  hasRequiredCanceledError$1 = 1;
  var n = AxiosError_1$1;
  function o(a) {
    n.call(this, a == null ? "canceled" : a, n.ERR_CANCELED), this.name = "CanceledError";
  }
  return utils$O.inherits(o, n, { __CANCEL__: !0 }), CanceledError_1$1 = o;
}
function requireParseProtocol$1() {
  return hasRequiredParseProtocol$1 ? parseProtocol$1 : (hasRequiredParseProtocol$1 = 1, parseProtocol$1 = function(n) {
    var o = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
    return o && o[1] || "";
  });
}
function requireXhr$1() {
  if (hasRequiredXhr$1)
    return xhr$1;
  hasRequiredXhr$1 = 1;
  var n = utils$O, o = requireSettle$1(), a = requireCookies$1(), u = buildURL$3, c = buildFullPath$3, p = requireParseHeaders$1(), d = requireIsURLSameOrigin$1(), w = transitional$1, S = AxiosError_1$1, k = requireCanceledError$1(), B = requireParseProtocol$1();
  return xhr$1 = function(I) {
    return new Promise(function(C, P) {
      var q, D = I.data, z = I.headers, F = I.responseType;
      function V() {
        I.cancelToken && I.cancelToken.unsubscribe(q), I.signal && I.signal.removeEventListener("abort", q);
      }
      n.isFormData(D) && n.isStandardBrowserEnv() && delete z["Content-Type"];
      var Z = new XMLHttpRequest();
      if (I.auth) {
        var N = I.auth.username || "", W = I.auth.password ? unescape(encodeURIComponent(I.auth.password)) : "";
        z.Authorization = "Basic " + btoa(N + ":" + W);
      }
      var H = c(I.baseURL, I.url);
      function te() {
        if (Z) {
          var _ = "getAllResponseHeaders" in Z ? p(Z.getAllResponseHeaders()) : null, b = { data: F && F !== "text" && F !== "json" ? Z.response : Z.responseText, status: Z.status, statusText: Z.statusText, headers: _, config: I, request: Z };
          o(function(m) {
            C(m), V();
          }, function(m) {
            P(m), V();
          }, b), Z = null;
        }
      }
      if (Z.open(I.method.toUpperCase(), u(H, I.params, I.paramsSerializer), !0), Z.timeout = I.timeout, "onloadend" in Z ? Z.onloadend = te : Z.onreadystatechange = function() {
        Z && Z.readyState === 4 && (Z.status !== 0 || Z.responseURL && Z.responseURL.indexOf("file:") === 0) && setTimeout(te);
      }, Z.onabort = function() {
        Z && (P(new S("Request aborted", S.ECONNABORTED, I, Z)), Z = null);
      }, Z.onerror = function() {
        P(new S("Network Error", S.ERR_NETWORK, I, Z, Z)), Z = null;
      }, Z.ontimeout = function() {
        var _ = I.timeout ? "timeout of " + I.timeout + "ms exceeded" : "timeout exceeded", b = I.transitional || w;
        I.timeoutErrorMessage && (_ = I.timeoutErrorMessage), P(new S(_, b.clarifyTimeoutError ? S.ETIMEDOUT : S.ECONNABORTED, I, Z)), Z = null;
      }, n.isStandardBrowserEnv()) {
        var g = (I.withCredentials || d(H)) && I.xsrfCookieName ? a.read(I.xsrfCookieName) : void 0;
        g && (z[I.xsrfHeaderName] = g);
      }
      "setRequestHeader" in Z && n.forEach(z, function(_, b) {
        D === void 0 && b.toLowerCase() === "content-type" ? delete z[b] : Z.setRequestHeader(b, _);
      }), n.isUndefined(I.withCredentials) || (Z.withCredentials = !!I.withCredentials), F && F !== "json" && (Z.responseType = I.responseType), typeof I.onDownloadProgress == "function" && Z.addEventListener("progress", I.onDownloadProgress), typeof I.onUploadProgress == "function" && Z.upload && Z.upload.addEventListener("progress", I.onUploadProgress), (I.cancelToken || I.signal) && (q = function(_) {
        Z && (P(!_ || _ && _.type ? new k() : _), Z.abort(), Z = null);
      }, I.cancelToken && I.cancelToken.subscribe(q), I.signal && (I.signal.aborted ? q() : I.signal.addEventListener("abort", q))), D || (D = null);
      var $ = B(H);
      $ && ["http", "https", "file"].indexOf($) === -1 ? P(new S("Unsupported protocol " + $ + ":", S.ERR_BAD_REQUEST, I)) : Z.send(D);
    });
  }, xhr$1;
}
function require_null$1() {
  return hasRequired_null$1 ? _null$1 : (hasRequired_null$1 = 1, _null$1 = null);
}
var utils$I = utils$O, normalizeHeaderName$2 = normalizeHeaderName$3, AxiosError$4 = AxiosError_1$1, transitionalDefaults$1 = transitional$1, toFormData$2 = toFormData_1$1, DEFAULT_CONTENT_TYPE$1 = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset$1(n, o) {
  !utils$I.isUndefined(n) && utils$I.isUndefined(n["Content-Type"]) && (n["Content-Type"] = o);
}
function getDefaultAdapter$1() {
  var n;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (n = requireXhr$1()), n;
}
function stringifySafely$1(n, o, a) {
  if (utils$I.isString(n))
    try {
      return (o || JSON.parse)(n), utils$I.trim(n);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (a || JSON.stringify)(n);
}
var defaults$7 = { transitional: transitionalDefaults$1, adapter: getDefaultAdapter$1(), transformRequest: [function(n, o) {
  if (normalizeHeaderName$2(o, "Accept"), normalizeHeaderName$2(o, "Content-Type"), utils$I.isFormData(n) || utils$I.isArrayBuffer(n) || utils$I.isBuffer(n) || utils$I.isStream(n) || utils$I.isFile(n) || utils$I.isBlob(n))
    return n;
  if (utils$I.isArrayBufferView(n))
    return n.buffer;
  if (utils$I.isURLSearchParams(n))
    return setContentTypeIfUnset$1(o, "application/x-www-form-urlencoded;charset=utf-8"), n.toString();
  var a, u = utils$I.isObject(n), c = o && o["Content-Type"];
  if ((a = utils$I.isFileList(n)) || u && c === "multipart/form-data") {
    var p = this.env && this.env.FormData;
    return toFormData$2(a ? { "files[]": n } : n, p && new p());
  }
  return u || c === "application/json" ? (setContentTypeIfUnset$1(o, "application/json"), stringifySafely$1(n)) : n;
}], transformResponse: [function(n) {
  var o = this.transitional || defaults$7.transitional, a = o && o.silentJSONParsing, u = o && o.forcedJSONParsing, c = !a && this.responseType === "json";
  if (c || u && utils$I.isString(n) && n.length)
    try {
      return JSON.parse(n);
    } catch (p) {
      if (c)
        throw p.name === "SyntaxError" ? AxiosError$4.from(p, AxiosError$4.ERR_BAD_RESPONSE, this, null, this.response) : p;
    }
  return n;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: require_null$1() }, validateStatus: function(n) {
  return n >= 200 && n < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*" } } };
utils$I.forEach(["delete", "get", "head"], function(n) {
  defaults$7.headers[n] = {};
}), utils$I.forEach(["post", "put", "patch"], function(n) {
  defaults$7.headers[n] = utils$I.merge(DEFAULT_CONTENT_TYPE$1);
});
var defaults_1$1 = defaults$7, utils$H = utils$O, defaults$6 = defaults_1$1, transformData$3 = function(n, o, a) {
  var u = this || defaults$6;
  return utils$H.forEach(a, function(c) {
    n = c.call(u, n, o);
  }), n;
}, isCancel$3, hasRequiredIsCancel$1;
function requireIsCancel$1() {
  return hasRequiredIsCancel$1 ? isCancel$3 : (hasRequiredIsCancel$1 = 1, isCancel$3 = function(n) {
    return !(!n || !n.__CANCEL__);
  });
}
var utils$G = utils$O, transformData$2 = transformData$3, isCancel$2 = requireIsCancel$1(), defaults$5 = defaults_1$1, CanceledError$1 = requireCanceledError$1();
function throwIfCancellationRequested$1(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new CanceledError$1();
}
var dispatchRequest$3 = function(n) {
  return throwIfCancellationRequested$1(n), n.headers = n.headers || {}, n.data = transformData$2.call(n, n.data, n.headers, n.transformRequest), n.headers = utils$G.merge(n.headers.common || {}, n.headers[n.method] || {}, n.headers), utils$G.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(o) {
    delete n.headers[o];
  }), (n.adapter || defaults$5.adapter)(n).then(function(o) {
    return throwIfCancellationRequested$1(n), o.data = transformData$2.call(n, o.data, o.headers, n.transformResponse), o;
  }, function(o) {
    return isCancel$2(o) || (throwIfCancellationRequested$1(n), o && o.response && (o.response.data = transformData$2.call(n, o.response.data, o.response.headers, n.transformResponse))), Promise.reject(o);
  });
}, utils$F = utils$O, mergeConfig$5 = function(n, o) {
  o = o || {};
  var a = {};
  function u(k, B) {
    return utils$F.isPlainObject(k) && utils$F.isPlainObject(B) ? utils$F.merge(k, B) : utils$F.isPlainObject(B) ? utils$F.merge({}, B) : utils$F.isArray(B) ? B.slice() : B;
  }
  function c(k) {
    return utils$F.isUndefined(o[k]) ? utils$F.isUndefined(n[k]) ? void 0 : u(void 0, n[k]) : u(n[k], o[k]);
  }
  function p(k) {
    if (!utils$F.isUndefined(o[k]))
      return u(void 0, o[k]);
  }
  function d(k) {
    return utils$F.isUndefined(o[k]) ? utils$F.isUndefined(n[k]) ? void 0 : u(void 0, n[k]) : u(void 0, o[k]);
  }
  function w(k) {
    return k in o ? u(n[k], o[k]) : k in n ? u(void 0, n[k]) : void 0;
  }
  var S = { url: p, method: p, data: p, baseURL: d, transformRequest: d, transformResponse: d, paramsSerializer: d, timeout: d, timeoutMessage: d, withCredentials: d, adapter: d, responseType: d, xsrfCookieName: d, xsrfHeaderName: d, onUploadProgress: d, onDownloadProgress: d, decompress: d, maxContentLength: d, maxBodyLength: d, beforeRedirect: d, transport: d, httpAgent: d, httpsAgent: d, cancelToken: d, socketPath: d, responseEncoding: d, validateStatus: w };
  return utils$F.forEach(Object.keys(n).concat(Object.keys(o)), function(k) {
    var B = S[k] || c, I = B(k);
    utils$F.isUndefined(I) && B !== w || (a[k] = I);
  }), a;
}, data$2, hasRequiredData$1;
function requireData$1() {
  return hasRequiredData$1 ? data$2 : (hasRequiredData$1 = 1, data$2 = { version: "0.27.2" });
}
var VERSION$1 = requireData$1().version, AxiosError$3 = AxiosError_1$1, validators$3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(n, o) {
  validators$3[n] = function(a) {
    return typeof a === n || "a" + (o < 1 ? "n " : " ") + n;
  };
});
var deprecatedWarnings$1 = {};
function assertOptions$1(n, o, a) {
  if (typeof n != "object")
    throw new AxiosError$3("options must be an object", AxiosError$3.ERR_BAD_OPTION_VALUE);
  for (var u = Object.keys(n), c = u.length; c-- > 0; ) {
    var p = u[c], d = o[p];
    if (d) {
      var w = n[p], S = w === void 0 || d(w, p, n);
      if (S !== !0)
        throw new AxiosError$3("option " + p + " must be " + S, AxiosError$3.ERR_BAD_OPTION_VALUE);
    } else if (a !== !0)
      throw new AxiosError$3("Unknown option " + p, AxiosError$3.ERR_BAD_OPTION);
  }
}
validators$3.transitional = function(n, o, a) {
  function u(c, p) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + c + "'" + p + (a ? ". " + a : "");
  }
  return function(c, p, d) {
    if (n === !1)
      throw new AxiosError$3(u(p, " has been removed" + (o ? " in " + o : "")), AxiosError$3.ERR_DEPRECATED);
    return o && !deprecatedWarnings$1[p] && (deprecatedWarnings$1[p] = !0, console.warn(u(p, " has been deprecated since v" + o + " and will be removed in the near future"))), !n || n(c, p, d);
  };
};
var validator$3 = { assertOptions: assertOptions$1, validators: validators$3 }, utils$E = utils$O, buildURL$2 = buildURL$3, InterceptorManager$2 = InterceptorManager_1$1, dispatchRequest$2 = dispatchRequest$3, mergeConfig$4 = mergeConfig$5, buildFullPath$2 = buildFullPath$3, validator$2 = validator$3, validators$2 = validator$2.validators;
function Axios$3(n) {
  this.defaults = n, this.interceptors = { request: new InterceptorManager$2(), response: new InterceptorManager$2() };
}
Axios$3.prototype.request = function(n, o) {
  typeof n == "string" ? (o = o || {}).url = n : o = n || {}, (o = mergeConfig$4(this.defaults, o)).method ? o.method = o.method.toLowerCase() : this.defaults.method ? o.method = this.defaults.method.toLowerCase() : o.method = "get";
  var a = o.transitional;
  a !== void 0 && validator$2.assertOptions(a, { silentJSONParsing: validators$2.transitional(validators$2.boolean), forcedJSONParsing: validators$2.transitional(validators$2.boolean), clarifyTimeoutError: validators$2.transitional(validators$2.boolean) }, !1);
  var u = [], c = !0;
  this.interceptors.request.forEach(function(I) {
    typeof I.runWhen == "function" && I.runWhen(o) === !1 || (c = c && I.synchronous, u.unshift(I.fulfilled, I.rejected));
  });
  var p, d = [];
  if (this.interceptors.response.forEach(function(I) {
    d.push(I.fulfilled, I.rejected);
  }), !c) {
    var w = [dispatchRequest$2, void 0];
    for (Array.prototype.unshift.apply(w, u), w = w.concat(d), p = Promise.resolve(o); w.length; )
      p = p.then(w.shift(), w.shift());
    return p;
  }
  for (var S = o; u.length; ) {
    var k = u.shift(), B = u.shift();
    try {
      S = k(S);
    } catch (I) {
      B(I);
      break;
    }
  }
  try {
    p = dispatchRequest$2(S);
  } catch (I) {
    return Promise.reject(I);
  }
  for (; d.length; )
    p = p.then(d.shift(), d.shift());
  return p;
}, Axios$3.prototype.getUri = function(n) {
  n = mergeConfig$4(this.defaults, n);
  var o = buildFullPath$2(n.baseURL, n.url);
  return buildURL$2(o, n.params, n.paramsSerializer);
}, utils$E.forEach(["delete", "get", "head", "options"], function(n) {
  Axios$3.prototype[n] = function(o, a) {
    return this.request(mergeConfig$4(a || {}, { method: n, url: o, data: (a || {}).data }));
  };
}), utils$E.forEach(["post", "put", "patch"], function(n) {
  function o(a) {
    return function(u, c, p) {
      return this.request(mergeConfig$4(p || {}, { method: n, headers: a ? { "Content-Type": "multipart/form-data" } : {}, url: u, data: c }));
    };
  }
  Axios$3.prototype[n] = o(), Axios$3.prototype[n + "Form"] = o(!0);
});
var Axios_1$1 = Axios$3, CancelToken_1$1, hasRequiredCancelToken$1, spread$1, hasRequiredSpread$1, isAxiosError$1, hasRequiredIsAxiosError$1;
function requireCancelToken$1() {
  if (hasRequiredCancelToken$1)
    return CancelToken_1$1;
  hasRequiredCancelToken$1 = 1;
  var n = requireCanceledError$1();
  function o(a) {
    if (typeof a != "function")
      throw new TypeError("executor must be a function.");
    var u;
    this.promise = new Promise(function(p) {
      u = p;
    });
    var c = this;
    this.promise.then(function(p) {
      if (c._listeners) {
        var d, w = c._listeners.length;
        for (d = 0; d < w; d++)
          c._listeners[d](p);
        c._listeners = null;
      }
    }), this.promise.then = function(p) {
      var d, w = new Promise(function(S) {
        c.subscribe(S), d = S;
      }).then(p);
      return w.cancel = function() {
        c.unsubscribe(d);
      }, w;
    }, a(function(p) {
      c.reason || (c.reason = new n(p), u(c.reason));
    });
  }
  return o.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, o.prototype.subscribe = function(a) {
    this.reason ? a(this.reason) : this._listeners ? this._listeners.push(a) : this._listeners = [a];
  }, o.prototype.unsubscribe = function(a) {
    if (this._listeners) {
      var u = this._listeners.indexOf(a);
      u !== -1 && this._listeners.splice(u, 1);
    }
  }, o.source = function() {
    var a;
    return { token: new o(function(u) {
      a = u;
    }), cancel: a };
  }, CancelToken_1$1 = o;
}
function requireSpread$1() {
  return hasRequiredSpread$1 ? spread$1 : (hasRequiredSpread$1 = 1, spread$1 = function(n) {
    return function(o) {
      return n.apply(null, o);
    };
  });
}
function requireIsAxiosError$1() {
  if (hasRequiredIsAxiosError$1)
    return isAxiosError$1;
  hasRequiredIsAxiosError$1 = 1;
  var n = utils$O;
  return isAxiosError$1 = function(o) {
    return n.isObject(o) && o.isAxiosError === !0;
  };
}
var utils$D = utils$O, bind$3 = bind$5, Axios$2 = Axios_1$1, mergeConfig$3 = mergeConfig$5, defaults$4 = defaults_1$1;
function createInstance$1(n) {
  var o = new Axios$2(n), a = bind$3(Axios$2.prototype.request, o);
  return utils$D.extend(a, Axios$2.prototype, o), utils$D.extend(a, o), a.create = function(u) {
    return createInstance$1(mergeConfig$3(n, u));
  }, a;
}
var axios$4 = createInstance$1(defaults$4);
axios$4.Axios = Axios$2, axios$4.CanceledError = requireCanceledError$1(), axios$4.CancelToken = requireCancelToken$1(), axios$4.isCancel = requireIsCancel$1(), axios$4.VERSION = requireData$1().version, axios$4.toFormData = toFormData_1$1, axios$4.AxiosError = AxiosError_1$1, axios$4.Cancel = axios$4.CanceledError, axios$4.all = function(n) {
  return Promise.all(n);
}, axios$4.spread = requireSpread$1(), axios$4.isAxiosError = requireIsAxiosError$1(), axios$5.exports = axios$4, axios$5.exports.default = axios$4, axios$6.exports = axios$5.exports;
const axios$3 = getDefaultExportFromCjs(axios$6.exports);
let GQL_ENDPOINT = "https://arweave.net/graphql";
const setEndpointUrl = (n) => GQL_ENDPOINT = n, run = async (n, o) => {
  const a = JSON.stringify({ query: n, variables: o }), { data: u } = await axios$3.post(GQL_ENDPOINT, a, { headers: { "content-type": "application/json" } });
  return u;
}, all = async (n, o) => {
  let a = !0, u = [], c = "";
  for (; a; ) {
    const p = (await run(n, { ...o, cursor: c })).data.transactions;
    p.edges && p.edges.length && (u = u.concat(p.edges), c = p.edges[p.edges.length - 1].cursor), a = p.pageInfo.hasNextPage;
  }
  return u;
}, backupEndpoint = "https://arweave-search.goldsky.com/graphql";
async function getOwnerDidArs({ arweave: n, dagOwner: o }) {
  const { host: a, port: u, protocol: c } = n.api.config;
  setEndpointUrl(`${c}://${a}:${u}/graphql`);
  const p = `query($cursor: String) {
    transactions(
    tags: [
		{ name: "DID-AR", values: ["true"] },
		{ name: "App-Name", values: ["SmartWeaveContract"] },
		{ name: "Uploader-Contract-Owner", values: ["${o}"] },
	]
    after: $cursor
    first: 100
  ) {
    pageInfo {
      hasNextPage
    }
    edges {
      cursor
      node {
			block {
				timestamp
			}
			tags {
				name
				value
			}
		}
    }
  }
}`;
  try {
    return (await all(p)).map((d) => d.node);
  } catch (d) {
    console.log("ArGQL failed", d), setEndpointUrl(backupEndpoint);
  }
  try {
    return (await all(p)).map((d) => d.node);
  } catch (d) {
    console.log("ArGQL failed, both gateways down", d);
  }
}
function get_each_context(n, o, a) {
  const u = n.slice();
  return u[5] = o[a], u;
}
function create_if_block$1(n) {
  let o, a, u = n[0], c = [];
  for (let d = 0; d < u.length; d += 1)
    c[d] = create_each_block(get_each_context(n, u, d));
  const p = (d) => transition_out(c[d], 1, 1, () => {
    c[d] = null;
  });
  return { c() {
    for (let d = 0; d < c.length; d += 1)
      c[d].c();
    o = empty();
  }, m(d, w) {
    for (let S = 0; S < c.length; S += 1)
      c[S].m(d, w);
    insert(d, o, w), a = !0;
  }, p(d, w) {
    if (3 & w) {
      let S;
      for (u = d[0], S = 0; S < u.length; S += 1) {
        const k = get_each_context(d, u, S);
        c[S] ? (c[S].p(k, w), transition_in(c[S], 1)) : (c[S] = create_each_block(k), c[S].c(), transition_in(c[S], 1), c[S].m(o.parentNode, o));
      }
      for (group_outros(), S = u.length; S < c.length; S += 1)
        p(S);
      check_outros();
    }
  }, i(d) {
    if (!a) {
      for (let w = 0; w < u.length; w += 1)
        transition_in(c[w]);
      a = !0;
    }
  }, o(d) {
    c = c.filter(Boolean);
    for (let w = 0; w < c.length; w += 1)
      transition_out(c[w]);
    a = !1;
  }, d(d) {
    destroy_each(c, d), d && detach(o);
  } };
}
function create_if_block_1$1(n) {
  let o, a;
  return o = new ResolveDID({ props: { did: n[1](n[5].id), $$slots: { timestamp: [create_timestamp_slot], default: [create_default_slot$1] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    3 & c && (p.did = u[1](u[5].id)), 259 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_default_slot$1(n) {
  let o, a, u = n[1](n[5].id) + "";
  return { c() {
    o = text(u), a = space();
  }, m(c, p) {
    insert(c, o, p), insert(c, a, p);
  }, p(c, p) {
    3 & p && u !== (u = c[1](c[5].id) + "") && set_data(o, u);
  }, d(c) {
    c && detach(o), c && detach(a);
  } };
}
function create_timestamp_slot(n) {
  let o, a, u = new Date(n[5].timestamp).toLocaleString() + "";
  return { c() {
    o = element("div"), a = text(u), attr(o, "slot", "timestamp");
  }, m(c, p) {
    insert(c, o, p), append(o, a);
  }, p(c, p) {
    1 & p && u !== (u = new Date(c[5].timestamp).toLocaleString() + "") && set_data(a, u);
  }, d(c) {
    c && detach(o);
  } };
}
function create_each_block(n) {
  let o, a, u = n[1] && n[5].id && create_if_block_1$1(n);
  return { c() {
    u && u.c(), o = empty();
  }, m(c, p) {
    u && u.m(c, p), insert(c, o, p), a = !0;
  }, p(c, p) {
    c[1] && c[5].id ? u ? (u.p(c, p), 3 & p && transition_in(u, 1)) : (u = create_if_block_1$1(c), u.c(), transition_in(u, 1), u.m(o.parentNode, o)) : u && (group_outros(), transition_out(u, 1, 1, () => {
      u = null;
    }), check_outros());
  }, i(c) {
    a || (transition_in(u), a = !0);
  }, o(c) {
    transition_out(u), a = !1;
  }, d(c) {
    u && u.d(c), c && detach(o);
  } };
}
function create_fragment$2(n) {
  let o, a, u = n[0] && create_if_block$1(n);
  return { c() {
    u && u.c(), o = empty();
  }, m(c, p) {
    u && u.m(c, p), insert(c, o, p), a = !0;
  }, p(c, [p]) {
    c[0] ? u ? (u.p(c, p), 1 & p && transition_in(u, 1)) : (u = create_if_block$1(c), u.c(), transition_in(u, 1), u.m(o.parentNode, o)) : u && (group_outros(), transition_out(u, 1, 1, () => {
      u = null;
    }), check_outros());
  }, i(c) {
    a || (transition_in(u), a = !0);
  }, o(c) {
    transition_out(u), a = !1;
  }, d(c) {
    u && u.d(c), c && detach(o);
  } };
}
function instance$2(n, o, a) {
  let { ownerAddress: u } = o, { local: c = !1 } = o;
  const p = createEventDispatcher();
  let d, w;
  return onMount(async () => {
    console.log("Looking for DID contracts...", new Date().toLocaleTimeString()), a(1, w = (I) => c ? `did:arlocal:${I}` : `did:ar:${I}`);
    let S = await Promise.resolve().then(() => index$3);
    S != null && S.default && (S = S.default), S != null && S.default && (S = S.default);
    let k = S.init({ host: "arweave.net", port: 443, protocol: "https", timeout: 2e4, logging: !1 }), B = null;
    try {
      B = await getOwnerDidArs({ arweave: k, dagOwner: u });
    } catch (I) {
      console.log("DIDAr get failed", I);
    }
    console.log("txs", B), B && B.length && (a(0, d = B.map((I) => {
      var C;
      return { id: I.tags.find((P) => P.name === "Uploader-Tx-Id").value, timestamp: 1e3 * ((C = I == null ? void 0 : I.block) == null ? void 0 : C.timestamp) };
    })), p("searchComplete", d));
  }), n.$$set = (S) => {
    "ownerAddress" in S && a(2, u = S.ownerAddress), "local" in S && a(3, c = S.local);
  }, [d, w, u, c];
}
class ListDIDs extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$2, create_fragment$2, safe_not_equal, { ownerAddress: 2, local: 3 });
  }
}
function add_css$1(n) {
  append_styles(n, "svelte-noxgz1", ".flex-row.svelte-noxgz1{flex-direction:row}.flex.svelte-noxgz1{display:flex}.flex-1.svelte-noxgz1{flex:1 1 0%}.items-center.svelte-noxgz1{align-items:center}.select-none.svelte-noxgz1{-webkit-user-select:none;-moz-user-select:none;user-select:none}.spinner.svelte-noxgz1{aspect-ratio:1;height:1em;width:1em;border:0.3em dotted rgba(250, 204, 21);border-radius:9999px;animation:spin 1s linear infinite;background:#fcff23;margin:0.25em}");
}
function create_fragment$1(n) {
  let o, a, u, c, p;
  const d = n[1].default, w = create_slot(d, n, n[0], null);
  return { c() {
    o = element("div"), a = element("div"), u = space(), c = element("div"), w && w.c(), attr(a, "class", "spinner select-none svelte-noxgz1"), attr(c, "class", "flex-1 svelte-noxgz1"), attr(o, "class", "flex flex-row items-center svelte-noxgz1");
  }, m(S, k) {
    insert(S, o, k), append(o, a), append(o, u), append(o, c), w && w.m(c, null), p = !0;
  }, p(S, [k]) {
    w && w.p && (!p || 1 & k) && update_slot_base(w, d, S, S[0], p ? get_slot_changes(d, S[0], k, null) : get_all_dirty_from_scope(S[0]), null);
  }, i(S) {
    p || (transition_in(w, S), p = !0);
  }, o(S) {
    transition_out(w, S), p = !1;
  }, d(S) {
    S && detach(o), w && w.d(S);
  } };
}
function instance$1(n, o, a) {
  let { $$slots: u = {}, $$scope: c } = o;
  return n.$$set = (p) => {
    "$$scope" in p && a(0, c = p.$$scope);
  }, [c, u];
}
class Spinner extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance$1, create_fragment$1, safe_not_equal, {}, add_css$1);
  }
}
function add_css(n) {
  append_styles(n, "svelte-1anxyld", `.m-4.svelte-1anxyld{margin:1rem
}.m-2.svelte-1anxyld{margin:0.5rem
}.w-fit.svelte-1anxyld{width:-moz-fit-content;width:fit-content
}.cursor-pointer.svelte-1anxyld{cursor:pointer
}.rounded.svelte-1anxyld{border-radius:0.25rem
}.rounded-lg.svelte-1anxyld{border-radius:0.5rem
}.bg-gray-50.svelte-1anxyld{--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity))
}.bg-blue-600.svelte-1anxyld{--tw-bg-opacity:1;background-color:rgb(37 99 235 / var(--tw-bg-opacity))
}.p-2.svelte-1anxyld{padding:0.5rem
}.p-4.svelte-1anxyld{padding:1rem
}.font-mono.svelte-1anxyld{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
}.text-white.svelte-1anxyld{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))
}.shadow.svelte-1anxyld{--tw-shadow:0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
}.hover\\:bg-blue-500.svelte-1anxyld:hover{--tw-bg-opacity:1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))
}`);
}
function create_else_block_1(n) {
  let o;
  return { c() {
    o = text("Connect with Wallet to create a Decentralized Identity");
  }, m(a, u) {
    insert(a, o, u);
  }, p: noop$2, i: noop$2, o: noop$2, d(a) {
    a && detach(o);
  } };
}
function create_if_block(n) {
  let o, a, u = n[0], c = create_key_block(n);
  return { c() {
    c.c(), o = empty();
  }, m(p, d) {
    c.m(p, d), insert(p, o, d), a = !0;
  }, p(p, d) {
    1 & d && safe_not_equal(u, u = p[0]) ? (group_outros(), transition_out(c, 1, 1, noop$2), check_outros(), c = create_key_block(p), c.c(), transition_in(c, 1), c.m(o.parentNode, o)) : c.p(p, d);
  }, i(p) {
    a || (transition_in(c), a = !0);
  }, o(p) {
    transition_out(c), a = !1;
  }, d(p) {
    p && detach(o), c.d(p);
  } };
}
function create_key_block_1(n) {
  let o, a;
  return o = new ListDIDs({ props: { ownerAddress: n[6] } }), o.$on("searchComplete", n[8]), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    64 & c && (p.ownerAddress = u[6]), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block_3(n) {
  let o, a;
  return o = new Spinner({ props: { $$slots: { default: [create_default_slot] }, $$scope: { ctx: n } } }), { c() {
    create_component(o.$$.fragment);
  }, m(u, c) {
    mount_component(o, u, c), a = !0;
  }, p(u, c) {
    const p = {};
    4096 & c && (p.$$scope = { dirty: c, ctx: u }), o.$set(p);
  }, i(u) {
    a || (transition_in(o.$$.fragment, u), a = !0);
  }, o(u) {
    transition_out(o.$$.fragment, u), a = !1;
  }, d(u) {
    destroy_component(o, u);
  } };
}
function create_if_block_1(n) {
  let o, a, u, c, p;
  function d(k, B) {
    return k[1] ? create_if_block_2 : create_else_block;
  }
  let w = d(n), S = w(n);
  return { c() {
    o = element("div"), S.c(), a = space(), u = element("div"), u.textContent = "Create Decentralized Identity (DID) with Wallet Keys", attr(o, "class", "m-4 svelte-1anxyld"), attr(u, "class", "bg-blue-600 hover:bg-blue-500 shadow rounded-lg m-4 p-4 w-fit text-white cursor-pointer svelte-1anxyld");
  }, m(k, B) {
    insert(k, o, B), S.m(o, null), insert(k, a, B), insert(k, u, B), c || (p = [listen(u, "click", function() {
      is_function(n[7]) && n[7].apply(this, arguments);
    }), listen(u, "keypress", function() {
      is_function(n[7]) && n[7].apply(this, arguments);
    })], c = !0);
  }, p(k, B) {
    w === (w = d(n = k)) && S ? S.p(n, B) : (S.d(1), S = w(n), S && (S.c(), S.m(o, null)));
  }, i: noop$2, o: noop$2, d(k) {
    k && detach(o), S.d(), k && detach(a), k && detach(u), c = !1, run_all(p);
  } };
}
function create_default_slot(n) {
  let o;
  return { c() {
    o = text("Creating DID...");
  }, m(a, u) {
    insert(a, o, u);
  }, d(a) {
    a && detach(o);
  } };
}
function create_else_block(n) {
  let o;
  return { c() {
    o = text("We will deploy a new Smart Contract to manage your DID.");
  }, m(a, u) {
    insert(a, o, u);
  }, p: noop$2, d(a) {
    a && detach(o);
  } };
}
function create_if_block_2(n) {
  let o, a, u, c, p, d;
  return { c() {
    o = text("Using existing contract "), a = element("span"), u = element("a"), c = text(n[1]), p = text("\u{1F517}\u2197\uFE0F"), attr(u, "href", d = "https://sonar.warp.cc/#/app/source/" + n[1] + "#code"), attr(u, "target", "_blank"), attr(u, "rel", "noopener noreferrer"), attr(a, "class", "font-mono bg-gray-50 m-2 p-2 rounded svelte-1anxyld");
  }, m(w, S) {
    insert(w, o, S), insert(w, a, S), append(a, u), append(u, c), append(u, p);
  }, p(w, S) {
    2 & S && set_data(c, w[1]), 2 & S && d !== (d = "https://sonar.warp.cc/#/app/source/" + w[1] + "#code") && attr(u, "href", d);
  }, d(w) {
    w && detach(o), w && detach(a);
  } };
}
function create_key_block(n) {
  let o, a, u, c, p, d = n[3], w = create_key_block_1(n);
  const S = [create_if_block_1, create_if_block_3], k = [];
  function B(I, C) {
    return I[5] || I[4] || !I[7] ? I[5] ? 1 : -1 : 0;
  }
  return ~(a = B(n)) && (u = k[a] = S[a](n)), { c() {
    w.c(), o = space(), u && u.c(), c = empty();
  }, m(I, C) {
    w.m(I, C), insert(I, o, C), ~a && k[a].m(I, C), insert(I, c, C), p = !0;
  }, p(I, C) {
    8 & C && safe_not_equal(d, d = I[3]) ? (group_outros(), transition_out(w, 1, 1, noop$2), check_outros(), w = create_key_block_1(I), w.c(), transition_in(w, 1), w.m(o.parentNode, o)) : w.p(I, C);
    let P = a;
    a = B(I), a === P ? ~a && k[a].p(I, C) : (u && (group_outros(), transition_out(k[P], 1, 1, () => {
      k[P] = null;
    }), check_outros()), ~a ? (u = k[a], u ? u.p(I, C) : (u = k[a] = S[a](I), u.c()), transition_in(u, 1), u.m(c.parentNode, c)) : u = null);
  }, i(I) {
    p || (transition_in(w), transition_in(u), p = !0);
  }, o(I) {
    transition_out(w), transition_out(u), p = !1;
  }, d(I) {
    w.d(I), I && detach(o), ~a && k[a].d(I), I && detach(c);
  } };
}
function create_fragment(n) {
  let o, a, u, c;
  const p = [create_if_block, create_else_block_1], d = [];
  function w(S, k) {
    return S[0] && S[2] && S[6] ? 0 : 1;
  }
  return o = w(n), a = d[o] = p[o](n), { c() {
    a.c(), u = empty();
  }, m(S, k) {
    d[o].m(S, k), insert(S, u, k), c = !0;
  }, p(S, [k]) {
    let B = o;
    o = w(S), o === B ? d[o].p(S, k) : (group_outros(), transition_out(d[B], 1, 1, () => {
      d[B] = null;
    }), check_outros(), a = d[o], a ? a.p(S, k) : (a = d[o] = p[o](S), a.c()), transition_in(a, 1), a.m(u.parentNode, u));
  }, i(S) {
    c || (transition_in(a), c = !0);
  }, o(S) {
    transition_out(a), c = !1;
  }, d(S) {
    d[o].d(S), S && detach(u);
  } };
}
function instance(n, o, a) {
  let u, c, p, d, { RSAPublicKey: w } = o, { Ed25519PublicKey: S } = o, { wallet: k } = o, { srcTx: B = "SoPGF6d-5oLy6-uKpJD2J2tT0ytM9LsXWbP5YQnVT6Q" } = o, I = !1, C = !1, P = !1;
  return onMount(async () => {
    if (I = new URLSearchParams(window.location.search).get("local") === "true", a(2, u = await init({ local: I })), I) {
      const { jwk: D, address: z } = await u.warp.testing.generateWallet();
      a(2, u.wallet = D, u), a(6, p = z), console.log("test address", z);
    }
    a(7, d = async function() {
      a(5, P = !0), a(3, c = await u.create({ RSAPublicKey: w, Ed25519PublicKey: S, srcTx: B }));
      const D = setInterval(async () => {
        a(6, p), a(0, k), C && (clearInterval(D), a(5, P = !1));
      }, 400);
    });
  }), n.$$set = (q) => {
    "RSAPublicKey" in q && a(9, w = q.RSAPublicKey), "Ed25519PublicKey" in q && a(10, S = q.Ed25519PublicKey), "wallet" in q && a(0, k = q.wallet), "srcTx" in q && a(1, B = q.srcTx);
  }, n.$$.update = () => {
    1 & n.$$.dirty && k && (async () => a(6, p = await k.arweaveWalletAPI.getActiveAddress()))();
  }, [k, B, u, c, C, P, p, d, async function(q) {
    console.log("searchComplete", q.detail), a(4, C = q.detail.length);
  }, w, S];
}
class DIDAr extends SvelteComponent {
  constructor(o) {
    super(), init$1(this, o, instance, create_fragment, safe_not_equal, { RSAPublicKey: 9, Ed25519PublicKey: 10, wallet: 0, srcTx: 1 }, add_css);
  }
}
var cjs = {}, ConsoleLogger$1 = {}, LoggerSettings = {}, exports;
exports = LoggerSettings, Object.defineProperty(exports, "__esModule", { value: !0 }), exports.lvlToOrder = exports.LogLevelOrder = void 0, exports.LogLevelOrder = { silly: 0, trace: 1, debug: 2, info: 3, warn: 4, error: 5, fatal: 6, none: 7 }, exports.lvlToOrder = function(n) {
  return exports.LogLevelOrder[n];
}, Object.defineProperty(ConsoleLogger$1, "__esModule", { value: !0 }), ConsoleLogger$1.ConsoleLogger = void 0;
const LoggerSettings_1 = LoggerSettings;
class ConsoleLogger {
  constructor(o, a) {
    this.moduleName = o, this.settings = a;
  }
  trace(o, ...a) {
    this.shouldLog("trace") && console.debug(this.message("trace", o), a);
  }
  error(o, ...a) {
    this.shouldLog("error") && console.error(this.message("error", o), a);
  }
  info(o, ...a) {
    this.shouldLog("info") && console.info(this.message("info", o), a);
  }
  silly(o, ...a) {
    this.shouldLog("silly") && console.debug(this.message("silly", o), a);
  }
  debug(o, ...a) {
    this.shouldLog("debug") && console.debug(this.message("debug", o), a);
  }
  warn(o, ...a) {
    this.shouldLog("warn") && console.warn(this.message("warn", o), a);
  }
  log(o, ...a) {
    this.shouldLog("info") && console.info(this.message("info", o), a);
  }
  fatal(o, ...a) {
    this.shouldLog("fatal") && console.error(this.message("fatal", o), a);
  }
  shouldLog(o) {
    return (0, LoggerSettings_1.lvlToOrder)(o) >= (0, LoggerSettings_1.lvlToOrder)(this.settings.minLevel);
  }
  setSettings(o) {
    this.settings = o;
  }
  message(o, a) {
    return `${new Date().toISOString()} ${o.toUpperCase()} [${this.moduleName}] ${a}`;
  }
}
ConsoleLogger$1.ConsoleLogger = ConsoleLogger;
var ConsoleLoggerFactory$1 = {};
Object.defineProperty(ConsoleLoggerFactory$1, "__esModule", { value: !0 }), ConsoleLoggerFactory$1.ConsoleLoggerFactory = void 0;
const ConsoleLogger_1 = ConsoleLogger$1;
class ConsoleLoggerFactory {
  constructor() {
    this.registeredLoggers = {}, this.registeredOptions = {}, this.defOptions = { minLevel: "info" }, this.setOptions = this.setOptions.bind(this), this.getOptions = this.getOptions.bind(this), this.create = this.create.bind(this), this.logLevel = this.logLevel.bind(this);
  }
  setOptions(o, a) {
    a ? this.registeredLoggers[a] ? this.registeredLoggers[a].setSettings({ ...this.registeredLoggers[a].settings, ...o }) : this.registeredOptions[a] = { ...this.defOptions, ...o } : (this.defOptions = o, Object.keys(this.registeredLoggers).forEach((u) => {
      this.registeredLoggers[u].setSettings({ ...this.registeredLoggers[u].settings, ...o });
    }));
  }
  getOptions(o) {
    return o ? this.registeredLoggers[o] ? this.registeredLoggers[o].settings : this.registeredOptions[o] ? this.registeredOptions[o] : this.defOptions : this.defOptions;
  }
  logLevel(o, a) {
    this.setOptions({ minLevel: o }, a);
  }
  create(o = "SWC") {
    return Object.prototype.hasOwnProperty.call(this.registeredLoggers, o) || (this.registeredLoggers[o] = new ConsoleLogger_1.ConsoleLogger(o, this.getOptions(o))), this.registeredLoggers[o];
  }
}
ConsoleLoggerFactory$1.ConsoleLoggerFactory = ConsoleLoggerFactory;
var WarpLogger = {};
Object.defineProperty(WarpLogger, "__esModule", { value: !0 });
var LoggerFactory$1 = {};
Object.defineProperty(LoggerFactory$1, "__esModule", { value: !0 }), LoggerFactory$1.LoggerFactory = void 0;
const ConsoleLoggerFactory_1 = ConsoleLoggerFactory$1;
class LoggerFactory {
  constructor() {
  }
  setOptions(o, a) {
    LoggerFactory.INST.setOptions(o, a);
  }
  getOptions(o) {
    return LoggerFactory.INST.getOptions(o);
  }
  logLevel(o, a) {
    LoggerFactory.INST.logLevel(o, a);
  }
  create(o) {
    return LoggerFactory.INST.create(o);
  }
  static use(o) {
    LoggerFactory.INST = o;
  }
}
LoggerFactory$1.LoggerFactory = LoggerFactory, LoggerFactory.INST = new ConsoleLoggerFactory_1.ConsoleLoggerFactory();
var Benchmark$1 = {};
Object.defineProperty(Benchmark$1, "__esModule", { value: !0 }), Benchmark$1.Benchmark = void 0;
class Benchmark {
  constructor() {
    this.start = Date.now(), this.end = null;
  }
  static measure() {
    return new Benchmark();
  }
  reset() {
    this.start = Date.now(), this.end = null;
  }
  stop() {
    this.end = Date.now();
  }
  elapsed(o = !1) {
    this.end === null && (this.end = Date.now());
    const a = this.end - this.start;
    return o ? a : `${(this.end - this.start).toFixed(0)}ms`;
  }
}
Benchmark$1.Benchmark = Benchmark;
var DefinitionLoader = {};
Object.defineProperty(DefinitionLoader, "__esModule", { value: !0 });
var ExecutorFactory = {};
Object.defineProperty(ExecutorFactory, "__esModule", { value: !0 });
var InteractionsLoader = {};
Object.defineProperty(InteractionsLoader, "__esModule", { value: !0 });
var InteractionsSorter = {};
Object.defineProperty(InteractionsSorter, "__esModule", { value: !0 });
var StateEvaluator = {};
Object.defineProperty(StateEvaluator, "__esModule", { value: !0 }), StateEvaluator.DefaultEvaluationOptions = StateEvaluator.EvalStateResult = void 0;
class EvalStateResult {
  constructor(o, a, u) {
    this.state = o, this.validity = a, this.errorMessages = u;
  }
}
StateEvaluator.EvalStateResult = EvalStateResult;
class DefaultEvaluationOptions {
  constructor() {
    this.ignoreExceptions = !0, this.waitForConfirmation = !1, this.updateCacheForEachInteraction = !1, this.internalWrites = !1, this.maxCallDepth = 7, this.maxInteractionEvaluationTimeSeconds = 60, this.stackTrace = { saveState: !1 }, this.bundlerUrl = "https://d1o5nlqr4okus2.cloudfront.net/", this.gasLimit = Number.MAX_SAFE_INTEGER, this.useFastCopy = !0, this.useVM2 = !1, this.allowUnsafeClient = !1, this.allowBigInt = !1, this.walletBalanceUrl = "http://nyc-1.dev.arweave.net:1984/", this.mineArLocalBlocks = !0, this.throwOnInternalWriteError = !0;
  }
}
StateEvaluator.DefaultEvaluationOptions = DefaultEvaluationOptions;
var ContractDefinitionLoader = {}, SmartWeaveTags = {}, t;
t = SmartWeaveTags, Object.defineProperty(t, "__esModule", { value: !0 }), t.SmartWeaveTags = void 0, function(n) {
  n.APP_NAME = "App-Name", n.APP_VERSION = "App-Version", n.CONTRACT_TX_ID = "Contract", n.INPUT = "Input", n.CONTENT_TYPE = "Content-Type", n.CONTRACT_SRC_TX_ID = "Contract-Src", n.SDK = "SDK", n.MIN_FEE = "Min-Fee", n.INIT_STATE = "Init-State", n.INIT_STATE_TX = "Init-State-TX", n.INTERACT_WRITE = "Interact-Write", n.WASM_LANG = "Wasm-Lang", n.WASM_LANG_VERSION = "Wasm-Lang-Version", n.WASM_META = "Wasm-Meta", n.REQUEST_VRF = "Request-Vrf";
}(t.SmartWeaveTags || (t.SmartWeaveTags = {}));
var utils$C = {};
function getTag$4(n, o) {
  const a = n.get("tags");
  for (const u of a)
    try {
      if (u.get("name", { decode: !0, string: !0 }) === o)
        return u.get("value", { decode: !0, string: !0 });
    } catch {
    }
  return !1;
}
function arrayToHex(n) {
  let o = "";
  for (const a of n)
    o += ("0" + a.toString(16)).slice(-2);
  return o;
}
Object.defineProperty(utils$C, "__esModule", { value: !0 }), utils$C.arrayToHex = utils$C.getTag = void 0, utils$C.getTag = getTag$4, utils$C.arrayToHex = arrayToHex;
var ArweaveWrapper = {}, web = {}, common$8 = {}, ar$1 = {}, bignumber = { exports: {} };
(function(n) {
  (function(o) {
    var a, u = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, c = Math.ceil, p = Math.floor, d = "[BigNumber Error] ", w = d + "Number primitive has more than 15 significant digits: ", S = 1e14, k = 14, B = 9007199254740991, I = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], C = 1e7, P = 1e9;
    function q(W) {
      var H = 0 | W;
      return W > 0 || W === H ? H : H - 1;
    }
    function D(W) {
      for (var H, te, g = 1, $ = W.length, _ = W[0] + ""; g < $; ) {
        for (H = W[g++] + "", te = k - H.length; te--; H = "0" + H)
          ;
        _ += H;
      }
      for ($ = _.length; _.charCodeAt(--$) === 48; )
        ;
      return _.slice(0, $ + 1 || 1);
    }
    function z(W, H) {
      var te, g, $ = W.c, _ = H.c, b = W.s, m = H.s, v = W.e, E = H.e;
      if (!b || !m)
        return null;
      if (te = $ && !$[0], g = _ && !_[0], te || g)
        return te ? g ? 0 : -m : b;
      if (b != m)
        return b;
      if (te = b < 0, g = v == E, !$ || !_)
        return g ? 0 : !$ ^ te ? 1 : -1;
      if (!g)
        return v > E ^ te ? 1 : -1;
      for (m = (v = $.length) < (E = _.length) ? v : E, b = 0; b < m; b++)
        if ($[b] != _[b])
          return $[b] > _[b] ^ te ? 1 : -1;
      return v == E ? 0 : v > E ^ te ? 1 : -1;
    }
    function F(W, H, te, g) {
      if (W < H || W > te || W !== p(W))
        throw Error(d + (g || "Argument") + (typeof W == "number" ? W < H || W > te ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(W));
    }
    function V(W) {
      var H = W.c.length - 1;
      return q(W.e / k) == H && W.c[H] % 2 != 0;
    }
    function Z(W, H) {
      return (W.length > 1 ? W.charAt(0) + "." + W.slice(1) : W) + (H < 0 ? "e" : "e+") + H;
    }
    function N(W, H, te) {
      var g, $;
      if (H < 0) {
        for ($ = te + "."; ++H; $ += te)
          ;
        W = $ + W;
      } else if (++H > (g = W.length)) {
        for ($ = te, H -= g; --H; $ += te)
          ;
        W += $;
      } else
        H < g && (W = W.slice(0, H) + "." + W.slice(H));
      return W;
    }
    a = function W(H) {
      var te, g, $, _, b, m, v, E, T, j, L = se.prototype = { constructor: se, toString: null, valueOf: null }, J = new se(1), Y = 20, ne = 4, Q = -7, oe = 21, ae = -1e7, ce = 1e7, ue = !1, le = 1, Se = 0, he = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, _e = "0123456789abcdefghijklmnopqrstuvwxyz", Le = !0;
      function se(h, y) {
        var A, M, x, O, G, X, ie, ee, re = this;
        if (!(re instanceof se))
          return new se(h, y);
        if (y == null) {
          if (h && h._isBigNumber === !0)
            return re.s = h.s, void (!h.c || h.e > ce ? re.c = re.e = null : h.e < ae ? re.c = [re.e = 0] : (re.e = h.e, re.c = h.c.slice()));
          if ((X = typeof h == "number") && 0 * h == 0) {
            if (re.s = 1 / h < 0 ? (h = -h, -1) : 1, h === ~~h) {
              for (O = 0, G = h; G >= 10; G /= 10, O++)
                ;
              return void (O > ce ? re.c = re.e = null : (re.e = O, re.c = [h]));
            }
            ee = String(h);
          } else {
            if (!u.test(ee = String(h)))
              return $(re, ee, X);
            re.s = ee.charCodeAt(0) == 45 ? (ee = ee.slice(1), -1) : 1;
          }
          (O = ee.indexOf(".")) > -1 && (ee = ee.replace(".", "")), (G = ee.search(/e/i)) > 0 ? (O < 0 && (O = G), O += +ee.slice(G + 1), ee = ee.substring(0, G)) : O < 0 && (O = ee.length);
        } else {
          if (F(y, 2, _e.length, "Base"), y == 10 && Le)
            return ke(re = new se(h), Y + re.e + 1, ne);
          if (ee = String(h), X = typeof h == "number") {
            if (0 * h != 0)
              return $(re, ee, X, y);
            if (re.s = 1 / h < 0 ? (ee = ee.slice(1), -1) : 1, se.DEBUG && ee.replace(/^0\.0*|\./, "").length > 15)
              throw Error(w + h);
          } else
            re.s = ee.charCodeAt(0) === 45 ? (ee = ee.slice(1), -1) : 1;
          for (A = _e.slice(0, y), O = G = 0, ie = ee.length; G < ie; G++)
            if (A.indexOf(M = ee.charAt(G)) < 0) {
              if (M == ".") {
                if (G > O) {
                  O = ie;
                  continue;
                }
              } else if (!x && (ee == ee.toUpperCase() && (ee = ee.toLowerCase()) || ee == ee.toLowerCase() && (ee = ee.toUpperCase()))) {
                x = !0, G = -1, O = 0;
                continue;
              }
              return $(re, String(h), X, y);
            }
          X = !1, (O = (ee = g(ee, y, 10, re.s)).indexOf(".")) > -1 ? ee = ee.replace(".", "") : O = ee.length;
        }
        for (G = 0; ee.charCodeAt(G) === 48; G++)
          ;
        for (ie = ee.length; ee.charCodeAt(--ie) === 48; )
          ;
        if (ee = ee.slice(G, ++ie)) {
          if (ie -= G, X && se.DEBUG && ie > 15 && (h > B || h !== p(h)))
            throw Error(w + re.s * h);
          if ((O = O - G - 1) > ce)
            re.c = re.e = null;
          else if (O < ae)
            re.c = [re.e = 0];
          else {
            if (re.e = O, re.c = [], G = (O + 1) % k, O < 0 && (G += k), G < ie) {
              for (G && re.c.push(+ee.slice(0, G)), ie -= k; G < ie; )
                re.c.push(+ee.slice(G, G += k));
              G = k - (ee = ee.slice(G)).length;
            } else
              G -= ie;
            for (; G--; ee += "0")
              ;
            re.c.push(+ee);
          }
        } else
          re.c = [re.e = 0];
      }
      function we(h, y, A, M) {
        var x, O, G, X, ie;
        if (A == null ? A = ne : F(A, 0, 8), !h.c)
          return h.toString();
        if (x = h.c[0], G = h.e, y == null)
          ie = D(h.c), ie = M == 1 || M == 2 && (G <= Q || G >= oe) ? Z(ie, G) : N(ie, G, "0");
        else if (O = (h = ke(new se(h), y, A)).e, X = (ie = D(h.c)).length, M == 1 || M == 2 && (y <= O || O <= Q)) {
          for (; X < y; ie += "0", X++)
            ;
          ie = Z(ie, O);
        } else if (y -= G, ie = N(ie, O, "0"), O + 1 > X) {
          if (--y > 0)
            for (ie += "."; y--; ie += "0")
              ;
        } else if ((y += O - X) > 0)
          for (O + 1 == X && (ie += "."); y--; ie += "0")
            ;
        return h.s < 0 && x ? "-" + ie : ie;
      }
      function We(h, y) {
        for (var A, M = 1, x = new se(h[0]); M < h.length; M++) {
          if (!(A = new se(h[M])).s) {
            x = A;
            break;
          }
          y.call(x, A) && (x = A);
        }
        return x;
      }
      function de(h, y, A) {
        for (var M = 1, x = y.length; !y[--x]; y.pop())
          ;
        for (x = y[0]; x >= 10; x /= 10, M++)
          ;
        return (A = M + A * k - 1) > ce ? h.c = h.e = null : A < ae ? h.c = [h.e = 0] : (h.e = A, h.c = y), h;
      }
      function ke(h, y, A, M) {
        var x, O, G, X, ie, ee, re, ye = h.c, fe = I;
        if (ye) {
          e: {
            for (x = 1, X = ye[0]; X >= 10; X /= 10, x++)
              ;
            if ((O = y - x) < 0)
              O += k, G = y, re = (ie = ye[ee = 0]) / fe[x - G - 1] % 10 | 0;
            else if ((ee = c((O + 1) / k)) >= ye.length) {
              if (!M)
                break e;
              for (; ye.length <= ee; ye.push(0))
                ;
              ie = re = 0, x = 1, G = (O %= k) - k + 1;
            } else {
              for (ie = X = ye[ee], x = 1; X >= 10; X /= 10, x++)
                ;
              re = (G = (O %= k) - k + x) < 0 ? 0 : ie / fe[x - G - 1] % 10 | 0;
            }
            if (M = M || y < 0 || ye[ee + 1] != null || (G < 0 ? ie : ie % fe[x - G - 1]), M = A < 4 ? (re || M) && (A == 0 || A == (h.s < 0 ? 3 : 2)) : re > 5 || re == 5 && (A == 4 || M || A == 6 && (O > 0 ? G > 0 ? ie / fe[x - G] : 0 : ye[ee - 1]) % 10 & 1 || A == (h.s < 0 ? 8 : 7)), y < 1 || !ye[0])
              return ye.length = 0, M ? (y -= h.e + 1, ye[0] = fe[(k - y % k) % k], h.e = -y || 0) : ye[0] = h.e = 0, h;
            if (O == 0 ? (ye.length = ee, X = 1, ee--) : (ye.length = ee + 1, X = fe[k - O], ye[ee] = G > 0 ? p(ie / fe[x - G] % fe[G]) * X : 0), M)
              for (; ; ) {
                if (ee == 0) {
                  for (O = 1, G = ye[0]; G >= 10; G /= 10, O++)
                    ;
                  for (G = ye[0] += X, X = 1; G >= 10; G /= 10, X++)
                    ;
                  O != X && (h.e++, ye[0] == S && (ye[0] = 1));
                  break;
                }
                if (ye[ee] += X, ye[ee] != S)
                  break;
                ye[ee--] = 0, X = 1;
              }
            for (O = ye.length; ye[--O] === 0; ye.pop())
              ;
          }
          h.e > ce ? h.c = h.e = null : h.e < ae && (h.c = [h.e = 0]);
        }
        return h;
      }
      function l(h) {
        var y, A = h.e;
        return A === null ? h.toString() : (y = D(h.c), y = A <= Q || A >= oe ? Z(y, A) : N(y, A, "0"), h.s < 0 ? "-" + y : y);
      }
      return se.clone = W, se.ROUND_UP = 0, se.ROUND_DOWN = 1, se.ROUND_CEIL = 2, se.ROUND_FLOOR = 3, se.ROUND_HALF_UP = 4, se.ROUND_HALF_DOWN = 5, se.ROUND_HALF_EVEN = 6, se.ROUND_HALF_CEIL = 7, se.ROUND_HALF_FLOOR = 8, se.EUCLID = 9, se.config = se.set = function(h) {
        var y, A;
        if (h != null) {
          if (typeof h != "object")
            throw Error(d + "Object expected: " + h);
          if (h.hasOwnProperty(y = "DECIMAL_PLACES") && (F(A = h[y], 0, P, y), Y = A), h.hasOwnProperty(y = "ROUNDING_MODE") && (F(A = h[y], 0, 8, y), ne = A), h.hasOwnProperty(y = "EXPONENTIAL_AT") && ((A = h[y]) && A.pop ? (F(A[0], -P, 0, y), F(A[1], 0, P, y), Q = A[0], oe = A[1]) : (F(A, -P, P, y), Q = -(oe = A < 0 ? -A : A))), h.hasOwnProperty(y = "RANGE"))
            if ((A = h[y]) && A.pop)
              F(A[0], -P, -1, y), F(A[1], 1, P, y), ae = A[0], ce = A[1];
            else {
              if (F(A, -P, P, y), !A)
                throw Error(d + y + " cannot be zero: " + A);
              ae = -(ce = A < 0 ? -A : A);
            }
          if (h.hasOwnProperty(y = "CRYPTO")) {
            if ((A = h[y]) !== !!A)
              throw Error(d + y + " not true or false: " + A);
            if (A) {
              if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                throw ue = !A, Error(d + "crypto unavailable");
              ue = A;
            } else
              ue = A;
          }
          if (h.hasOwnProperty(y = "MODULO_MODE") && (F(A = h[y], 0, 9, y), le = A), h.hasOwnProperty(y = "POW_PRECISION") && (F(A = h[y], 0, P, y), Se = A), h.hasOwnProperty(y = "FORMAT")) {
            if (typeof (A = h[y]) != "object")
              throw Error(d + y + " not an object: " + A);
            he = A;
          }
          if (h.hasOwnProperty(y = "ALPHABET")) {
            if (typeof (A = h[y]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(A))
              throw Error(d + y + " invalid: " + A);
            Le = A.slice(0, 10) == "0123456789", _e = A;
          }
        }
        return { DECIMAL_PLACES: Y, ROUNDING_MODE: ne, EXPONENTIAL_AT: [Q, oe], RANGE: [ae, ce], CRYPTO: ue, MODULO_MODE: le, POW_PRECISION: Se, FORMAT: he, ALPHABET: _e };
      }, se.isBigNumber = function(h) {
        if (!h || h._isBigNumber !== !0)
          return !1;
        if (!se.DEBUG)
          return !0;
        var y, A, M = h.c, x = h.e, O = h.s;
        e:
          if ({}.toString.call(M) == "[object Array]") {
            if ((O === 1 || O === -1) && x >= -P && x <= P && x === p(x)) {
              if (M[0] === 0) {
                if (x === 0 && M.length === 1)
                  return !0;
                break e;
              }
              if ((y = (x + 1) % k) < 1 && (y += k), String(M[0]).length == y) {
                for (y = 0; y < M.length; y++)
                  if ((A = M[y]) < 0 || A >= S || A !== p(A))
                    break e;
                if (A !== 0)
                  return !0;
              }
            }
          } else if (M === null && x === null && (O === null || O === 1 || O === -1))
            return !0;
        throw Error(d + "Invalid BigNumber: " + h);
      }, se.maximum = se.max = function() {
        return We(arguments, L.lt);
      }, se.minimum = se.min = function() {
        return We(arguments, L.gt);
      }, se.random = (_ = 9007199254740992, b = Math.random() * _ & 2097151 ? function() {
        return p(Math.random() * _);
      } : function() {
        return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
      }, function(h) {
        var y, A, M, x, O, G = 0, X = [], ie = new se(J);
        if (h == null ? h = Y : F(h, 0, P), x = c(h / k), ue)
          if (crypto.getRandomValues) {
            for (y = crypto.getRandomValues(new Uint32Array(x *= 2)); G < x; )
              (O = 131072 * y[G] + (y[G + 1] >>> 11)) >= 9e15 ? (A = crypto.getRandomValues(new Uint32Array(2)), y[G] = A[0], y[G + 1] = A[1]) : (X.push(O % 1e14), G += 2);
            G = x / 2;
          } else {
            if (!crypto.randomBytes)
              throw ue = !1, Error(d + "crypto unavailable");
            for (y = crypto.randomBytes(x *= 7); G < x; )
              (O = 281474976710656 * (31 & y[G]) + 1099511627776 * y[G + 1] + 4294967296 * y[G + 2] + 16777216 * y[G + 3] + (y[G + 4] << 16) + (y[G + 5] << 8) + y[G + 6]) >= 9e15 ? crypto.randomBytes(7).copy(y, G) : (X.push(O % 1e14), G += 7);
            G = x / 7;
          }
        if (!ue)
          for (; G < x; )
            (O = b()) < 9e15 && (X[G++] = O % 1e14);
        for (x = X[--G], h %= k, x && h && (O = I[k - h], X[G] = p(x / O) * O); X[G] === 0; X.pop(), G--)
          ;
        if (G < 0)
          X = [M = 0];
        else {
          for (M = -1; X[0] === 0; X.splice(0, 1), M -= k)
            ;
          for (G = 1, O = X[0]; O >= 10; O /= 10, G++)
            ;
          G < k && (M -= k - G);
        }
        return ie.e = M, ie.c = X, ie;
      }), se.sum = function() {
        for (var h = 1, y = arguments, A = new se(y[0]); h < y.length; )
          A = A.plus(y[h++]);
        return A;
      }, g = function() {
        var h = "0123456789";
        function y(A, M, x, O) {
          for (var G, X, ie = [0], ee = 0, re = A.length; ee < re; ) {
            for (X = ie.length; X--; ie[X] *= M)
              ;
            for (ie[0] += O.indexOf(A.charAt(ee++)), G = 0; G < ie.length; G++)
              ie[G] > x - 1 && (ie[G + 1] == null && (ie[G + 1] = 0), ie[G + 1] += ie[G] / x | 0, ie[G] %= x);
          }
          return ie.reverse();
        }
        return function(A, M, x, O, G) {
          var X, ie, ee, re, ye, fe, pe, Re, me = A.indexOf("."), Ee = Y, Ce = ne;
          for (me >= 0 && (re = Se, Se = 0, A = A.replace(".", ""), fe = (Re = new se(M)).pow(A.length - me), Se = re, Re.c = y(N(D(fe.c), fe.e, "0"), 10, x, h), Re.e = Re.c.length), ee = re = (pe = y(A, M, x, G ? (X = _e, h) : (X = h, _e))).length; pe[--re] == 0; pe.pop())
            ;
          if (!pe[0])
            return X.charAt(0);
          if (me < 0 ? --ee : (fe.c = pe, fe.e = ee, fe.s = O, pe = (fe = te(fe, Re, Ee, Ce, x)).c, ye = fe.r, ee = fe.e), me = pe[ie = ee + Ee + 1], re = x / 2, ye = ye || ie < 0 || pe[ie + 1] != null, ye = Ce < 4 ? (me != null || ye) && (Ce == 0 || Ce == (fe.s < 0 ? 3 : 2)) : me > re || me == re && (Ce == 4 || ye || Ce == 6 && 1 & pe[ie - 1] || Ce == (fe.s < 0 ? 8 : 7)), ie < 1 || !pe[0])
            A = ye ? N(X.charAt(1), -Ee, X.charAt(0)) : X.charAt(0);
          else {
            if (pe.length = ie, ye)
              for (--x; ++pe[--ie] > x; )
                pe[ie] = 0, ie || (++ee, pe = [1].concat(pe));
            for (re = pe.length; !pe[--re]; )
              ;
            for (me = 0, A = ""; me <= re; A += X.charAt(pe[me++]))
              ;
            A = N(A, ee, X.charAt(0));
          }
          return A;
        };
      }(), te = function() {
        function h(M, x, O) {
          var G, X, ie, ee, re = 0, ye = M.length, fe = x % C, pe = x / C | 0;
          for (M = M.slice(); ye--; )
            re = ((X = fe * (ie = M[ye] % C) + (G = pe * ie + (ee = M[ye] / C | 0) * fe) % C * C + re) / O | 0) + (G / C | 0) + pe * ee, M[ye] = X % O;
          return re && (M = [re].concat(M)), M;
        }
        function y(M, x, O, G) {
          var X, ie;
          if (O != G)
            ie = O > G ? 1 : -1;
          else
            for (X = ie = 0; X < O; X++)
              if (M[X] != x[X]) {
                ie = M[X] > x[X] ? 1 : -1;
                break;
              }
          return ie;
        }
        function A(M, x, O, G) {
          for (var X = 0; O--; )
            M[O] -= X, X = M[O] < x[O] ? 1 : 0, M[O] = X * G + M[O] - x[O];
          for (; !M[0] && M.length > 1; M.splice(0, 1))
            ;
        }
        return function(M, x, O, G, X) {
          var ie, ee, re, ye, fe, pe, Re, me, Ee, Ce, ge, Ae, Fe, $e, Me, qe, ve, Oe = M.s == x.s ? 1 : -1, He = M.c, be = x.c;
          if (!(He && He[0] && be && be[0]))
            return new se(M.s && x.s && (He ? !be || He[0] != be[0] : be) ? He && He[0] == 0 || !be ? 0 * Oe : Oe / 0 : NaN);
          for (Ee = (me = new se(Oe)).c = [], Oe = O + (ee = M.e - x.e) + 1, X || (X = S, ee = q(M.e / k) - q(x.e / k), Oe = Oe / k | 0), re = 0; be[re] == (He[re] || 0); re++)
            ;
          if (be[re] > (He[re] || 0) && ee--, Oe < 0)
            Ee.push(1), ye = !0;
          else {
            for ($e = He.length, qe = be.length, re = 0, Oe += 2, (fe = p(X / (be[0] + 1))) > 1 && (be = h(be, fe, X), He = h(He, fe, X), qe = be.length, $e = He.length), Fe = qe, ge = (Ce = He.slice(0, qe)).length; ge < qe; Ce[ge++] = 0)
              ;
            ve = be.slice(), ve = [0].concat(ve), Me = be[0], be[1] >= X / 2 && Me++;
            do {
              if (fe = 0, (ie = y(be, Ce, qe, ge)) < 0) {
                if (Ae = Ce[0], qe != ge && (Ae = Ae * X + (Ce[1] || 0)), (fe = p(Ae / Me)) > 1)
                  for (fe >= X && (fe = X - 1), Re = (pe = h(be, fe, X)).length, ge = Ce.length; y(pe, Ce, Re, ge) == 1; )
                    fe--, A(pe, qe < Re ? ve : be, Re, X), Re = pe.length, ie = 1;
                else
                  fe == 0 && (ie = fe = 1), Re = (pe = be.slice()).length;
                if (Re < ge && (pe = [0].concat(pe)), A(Ce, pe, ge, X), ge = Ce.length, ie == -1)
                  for (; y(be, Ce, qe, ge) < 1; )
                    fe++, A(Ce, qe < ge ? ve : be, ge, X), ge = Ce.length;
              } else
                ie === 0 && (fe++, Ce = [0]);
              Ee[re++] = fe, Ce[0] ? Ce[ge++] = He[Fe] || 0 : (Ce = [He[Fe]], ge = 1);
            } while ((Fe++ < $e || Ce[0] != null) && Oe--);
            ye = Ce[0] != null, Ee[0] || Ee.splice(0, 1);
          }
          if (X == S) {
            for (re = 1, Oe = Ee[0]; Oe >= 10; Oe /= 10, re++)
              ;
            ke(me, O + (me.e = re + ee * k - 1) + 1, G, ye);
          } else
            me.e = ee, me.r = +ye;
          return me;
        };
      }(), m = /^(-?)0([xbo])(?=\w[\w.]*$)/i, v = /^([^.]+)\.$/, E = /^\.([^.]+)$/, T = /^-?(Infinity|NaN)$/, j = /^\s*\+(?=[\w.])|^\s+|\s+$/g, $ = function(h, y, A, M) {
        var x, O = A ? y : y.replace(j, "");
        if (T.test(O))
          h.s = isNaN(O) ? null : O < 0 ? -1 : 1;
        else {
          if (!A && (O = O.replace(m, function(G, X, ie) {
            return x = (ie = ie.toLowerCase()) == "x" ? 16 : ie == "b" ? 2 : 8, M && M != x ? G : X;
          }), M && (x = M, O = O.replace(v, "$1").replace(E, "0.$1")), y != O))
            return new se(O, x);
          if (se.DEBUG)
            throw Error(d + "Not a" + (M ? " base " + M : "") + " number: " + y);
          h.s = null;
        }
        h.c = h.e = null;
      }, L.absoluteValue = L.abs = function() {
        var h = new se(this);
        return h.s < 0 && (h.s = 1), h;
      }, L.comparedTo = function(h, y) {
        return z(this, new se(h, y));
      }, L.decimalPlaces = L.dp = function(h, y) {
        var A, M, x, O = this;
        if (h != null)
          return F(h, 0, P), y == null ? y = ne : F(y, 0, 8), ke(new se(O), h + O.e + 1, y);
        if (!(A = O.c))
          return null;
        if (M = ((x = A.length - 1) - q(this.e / k)) * k, x = A[x])
          for (; x % 10 == 0; x /= 10, M--)
            ;
        return M < 0 && (M = 0), M;
      }, L.dividedBy = L.div = function(h, y) {
        return te(this, new se(h, y), Y, ne);
      }, L.dividedToIntegerBy = L.idiv = function(h, y) {
        return te(this, new se(h, y), 0, 1);
      }, L.exponentiatedBy = L.pow = function(h, y) {
        var A, M, x, O, G, X, ie, ee, re = this;
        if ((h = new se(h)).c && !h.isInteger())
          throw Error(d + "Exponent not an integer: " + l(h));
        if (y != null && (y = new se(y)), G = h.e > 14, !re.c || !re.c[0] || re.c[0] == 1 && !re.e && re.c.length == 1 || !h.c || !h.c[0])
          return ee = new se(Math.pow(+l(re), G ? 2 - V(h) : +l(h))), y ? ee.mod(y) : ee;
        if (X = h.s < 0, y) {
          if (y.c ? !y.c[0] : !y.s)
            return new se(NaN);
          (M = !X && re.isInteger() && y.isInteger()) && (re = re.mod(y));
        } else {
          if (h.e > 9 && (re.e > 0 || re.e < -1 || (re.e == 0 ? re.c[0] > 1 || G && re.c[1] >= 24e7 : re.c[0] < 8e13 || G && re.c[0] <= 9999975e7)))
            return O = re.s < 0 && V(h) ? -0 : 0, re.e > -1 && (O = 1 / O), new se(X ? 1 / O : O);
          Se && (O = c(Se / k + 2));
        }
        for (G ? (A = new se(0.5), X && (h.s = 1), ie = V(h)) : ie = (x = Math.abs(+l(h))) % 2, ee = new se(J); ; ) {
          if (ie) {
            if (!(ee = ee.times(re)).c)
              break;
            O ? ee.c.length > O && (ee.c.length = O) : M && (ee = ee.mod(y));
          }
          if (x) {
            if ((x = p(x / 2)) === 0)
              break;
            ie = x % 2;
          } else if (ke(h = h.times(A), h.e + 1, 1), h.e > 14)
            ie = V(h);
          else {
            if ((x = +l(h)) == 0)
              break;
            ie = x % 2;
          }
          re = re.times(re), O ? re.c && re.c.length > O && (re.c.length = O) : M && (re = re.mod(y));
        }
        return M ? ee : (X && (ee = J.div(ee)), y ? ee.mod(y) : O ? ke(ee, Se, ne, void 0) : ee);
      }, L.integerValue = function(h) {
        var y = new se(this);
        return h == null ? h = ne : F(h, 0, 8), ke(y, y.e + 1, h);
      }, L.isEqualTo = L.eq = function(h, y) {
        return z(this, new se(h, y)) === 0;
      }, L.isFinite = function() {
        return !!this.c;
      }, L.isGreaterThan = L.gt = function(h, y) {
        return z(this, new se(h, y)) > 0;
      }, L.isGreaterThanOrEqualTo = L.gte = function(h, y) {
        return (y = z(this, new se(h, y))) === 1 || y === 0;
      }, L.isInteger = function() {
        return !!this.c && q(this.e / k) > this.c.length - 2;
      }, L.isLessThan = L.lt = function(h, y) {
        return z(this, new se(h, y)) < 0;
      }, L.isLessThanOrEqualTo = L.lte = function(h, y) {
        return (y = z(this, new se(h, y))) === -1 || y === 0;
      }, L.isNaN = function() {
        return !this.s;
      }, L.isNegative = function() {
        return this.s < 0;
      }, L.isPositive = function() {
        return this.s > 0;
      }, L.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, L.minus = function(h, y) {
        var A, M, x, O, G = this, X = G.s;
        if (y = (h = new se(h, y)).s, !X || !y)
          return new se(NaN);
        if (X != y)
          return h.s = -y, G.plus(h);
        var ie = G.e / k, ee = h.e / k, re = G.c, ye = h.c;
        if (!ie || !ee) {
          if (!re || !ye)
            return re ? (h.s = -y, h) : new se(ye ? G : NaN);
          if (!re[0] || !ye[0])
            return ye[0] ? (h.s = -y, h) : new se(re[0] ? G : ne == 3 ? -0 : 0);
        }
        if (ie = q(ie), ee = q(ee), re = re.slice(), X = ie - ee) {
          for ((O = X < 0) ? (X = -X, x = re) : (ee = ie, x = ye), x.reverse(), y = X; y--; x.push(0))
            ;
          x.reverse();
        } else
          for (M = (O = (X = re.length) < (y = ye.length)) ? X : y, X = y = 0; y < M; y++)
            if (re[y] != ye[y]) {
              O = re[y] < ye[y];
              break;
            }
        if (O && (x = re, re = ye, ye = x, h.s = -h.s), (y = (M = ye.length) - (A = re.length)) > 0)
          for (; y--; re[A++] = 0)
            ;
        for (y = S - 1; M > X; ) {
          if (re[--M] < ye[M]) {
            for (A = M; A && !re[--A]; re[A] = y)
              ;
            --re[A], re[M] += S;
          }
          re[M] -= ye[M];
        }
        for (; re[0] == 0; re.splice(0, 1), --ee)
          ;
        return re[0] ? de(h, re, ee) : (h.s = ne == 3 ? -1 : 1, h.c = [h.e = 0], h);
      }, L.modulo = L.mod = function(h, y) {
        var A, M, x = this;
        return h = new se(h, y), !x.c || !h.s || h.c && !h.c[0] ? new se(NaN) : !h.c || x.c && !x.c[0] ? new se(x) : (le == 9 ? (M = h.s, h.s = 1, A = te(x, h, 0, 3), h.s = M, A.s *= M) : A = te(x, h, 0, le), (h = x.minus(A.times(h))).c[0] || le != 1 || (h.s = x.s), h);
      }, L.multipliedBy = L.times = function(h, y) {
        var A, M, x, O, G, X, ie, ee, re, ye, fe, pe, Re, me, Ee, Ce = this, ge = Ce.c, Ae = (h = new se(h, y)).c;
        if (!(ge && Ae && ge[0] && Ae[0]))
          return !Ce.s || !h.s || ge && !ge[0] && !Ae || Ae && !Ae[0] && !ge ? h.c = h.e = h.s = null : (h.s *= Ce.s, ge && Ae ? (h.c = [0], h.e = 0) : h.c = h.e = null), h;
        for (M = q(Ce.e / k) + q(h.e / k), h.s *= Ce.s, (ie = ge.length) < (ye = Ae.length) && (Re = ge, ge = Ae, Ae = Re, x = ie, ie = ye, ye = x), x = ie + ye, Re = []; x--; Re.push(0))
          ;
        for (me = S, Ee = C, x = ye; --x >= 0; ) {
          for (A = 0, fe = Ae[x] % Ee, pe = Ae[x] / Ee | 0, O = x + (G = ie); O > x; )
            A = ((ee = fe * (ee = ge[--G] % Ee) + (X = pe * ee + (re = ge[G] / Ee | 0) * fe) % Ee * Ee + Re[O] + A) / me | 0) + (X / Ee | 0) + pe * re, Re[O--] = ee % me;
          Re[O] = A;
        }
        return A ? ++M : Re.splice(0, 1), de(h, Re, M);
      }, L.negated = function() {
        var h = new se(this);
        return h.s = -h.s || null, h;
      }, L.plus = function(h, y) {
        var A, M = this, x = M.s;
        if (y = (h = new se(h, y)).s, !x || !y)
          return new se(NaN);
        if (x != y)
          return h.s = -y, M.minus(h);
        var O = M.e / k, G = h.e / k, X = M.c, ie = h.c;
        if (!O || !G) {
          if (!X || !ie)
            return new se(x / 0);
          if (!X[0] || !ie[0])
            return ie[0] ? h : new se(X[0] ? M : 0 * x);
        }
        if (O = q(O), G = q(G), X = X.slice(), x = O - G) {
          for (x > 0 ? (G = O, A = ie) : (x = -x, A = X), A.reverse(); x--; A.push(0))
            ;
          A.reverse();
        }
        for ((x = X.length) - (y = ie.length) < 0 && (A = ie, ie = X, X = A, y = x), x = 0; y; )
          x = (X[--y] = X[y] + ie[y] + x) / S | 0, X[y] = S === X[y] ? 0 : X[y] % S;
        return x && (X = [x].concat(X), ++G), de(h, X, G);
      }, L.precision = L.sd = function(h, y) {
        var A, M, x, O = this;
        if (h != null && h !== !!h)
          return F(h, 1, P), y == null ? y = ne : F(y, 0, 8), ke(new se(O), h, y);
        if (!(A = O.c))
          return null;
        if (M = (x = A.length - 1) * k + 1, x = A[x]) {
          for (; x % 10 == 0; x /= 10, M--)
            ;
          for (x = A[0]; x >= 10; x /= 10, M++)
            ;
        }
        return h && O.e + 1 > M && (M = O.e + 1), M;
      }, L.shiftedBy = function(h) {
        return F(h, -9007199254740991, B), this.times("1e" + h);
      }, L.squareRoot = L.sqrt = function() {
        var h, y, A, M, x, O = this, G = O.c, X = O.s, ie = O.e, ee = Y + 4, re = new se("0.5");
        if (X !== 1 || !G || !G[0])
          return new se(!X || X < 0 && (!G || G[0]) ? NaN : G ? O : 1 / 0);
        if ((X = Math.sqrt(+l(O))) == 0 || X == 1 / 0 ? (((y = D(G)).length + ie) % 2 == 0 && (y += "0"), X = Math.sqrt(+y), ie = q((ie + 1) / 2) - (ie < 0 || ie % 2), A = new se(y = X == 1 / 0 ? "5e" + ie : (y = X.toExponential()).slice(0, y.indexOf("e") + 1) + ie)) : A = new se(X + ""), A.c[0]) {
          for ((X = (ie = A.e) + ee) < 3 && (X = 0); ; )
            if (x = A, A = re.times(x.plus(te(O, x, ee, 1))), D(x.c).slice(0, X) === (y = D(A.c)).slice(0, X)) {
              if (A.e < ie && --X, (y = y.slice(X - 3, X + 1)) != "9999" && (M || y != "4999")) {
                +y && (+y.slice(1) || y.charAt(0) != "5") || (ke(A, A.e + Y + 2, 1), h = !A.times(A).eq(O));
                break;
              }
              if (!M && (ke(x, x.e + Y + 2, 0), x.times(x).eq(O))) {
                A = x;
                break;
              }
              ee += 4, X += 4, M = 1;
            }
        }
        return ke(A, A.e + Y + 1, ne, h);
      }, L.toExponential = function(h, y) {
        return h != null && (F(h, 0, P), h++), we(this, h, y, 1);
      }, L.toFixed = function(h, y) {
        return h != null && (F(h, 0, P), h = h + this.e + 1), we(this, h, y);
      }, L.toFormat = function(h, y, A) {
        var M, x = this;
        if (A == null)
          h != null && y && typeof y == "object" ? (A = y, y = null) : h && typeof h == "object" ? (A = h, h = y = null) : A = he;
        else if (typeof A != "object")
          throw Error(d + "Argument not an object: " + A);
        if (M = x.toFixed(h, y), x.c) {
          var O, G = M.split("."), X = +A.groupSize, ie = +A.secondaryGroupSize, ee = A.groupSeparator || "", re = G[0], ye = G[1], fe = x.s < 0, pe = fe ? re.slice(1) : re, Re = pe.length;
          if (ie && (O = X, X = ie, ie = O, Re -= O), X > 0 && Re > 0) {
            for (O = Re % X || X, re = pe.substr(0, O); O < Re; O += X)
              re += ee + pe.substr(O, X);
            ie > 0 && (re += ee + pe.slice(O)), fe && (re = "-" + re);
          }
          M = ye ? re + (A.decimalSeparator || "") + ((ie = +A.fractionGroupSize) ? ye.replace(new RegExp("\\d{" + ie + "}\\B", "g"), "$&" + (A.fractionGroupSeparator || "")) : ye) : re;
        }
        return (A.prefix || "") + M + (A.suffix || "");
      }, L.toFraction = function(h) {
        var y, A, M, x, O, G, X, ie, ee, re, ye, fe, pe = this, Re = pe.c;
        if (h != null && (!(X = new se(h)).isInteger() && (X.c || X.s !== 1) || X.lt(J)))
          throw Error(d + "Argument " + (X.isInteger() ? "out of range: " : "not an integer: ") + l(X));
        if (!Re)
          return new se(pe);
        for (y = new se(J), ee = A = new se(J), M = ie = new se(J), fe = D(Re), O = y.e = fe.length - pe.e - 1, y.c[0] = I[(G = O % k) < 0 ? k + G : G], h = !h || X.comparedTo(y) > 0 ? O > 0 ? y : ee : X, G = ce, ce = 1 / 0, X = new se(fe), ie.c[0] = 0; re = te(X, y, 0, 1), (x = A.plus(re.times(M))).comparedTo(h) != 1; )
          A = M, M = x, ee = ie.plus(re.times(x = ee)), ie = x, y = X.minus(re.times(x = y)), X = x;
        return x = te(h.minus(A), M, 0, 1), ie = ie.plus(x.times(ee)), A = A.plus(x.times(M)), ie.s = ee.s = pe.s, ye = te(ee, M, O *= 2, ne).minus(pe).abs().comparedTo(te(ie, A, O, ne).minus(pe).abs()) < 1 ? [ee, M] : [ie, A], ce = G, ye;
      }, L.toNumber = function() {
        return +l(this);
      }, L.toPrecision = function(h, y) {
        return h != null && F(h, 1, P), we(this, h, y, 2);
      }, L.toString = function(h) {
        var y, A = this, M = A.s, x = A.e;
        return x === null ? M ? (y = "Infinity", M < 0 && (y = "-" + y)) : y = "NaN" : (h == null ? y = x <= Q || x >= oe ? Z(D(A.c), x) : N(D(A.c), x, "0") : h === 10 && Le ? y = N(D((A = ke(new se(A), Y + x + 1, ne)).c), A.e, "0") : (F(h, 2, _e.length, "Base"), y = g(N(D(A.c), x, "0"), 10, h, M, !0)), M < 0 && A.c[0] && (y = "-" + y)), y;
      }, L.valueOf = L.toJSON = function() {
        return l(this);
      }, L._isBigNumber = !0, H != null && se.set(H), se;
    }(), a.default = a.BigNumber = a, n.exports ? n.exports = a : (o || (o = typeof self < "u" && self ? self : window), o.BigNumber = a);
  })(commonjsGlobal);
})(bignumber), Object.defineProperty(ar$1, "__esModule", { value: !0 });
const bignumber_js_1$2 = bignumber.exports;
class Ar$1 {
  constructor() {
    this.BigNum = (o, a) => new (bignumber_js_1$2.BigNumber.clone({ DECIMAL_PLACES: a }))(o);
  }
  winstonToAr(o, { formatted: a = !1, decimals: u = 12, trim: c = !0 } = {}) {
    let p = this.stringToBigNum(o, u).shiftedBy(-12);
    return a ? p.toFormat(u) : p.toFixed(u);
  }
  arToWinston(o, { formatted: a = !1 } = {}) {
    let u = this.stringToBigNum(o).shiftedBy(12);
    return a ? u.toFormat() : u.toFixed(0);
  }
  compare(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.comparedTo(c);
  }
  isEqual(o, a) {
    return this.compare(o, a) === 0;
  }
  isLessThan(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.isLessThan(c);
  }
  isGreaterThan(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.isGreaterThan(c);
  }
  add(o, a) {
    let u = this.stringToBigNum(o);
    return this.stringToBigNum(a), u.plus(a).toFixed(0);
  }
  sub(o, a) {
    let u = this.stringToBigNum(o);
    return this.stringToBigNum(a), u.minus(a).toFixed(0);
  }
  stringToBigNum(o, a = 12) {
    return this.BigNum(o, a);
  }
}
ar$1.default = Ar$1;
var api$2 = {}, axios$2 = { exports: {} }, axios$1 = { exports: {} }, bind$2 = function(n, o) {
  return function() {
    for (var a = new Array(arguments.length), u = 0; u < a.length; u++)
      a[u] = arguments[u];
    return n.apply(o, a);
  };
}, bind$1 = bind$2, toString$1 = Object.prototype.toString, kindOf = function(n) {
  return function(o) {
    var a = toString$1.call(o);
    return n[a] || (n[a] = a.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(n) {
  return n = n.toLowerCase(), function(o) {
    return kindOf(o) === n;
  };
}
function isArray$4(n) {
  return Array.isArray(n);
}
function isUndefined(n) {
  return n === void 0;
}
function isBuffer$3(n) {
  return n !== null && !isUndefined(n) && n.constructor !== null && !isUndefined(n.constructor) && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(n) {
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(n) : n && n.buffer && isArrayBuffer(n.buffer);
}
function isString(n) {
  return typeof n == "string";
}
function isNumber(n) {
  return typeof n == "number";
}
function isObject$7(n) {
  return n !== null && typeof n == "object";
}
function isPlainObject(n) {
  if (kindOf(n) !== "object")
    return !1;
  var o = Object.getPrototypeOf(n);
  return o === null || o === Object.prototype;
}
var isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob$1 = kindOfTest("Blob"), isFileList = kindOfTest("FileList");
function isFunction$3(n) {
  return toString$1.call(n) === "[object Function]";
}
function isStream(n) {
  return isObject$7(n) && isFunction$3(n.pipe);
}
function isFormData(n) {
  var o = "[object FormData]";
  return n && (typeof FormData == "function" && n instanceof FormData || toString$1.call(n) === o || isFunction$3(n.toString) && n.toString() === o);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(n) {
  return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return (typeof navigator > "u" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window < "u" && typeof document < "u";
}
function forEach(n, o) {
  if (n != null)
    if (typeof n != "object" && (n = [n]), isArray$4(n))
      for (var a = 0, u = n.length; a < u; a++)
        o.call(null, n[a], a, n);
    else
      for (var c in n)
        Object.prototype.hasOwnProperty.call(n, c) && o.call(null, n[c], c, n);
}
function merge() {
  var n = {};
  function o(c, p) {
    isPlainObject(n[p]) && isPlainObject(c) ? n[p] = merge(n[p], c) : isPlainObject(c) ? n[p] = merge({}, c) : isArray$4(c) ? n[p] = c.slice() : n[p] = c;
  }
  for (var a = 0, u = arguments.length; a < u; a++)
    forEach(arguments[a], o);
  return n;
}
function extend(n, o, a) {
  return forEach(o, function(u, c) {
    n[c] = a && typeof u == "function" ? bind$1(u, a) : u;
  }), n;
}
function stripBOM(n) {
  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;
}
function inherits$a(n, o, a, u) {
  n.prototype = Object.create(o.prototype, u), n.prototype.constructor = n, a && Object.assign(n.prototype, a);
}
function toFlatObject(n, o, a) {
  var u, c, p, d = {};
  o = o || {};
  do {
    for (c = (u = Object.getOwnPropertyNames(n)).length; c-- > 0; )
      d[p = u[c]] || (o[p] = n[p], d[p] = !0);
    n = Object.getPrototypeOf(n);
  } while (n && (!a || a(n, o)) && n !== Object.prototype);
  return o;
}
function endsWith(n, o, a) {
  n = String(n), (a === void 0 || a > n.length) && (a = n.length), a -= o.length;
  var u = n.indexOf(o, a);
  return u !== -1 && u === a;
}
function toArray$1(n) {
  if (!n)
    return null;
  var o = n.length;
  if (isUndefined(o))
    return null;
  for (var a = new Array(o); o-- > 0; )
    a[o] = n[o];
  return a;
}
var isTypedArray$3 = function(n) {
  return function(o) {
    return n && o instanceof n;
  };
}(typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array)), utils$B = { isArray: isArray$4, isArrayBuffer, isBuffer: isBuffer$3, isFormData, isArrayBufferView, isString, isNumber, isObject: isObject$7, isPlainObject, isUndefined, isDate, isFile, isBlob: isBlob$1, isFunction: isFunction$3, isStream, isURLSearchParams, isStandardBrowserEnv, forEach, merge, extend, trim, stripBOM, inherits: inherits$a, toFlatObject, kindOf, kindOfTest, endsWith, toArray: toArray$1, isTypedArray: isTypedArray$3, isFileList }, utils$A = utils$B;
function encode$2(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function(n, o, a) {
  if (!o)
    return n;
  var u;
  if (a)
    u = a(o);
  else if (utils$A.isURLSearchParams(o))
    u = o.toString();
  else {
    var c = [];
    utils$A.forEach(o, function(d, w) {
      d != null && (utils$A.isArray(d) ? w += "[]" : d = [d], utils$A.forEach(d, function(S) {
        utils$A.isDate(S) ? S = S.toISOString() : utils$A.isObject(S) && (S = JSON.stringify(S)), c.push(encode$2(w) + "=" + encode$2(S));
      }));
    }), u = c.join("&");
  }
  if (u) {
    var p = n.indexOf("#");
    p !== -1 && (n = n.slice(0, p)), n += (n.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return n;
}, utils$z = utils$B;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function(n, o, a) {
  return this.handlers.push({ fulfilled: n, rejected: o, synchronous: !!a && a.synchronous, runWhen: a ? a.runWhen : null }), this.handlers.length - 1;
}, InterceptorManager$1.prototype.eject = function(n) {
  this.handlers[n] && (this.handlers[n] = null);
}, InterceptorManager$1.prototype.forEach = function(n) {
  utils$z.forEach(this.handlers, function(o) {
    o !== null && n(o);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$y = utils$B, normalizeHeaderName$1 = function(n, o) {
  utils$y.forEach(n, function(a, u) {
    u !== o && u.toUpperCase() === o.toUpperCase() && (n[o] = a, delete n[u]);
  });
}, utils$x = utils$B;
function AxiosError$2(n, o, a, u, c) {
  Error.call(this), this.message = n, this.name = "AxiosError", o && (this.code = o), a && (this.config = a), u && (this.request = u), c && (this.response = c);
}
utils$x.inherits(AxiosError$2, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
} });
var prototype = AxiosError$2.prototype, descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(n) {
  descriptors[n] = { value: n };
}), Object.defineProperties(AxiosError$2, descriptors), Object.defineProperty(prototype, "isAxiosError", { value: !0 }), AxiosError$2.from = function(n, o, a, u, c, p) {
  var d = Object.create(prototype);
  return utils$x.toFlatObject(n, d, function(w) {
    return w !== Error.prototype;
  }), AxiosError$2.call(d, n.message, o, a, u, c), d.name = n.name, p && Object.assign(d, p), d;
};
var AxiosError_1 = AxiosError$2, transitional = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, utils$w = utils$B;
function toFormData$1(n, o) {
  o = o || new FormData();
  var a = [];
  function u(c) {
    return c === null ? "" : utils$w.isDate(c) ? c.toISOString() : utils$w.isArrayBuffer(c) || utils$w.isTypedArray(c) ? typeof Blob == "function" ? new Blob([c]) : Buffer.from(c) : c;
  }
  return function c(p, d) {
    if (utils$w.isPlainObject(p) || utils$w.isArray(p)) {
      if (a.indexOf(p) !== -1)
        throw Error("Circular reference detected in " + d);
      a.push(p), utils$w.forEach(p, function(w, S) {
        if (!utils$w.isUndefined(w)) {
          var k, B = d ? d + "." + S : S;
          if (w && !d && typeof w == "object") {
            if (utils$w.endsWith(S, "{}"))
              w = JSON.stringify(w);
            else if (utils$w.endsWith(S, "[]") && (k = utils$w.toArray(w)))
              return void k.forEach(function(I) {
                !utils$w.isUndefined(I) && o.append(B, u(I));
              });
          }
          c(w, B);
        }
      }), a.pop();
    } else
      o.append(d, u(p));
  }(n), o;
}
var toFormData_1 = toFormData$1, settle, hasRequiredSettle, cookies, hasRequiredCookies;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var n = AxiosError_1;
  return settle = function(o, a, u) {
    var c = u.config.validateStatus;
    u.status && c && !c(u.status) ? a(new n("Request failed with status code " + u.status, [n.ERR_BAD_REQUEST, n.ERR_BAD_RESPONSE][Math.floor(u.status / 100) - 4], u.config, u.request, u)) : o(u);
  };
}
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var n = utils$B;
  return cookies = n.isStandardBrowserEnv() ? { write: function(o, a, u, c, p, d) {
    var w = [];
    w.push(o + "=" + encodeURIComponent(a)), n.isNumber(u) && w.push("expires=" + new Date(u).toGMTString()), n.isString(c) && w.push("path=" + c), n.isString(p) && w.push("domain=" + p), d === !0 && w.push("secure"), document.cookie = w.join("; ");
  }, read: function(o) {
    var a = document.cookie.match(new RegExp("(^|;\\s*)(" + o + ")=([^;]*)"));
    return a ? decodeURIComponent(a[3]) : null;
  }, remove: function(o) {
    this.write(o, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } }, cookies;
}
var isAbsoluteURL$1 = function(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}, combineURLs$1 = function(n, o) {
  return o ? n.replace(/\/+$/, "") + "/" + o.replace(/^\/+/, "") : n;
}, isAbsoluteURL = isAbsoluteURL$1, combineURLs = combineURLs$1, buildFullPath$1 = function(n, o) {
  return n && !isAbsoluteURL(o) ? combineURLs(n, o) : o;
}, parseHeaders, hasRequiredParseHeaders, isURLSameOrigin, hasRequiredIsURLSameOrigin, CanceledError_1, hasRequiredCanceledError, parseProtocol, hasRequiredParseProtocol, xhr, hasRequiredXhr, _null, hasRequired_null;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var n = utils$B, o = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
  return parseHeaders = function(a) {
    var u, c, p, d = {};
    return a && n.forEach(a.split(`
`), function(w) {
      if (p = w.indexOf(":"), u = n.trim(w.substr(0, p)).toLowerCase(), c = n.trim(w.substr(p + 1)), u) {
        if (d[u] && o.indexOf(u) >= 0)
          return;
        d[u] = u === "set-cookie" ? (d[u] ? d[u] : []).concat([c]) : d[u] ? d[u] + ", " + c : c;
      }
    }), d;
  }, parseHeaders;
}
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var n = utils$B;
  return isURLSameOrigin = n.isStandardBrowserEnv() ? function() {
    var o, a = /(msie|trident)/i.test(navigator.userAgent), u = document.createElement("a");
    function c(p) {
      var d = p;
      return a && (u.setAttribute("href", d), d = u.href), u.setAttribute("href", d), { href: u.href, protocol: u.protocol ? u.protocol.replace(/:$/, "") : "", host: u.host, search: u.search ? u.search.replace(/^\?/, "") : "", hash: u.hash ? u.hash.replace(/^#/, "") : "", hostname: u.hostname, port: u.port, pathname: u.pathname.charAt(0) === "/" ? u.pathname : "/" + u.pathname };
    }
    return o = c(window.location.href), function(p) {
      var d = n.isString(p) ? c(p) : p;
      return d.protocol === o.protocol && d.host === o.host;
    };
  }() : function() {
    return !0;
  };
}
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var n = AxiosError_1;
  function o(a) {
    n.call(this, a == null ? "canceled" : a, n.ERR_CANCELED), this.name = "CanceledError";
  }
  return utils$B.inherits(o, n, { __CANCEL__: !0 }), CanceledError_1 = o;
}
function requireParseProtocol() {
  return hasRequiredParseProtocol ? parseProtocol : (hasRequiredParseProtocol = 1, parseProtocol = function(n) {
    var o = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
    return o && o[1] || "";
  });
}
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var n = utils$B, o = requireSettle(), a = requireCookies(), u = buildURL$1, c = buildFullPath$1, p = requireParseHeaders(), d = requireIsURLSameOrigin(), w = transitional, S = AxiosError_1, k = requireCanceledError(), B = requireParseProtocol();
  return xhr = function(I) {
    return new Promise(function(C, P) {
      var q, D = I.data, z = I.headers, F = I.responseType;
      function V() {
        I.cancelToken && I.cancelToken.unsubscribe(q), I.signal && I.signal.removeEventListener("abort", q);
      }
      n.isFormData(D) && n.isStandardBrowserEnv() && delete z["Content-Type"];
      var Z = new XMLHttpRequest();
      if (I.auth) {
        var N = I.auth.username || "", W = I.auth.password ? unescape(encodeURIComponent(I.auth.password)) : "";
        z.Authorization = "Basic " + btoa(N + ":" + W);
      }
      var H = c(I.baseURL, I.url);
      function te() {
        if (Z) {
          var _ = "getAllResponseHeaders" in Z ? p(Z.getAllResponseHeaders()) : null, b = { data: F && F !== "text" && F !== "json" ? Z.response : Z.responseText, status: Z.status, statusText: Z.statusText, headers: _, config: I, request: Z };
          o(function(m) {
            C(m), V();
          }, function(m) {
            P(m), V();
          }, b), Z = null;
        }
      }
      if (Z.open(I.method.toUpperCase(), u(H, I.params, I.paramsSerializer), !0), Z.timeout = I.timeout, "onloadend" in Z ? Z.onloadend = te : Z.onreadystatechange = function() {
        Z && Z.readyState === 4 && (Z.status !== 0 || Z.responseURL && Z.responseURL.indexOf("file:") === 0) && setTimeout(te);
      }, Z.onabort = function() {
        Z && (P(new S("Request aborted", S.ECONNABORTED, I, Z)), Z = null);
      }, Z.onerror = function() {
        P(new S("Network Error", S.ERR_NETWORK, I, Z, Z)), Z = null;
      }, Z.ontimeout = function() {
        var _ = I.timeout ? "timeout of " + I.timeout + "ms exceeded" : "timeout exceeded", b = I.transitional || w;
        I.timeoutErrorMessage && (_ = I.timeoutErrorMessage), P(new S(_, b.clarifyTimeoutError ? S.ETIMEDOUT : S.ECONNABORTED, I, Z)), Z = null;
      }, n.isStandardBrowserEnv()) {
        var g = (I.withCredentials || d(H)) && I.xsrfCookieName ? a.read(I.xsrfCookieName) : void 0;
        g && (z[I.xsrfHeaderName] = g);
      }
      "setRequestHeader" in Z && n.forEach(z, function(_, b) {
        D === void 0 && b.toLowerCase() === "content-type" ? delete z[b] : Z.setRequestHeader(b, _);
      }), n.isUndefined(I.withCredentials) || (Z.withCredentials = !!I.withCredentials), F && F !== "json" && (Z.responseType = I.responseType), typeof I.onDownloadProgress == "function" && Z.addEventListener("progress", I.onDownloadProgress), typeof I.onUploadProgress == "function" && Z.upload && Z.upload.addEventListener("progress", I.onUploadProgress), (I.cancelToken || I.signal) && (q = function(_) {
        Z && (P(!_ || _ && _.type ? new k() : _), Z.abort(), Z = null);
      }, I.cancelToken && I.cancelToken.subscribe(q), I.signal && (I.signal.aborted ? q() : I.signal.addEventListener("abort", q))), D || (D = null);
      var $ = B(H);
      $ && ["http", "https", "file"].indexOf($) === -1 ? P(new S("Unsupported protocol " + $ + ":", S.ERR_BAD_REQUEST, I)) : Z.send(D);
    });
  }, xhr;
}
function require_null() {
  return hasRequired_null ? _null : (hasRequired_null = 1, _null = null);
}
var utils$v = utils$B, normalizeHeaderName = normalizeHeaderName$1, AxiosError$1 = AxiosError_1, transitionalDefaults = transitional, toFormData = toFormData_1, DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset(n, o) {
  !utils$v.isUndefined(n) && utils$v.isUndefined(n["Content-Type"]) && (n["Content-Type"] = o);
}
function getDefaultAdapter() {
  var n;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (n = requireXhr()), n;
}
function stringifySafely(n, o, a) {
  if (utils$v.isString(n))
    try {
      return (o || JSON.parse)(n), utils$v.trim(n);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (a || JSON.stringify)(n);
}
var defaults$3 = { transitional: transitionalDefaults, adapter: getDefaultAdapter(), transformRequest: [function(n, o) {
  if (normalizeHeaderName(o, "Accept"), normalizeHeaderName(o, "Content-Type"), utils$v.isFormData(n) || utils$v.isArrayBuffer(n) || utils$v.isBuffer(n) || utils$v.isStream(n) || utils$v.isFile(n) || utils$v.isBlob(n))
    return n;
  if (utils$v.isArrayBufferView(n))
    return n.buffer;
  if (utils$v.isURLSearchParams(n))
    return setContentTypeIfUnset(o, "application/x-www-form-urlencoded;charset=utf-8"), n.toString();
  var a, u = utils$v.isObject(n), c = o && o["Content-Type"];
  if ((a = utils$v.isFileList(n)) || u && c === "multipart/form-data") {
    var p = this.env && this.env.FormData;
    return toFormData(a ? { "files[]": n } : n, p && new p());
  }
  return u || c === "application/json" ? (setContentTypeIfUnset(o, "application/json"), stringifySafely(n)) : n;
}], transformResponse: [function(n) {
  var o = this.transitional || defaults$3.transitional, a = o && o.silentJSONParsing, u = o && o.forcedJSONParsing, c = !a && this.responseType === "json";
  if (c || u && utils$v.isString(n) && n.length)
    try {
      return JSON.parse(n);
    } catch (p) {
      if (c)
        throw p.name === "SyntaxError" ? AxiosError$1.from(p, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : p;
    }
  return n;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: require_null() }, validateStatus: function(n) {
  return n >= 200 && n < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*" } } };
utils$v.forEach(["delete", "get", "head"], function(n) {
  defaults$3.headers[n] = {};
}), utils$v.forEach(["post", "put", "patch"], function(n) {
  defaults$3.headers[n] = utils$v.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$u = utils$B, defaults$2 = defaults_1, transformData$1 = function(n, o, a) {
  var u = this || defaults$2;
  return utils$u.forEach(a, function(c) {
    n = c.call(u, n, o);
  }), n;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel ? isCancel$1 : (hasRequiredIsCancel = 1, isCancel$1 = function(n) {
    return !(!n || !n.__CANCEL__);
  });
}
var utils$t = utils$B, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1, CanceledError = requireCanceledError();
function throwIfCancellationRequested(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new CanceledError();
}
var dispatchRequest$1 = function(n) {
  return throwIfCancellationRequested(n), n.headers = n.headers || {}, n.data = transformData.call(n, n.data, n.headers, n.transformRequest), n.headers = utils$t.merge(n.headers.common || {}, n.headers[n.method] || {}, n.headers), utils$t.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(o) {
    delete n.headers[o];
  }), (n.adapter || defaults$1.adapter)(n).then(function(o) {
    return throwIfCancellationRequested(n), o.data = transformData.call(n, o.data, o.headers, n.transformResponse), o;
  }, function(o) {
    return isCancel(o) || (throwIfCancellationRequested(n), o && o.response && (o.response.data = transformData.call(n, o.response.data, o.response.headers, n.transformResponse))), Promise.reject(o);
  });
}, utils$s = utils$B, mergeConfig$2 = function(n, o) {
  o = o || {};
  var a = {};
  function u(k, B) {
    return utils$s.isPlainObject(k) && utils$s.isPlainObject(B) ? utils$s.merge(k, B) : utils$s.isPlainObject(B) ? utils$s.merge({}, B) : utils$s.isArray(B) ? B.slice() : B;
  }
  function c(k) {
    return utils$s.isUndefined(o[k]) ? utils$s.isUndefined(n[k]) ? void 0 : u(void 0, n[k]) : u(n[k], o[k]);
  }
  function p(k) {
    if (!utils$s.isUndefined(o[k]))
      return u(void 0, o[k]);
  }
  function d(k) {
    return utils$s.isUndefined(o[k]) ? utils$s.isUndefined(n[k]) ? void 0 : u(void 0, n[k]) : u(void 0, o[k]);
  }
  function w(k) {
    return k in o ? u(n[k], o[k]) : k in n ? u(void 0, n[k]) : void 0;
  }
  var S = { url: p, method: p, data: p, baseURL: d, transformRequest: d, transformResponse: d, paramsSerializer: d, timeout: d, timeoutMessage: d, withCredentials: d, adapter: d, responseType: d, xsrfCookieName: d, xsrfHeaderName: d, onUploadProgress: d, onDownloadProgress: d, decompress: d, maxContentLength: d, maxBodyLength: d, beforeRedirect: d, transport: d, httpAgent: d, httpsAgent: d, cancelToken: d, socketPath: d, responseEncoding: d, validateStatus: w };
  return utils$s.forEach(Object.keys(n).concat(Object.keys(o)), function(k) {
    var B = S[k] || c, I = B(k);
    utils$s.isUndefined(I) && B !== w || (a[k] = I);
  }), a;
}, data$1, hasRequiredData;
function requireData() {
  return hasRequiredData ? data$1 : (hasRequiredData = 1, data$1 = { version: "0.27.2" });
}
var VERSION = requireData().version, AxiosError = AxiosError_1, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(n, o) {
  validators$1[n] = function(a) {
    return typeof a === n || "a" + (o < 1 ? "n " : " ") + n;
  };
});
var deprecatedWarnings = {};
function assertOptions(n, o, a) {
  if (typeof n != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  for (var u = Object.keys(n), c = u.length; c-- > 0; ) {
    var p = u[c], d = o[p];
    if (d) {
      var w = n[p], S = w === void 0 || d(w, p, n);
      if (S !== !0)
        throw new AxiosError("option " + p + " must be " + S, AxiosError.ERR_BAD_OPTION_VALUE);
    } else if (a !== !0)
      throw new AxiosError("Unknown option " + p, AxiosError.ERR_BAD_OPTION);
  }
}
validators$1.transitional = function(n, o, a) {
  function u(c, p) {
    return "[Axios v" + VERSION + "] Transitional option '" + c + "'" + p + (a ? ". " + a : "");
  }
  return function(c, p, d) {
    if (n === !1)
      throw new AxiosError(u(p, " has been removed" + (o ? " in " + o : "")), AxiosError.ERR_DEPRECATED);
    return o && !deprecatedWarnings[p] && (deprecatedWarnings[p] = !0, console.warn(u(p, " has been deprecated since v" + o + " and will be removed in the near future"))), !n || n(c, p, d);
  };
};
var validator$1 = { assertOptions, validators: validators$1 }, utils$r = utils$B, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, buildFullPath = buildFullPath$1, validator = validator$1, validators = validator.validators;
function Axios$1(n) {
  this.defaults = n, this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };
}
Axios$1.prototype.request = function(n, o) {
  typeof n == "string" ? (o = o || {}).url = n : o = n || {}, (o = mergeConfig$1(this.defaults, o)).method ? o.method = o.method.toLowerCase() : this.defaults.method ? o.method = this.defaults.method.toLowerCase() : o.method = "get";
  var a = o.transitional;
  a !== void 0 && validator.assertOptions(a, { silentJSONParsing: validators.transitional(validators.boolean), forcedJSONParsing: validators.transitional(validators.boolean), clarifyTimeoutError: validators.transitional(validators.boolean) }, !1);
  var u = [], c = !0;
  this.interceptors.request.forEach(function(I) {
    typeof I.runWhen == "function" && I.runWhen(o) === !1 || (c = c && I.synchronous, u.unshift(I.fulfilled, I.rejected));
  });
  var p, d = [];
  if (this.interceptors.response.forEach(function(I) {
    d.push(I.fulfilled, I.rejected);
  }), !c) {
    var w = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(w, u), w = w.concat(d), p = Promise.resolve(o); w.length; )
      p = p.then(w.shift(), w.shift());
    return p;
  }
  for (var S = o; u.length; ) {
    var k = u.shift(), B = u.shift();
    try {
      S = k(S);
    } catch (I) {
      B(I);
      break;
    }
  }
  try {
    p = dispatchRequest(S);
  } catch (I) {
    return Promise.reject(I);
  }
  for (; d.length; )
    p = p.then(d.shift(), d.shift());
  return p;
}, Axios$1.prototype.getUri = function(n) {
  n = mergeConfig$1(this.defaults, n);
  var o = buildFullPath(n.baseURL, n.url);
  return buildURL(o, n.params, n.paramsSerializer);
}, utils$r.forEach(["delete", "get", "head", "options"], function(n) {
  Axios$1.prototype[n] = function(o, a) {
    return this.request(mergeConfig$1(a || {}, { method: n, url: o, data: (a || {}).data }));
  };
}), utils$r.forEach(["post", "put", "patch"], function(n) {
  function o(a) {
    return function(u, c, p) {
      return this.request(mergeConfig$1(p || {}, { method: n, headers: a ? { "Content-Type": "multipart/form-data" } : {}, url: u, data: c }));
    };
  }
  Axios$1.prototype[n] = o(), Axios$1.prototype[n + "Form"] = o(!0);
});
var Axios_1 = Axios$1, CancelToken_1, hasRequiredCancelToken, spread, hasRequiredSpread, isAxiosError, hasRequiredIsAxiosError;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var n = requireCanceledError();
  function o(a) {
    if (typeof a != "function")
      throw new TypeError("executor must be a function.");
    var u;
    this.promise = new Promise(function(p) {
      u = p;
    });
    var c = this;
    this.promise.then(function(p) {
      if (c._listeners) {
        var d, w = c._listeners.length;
        for (d = 0; d < w; d++)
          c._listeners[d](p);
        c._listeners = null;
      }
    }), this.promise.then = function(p) {
      var d, w = new Promise(function(S) {
        c.subscribe(S), d = S;
      }).then(p);
      return w.cancel = function() {
        c.unsubscribe(d);
      }, w;
    }, a(function(p) {
      c.reason || (c.reason = new n(p), u(c.reason));
    });
  }
  return o.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, o.prototype.subscribe = function(a) {
    this.reason ? a(this.reason) : this._listeners ? this._listeners.push(a) : this._listeners = [a];
  }, o.prototype.unsubscribe = function(a) {
    if (this._listeners) {
      var u = this._listeners.indexOf(a);
      u !== -1 && this._listeners.splice(u, 1);
    }
  }, o.source = function() {
    var a;
    return { token: new o(function(u) {
      a = u;
    }), cancel: a };
  }, CancelToken_1 = o;
}
function requireSpread() {
  return hasRequiredSpread ? spread : (hasRequiredSpread = 1, spread = function(n) {
    return function(o) {
      return n.apply(null, o);
    };
  });
}
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var n = utils$B;
  return isAxiosError = function(o) {
    return n.isObject(o) && o.isAxiosError === !0;
  };
}
var utils$q = utils$B, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(n) {
  var o = new Axios(n), a = bind(Axios.prototype.request, o);
  return utils$q.extend(a, Axios.prototype, o), utils$q.extend(a, o), a.create = function(u) {
    return createInstance(mergeConfig(n, u));
  }, a;
}
var axios = createInstance(defaults);
axios.Axios = Axios, axios.CanceledError = requireCanceledError(), axios.CancelToken = requireCancelToken(), axios.isCancel = requireIsCancel(), axios.VERSION = requireData().version, axios.toFormData = toFormData_1, axios.AxiosError = AxiosError_1, axios.Cancel = axios.CanceledError, axios.all = function(n) {
  return Promise.all(n);
}, axios.spread = requireSpread(), axios.isAxiosError = requireIsAxiosError(), axios$1.exports = axios, axios$1.exports.default = axios, axios$2.exports = axios$1.exports, Object.defineProperty(api$2, "__esModule", { value: !0 });
const axios_1$1 = axios$2.exports;
class Api$1 {
  constructor(o) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(o);
  }
  applyConfig(o) {
    this.config = this.mergeDefaults(o);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(o) {
    const a = o.protocol || "http", u = o.port || (a === "https" ? 443 : 80);
    return { host: o.host || "127.0.0.1", protocol: a, port: u, timeout: o.timeout || 2e4, logging: o.logging || !1, logger: o.logger || console.log, network: o.network };
  }
  async get(o, a) {
    try {
      return await this.request().get(o, a);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(o, a, u) {
    try {
      return await this.request().post(o, a, u);
    } catch (c) {
      if (c.response && c.response.status)
        return c.response;
      throw c;
    }
  }
  request() {
    const o = {};
    this.config.network && (o["x-network"] = this.config.network);
    let a = axios_1$1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: o });
    return this.config.logging && (a.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), a.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), a;
  }
}
api$2.default = Api$1;
var webcryptoDriver = {}, utils$p = {}, base64Js = {};
base64Js.byteLength = byteLength, base64Js.toByteArray = toByteArray, base64Js.fromByteArray = fromByteArray;
for (var lookup$1 = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code$1.length; i < len; ++i)
  lookup$1[i] = code$1[i], revLookup[code$1.charCodeAt(i)] = i;
function getLens(n) {
  var o = n.length;
  if (o % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var a = n.indexOf("=");
  return a === -1 && (a = o), [a, a === o ? 0 : 4 - a % 4];
}
function byteLength(n) {
  var o = getLens(n), a = o[0], u = o[1];
  return 3 * (a + u) / 4 - u;
}
function _byteLength(n, o, a) {
  return 3 * (o + a) / 4 - a;
}
function toByteArray(n) {
  var o, a, u = getLens(n), c = u[0], p = u[1], d = new Arr(_byteLength(n, c, p)), w = 0, S = p > 0 ? c - 4 : c;
  for (a = 0; a < S; a += 4)
    o = revLookup[n.charCodeAt(a)] << 18 | revLookup[n.charCodeAt(a + 1)] << 12 | revLookup[n.charCodeAt(a + 2)] << 6 | revLookup[n.charCodeAt(a + 3)], d[w++] = o >> 16 & 255, d[w++] = o >> 8 & 255, d[w++] = 255 & o;
  return p === 2 && (o = revLookup[n.charCodeAt(a)] << 2 | revLookup[n.charCodeAt(a + 1)] >> 4, d[w++] = 255 & o), p === 1 && (o = revLookup[n.charCodeAt(a)] << 10 | revLookup[n.charCodeAt(a + 1)] << 4 | revLookup[n.charCodeAt(a + 2)] >> 2, d[w++] = o >> 8 & 255, d[w++] = 255 & o), d;
}
function tripletToBase64(n) {
  return lookup$1[n >> 18 & 63] + lookup$1[n >> 12 & 63] + lookup$1[n >> 6 & 63] + lookup$1[63 & n];
}
function encodeChunk(n, o, a) {
  for (var u, c = [], p = o; p < a; p += 3)
    u = (n[p] << 16 & 16711680) + (n[p + 1] << 8 & 65280) + (255 & n[p + 2]), c.push(tripletToBase64(u));
  return c.join("");
}
function fromByteArray(n) {
  for (var o, a = n.length, u = a % 3, c = [], p = 16383, d = 0, w = a - u; d < w; d += p)
    c.push(encodeChunk(n, d, d + p > w ? w : d + p));
  return u === 1 ? (o = n[a - 1], c.push(lookup$1[o >> 2] + lookup$1[o << 4 & 63] + "==")) : u === 2 && (o = (n[a - 2] << 8) + n[a - 1], c.push(lookup$1[o >> 10] + lookup$1[o >> 4 & 63] + lookup$1[o << 2 & 63] + "=")), c.join("");
}
revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
var util = {}, types = {}, shams$1, hasRequiredShams$1, shams, hasRequiredShams, hasSymbols, hasRequiredHasSymbols, implementation, hasRequiredImplementation, functionBind, hasRequiredFunctionBind, src, hasRequiredSrc, getIntrinsic, hasRequiredGetIntrinsic;
function requireShams$1() {
  return hasRequiredShams$1 ? shams$1 : (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var n = {}, o = Symbol("test"), a = Object(o);
    if (typeof o == "string" || Object.prototype.toString.call(o) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
      return !1;
    for (o in n[o] = 42, n)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(n).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(n).length !== 0)
      return !1;
    var u = Object.getOwnPropertySymbols(n);
    if (u.length !== 1 || u[0] !== o || !Object.prototype.propertyIsEnumerable.call(n, o))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = Object.getOwnPropertyDescriptor(n, o);
      if (c.value !== 42 || c.enumerable !== !0)
        return !1;
    }
    return !0;
  });
}
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var n = requireShams$1();
  return shams = function() {
    return n() && !!Symbol.toStringTag;
  };
}
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var n = typeof Symbol < "u" && Symbol, o = requireShams$1();
  return hasSymbols = function() {
    return typeof n == "function" && typeof Symbol == "function" && typeof n("foo") == "symbol" && typeof Symbol("bar") == "symbol" && o();
  };
}
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var n = "Function.prototype.bind called on incompatible ", o = Array.prototype.slice, a = Object.prototype.toString, u = "[object Function]";
  return implementation = function(c) {
    var p = this;
    if (typeof p != "function" || a.call(p) !== u)
      throw new TypeError(n + p);
    for (var d, w = o.call(arguments, 1), S = function() {
      if (this instanceof d) {
        var P = p.apply(this, w.concat(o.call(arguments)));
        return Object(P) === P ? P : this;
      }
      return p.apply(c, w.concat(o.call(arguments)));
    }, k = Math.max(0, p.length - w.length), B = [], I = 0; I < k; I++)
      B.push("$" + I);
    if (d = Function("binder", "return function (" + B.join(",") + "){ return binder.apply(this,arguments); }")(S), p.prototype) {
      var C = function() {
      };
      C.prototype = p.prototype, d.prototype = new C(), C.prototype = null;
    }
    return d;
  }, implementation;
}
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var n = requireImplementation();
  return functionBind = Function.prototype.bind || n;
}
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var n = requireFunctionBind();
  return src = n.call(Function.call, Object.prototype.hasOwnProperty);
}
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  var n;
  hasRequiredGetIntrinsic = 1;
  var o = SyntaxError, a = Function, u = TypeError, c = function(_) {
    try {
      return a('"use strict"; return (' + _ + ").constructor;")();
    } catch {
    }
  }, p = Object.getOwnPropertyDescriptor;
  if (p)
    try {
      p({}, "");
    } catch {
      p = null;
    }
  var d = function() {
    throw new u();
  }, w = p ? function() {
    try {
      return d;
    } catch {
      try {
        return p(arguments, "callee").get;
      } catch {
        return d;
      }
    }
  }() : d, S = requireHasSymbols()(), k = Object.getPrototypeOf || function(_) {
    return _.__proto__;
  }, B = {}, I = typeof Uint8Array > "u" ? n : k(Uint8Array), C = { "%AggregateError%": typeof AggregateError > "u" ? n : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? n : ArrayBuffer, "%ArrayIteratorPrototype%": S ? k([][Symbol.iterator]()) : n, "%AsyncFromSyncIteratorPrototype%": n, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? n : Atomics, "%BigInt%": typeof BigInt > "u" ? n : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? n : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? n : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? n : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? n : FinalizationRegistry, "%Function%": a, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? n : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? n : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? n : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": S ? k(k([][Symbol.iterator]())) : n, "%JSON%": typeof JSON == "object" ? JSON : n, "%Map%": typeof Map > "u" ? n : Map, "%MapIteratorPrototype%": typeof Map < "u" && S ? k((/* @__PURE__ */ new Map())[Symbol.iterator]()) : n, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? n : Promise, "%Proxy%": typeof Proxy > "u" ? n : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? n : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? n : Set, "%SetIteratorPrototype%": typeof Set < "u" && S ? k((/* @__PURE__ */ new Set())[Symbol.iterator]()) : n, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? n : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": S ? k(""[Symbol.iterator]()) : n, "%Symbol%": S ? Symbol : n, "%SyntaxError%": o, "%ThrowTypeError%": w, "%TypedArray%": I, "%TypeError%": u, "%Uint8Array%": typeof Uint8Array > "u" ? n : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? n : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? n : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? n : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? n : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? n : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? n : WeakSet }, P = function _(b) {
    var m;
    if (b === "%AsyncFunction%")
      m = c("async function () {}");
    else if (b === "%GeneratorFunction%")
      m = c("function* () {}");
    else if (b === "%AsyncGeneratorFunction%")
      m = c("async function* () {}");
    else if (b === "%AsyncGenerator%") {
      var v = _("%AsyncGeneratorFunction%");
      v && (m = v.prototype);
    } else if (b === "%AsyncIteratorPrototype%") {
      var E = _("%AsyncGenerator%");
      E && (m = k(E.prototype));
    }
    return C[b] = m, m;
  }, q = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, D = requireFunctionBind(), z = requireSrc(), F = D.call(Function.call, Array.prototype.concat), V = D.call(Function.apply, Array.prototype.splice), Z = D.call(Function.call, String.prototype.replace), N = D.call(Function.call, String.prototype.slice), W = D.call(Function.call, RegExp.prototype.exec), H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, te = /\\(\\)?/g, g = function(_) {
    var b = N(_, 0, 1), m = N(_, -1);
    if (b === "%" && m !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (m === "%" && b !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var v = [];
    return Z(_, H, function(E, T, j, L) {
      v[v.length] = j ? Z(L, te, "$1") : T || E;
    }), v;
  }, $ = function(_, b) {
    var m, v = _;
    if (z(q, v) && (v = "%" + (m = q[v])[0] + "%"), z(C, v)) {
      var E = C[v];
      if (E === B && (E = P(v)), E === void 0 && !b)
        throw new u("intrinsic " + _ + " exists, but is not available. Please file an issue!");
      return { alias: m, name: v, value: E };
    }
    throw new o("intrinsic " + _ + " does not exist!");
  };
  return getIntrinsic = function(_, b) {
    if (typeof _ != "string" || _.length === 0)
      throw new u("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof b != "boolean")
      throw new u('"allowMissing" argument must be a boolean');
    if (W(/^%?[^%]*%?$/, _) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var m = g(_), v = m.length > 0 ? m[0] : "", E = $("%" + v + "%", b), T = E.name, j = E.value, L = !1, J = E.alias;
    J && (v = J[0], V(m, F([0, 1], J)));
    for (var Y = 1, ne = !0; Y < m.length; Y += 1) {
      var Q = m[Y], oe = N(Q, 0, 1), ae = N(Q, -1);
      if ((oe === '"' || oe === "'" || oe === "`" || ae === '"' || ae === "'" || ae === "`") && oe !== ae)
        throw new o("property names with quotes must have matching quotes");
      if (Q !== "constructor" && ne || (L = !0), z(C, T = "%" + (v += "." + Q) + "%"))
        j = C[T];
      else if (j != null) {
        if (!(Q in j)) {
          if (!b)
            throw new u("base intrinsic for " + _ + " exists, but the property is not available.");
          return;
        }
        if (p && Y + 1 >= m.length) {
          var ce = p(j, Q);
          j = (ne = !!ce) && "get" in ce && !("originalValue" in ce.get) ? ce.get : j[Q];
        } else
          ne = z(j, Q), j = j[Q];
        ne && !L && (C[T] = j);
      }
    }
    return j;
  }, getIntrinsic;
}
var callBind = { exports: {} }, hasRequiredCallBind, callBound, hasRequiredCallBound, isArguments$2, hasRequiredIsArguments, isGeneratorFunction, hasRequiredIsGeneratorFunction, isCallable, hasRequiredIsCallable, forEach_1, hasRequiredForEach, availableTypedArrays, hasRequiredAvailableTypedArrays, getOwnPropertyDescriptor, hasRequiredGetOwnPropertyDescriptor, isTypedArray$2, hasRequiredIsTypedArray, whichTypedArray, hasRequiredWhichTypedArray, hasRequiredTypes, isBufferBrowser, hasRequiredIsBufferBrowser;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(n) {
    var o = requireFunctionBind(), a = requireGetIntrinsic(), u = a("%Function.prototype.apply%"), c = a("%Function.prototype.call%"), p = a("%Reflect.apply%", !0) || o.call(c, u), d = a("%Object.getOwnPropertyDescriptor%", !0), w = a("%Object.defineProperty%", !0), S = a("%Math.max%");
    if (w)
      try {
        w({}, "a", { value: 1 });
      } catch {
        w = null;
      }
    n.exports = function(B) {
      var I = p(o, c, arguments);
      if (d && w) {
        var C = d(I, "length");
        C.configurable && w(I, "length", { value: 1 + S(0, B.length - (arguments.length - 1)) });
      }
      return I;
    };
    var k = function() {
      return p(o, u, arguments);
    };
    w ? w(n.exports, "apply", { value: k }) : n.exports.apply = k;
  }(callBind)), callBind.exports;
}
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var n = requireGetIntrinsic(), o = requireCallBind(), a = o(n("String.prototype.indexOf"));
  return callBound = function(u, c) {
    var p = n(u, !!c);
    return typeof p == "function" && a(u, ".prototype.") > -1 ? o(p) : p;
  }, callBound;
}
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments$2;
  hasRequiredIsArguments = 1;
  var n = requireShams()(), o = requireCallBound()("Object.prototype.toString"), a = function(p) {
    return !(n && p && typeof p == "object" && Symbol.toStringTag in p) && o(p) === "[object Arguments]";
  }, u = function(p) {
    return !!a(p) || p !== null && typeof p == "object" && typeof p.length == "number" && p.length >= 0 && o(p) !== "[object Array]" && o(p.callee) === "[object Function]";
  }, c = function() {
    return a(arguments);
  }();
  return a.isLegacyArguments = u, isArguments$2 = c ? a : u;
}
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var n, o = Object.prototype.toString, a = Function.prototype.toString, u = /^\s*(?:function)?\*/, c = requireShams()(), p = Object.getPrototypeOf;
  return isGeneratorFunction = function(d) {
    if (typeof d != "function")
      return !1;
    if (u.test(a.call(d)))
      return !0;
    if (!c)
      return o.call(d) === "[object GeneratorFunction]";
    if (!p)
      return !1;
    if (n === void 0) {
      var w = function() {
        if (!c)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }();
      n = !!w && p(w);
    }
    return p(d) === n;
  };
}
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var n, o, a = Function.prototype.toString, u = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
  if (typeof u == "function" && typeof Object.defineProperty == "function")
    try {
      n = Object.defineProperty({}, "length", { get: function() {
        throw o;
      } }), o = {}, u(function() {
        throw 42;
      }, null, n);
    } catch (C) {
      C !== o && (u = null);
    }
  else
    u = null;
  var c = /^\s*class\b/, p = function(C) {
    try {
      var P = a.call(C);
      return c.test(P);
    } catch {
      return !1;
    }
  }, d = function(C) {
    try {
      return !p(C) && (a.call(C), !0);
    } catch {
      return !1;
    }
  }, w = Object.prototype.toString, S = typeof Symbol == "function" && !!Symbol.toStringTag, k = !(0 in [,]), B = function() {
    return !1;
  };
  if (typeof document == "object") {
    var I = document.all;
    w.call(I) === w.call(document.all) && (B = function(C) {
      if ((k || !C) && (C === void 0 || typeof C == "object"))
        try {
          var P = w.call(C);
          return (P === "[object HTMLAllCollection]" || P === "[object HTML document.all class]" || P === "[object HTMLCollection]" || P === "[object Object]") && C("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = u ? function(C) {
    if (B(C))
      return !0;
    if (!C || typeof C != "function" && typeof C != "object")
      return !1;
    try {
      u(C, null, n);
    } catch (P) {
      if (P !== o)
        return !1;
    }
    return !p(C) && d(C);
  } : function(C) {
    if (B(C))
      return !0;
    if (!C || typeof C != "function" && typeof C != "object")
      return !1;
    if (S)
      return d(C);
    if (p(C))
      return !1;
    var P = w.call(C);
    return !(P !== "[object Function]" && P !== "[object GeneratorFunction]" && !/^\[object HTML/.test(P)) && d(C);
  };
}
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var n = requireIsCallable(), o = Object.prototype.toString, a = Object.prototype.hasOwnProperty, u = function(d, w, S) {
    for (var k = 0, B = d.length; k < B; k++)
      a.call(d, k) && (S == null ? w(d[k], k, d) : w.call(S, d[k], k, d));
  }, c = function(d, w, S) {
    for (var k = 0, B = d.length; k < B; k++)
      S == null ? w(d.charAt(k), k, d) : w.call(S, d.charAt(k), k, d);
  }, p = function(d, w, S) {
    for (var k in d)
      a.call(d, k) && (S == null ? w(d[k], k, d) : w.call(S, d[k], k, d));
  };
  return forEach_1 = function(d, w, S) {
    if (!n(w))
      throw new TypeError("iterator must be a function");
    var k;
    arguments.length >= 3 && (k = S), o.call(d) === "[object Array]" ? u(d, w, k) : typeof d == "string" ? c(d, w, k) : p(d, w, k);
  }, forEach_1;
}
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var n = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], o = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var a = [], u = 0; u < n.length; u++)
      typeof o[n[u]] == "function" && (a[a.length] = n[u]);
    return a;
  }, availableTypedArrays;
}
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var n = requireGetIntrinsic()("%Object.getOwnPropertyDescriptor%", !0);
  if (n)
    try {
      n([], "length");
    } catch {
      n = null;
    }
  return getOwnPropertyDescriptor = n;
}
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$2;
  hasRequiredIsTypedArray = 1;
  var n = requireForEach(), o = requireAvailableTypedArrays(), a = requireCallBound(), u = a("Object.prototype.toString"), c = requireShams()(), p = typeof globalThis > "u" ? commonjsGlobal : globalThis, d = o(), w = a("Array.prototype.indexOf", !0) || function(C, P) {
    for (var q = 0; q < C.length; q += 1)
      if (C[q] === P)
        return q;
    return -1;
  }, S = a("String.prototype.slice"), k = {}, B = requireGetOwnPropertyDescriptor(), I = Object.getPrototypeOf;
  return c && B && I && n(d, function(C) {
    var P = new p[C]();
    if (Symbol.toStringTag in P) {
      var q = I(P), D = B(q, Symbol.toStringTag);
      if (!D) {
        var z = I(q);
        D = B(z, Symbol.toStringTag);
      }
      k[C] = D.get;
    }
  }), isTypedArray$2 = function(C) {
    if (!C || typeof C != "object")
      return !1;
    if (!c || !(Symbol.toStringTag in C)) {
      var P = S(u(C), 8, -1);
      return w(d, P) > -1;
    }
    return !!B && function(q) {
      var D = !1;
      return n(k, function(z, F) {
        if (!D)
          try {
            D = z.call(q) === F;
          } catch {
          }
      }), D;
    }(C);
  };
}
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var n = requireForEach(), o = requireAvailableTypedArrays(), a = requireCallBound(), u = a("Object.prototype.toString"), c = requireShams()(), p = typeof globalThis > "u" ? commonjsGlobal : globalThis, d = o(), w = a("String.prototype.slice"), S = {}, k = requireGetOwnPropertyDescriptor(), B = Object.getPrototypeOf;
  c && k && B && n(d, function(C) {
    if (typeof p[C] == "function") {
      var P = new p[C]();
      if (Symbol.toStringTag in P) {
        var q = B(P), D = k(q, Symbol.toStringTag);
        if (!D) {
          var z = B(q);
          D = k(z, Symbol.toStringTag);
        }
        S[C] = D.get;
      }
    }
  });
  var I = requireIsTypedArray();
  return whichTypedArray = function(C) {
    return !!I(C) && (c && Symbol.toStringTag in C ? function(P) {
      var q = !1;
      return n(S, function(D, z) {
        if (!q)
          try {
            var F = D.call(P);
            F === z && (q = F);
          } catch {
          }
      }), q;
    }(C) : w(u(C), 8, -1));
  }, whichTypedArray;
}
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(n) {
    var o = requireIsArguments(), a = requireIsGeneratorFunction(), u = requireWhichTypedArray(), c = requireIsTypedArray();
    function p(T) {
      return T.call.bind(T);
    }
    var d = typeof BigInt < "u", w = typeof Symbol < "u", S = p(Object.prototype.toString), k = p(Number.prototype.valueOf), B = p(String.prototype.valueOf), I = p(Boolean.prototype.valueOf);
    if (d)
      var C = p(BigInt.prototype.valueOf);
    if (w)
      var P = p(Symbol.prototype.valueOf);
    function q(T, j) {
      if (typeof T != "object")
        return !1;
      try {
        return j(T), !0;
      } catch {
        return !1;
      }
    }
    function D(T) {
      return S(T) === "[object Map]";
    }
    function z(T) {
      return S(T) === "[object Set]";
    }
    function F(T) {
      return S(T) === "[object WeakMap]";
    }
    function V(T) {
      return S(T) === "[object WeakSet]";
    }
    function Z(T) {
      return S(T) === "[object ArrayBuffer]";
    }
    function N(T) {
      return typeof ArrayBuffer < "u" && (Z.working ? Z(T) : T instanceof ArrayBuffer);
    }
    function W(T) {
      return S(T) === "[object DataView]";
    }
    function H(T) {
      return typeof DataView < "u" && (W.working ? W(T) : T instanceof DataView);
    }
    n.isArgumentsObject = o, n.isGeneratorFunction = a, n.isTypedArray = c, n.isPromise = function(T) {
      return typeof Promise < "u" && T instanceof Promise || T !== null && typeof T == "object" && typeof T.then == "function" && typeof T.catch == "function";
    }, n.isArrayBufferView = function(T) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(T) : c(T) || H(T);
    }, n.isUint8Array = function(T) {
      return u(T) === "Uint8Array";
    }, n.isUint8ClampedArray = function(T) {
      return u(T) === "Uint8ClampedArray";
    }, n.isUint16Array = function(T) {
      return u(T) === "Uint16Array";
    }, n.isUint32Array = function(T) {
      return u(T) === "Uint32Array";
    }, n.isInt8Array = function(T) {
      return u(T) === "Int8Array";
    }, n.isInt16Array = function(T) {
      return u(T) === "Int16Array";
    }, n.isInt32Array = function(T) {
      return u(T) === "Int32Array";
    }, n.isFloat32Array = function(T) {
      return u(T) === "Float32Array";
    }, n.isFloat64Array = function(T) {
      return u(T) === "Float64Array";
    }, n.isBigInt64Array = function(T) {
      return u(T) === "BigInt64Array";
    }, n.isBigUint64Array = function(T) {
      return u(T) === "BigUint64Array";
    }, D.working = typeof Map < "u" && D(/* @__PURE__ */ new Map()), n.isMap = function(T) {
      return typeof Map < "u" && (D.working ? D(T) : T instanceof Map);
    }, z.working = typeof Set < "u" && z(/* @__PURE__ */ new Set()), n.isSet = function(T) {
      return typeof Set < "u" && (z.working ? z(T) : T instanceof Set);
    }, F.working = typeof WeakMap < "u" && F(/* @__PURE__ */ new WeakMap()), n.isWeakMap = function(T) {
      return typeof WeakMap < "u" && (F.working ? F(T) : T instanceof WeakMap);
    }, V.working = typeof WeakSet < "u" && V(/* @__PURE__ */ new WeakSet()), n.isWeakSet = function(T) {
      return V(T);
    }, Z.working = typeof ArrayBuffer < "u" && Z(new ArrayBuffer()), n.isArrayBuffer = N, W.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && W(new DataView(new ArrayBuffer(1), 0, 1)), n.isDataView = H;
    var te = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function g(T) {
      return S(T) === "[object SharedArrayBuffer]";
    }
    function $(T) {
      return te !== void 0 && (g.working === void 0 && (g.working = g(new te())), g.working ? g(T) : T instanceof te);
    }
    function _(T) {
      return q(T, k);
    }
    function b(T) {
      return q(T, B);
    }
    function m(T) {
      return q(T, I);
    }
    function v(T) {
      return d && q(T, C);
    }
    function E(T) {
      return w && q(T, P);
    }
    n.isSharedArrayBuffer = $, n.isAsyncFunction = function(T) {
      return S(T) === "[object AsyncFunction]";
    }, n.isMapIterator = function(T) {
      return S(T) === "[object Map Iterator]";
    }, n.isSetIterator = function(T) {
      return S(T) === "[object Set Iterator]";
    }, n.isGeneratorObject = function(T) {
      return S(T) === "[object Generator]";
    }, n.isWebAssemblyCompiledModule = function(T) {
      return S(T) === "[object WebAssembly.Module]";
    }, n.isNumberObject = _, n.isStringObject = b, n.isBooleanObject = m, n.isBigIntObject = v, n.isSymbolObject = E, n.isBoxedPrimitive = function(T) {
      return _(T) || b(T) || m(T) || v(T) || E(T);
    }, n.isAnyArrayBuffer = function(T) {
      return typeof Uint8Array < "u" && (N(T) || $(T));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(T) {
      Object.defineProperty(n, T, { enumerable: !1, value: function() {
        throw new Error(T + " is not supported in userland");
      } });
    });
  }(types)), types;
}
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser ? isBufferBrowser : (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(n) {
    return n && typeof n == "object" && typeof n.copy == "function" && typeof n.fill == "function" && typeof n.readUInt8 == "function";
  });
}
var inherits_browser = { exports: {} }, hasRequiredUtil;
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, function(n) {
    var o = Object.getOwnPropertyDescriptors || function(E) {
      for (var T = Object.keys(E), j = {}, L = 0; L < T.length; L++)
        j[T[L]] = Object.getOwnPropertyDescriptor(E, T[L]);
      return j;
    }, a = /%[sdj%]/g;
    n.format = function(E) {
      if (!z(E)) {
        for (var T = [], j = 0; j < arguments.length; j++)
          T.push(d(arguments[j]));
        return T.join(" ");
      }
      j = 1;
      for (var L = arguments, J = L.length, Y = String(E).replace(a, function(Q) {
        if (Q === "%%")
          return "%";
        if (j >= J)
          return Q;
        switch (Q) {
          case "%s":
            return String(L[j++]);
          case "%d":
            return Number(L[j++]);
          case "%j":
            try {
              return JSON.stringify(L[j++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Q;
        }
      }), ne = L[j]; j < J; ne = L[++j])
        q(ne) || !Z(ne) ? Y += " " + ne : Y += " " + d(ne);
      return Y;
    }, n.deprecate = function(E, T) {
      if (typeof process < "u" && process.noDeprecation === !0)
        return E;
      if (typeof process > "u")
        return function() {
          return n.deprecate(E, T).apply(this, arguments);
        };
      var j = !1;
      return function() {
        if (!j) {
          if (process.throwDeprecation)
            throw new Error(T);
          process.traceDeprecation ? console.trace(T) : console.error(T), j = !0;
        }
        return E.apply(this, arguments);
      };
    };
    var u = {}, c = /^$/;
    if (process.env.NODE_DEBUG) {
      var p = process.env.NODE_DEBUG;
      p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), c = new RegExp("^" + p + "$", "i");
    }
    function d(E, T) {
      var j = { seen: [], stylize: S };
      return arguments.length >= 3 && (j.depth = arguments[2]), arguments.length >= 4 && (j.colors = arguments[3]), P(T) ? j.showHidden = T : T && n._extend(j, T), F(j.showHidden) && (j.showHidden = !1), F(j.depth) && (j.depth = 2), F(j.colors) && (j.colors = !1), F(j.customInspect) && (j.customInspect = !0), j.colors && (j.stylize = w), k(j, E, j.depth);
    }
    function w(E, T) {
      var j = d.styles[T];
      return j ? "\x1B[" + d.colors[j][0] + "m" + E + "\x1B[" + d.colors[j][1] + "m" : E;
    }
    function S(E, T) {
      return E;
    }
    function k(E, T, j) {
      if (E.customInspect && T && H(T.inspect) && T.inspect !== n.inspect && (!T.constructor || T.constructor.prototype !== T)) {
        var L = T.inspect(j, E);
        return z(L) || (L = k(E, L, j)), L;
      }
      var J = function(le, Se) {
        if (F(Se))
          return le.stylize("undefined", "undefined");
        if (z(Se)) {
          var he = "'" + JSON.stringify(Se).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return le.stylize(he, "string");
        }
        return D(Se) ? le.stylize("" + Se, "number") : P(Se) ? le.stylize("" + Se, "boolean") : q(Se) ? le.stylize("null", "null") : void 0;
      }(E, T);
      if (J)
        return J;
      var Y = Object.keys(T), ne = function(le) {
        var Se = {};
        return le.forEach(function(he, _e) {
          Se[he] = !0;
        }), Se;
      }(Y);
      if (E.showHidden && (Y = Object.getOwnPropertyNames(T)), W(T) && (Y.indexOf("message") >= 0 || Y.indexOf("description") >= 0))
        return B(T);
      if (Y.length === 0) {
        if (H(T)) {
          var Q = T.name ? ": " + T.name : "";
          return E.stylize("[Function" + Q + "]", "special");
        }
        if (V(T))
          return E.stylize(RegExp.prototype.toString.call(T), "regexp");
        if (N(T))
          return E.stylize(Date.prototype.toString.call(T), "date");
        if (W(T))
          return B(T);
      }
      var oe, ae = "", ce = !1, ue = ["{", "}"];
      return C(T) && (ce = !0, ue = ["[", "]"]), H(T) && (ae = " [Function" + (T.name ? ": " + T.name : "") + "]"), V(T) && (ae = " " + RegExp.prototype.toString.call(T)), N(T) && (ae = " " + Date.prototype.toUTCString.call(T)), W(T) && (ae = " " + B(T)), Y.length !== 0 || ce && T.length != 0 ? j < 0 ? V(T) ? E.stylize(RegExp.prototype.toString.call(T), "regexp") : E.stylize("[Object]", "special") : (E.seen.push(T), oe = ce ? function(le, Se, he, _e, Le) {
        for (var se = [], we = 0, We = Se.length; we < We; ++we)
          b(Se, String(we)) ? se.push(I(le, Se, he, _e, String(we), !0)) : se.push("");
        return Le.forEach(function(de) {
          de.match(/^\d+$/) || se.push(I(le, Se, he, _e, de, !0));
        }), se;
      }(E, T, j, ne, Y) : Y.map(function(le) {
        return I(E, T, j, ne, le, ce);
      }), E.seen.pop(), function(le, Se, he) {
        return le.reduce(function(_e, Le) {
          return Le.indexOf(`
`), _e + Le.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? he[0] + (Se === "" ? "" : Se + `
 `) + " " + le.join(`,
  `) + " " + he[1] : he[0] + Se + " " + le.join(", ") + " " + he[1];
      }(oe, ae, ue)) : ue[0] + ae + ue[1];
    }
    function B(E) {
      return "[" + Error.prototype.toString.call(E) + "]";
    }
    function I(E, T, j, L, J, Y) {
      var ne, Q, oe;
      if ((oe = Object.getOwnPropertyDescriptor(T, J) || { value: T[J] }).get ? Q = oe.set ? E.stylize("[Getter/Setter]", "special") : E.stylize("[Getter]", "special") : oe.set && (Q = E.stylize("[Setter]", "special")), b(L, J) || (ne = "[" + J + "]"), Q || (E.seen.indexOf(oe.value) < 0 ? (Q = q(j) ? k(E, oe.value, null) : k(E, oe.value, j - 1)).indexOf(`
`) > -1 && (Q = Y ? Q.split(`
`).map(function(ae) {
        return "  " + ae;
      }).join(`
`).substr(2) : `
` + Q.split(`
`).map(function(ae) {
        return "   " + ae;
      }).join(`
`)) : Q = E.stylize("[Circular]", "special")), F(ne)) {
        if (Y && J.match(/^\d+$/))
          return Q;
        (ne = JSON.stringify("" + J)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ne = ne.substr(1, ne.length - 2), ne = E.stylize(ne, "name")) : (ne = ne.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ne = E.stylize(ne, "string"));
      }
      return ne + ": " + Q;
    }
    function C(E) {
      return Array.isArray(E);
    }
    function P(E) {
      return typeof E == "boolean";
    }
    function q(E) {
      return E === null;
    }
    function D(E) {
      return typeof E == "number";
    }
    function z(E) {
      return typeof E == "string";
    }
    function F(E) {
      return E === void 0;
    }
    function V(E) {
      return Z(E) && te(E) === "[object RegExp]";
    }
    function Z(E) {
      return typeof E == "object" && E !== null;
    }
    function N(E) {
      return Z(E) && te(E) === "[object Date]";
    }
    function W(E) {
      return Z(E) && (te(E) === "[object Error]" || E instanceof Error);
    }
    function H(E) {
      return typeof E == "function";
    }
    function te(E) {
      return Object.prototype.toString.call(E);
    }
    function g(E) {
      return E < 10 ? "0" + E.toString(10) : E.toString(10);
    }
    n.debuglog = function(E) {
      if (E = E.toUpperCase(), !u[E])
        if (c.test(E)) {
          var T = process.pid;
          u[E] = function() {
            var j = n.format.apply(n, arguments);
            console.error("%s %d: %s", E, T, j);
          };
        } else
          u[E] = function() {
          };
      return u[E];
    }, n.inspect = d, d.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, d.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, n.types = requireTypes(), n.isArray = C, n.isBoolean = P, n.isNull = q, n.isNullOrUndefined = function(E) {
      return E == null;
    }, n.isNumber = D, n.isString = z, n.isSymbol = function(E) {
      return typeof E == "symbol";
    }, n.isUndefined = F, n.isRegExp = V, n.types.isRegExp = V, n.isObject = Z, n.isDate = N, n.types.isDate = N, n.isError = W, n.types.isNativeError = W, n.isFunction = H, n.isPrimitive = function(E) {
      return E === null || typeof E == "boolean" || typeof E == "number" || typeof E == "string" || typeof E == "symbol" || E === void 0;
    }, n.isBuffer = requireIsBufferBrowser();
    var $ = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function _() {
      var E = new Date(), T = [g(E.getHours()), g(E.getMinutes()), g(E.getSeconds())].join(":");
      return [E.getDate(), $[E.getMonth()], T].join(" ");
    }
    function b(E, T) {
      return Object.prototype.hasOwnProperty.call(E, T);
    }
    n.log = function() {
      console.log("%s - %s", _(), n.format.apply(n, arguments));
    }, n.inherits = inherits_browser.exports, n._extend = function(E, T) {
      if (!T || !Z(T))
        return E;
      for (var j = Object.keys(T), L = j.length; L--; )
        E[j[L]] = T[j[L]];
      return E;
    };
    var m = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    function v(E, T) {
      if (!E) {
        var j = new Error("Promise was rejected with a falsy value");
        j.reason = E, E = j;
      }
      return T(E);
    }
    n.promisify = function(E) {
      if (typeof E != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (m && E[m]) {
        var T;
        if (typeof (T = E[m]) != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(T, m, { value: T, enumerable: !1, writable: !1, configurable: !0 }), T;
      }
      function T() {
        for (var j, L, J = new Promise(function(Q, oe) {
          j = Q, L = oe;
        }), Y = [], ne = 0; ne < arguments.length; ne++)
          Y.push(arguments[ne]);
        Y.push(function(Q, oe) {
          Q ? L(Q) : j(oe);
        });
        try {
          E.apply(this, Y);
        } catch (Q) {
          L(Q);
        }
        return J;
      }
      return Object.setPrototypeOf(T, Object.getPrototypeOf(E)), m && Object.defineProperty(T, m, { value: T, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(T, o(E));
    }, n.promisify.custom = m, n.callbackify = function(E) {
      if (typeof E != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function T() {
        for (var j = [], L = 0; L < arguments.length; L++)
          j.push(arguments[L]);
        var J = j.pop();
        if (typeof J != "function")
          throw new TypeError("The last argument must be of type Function");
        var Y = this, ne = function() {
          return J.apply(Y, arguments);
        };
        E.apply(this, j).then(function(Q) {
          process.nextTick(ne.bind(null, null, Q));
        }, function(Q) {
          process.nextTick(v.bind(null, Q, ne));
        });
      }
      return Object.setPrototypeOf(T, Object.getPrototypeOf(E)), Object.defineProperties(T, o(E)), T;
    };
  }(util)), util;
}
typeof Object.create == "function" ? inherits_browser.exports = function(n, o) {
  o && (n.super_ = o, n.prototype = Object.create(o.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }));
} : inherits_browser.exports = function(n, o) {
  if (o) {
    n.super_ = o;
    var a = function() {
    };
    a.prototype = o.prototype, n.prototype = new a(), n.prototype.constructor = n;
  }
}, Object.defineProperty(utils$p, "__esModule", { value: !0 }), utils$p.b64UrlDecode = utils$p.b64UrlEncode = utils$p.bufferTob64Url = utils$p.bufferTob64 = utils$p.b64UrlToBuffer = utils$p.stringToB64Url = utils$p.stringToBuffer = utils$p.bufferToString = utils$p.b64UrlToString = utils$p.concatBuffers = void 0;
const B64js$1 = base64Js;
function concatBuffers$1(n) {
  let o = 0;
  for (let c = 0; c < n.length; c++)
    o += n[c].byteLength;
  let a = new Uint8Array(o), u = 0;
  a.set(new Uint8Array(n[0]), u), u += n[0].byteLength;
  for (let c = 1; c < n.length; c++)
    a.set(new Uint8Array(n[c]), u), u += n[c].byteLength;
  return a;
}
function b64UrlToString$1(n) {
  return bufferToString$1(b64UrlToBuffer$1(n));
}
function bufferToString$1(n) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(n) : new TextDecoder("utf-8", { fatal: !0 }).decode(n);
}
function stringToBuffer$1(n) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(n) : new TextEncoder().encode(n);
}
function stringToB64Url$1(n) {
  return bufferTob64Url$1(stringToBuffer$1(n));
}
function b64UrlToBuffer$1(n) {
  return new Uint8Array(B64js$1.toByteArray(b64UrlDecode$1(n)));
}
function bufferTob64$1(n) {
  return B64js$1.fromByteArray(new Uint8Array(n));
}
function bufferTob64Url$1(n) {
  return b64UrlEncode$1(bufferTob64$1(n));
}
function b64UrlEncode$1(n) {
  return n.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode$1(n) {
  let o;
  return o = (n = n.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - n.length % 4, n.concat("=".repeat(o));
}
utils$p.concatBuffers = concatBuffers$1, utils$p.b64UrlToString = b64UrlToString$1, utils$p.bufferToString = bufferToString$1, utils$p.stringToBuffer = stringToBuffer$1, utils$p.stringToB64Url = stringToB64Url$1, utils$p.b64UrlToBuffer = b64UrlToBuffer$1, utils$p.bufferTob64 = bufferTob64$1, utils$p.bufferTob64Url = bufferTob64Url$1, utils$p.b64UrlEncode = b64UrlEncode$1, utils$p.b64UrlDecode = b64UrlDecode$1, Object.defineProperty(webcryptoDriver, "__esModule", { value: !0 });
const ArweaveUtils$6 = utils$p;
class WebCryptoDriver {
  constructor() {
    if (this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", !this.detectWebCrypto())
      throw new Error("SubtleCrypto not available!");
    this.driver = crypto.subtle;
  }
  async generateJWK() {
    let o = await this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, !0, ["sign"]), a = await this.driver.exportKey("jwk", o.privateKey);
    return { kty: a.kty, e: a.e, n: a.n, d: a.d, p: a.p, q: a.q, dp: a.dp, dq: a.dq, qi: a.qi };
  }
  async sign(o, a, { saltLength: u } = {}) {
    let c = await this.driver.sign({ name: "RSA-PSS", saltLength: 32 }, await this.jwkToCryptoKey(o), a);
    return new Uint8Array(c);
  }
  async hash(o, a = "SHA-256") {
    let u = await this.driver.digest(a, o);
    return new Uint8Array(u);
  }
  async verify(o, a, u) {
    const c = { kty: "RSA", e: "AQAB", n: o }, p = await this.jwkToPublicCryptoKey(c), d = this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, p, u, a), w = this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, p, u, a);
    return d || w;
  }
  async jwkToCryptoKey(o) {
    return this.driver.importKey("jwk", o, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["sign"]);
  }
  async jwkToPublicCryptoKey(o) {
    return this.driver.importKey("jwk", o, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["verify"]);
  }
  detectWebCrypto() {
    if (typeof crypto > "u")
      return !1;
    const o = crypto == null ? void 0 : crypto.subtle;
    return o !== void 0 && ["generateKey", "importKey", "exportKey", "digest", "sign"].every((a) => typeof o[a] == "function");
  }
  async encrypt(o, a, u) {
    const c = await this.driver.importKey("raw", typeof a == "string" ? ArweaveUtils$6.stringToBuffer(a) : a, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), p = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, c, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), d = new Uint8Array(16);
    crypto.getRandomValues(d);
    const w = await this.driver.encrypt({ name: "AES-CBC", iv: d }, p, o);
    return ArweaveUtils$6.concatBuffers([d, w]);
  }
  async decrypt(o, a, u) {
    const c = await this.driver.importKey("raw", typeof a == "string" ? ArweaveUtils$6.stringToBuffer(a) : a, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), p = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, c, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), d = o.slice(0, 16), w = await this.driver.decrypt({ name: "AES-CBC", iv: d }, p, o.slice(16));
    return ArweaveUtils$6.concatBuffers([w]);
  }
}
webcryptoDriver.default = WebCryptoDriver;
var network$1 = {};
Object.defineProperty(network$1, "__esModule", { value: !0 });
class Network$1 {
  constructor(o) {
    this.api = o;
  }
  getInfo() {
    return this.api.get("info").then((o) => o.data);
  }
  getPeers() {
    return this.api.get("peers").then((o) => o.data);
  }
}
network$1.default = Network$1;
var transactions$1 = {}, error$1 = {};
Object.defineProperty(error$1, "__esModule", { value: !0 }), error$1.getError = void 0;
class ArweaveError$1 extends Error {
  constructor(o, a = {}) {
    a.message ? super(a.message) : super(), this.type = o, this.response = a.response;
  }
  getType() {
    return this.type;
  }
}
function getError$1(n) {
  let o = n.data;
  if (typeof n.data == "string")
    try {
      o = JSON.parse(n.data);
    } catch {
    }
  if (n.data instanceof ArrayBuffer || n.data instanceof Uint8Array)
    try {
      o = JSON.parse(o.toString());
    } catch {
    }
  return o ? o.error || o : n.statusText || "unknown";
}
error$1.default = ArweaveError$1, error$1.getError = getError$1;
var transaction$1 = {}, deepHash$1 = {}, hasRequiredDeepHash$1;
function requireDeepHash$1() {
  if (hasRequiredDeepHash$1)
    return deepHash$1;
  hasRequiredDeepHash$1 = 1, Object.defineProperty(deepHash$1, "__esModule", { value: !0 });
  const n = requireCommon$1();
  async function o(u) {
    if (Array.isArray(u)) {
      const d = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("list"), n.default.utils.stringToBuffer(u.length.toString())]);
      return await a(u, await n.default.crypto.hash(d, "SHA-384"));
    }
    const c = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("blob"), n.default.utils.stringToBuffer(u.byteLength.toString())]), p = n.default.utils.concatBuffers([await n.default.crypto.hash(c, "SHA-384"), await n.default.crypto.hash(u, "SHA-384")]);
    return await n.default.crypto.hash(p, "SHA-384");
  }
  async function a(u, c) {
    if (u.length < 1)
      return c;
    const p = n.default.utils.concatBuffers([c, await o(u[0])]), d = await n.default.crypto.hash(p, "SHA-384");
    return await a(u.slice(1), d);
  }
  return deepHash$1.default = o, deepHash$1;
}
var merkle$1 = {}, hasRequiredMerkle$1, hasRequiredTransaction$1;
function requireMerkle$1() {
  return hasRequiredMerkle$1 || (hasRequiredMerkle$1 = 1, function(n) {
    Object.defineProperty(n, "__esModule", { value: !0 }), n.debug = n.validatePath = n.arrayCompare = n.bufferToInt = n.intToBuffer = n.arrayFlatten = n.generateProofs = n.buildLayers = n.generateTransactionChunks = n.generateTree = n.computeRootHash = n.generateLeaves = n.chunkData = n.MIN_CHUNK_SIZE = n.MAX_CHUNK_SIZE = void 0;
    const o = requireCommon$1(), a = utils$p;
    n.MAX_CHUNK_SIZE = 262144, n.MIN_CHUNK_SIZE = 32768;
    async function u(q) {
      let D = [], z = q, F = 0;
      for (; z.byteLength >= n.MAX_CHUNK_SIZE; ) {
        let V = n.MAX_CHUNK_SIZE, Z = z.byteLength - n.MAX_CHUNK_SIZE;
        Z > 0 && Z < n.MIN_CHUNK_SIZE && (V = Math.ceil(z.byteLength / 2));
        const N = z.slice(0, V), W = await o.default.crypto.hash(N);
        F += N.byteLength, D.push({ dataHash: W, minByteRange: F - N.byteLength, maxByteRange: F }), z = z.slice(V);
      }
      return D.push({ dataHash: await o.default.crypto.hash(z), minByteRange: F, maxByteRange: F + z.byteLength }), D;
    }
    async function c(q) {
      return Promise.all(q.map(async ({ dataHash: D, minByteRange: z, maxByteRange: F }) => ({ type: "leaf", id: await I(await Promise.all([I(D), I(C(F))])), dataHash: D, minByteRange: z, maxByteRange: F })));
    }
    async function p(q) {
      return await d(await c(await u(q)));
    }
    async function d(q, D = 0) {
      if (q.length < 2)
        return q[0];
      const z = [];
      for (let F = 0; F < q.length; F += 2)
        z.push(await B(q[F], q[F + 1]));
      return d(z, D + 1);
    }
    function w(q) {
      const D = S(q);
      return Array.isArray(D) ? k(D) : [D];
    }
    function S(q, D = new Uint8Array(), z = 0) {
      if (q.type == "leaf")
        return { offset: q.maxByteRange - 1, proof: (0, a.concatBuffers)([D, q.dataHash, C(q.maxByteRange)]) };
      if (q.type == "branch") {
        const F = (0, a.concatBuffers)([D, q.leftChild.id, q.rightChild.id, C(q.byteRange)]);
        return [S(q.leftChild, F, z + 1), S(q.rightChild, F, z + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function k(q) {
      const D = [];
      return q.forEach((z) => {
        Array.isArray(z) ? D.push(...k(z)) : D.push(z);
      }), D;
    }
    async function B(q, D) {
      return D ? { type: "branch", id: await I([await I(q.id), await I(D.id), await I(C(q.maxByteRange))]), byteRange: q.maxByteRange, maxByteRange: D.maxByteRange, leftChild: q, rightChild: D } : q;
    }
    async function I(q) {
      return Array.isArray(q) && (q = o.default.utils.concatBuffers(q)), new Uint8Array(await o.default.crypto.hash(q));
    }
    function C(q) {
      const D = new Uint8Array(32);
      for (var z = D.length - 1; z >= 0; z--) {
        var F = q % 256;
        D[z] = F, q = (q - F) / 256;
      }
      return D;
    }
    function P(q) {
      let D = 0;
      for (var z = 0; z < q.length; z++)
        D *= 256, D += q[z];
      return D;
    }
    n.chunkData = u, n.generateLeaves = c, n.computeRootHash = async function(q) {
      return (await p(q)).id;
    }, n.generateTree = p, n.generateTransactionChunks = async function(q) {
      const D = await u(q), z = await c(D), F = await d(z), V = await w(F), Z = D.slice(-1)[0];
      return Z.maxByteRange - Z.minByteRange == 0 && (D.splice(D.length - 1, 1), V.splice(V.length - 1, 1)), { data_root: F.id, chunks: D, proofs: V };
    }, n.buildLayers = d, n.generateProofs = w, n.arrayFlatten = k, n.intToBuffer = C, n.bufferToInt = P, n.arrayCompare = (q, D) => q.every((z, F) => D[F] === z), n.validatePath = async function q(D, z, F, V, Z) {
      if (V <= 0)
        return !1;
      if (z >= V)
        return q(D, 0, V - 1, V, Z);
      if (z < 0)
        return q(D, 0, 0, V, Z);
      if (Z.length == 64) {
        const _ = Z.slice(0, 32), b = Z.slice(_.length, _.length + 32), m = await I([await I(_), await I(b)]);
        return !!(0, n.arrayCompare)(D, m) && { offset: V - 1, leftBound: F, rightBound: V, chunkSize: V - F };
      }
      const N = Z.slice(0, 32), W = Z.slice(N.length, N.length + 32), H = Z.slice(N.length + W.length, N.length + W.length + 32), te = P(H), g = Z.slice(N.length + W.length + H.length), $ = await I([await I(N), await I(W), await I(H)]);
      return !!(0, n.arrayCompare)(D, $) && (z < te ? await q(N, z, F, Math.min(V, te), g) : await q(W, z, Math.max(F, te), V, g));
    }, n.debug = async function q(D, z = "") {
      if (D.byteLength < 1)
        return z;
      const F = D.slice(0, 32), V = D.slice(F.length, F.length + 32), Z = D.slice(F.length + V.length, F.length + V.length + 32), N = P(Z), W = D.slice(F.length + V.length + Z.length), H = await I([await I(F), await I(V), await I(Z)]);
      return q(W, `${z}
${JSON.stringify(Buffer.from(F))},${JSON.stringify(Buffer.from(V))},${N} => ${JSON.stringify(H)}`);
    };
  }(merkle$1)), merkle$1;
}
function requireTransaction$1() {
  if (hasRequiredTransaction$1)
    return transaction$1;
  hasRequiredTransaction$1 = 1, Object.defineProperty(transaction$1, "__esModule", { value: !0 }), transaction$1.Tag = void 0;
  const n = utils$p, o = requireDeepHash$1(), a = requireMerkle$1();
  class u {
    get(d, w) {
      if (!Object.getOwnPropertyNames(this).includes(d))
        throw new Error(`Field "${d}" is not a property of the Arweave Transaction class.`);
      return this[d] instanceof Uint8Array ? w && w.decode && w.string ? n.bufferToString(this[d]) : w && w.decode && !w.string ? this[d] : n.bufferTob64Url(this[d]) : w && w.decode == 1 ? w && w.string ? n.b64UrlToString(this[d]) : n.b64UrlToBuffer(this[d]) : this[d];
    }
  }
  class c extends u {
    constructor(d, w, S = !1) {
      super(), this.name = d, this.value = w;
    }
  }
  return transaction$1.Tag = c, transaction$1.default = class extends u {
    constructor(p = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, p), typeof this.data == "string" && (this.data = n.b64UrlToBuffer(this.data)), p.tags && (this.tags = p.tags.map((d) => new c(d.name, d.value)));
    }
    addTag(p, d) {
      this.tags.push(new c(n.stringToB64Url(p), n.stringToB64Url(d)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: n.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(p) {
      this.owner = p;
    }
    setSignature({ id: p, owner: d, reward: w, tags: S, signature: k }) {
      this.id = p, this.owner = d, w && (this.reward = w), S && (this.tags = S), this.signature = k;
    }
    async prepareChunks(p) {
      !this.chunks && p.byteLength > 0 && (this.chunks = await (0, a.generateTransactionChunks)(p), this.data_root = n.bufferTob64Url(this.chunks.data_root)), this.chunks || p.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(p, d) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const w = this.chunks.proofs[p], S = this.chunks.chunks[p];
      return { data_root: this.data_root, data_size: this.data_size, data_path: n.bufferTob64Url(w.proof), offset: w.offset.toString(), chunk: n.bufferTob64Url(d.slice(S.minByteRange, S.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let p = this.tags.reduce((w, S) => n.concatBuffers([w, S.get("name", { decode: !0, string: !1 }), S.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return n.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), n.stringToBuffer(this.quantity), n.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), p]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const d = this.tags.map((w) => [w.get("name", { decode: !0, string: !1 }), w.get("value", { decode: !0, string: !1 })]);
          return await (0, o.default)([n.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), n.stringToBuffer(this.quantity), n.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), d, n.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction$1;
}
var transactionUploader$1 = {}, hasRequiredTransactionUploader$1, hasRequiredTransactions$1;
function requireTransactionUploader$1() {
  if (hasRequiredTransactionUploader$1)
    return transactionUploader$1;
  hasRequiredTransactionUploader$1 = 1, Object.defineProperty(transactionUploader$1, "__esModule", { value: !0 }), transactionUploader$1.TransactionUploader = void 0;
  const n = requireTransaction$1(), o = utils$p, a = error$1, u = requireMerkle$1(), c = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class p {
    constructor(w, S) {
      if (this.api = w, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !S.id)
        throw new Error("Transaction is not signed");
      if (!S.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = S.data, this.transaction = new n.default(Object.assign({}, S, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(w) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let S = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (S > 0 && (S -= S * Math.random() * 0.3, await new Promise((I) => setTimeout(I, S))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      w && (this.chunkIndex = w);
      const k = this.transaction.getChunk(w || this.chunkIndex, this.data);
      if (!await (0, u.validatePath)(this.transaction.chunks.data_root, parseInt(k.offset), 0, parseInt(k.data_size), o.b64UrlToBuffer(k.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const B = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((I) => (console.error(I.message), { status: -1, data: { error: I.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = B.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, a.getError)(B), c.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized(w, S, k) {
      if (!S || typeof S.chunkIndex != "number" || typeof S.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var B = new n.default(S.transaction);
      B.chunks || await B.prepareChunks(k);
      const I = new p(w, B);
      if (I.chunkIndex = S.chunkIndex, I.lastRequestTimeEnd = S.lastRequestTimeEnd, I.lastResponseError = S.lastResponseError, I.lastResponseStatus = S.lastResponseStatus, I.txPosted = S.txPosted, I.data = k, I.transaction.data_root !== S.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return I;
    }
    static async fromTransactionId(w, S) {
      const k = await w.get(`tx/${S}`);
      if (k.status !== 200)
        throw new Error(`Tx ${S} not found: ${k.status}`);
      const B = k.data;
      return B.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: B };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const S = await this.api.post("tx", this.transaction).catch((k) => (console.error(k), { status: -1, data: { error: k.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = S.status, this.transaction.data = new Uint8Array(0), S.status >= 200 && S.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, a.getError)(S), new Error(`Unable to upload transaction: ${S.status}, ${this.lastResponseError}`);
      }
      const w = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = w.status, !(w.status >= 200 && w.status < 300))
        throw this.lastResponseError = (0, a.getError)(w), new Error(`Unable to upload transaction: ${w.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader$1.TransactionUploader = p, transactionUploader$1;
}
function requireTransactions$1() {
  if (hasRequiredTransactions$1)
    return transactions$1;
  hasRequiredTransactions$1 = 1;
  var n = commonjsGlobal && commonjsGlobal.__await || function(d) {
    return this instanceof n ? (this.v = d, this) : new n(d);
  }, o = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(d, w, S) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var k, B = S.apply(d, w || []), I = [];
    return k = {}, C("next"), C("throw"), C("return"), k[Symbol.asyncIterator] = function() {
      return this;
    }, k;
    function C(F) {
      B[F] && (k[F] = function(V) {
        return new Promise(function(Z, N) {
          I.push([F, V, Z, N]) > 1 || P(F, V);
        });
      });
    }
    function P(F, V) {
      try {
        (function(Z) {
          Z.value instanceof n ? Promise.resolve(Z.value.v).then(q, D) : z(I[0][2], Z);
        })(B[F](V));
      } catch (Z) {
        z(I[0][3], Z);
      }
    }
    function q(F) {
      P("next", F);
    }
    function D(F) {
      P("throw", F);
    }
    function z(F, V) {
      F(V), I.shift(), I.length && P(I[0][0], I[0][1]);
    }
  };
  Object.defineProperty(transactions$1, "__esModule", { value: !0 });
  const a = error$1, u = requireTransaction$1(), c = utils$p, p = requireTransactionUploader$1();
  return transactions$1.default = class {
    constructor(d, w, S) {
      this.api = d, this.crypto = w, this.chunks = S;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((d) => d.data);
    }
    getPrice(d, w) {
      let S = w ? `price/${d}/${w}` : `price/${d}`;
      return this.api.get(S, { transformResponse: [function(k) {
        return k;
      }] }).then((k) => k.data);
    }
    async get(d) {
      const w = await this.api.get(`tx/${d}`);
      if (w.status == 200) {
        const S = parseInt(w.data.data_size);
        if (w.data.format >= 2 && S > 0 && S <= 12582912) {
          const k = await this.getData(d);
          return new u.default(Object.assign(Object.assign({}, w.data), { data: k }));
        }
        return new u.default(Object.assign(Object.assign({}, w.data), { format: w.data.format || 1 }));
      }
      throw w.status == 404 ? new a.default("TX_NOT_FOUND") : w.status == 410 ? new a.default("TX_FAILED") : new a.default("TX_INVALID");
    }
    fromRaw(d) {
      return new u.default(d);
    }
    async search(d, w) {
      return this.api.post("arql", { op: "equals", expr1: d, expr2: w }).then((S) => S.data ? S.data : []);
    }
    getStatus(d) {
      return this.api.get(`tx/${d}/status`).then((w) => w.status == 200 ? { status: 200, confirmed: w.data } : { status: w.status, confirmed: null });
    }
    async getData(d, w) {
      let S;
      try {
        S = await this.chunks.downloadChunkedData(d);
      } catch (k) {
        console.error(`Error while trying to download chunked data for ${d}`), console.error(k);
      }
      if (!S) {
        console.warn(`Falling back to gateway cache for ${d}`);
        try {
          S = (await this.api.get(`/${d}`)).data;
        } catch (k) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${d}`), console.error(k);
        }
      }
      if (!S)
        throw new Error(`${d} was not found!`);
      return w && w.decode && !w.string ? S : w && w.decode && w.string ? c.bufferToString(S) : c.bufferTob64Url(S);
    }
    async sign(d, w, S) {
      if (!(w || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if (w && w !== "use_wallet") {
        d.setOwner(w.n);
        let k = await d.getSignatureData(), B = await this.crypto.sign(w, k, S), I = await this.crypto.hash(B);
        d.setSignature({ id: c.bufferTob64Url(I), owner: w.n, signature: c.bufferTob64Url(B) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const k = await window.arweaveWallet.sign(d, S);
        d.setSignature({ id: k.id, owner: k.owner, reward: k.reward, tags: k.tags, signature: k.signature });
      }
    }
    async verify(d) {
      const w = await d.getSignatureData(), S = d.get("signature", { decode: !0, string: !1 }), k = c.bufferTob64Url(await this.crypto.hash(S));
      if (d.id !== k)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(d.owner, w, S);
    }
    async post(d) {
      if (typeof d == "string" ? d = new u.default(JSON.parse(d)) : typeof d.readInt32BE == "function" ? d = new u.default(JSON.parse(d.toString())) : typeof d != "object" || d instanceof u.default || (d = new u.default(d)), !(d instanceof u.default))
        throw new Error("Must be Transaction object");
      d.chunks || await d.prepareChunks(d.data);
      const w = await this.getUploader(d, d.data);
      try {
        for (; !w.isComplete; )
          await w.uploadChunk();
      } catch (S) {
        if (w.lastResponseStatus > 0)
          return { status: w.lastResponseStatus, statusText: w.lastResponseError, data: { error: w.lastResponseError } };
        throw S;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(d, w) {
      let S;
      if (w instanceof ArrayBuffer && (w = new Uint8Array(w)), d instanceof u.default) {
        if (w || (w = d.data), !(w instanceof Uint8Array))
          throw new Error("Data format is invalid");
        d.chunks || await d.prepareChunks(w), S = new p.TransactionUploader(this.api, d), S.data && S.data.length !== 0 || (S.data = w);
      } else {
        if (typeof d == "string" && (d = await p.TransactionUploader.fromTransactionId(this.api, d)), !(w && w instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        S = await p.TransactionUploader.fromSerialized(this.api, d, w);
      }
      return S;
    }
    upload(d, w) {
      return o(this, arguments, function* () {
        const S = yield n(this.getUploader(d, w));
        for (; !S.isComplete; )
          yield n(S.uploadChunk()), yield yield n(S);
        return yield n(S);
      });
    }
  }, transactions$1;
}
var wallets$1 = {};
Object.defineProperty(wallets$1, "__esModule", { value: !0 });
const ArweaveUtils$5 = utils$p;
class Wallets$1 {
  constructor(o, a) {
    this.api = o, this.crypto = a;
  }
  getBalance(o) {
    return this.api.get(`wallet/${o}/balance`, { transformResponse: [function(a) {
      return a;
    }] }).then((a) => a.data);
  }
  getLastTransactionID(o) {
    return this.api.get(`wallet/${o}/last_tx`).then((a) => a.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(o) {
    return o && o !== "use_wallet" ? this.getAddress(o) : this.getAddress();
  }
  async getAddress(o) {
    if (o && o !== "use_wallet")
      return this.ownerToAddress(o.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(o) {
    return ArweaveUtils$5.bufferTob64Url(await this.crypto.hash(ArweaveUtils$5.b64UrlToBuffer(o)));
  }
}
wallets$1.default = Wallets$1;
var silo$1 = {};
Object.defineProperty(silo$1, "__esModule", { value: !0 }), silo$1.SiloResource = void 0;
const ArweaveUtils$4 = utils$p;
class Silo$1 {
  constructor(o, a, u) {
    this.api = o, this.crypto = a, this.transactions = u;
  }
  async get(o) {
    if (!o)
      throw new Error("No Silo URI specified");
    const a = await this.parseUri(o), u = await this.transactions.search("Silo-Name", a.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${o}`);
    const c = await this.transactions.get(u[0]);
    if (!c)
      throw new Error(`No data could be found for the Silo URI: ${o}`);
    const p = c.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(p, a.getEncryptionKey());
  }
  async readTransactionData(o, a) {
    if (!a)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(a), c = o.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(c, u.getEncryptionKey());
  }
  async parseUri(o) {
    const a = o.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!a)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = a[1], c = Math.pow(2, parseInt(a[2])), p = await this.hash(ArweaveUtils$4.stringToBuffer(u), c), d = ArweaveUtils$4.bufferTob64(p.slice(0, 15)), w = await this.hash(p.slice(16, 31), 1);
    return new SiloResource$1(o, d, w);
  }
  async hash(o, a) {
    let u = await this.crypto.hash(o);
    for (let c = 0; c < a - 1; c++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo$1.default = Silo$1;
class SiloResource$1 {
  constructor(o, a, u) {
    this.uri = o, this.accessKey = a, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo$1.SiloResource = SiloResource$1;
var chunks$1 = {};
Object.defineProperty(chunks$1, "__esModule", { value: !0 });
const error_1$3 = error$1, ArweaveUtils$3 = utils$p;
class Chunks$1 {
  constructor(o) {
    this.api = o;
  }
  async getTransactionOffset(o) {
    const a = await this.api.get(`tx/${o}/offset`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$3.getError)(a)}`);
  }
  async getChunk(o) {
    const a = await this.api.get(`chunk/${o}`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$3.getError)(a)}`);
  }
  async getChunkData(o) {
    const a = await this.getChunk(o);
    return ArweaveUtils$3.b64UrlToBuffer(a.chunk);
  }
  firstChunkOffset(o) {
    return parseInt(o.offset) - parseInt(o.size) + 1;
  }
  async downloadChunkedData(o) {
    const a = await this.getTransactionOffset(o), u = parseInt(a.size), c = parseInt(a.offset) - u + 1, p = new Uint8Array(u);
    let d = 0;
    for (; d < u; ) {
      let w;
      this.api.config.logging && console.log(`[chunk] ${d}/${u}`);
      try {
        w = await this.getChunkData(c + d);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${c + d}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!w)
        throw new Error(`Couldn't complete data download at ${d}/${u}`);
      p.set(w, d), d += w.length;
    }
    return p;
  }
}
chunks$1.default = Chunks$1;
var blocks$1 = {};
Object.defineProperty(blocks$1, "__esModule", { value: !0 });
const error_1$2 = error$1;
class Blocks$1 {
  constructor(o, a) {
    this.api = o, this.network = a;
  }
  async get(o) {
    const a = await this.api.get(`${Blocks$1.ENDPOINT}${o}`);
    if (a.status === 200)
      return a.data;
    throw a.status === 404 ? new error_1$2.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${a}`);
  }
  async getCurrent() {
    const { current: o } = await this.network.getInfo();
    return await this.get(o);
  }
}
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$8;
  hasRequiredCommon$1 = 1, Object.defineProperty(common$8, "__esModule", { value: !0 });
  const n = ar$1, o = api$2, a = webcryptoDriver, u = network$1, c = requireTransactions$1(), p = wallets$1, d = requireTransaction$1(), w = utils$p, S = silo$1, k = chunks$1, B = blocks$1;
  class I {
    constructor(P) {
      this.api = new o.default(P), this.wallets = new p.default(this.api, I.crypto), this.chunks = new k.default(this.api), this.transactions = new c.default(this.api, I.crypto, this.chunks), this.silo = new S.default(this.api, this.crypto, this.transactions), this.network = new u.default(this.api), this.blocks = new B.default(this.api, this.network), this.ar = new n.default();
    }
    get crypto() {
      return I.crypto;
    }
    get utils() {
      return I.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(P, q) {
      const D = {};
      if (Object.assign(D, P), !(P.data || P.target && P.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (P.owner == null && q && q !== "use_wallet" && (D.owner = q.n), P.last_tx == null && (D.last_tx = await this.transactions.getTransactionAnchor()), typeof P.data == "string" && (P.data = w.stringToBuffer(P.data)), P.data instanceof ArrayBuffer && (P.data = new Uint8Array(P.data)), P.data && !(P.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (P.reward == null) {
        const F = P.data ? P.data.byteLength : 0;
        D.reward = await this.transactions.getPrice(F, D.target);
      }
      D.data_root = "", D.data_size = P.data ? P.data.byteLength.toString() : "0", D.data = P.data || new Uint8Array(0);
      const z = new d.default(D);
      return await z.getSignatureData(), z;
    }
    async createSiloTransaction(P, q, D) {
      const z = {};
      if (Object.assign(z, P), !P.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!D)
        throw new Error("No Silo URI specified.");
      if (P.target || P.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (P.owner == null) {
        if (!q || !q.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        z.owner = q.n;
      }
      P.last_tx == null && (z.last_tx = await this.transactions.getTransactionAnchor());
      const F = await this.silo.parseUri(D);
      if (typeof P.data == "string") {
        const Z = await this.crypto.encrypt(w.stringToBuffer(P.data), F.getEncryptionKey());
        z.reward = await this.transactions.getPrice(Z.byteLength), z.data = w.bufferTob64Url(Z);
      }
      if (P.data instanceof Uint8Array) {
        const Z = await this.crypto.encrypt(P.data, F.getEncryptionKey());
        z.reward = await this.transactions.getPrice(Z.byteLength), z.data = w.bufferTob64Url(Z);
      }
      const V = new d.default(z);
      return V.addTag("Silo-Name", F.getAccessKey()), V.addTag("Silo-Version", "0.1.0"), V;
    }
    arql(P) {
      return this.api.post("/arql", P).then((q) => q.data || []);
    }
  }
  return common$8.default = I, I.crypto = new a.default(), I.utils = w, common$8;
}
blocks$1.default = Blocks$1, Blocks$1.ENDPOINT = "block/hash/", function(n) {
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(c, p, d, w) {
    w === void 0 && (w = d);
    var S = Object.getOwnPropertyDescriptor(p, d);
    S && !("get" in S ? !p.__esModule : S.writable || S.configurable) || (S = { enumerable: !0, get: function() {
      return p[d];
    } }), Object.defineProperty(c, w, S);
  } : function(c, p, d, w) {
    w === void 0 && (w = d), c[w] = p[d];
  }), a = commonjsGlobal && commonjsGlobal.__exportStar || function(c, p) {
    for (var d in c)
      d === "default" || Object.prototype.hasOwnProperty.call(p, d) || o(p, c, d);
  };
  Object.defineProperty(n, "__esModule", { value: !0 });
  const u = requireCommon$1();
  u.default.init = function(c = {}) {
    const p = function() {
      const k = { host: "arweave.net", port: 443, protocol: "https" };
      if (!(window && window.location && window.location.protocol && window.location.hostname))
        return k;
      const B = window.location.protocol.replace(":", ""), I = window.location.hostname, C = window.location.port ? parseInt(window.location.port) : B == "https" ? 443 : 80;
      return ["localhost", "127.0.0.1"].includes(I) || B == "file" ? k : { host: I, port: C, protocol: B };
    }(), d = c.protocol || p.protocol, w = c.host || p.host, S = c.port || p.port;
    return new u.default(Object.assign(Object.assign({}, c), { host: w, protocol: d, port: S }));
  }, window.Arweave = u.default, a(requireCommon$1(), n), n.default = u.default;
}(web);
const index$2 = getDefaultExportFromCjs(web), index$3 = _mergeNamespaces({ __proto__: null, default: index$2 }, [web]);
var transaction = {}, utils$o = {}, __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$6(o, n, a);
  return __setModuleDefault$6(o, n), o;
};
Object.defineProperty(utils$o, "__esModule", { value: !0 }), utils$o.b64UrlDecode = utils$o.b64UrlEncode = utils$o.bufferTob64Url = utils$o.bufferTob64 = utils$o.b64UrlToBuffer = utils$o.stringToB64Url = utils$o.stringToBuffer = utils$o.bufferToString = utils$o.b64UrlToString = utils$o.concatBuffers = void 0;
const B64js = __importStar$6(base64Js);
function concatBuffers(n) {
  let o = 0;
  for (let c = 0; c < n.length; c++)
    o += n[c].byteLength;
  let a = new Uint8Array(o), u = 0;
  a.set(new Uint8Array(n[0]), u), u += n[0].byteLength;
  for (let c = 1; c < n.length; c++)
    a.set(new Uint8Array(n[c]), u), u += n[c].byteLength;
  return a;
}
function b64UrlToString(n) {
  return bufferToString(b64UrlToBuffer(n));
}
function bufferToString(n) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(n) : new TextDecoder("utf-8", { fatal: !0 }).decode(n);
}
function stringToBuffer(n) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(n) : new TextEncoder().encode(n);
}
function stringToB64Url(n) {
  return bufferTob64Url(stringToBuffer(n));
}
function b64UrlToBuffer(n) {
  return new Uint8Array(B64js.toByteArray(b64UrlDecode(n)));
}
function bufferTob64(n) {
  return B64js.fromByteArray(new Uint8Array(n));
}
function bufferTob64Url(n) {
  return b64UrlEncode(bufferTob64(n));
}
function b64UrlEncode(n) {
  return n.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(n) {
  let o;
  return o = (n = n.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - n.length % 4, n.concat("=".repeat(o));
}
utils$o.concatBuffers = concatBuffers, utils$o.b64UrlToString = b64UrlToString, utils$o.bufferToString = bufferToString, utils$o.stringToBuffer = stringToBuffer, utils$o.stringToB64Url = stringToB64Url, utils$o.b64UrlToBuffer = b64UrlToBuffer, utils$o.bufferTob64 = bufferTob64, utils$o.bufferTob64Url = bufferTob64Url, utils$o.b64UrlEncode = b64UrlEncode, utils$o.b64UrlDecode = b64UrlDecode;
var deepHash = {}, common$7 = {}, ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
const bignumber_js_1$1 = bignumber.exports;
class Ar {
  constructor() {
    this.BigNum = (o, a) => new (bignumber_js_1$1.BigNumber.clone({ DECIMAL_PLACES: a }))(o);
  }
  winstonToAr(o, { formatted: a = !1, decimals: u = 12, trim: c = !0 } = {}) {
    let p = this.stringToBigNum(o, u).shiftedBy(-12);
    return a ? p.toFormat(u) : p.toFixed(u);
  }
  arToWinston(o, { formatted: a = !1 } = {}) {
    let u = this.stringToBigNum(o).shiftedBy(12);
    return a ? u.toFormat() : u.toFixed(0);
  }
  compare(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.comparedTo(c);
  }
  isEqual(o, a) {
    return this.compare(o, a) === 0;
  }
  isLessThan(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.isLessThan(c);
  }
  isGreaterThan(o, a) {
    let u = this.stringToBigNum(o), c = this.stringToBigNum(a);
    return u.isGreaterThan(c);
  }
  add(o, a) {
    let u = this.stringToBigNum(o);
    return this.stringToBigNum(a), u.plus(a).toFixed(0);
  }
  sub(o, a) {
    let u = this.stringToBigNum(o);
    return this.stringToBigNum(a), u.minus(a).toFixed(0);
  }
  stringToBigNum(o, a = 12) {
    return this.BigNum(o, a);
  }
}
ar.default = Ar;
var api$1 = {}, __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(api$1, "__esModule", { value: !0 });
const axios_1 = __importDefault$8(axios$2.exports);
class Api {
  constructor(o) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(o);
  }
  applyConfig(o) {
    this.config = this.mergeDefaults(o);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(o) {
    const a = o.protocol || "http", u = o.port || (a === "https" ? 443 : 80);
    return { host: o.host || "127.0.0.1", protocol: a, port: u, timeout: o.timeout || 2e4, logging: o.logging || !1, logger: o.logger || console.log, network: o.network };
  }
  async get(o, a) {
    try {
      return await this.request().get(o, a);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(o, a, u) {
    try {
      return await this.request().post(o, a, u);
    } catch (c) {
      if (c.response && c.response.status)
        return c.response;
      throw c;
    }
  }
  request() {
    const o = {};
    this.config.network && (o["x-network"] = this.config.network);
    let a = axios_1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: o });
    return this.config.logging && (a.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), a.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), a;
  }
}
api$1.default = Api;
var nodeDriver = {}, pem$2 = {}, asn1 = {}, bn$3 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" })), require$$2$1 = getAugmentedNamespace(__viteBrowserExternal$1);
(function(n, o) {
  function a(g, $) {
    if (!g)
      throw new Error($ || "Assertion failed");
  }
  function u(g, $) {
    g.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, g.prototype = new _(), g.prototype.constructor = g;
  }
  function c(g, $, _) {
    if (c.isBN(g))
      return g;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, g !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(g || 0, $ || 10, _ || "be"));
  }
  var p;
  typeof bn$3 == "object" ? bn$3.exports = c : o.BN = c, c.BN = c, c.wordSize = 26;
  try {
    p = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(g, $) {
    var _ = g.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(g, $, _) {
    var b = d(g, _);
    return _ - 1 >= $ && (b |= d(g, _ - 1) << 4), b;
  }
  function S(g, $, _, b) {
    for (var m = 0, v = Math.min(g.length, _), E = $; E < v; E++) {
      var T = g.charCodeAt(E) - 48;
      m *= b, m += T >= 49 ? T - 49 + 10 : T >= 17 ? T - 17 + 10 : T;
    }
    return m;
  }
  c.isBN = function(g) {
    return g instanceof c || g !== null && typeof g == "object" && g.constructor.wordSize === c.wordSize && Array.isArray(g.words);
  }, c.max = function(g, $) {
    return g.cmp($) > 0 ? g : $;
  }, c.min = function(g, $) {
    return g.cmp($) < 0 ? g : $;
  }, c.prototype._init = function(g, $, _) {
    if (typeof g == "number")
      return this._initNumber(g, $, _);
    if (typeof g == "object")
      return this._initArray(g, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var b = 0;
    (g = g.toString().replace(/\s+/g, ""))[0] === "-" && (b++, this.negative = 1), b < g.length && ($ === 16 ? this._parseHex(g, b, _) : (this._parseBase(g, $, b), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(g, $, _) {
    g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [67108863 & g], this.length = 1) : g < 4503599627370496 ? (this.words = [67108863 & g, g / 67108864 & 67108863], this.length = 2) : (a(g < 9007199254740992), this.words = [67108863 & g, g / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(g, $, _) {
    if (a(typeof g.length == "number"), g.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v, E = 0;
    if (_ === "be")
      for (b = g.length - 1, m = 0; b >= 0; b -= 3)
        v = g[b] | g[b - 1] << 8 | g[b - 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    else if (_ === "le")
      for (b = 0, m = 0; b < g.length; b += 3)
        v = g[b] | g[b + 1] << 8 | g[b + 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    return this.strip();
  }, c.prototype._parseHex = function(g, $, _) {
    this.length = Math.ceil((g.length - $) / 6), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v = 0, E = 0;
    if (_ === "be")
      for (b = g.length - 1; b >= $; b -= 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    else
      for (b = (g.length - $) % 2 == 0 ? $ + 1 : $; b < g.length; b += 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(g, $, _) {
    this.words = [0], this.length = 1;
    for (var b = 0, m = 1; m <= 67108863; m *= $)
      b++;
    b--, m = m / $ | 0;
    for (var v = g.length - _, E = v % b, T = Math.min(v, v - E) + _, j = 0, L = _; L < T; L += b)
      j = S(g, L, L + b, $), this.imuln(m), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    if (E !== 0) {
      var J = 1;
      for (j = S(g, L, g.length, $), L = 0; L < E; L++)
        J *= $;
      this.imuln(J), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    }
    this.strip();
  }, c.prototype.copy = function(g) {
    g.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      g.words[$] = this.words[$];
    g.length = this.length, g.negative = this.negative, g.red = this.red;
  }, c.prototype.clone = function() {
    var g = new c(null);
    return this.copy(g), g;
  }, c.prototype._expand = function(g) {
    for (; this.length < g; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var k = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(g, $, _) {
    _.negative = $.negative ^ g.negative;
    var b = g.length + $.length | 0;
    _.length = b, b = b - 1 | 0;
    var m = 0 | g.words[0], v = 0 | $.words[0], E = m * v, T = 67108863 & E, j = E / 67108864 | 0;
    _.words[0] = T;
    for (var L = 1; L < b; L++) {
      for (var J = j >>> 26, Y = 67108863 & j, ne = Math.min(L, $.length - 1), Q = Math.max(0, L - g.length + 1); Q <= ne; Q++) {
        var oe = L - Q | 0;
        J += (E = (m = 0 | g.words[oe]) * (v = 0 | $.words[Q]) + Y) / 67108864 | 0, Y = 67108863 & E;
      }
      _.words[L] = 0 | Y, j = 0 | J;
    }
    return j !== 0 ? _.words[L] = 0 | j : _.length--, _.strip();
  }
  c.prototype.toString = function(g, $) {
    var _;
    if ($ = 0 | $ || 1, (g = g || 10) === 16 || g === "hex") {
      _ = "";
      for (var b = 0, m = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], T = (16777215 & (E << b | m)).toString(16);
        _ = (m = E >>> 24 - b & 16777215) != 0 || v !== this.length - 1 ? k[6 - T.length] + T + _ : T + _, (b += 2) >= 26 && (b -= 26, v--);
      }
      for (m !== 0 && (_ = m.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (g === (0 | g) && g >= 2 && g <= 36) {
      var j = B[g], L = I[g];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var Y = J.modn(L).toString(g);
        _ = (J = J.idivn(L)).isZero() ? Y + _ : k[j - Y.length] + Y + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var g = this.words[0];
    return this.length === 2 ? g += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(g, $) {
    return a(p !== void 0), this.toArrayLike(p, g, $);
  }, c.prototype.toArray = function(g, $) {
    return this.toArrayLike(Array, g, $);
  }, c.prototype.toArrayLike = function(g, $, _) {
    var b = this.byteLength(), m = _ || Math.max(1, b);
    a(b <= m, "byte array longer than desired length"), a(m > 0, "Requested array length <= 0"), this.strip();
    var v, E, T = $ === "le", j = new g(m), L = this.clone();
    if (T) {
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[E] = v;
      for (; E < m; E++)
        j[E] = 0;
    } else {
      for (E = 0; E < m - b; E++)
        j[E] = 0;
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[m - E - 1] = v;
    }
    return j;
  }, Math.clz32 ? c.prototype._countBits = function(g) {
    return 32 - Math.clz32(g);
  } : c.prototype._countBits = function(g) {
    var $ = g, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(g) {
    if (g === 0)
      return 26;
    var $ = g, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var g = this.words[this.length - 1], $ = this._countBits(g);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var g = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (g += _, _ !== 26)
        break;
    }
    return g;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(g) {
    return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(g) {
    return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(g) {
    for (; this.length < g.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < g.length; $++)
      this.words[$] = this.words[$] | g.words[$];
    return this.strip();
  }, c.prototype.ior = function(g) {
    return a((this.negative | g.negative) == 0), this.iuor(g);
  }, c.prototype.or = function(g) {
    return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
  }, c.prototype.uor = function(g) {
    return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
  }, c.prototype.iuand = function(g) {
    var $;
    $ = this.length > g.length ? g : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & g.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(g) {
    return a((this.negative | g.negative) == 0), this.iuand(g);
  }, c.prototype.and = function(g) {
    return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
  }, c.prototype.uand = function(g) {
    return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
  }, c.prototype.iuxor = function(g) {
    var $, _;
    this.length > g.length ? ($ = this, _ = g) : ($ = g, _ = this);
    for (var b = 0; b < _.length; b++)
      this.words[b] = $.words[b] ^ _.words[b];
    if (this !== $)
      for (; b < $.length; b++)
        this.words[b] = $.words[b];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(g) {
    return a((this.negative | g.negative) == 0), this.iuxor(g);
  }, c.prototype.xor = function(g) {
    return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
  }, c.prototype.uxor = function(g) {
    return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
  }, c.prototype.inotn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = 0 | Math.ceil(g / 26), _ = g % 26;
    this._expand($), _ > 0 && $--;
    for (var b = 0; b < $; b++)
      this.words[b] = 67108863 & ~this.words[b];
    return _ > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(g) {
    return this.clone().inotn(g);
  }, c.prototype.setn = function(g, $) {
    a(typeof g == "number" && g >= 0);
    var _ = g / 26 | 0, b = g % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << b : this.words[_] & ~(1 << b), this.strip();
  }, c.prototype.iadd = function(g) {
    var $, _, b;
    if (this.negative !== 0 && g.negative === 0)
      return this.negative = 0, $ = this.isub(g), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && g.negative !== 0)
      return g.negative = 0, $ = this.isub(g), g.negative = 1, $._normSign();
    this.length > g.length ? (_ = this, b = g) : (_ = g, b = this);
    for (var m = 0, v = 0; v < b.length; v++)
      $ = (0 | _.words[v]) + (0 | b.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    for (; m !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    if (this.length = _.length, m !== 0)
      this.words[this.length] = m, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(g) {
    var $;
    return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, $ = this.sub(g), g.negative ^= 1, $) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = g.sub(this), this.negative = 1, $) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
  }, c.prototype.isub = function(g) {
    if (g.negative !== 0) {
      g.negative = 0;
      var $ = this.iadd(g);
      return g.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
    var _, b, m = this.cmp(g);
    if (m === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    m > 0 ? (_ = this, b = g) : (_ = g, b = this);
    for (var v = 0, E = 0; E < b.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | b.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(g) {
    return this.clone().isub(g);
  };
  var P = function(g, $, _) {
    var b, m, v, E = g.words, T = $.words, j = _.words, L = 0, J = 0 | E[0], Y = 8191 & J, ne = J >>> 13, Q = 0 | E[1], oe = 8191 & Q, ae = Q >>> 13, ce = 0 | E[2], ue = 8191 & ce, le = ce >>> 13, Se = 0 | E[3], he = 8191 & Se, _e = Se >>> 13, Le = 0 | E[4], se = 8191 & Le, we = Le >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, y = l >>> 13, A = 0 | E[7], M = 8191 & A, x = A >>> 13, O = 0 | E[8], G = 8191 & O, X = O >>> 13, ie = 0 | E[9], ee = 8191 & ie, re = ie >>> 13, ye = 0 | T[0], fe = 8191 & ye, pe = ye >>> 13, Re = 0 | T[1], me = 8191 & Re, Ee = Re >>> 13, Ce = 0 | T[2], ge = 8191 & Ce, Ae = Ce >>> 13, Fe = 0 | T[3], $e = 8191 & Fe, Me = Fe >>> 13, qe = 0 | T[4], ve = 8191 & qe, Oe = qe >>> 13, He = 0 | T[5], be = 8191 & He, Pe = He >>> 13, ze = 0 | T[6], Te = 8191 & ze, Ne = ze >>> 13, Ve = 0 | T[7], xe = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | T[8], Be = 8191 & Je, je = Je >>> 13, Xe = 0 | T[9], Ie = 8191 & Xe, De = Xe >>> 13;
    _.negative = g.negative ^ $.negative, _.length = 19;
    var Ge = (L + (b = Math.imul(Y, fe)) | 0) + ((8191 & (m = (m = Math.imul(Y, pe)) + Math.imul(ne, fe) | 0)) << 13) | 0;
    L = ((v = Math.imul(ne, pe)) + (m >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, b = Math.imul(oe, fe), m = (m = Math.imul(oe, pe)) + Math.imul(ae, fe) | 0, v = Math.imul(ae, pe);
    var Ke = (L + (b = b + Math.imul(Y, me) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ee) | 0) + Math.imul(ne, me) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ee) | 0) + (m >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, b = Math.imul(ue, fe), m = (m = Math.imul(ue, pe)) + Math.imul(le, fe) | 0, v = Math.imul(le, pe), b = b + Math.imul(oe, me) | 0, m = (m = m + Math.imul(oe, Ee) | 0) + Math.imul(ae, me) | 0, v = v + Math.imul(ae, Ee) | 0;
    var Ye = (L + (b = b + Math.imul(Y, ge) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ae) | 0) + Math.imul(ne, ge) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ae) | 0) + (m >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, b = Math.imul(he, fe), m = (m = Math.imul(he, pe)) + Math.imul(_e, fe) | 0, v = Math.imul(_e, pe), b = b + Math.imul(ue, me) | 0, m = (m = m + Math.imul(ue, Ee) | 0) + Math.imul(le, me) | 0, v = v + Math.imul(le, Ee) | 0, b = b + Math.imul(oe, ge) | 0, m = (m = m + Math.imul(oe, Ae) | 0) + Math.imul(ae, ge) | 0, v = v + Math.imul(ae, Ae) | 0;
    var Ze = (L + (b = b + Math.imul(Y, $e) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Me) | 0) + Math.imul(ne, $e) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Me) | 0) + (m >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, b = Math.imul(se, fe), m = (m = Math.imul(se, pe)) + Math.imul(we, fe) | 0, v = Math.imul(we, pe), b = b + Math.imul(he, me) | 0, m = (m = m + Math.imul(he, Ee) | 0) + Math.imul(_e, me) | 0, v = v + Math.imul(_e, Ee) | 0, b = b + Math.imul(ue, ge) | 0, m = (m = m + Math.imul(ue, Ae) | 0) + Math.imul(le, ge) | 0, v = v + Math.imul(le, Ae) | 0, b = b + Math.imul(oe, $e) | 0, m = (m = m + Math.imul(oe, Me) | 0) + Math.imul(ae, $e) | 0, v = v + Math.imul(ae, Me) | 0;
    var Qe = (L + (b = b + Math.imul(Y, ve) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Oe) | 0) + Math.imul(ne, ve) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Oe) | 0) + (m >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, b = Math.imul(de, fe), m = (m = Math.imul(de, pe)) + Math.imul(ke, fe) | 0, v = Math.imul(ke, pe), b = b + Math.imul(se, me) | 0, m = (m = m + Math.imul(se, Ee) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ee) | 0, b = b + Math.imul(he, ge) | 0, m = (m = m + Math.imul(he, Ae) | 0) + Math.imul(_e, ge) | 0, v = v + Math.imul(_e, Ae) | 0, b = b + Math.imul(ue, $e) | 0, m = (m = m + Math.imul(ue, Me) | 0) + Math.imul(le, $e) | 0, v = v + Math.imul(le, Me) | 0, b = b + Math.imul(oe, ve) | 0, m = (m = m + Math.imul(oe, Oe) | 0) + Math.imul(ae, ve) | 0, v = v + Math.imul(ae, Oe) | 0;
    var et = (L + (b = b + Math.imul(Y, be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Pe) | 0) + Math.imul(ne, be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Pe) | 0) + (m >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, b = Math.imul(h, fe), m = (m = Math.imul(h, pe)) + Math.imul(y, fe) | 0, v = Math.imul(y, pe), b = b + Math.imul(de, me) | 0, m = (m = m + Math.imul(de, Ee) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ee) | 0, b = b + Math.imul(se, ge) | 0, m = (m = m + Math.imul(se, Ae) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, Ae) | 0, b = b + Math.imul(he, $e) | 0, m = (m = m + Math.imul(he, Me) | 0) + Math.imul(_e, $e) | 0, v = v + Math.imul(_e, Me) | 0, b = b + Math.imul(ue, ve) | 0, m = (m = m + Math.imul(ue, Oe) | 0) + Math.imul(le, ve) | 0, v = v + Math.imul(le, Oe) | 0, b = b + Math.imul(oe, be) | 0, m = (m = m + Math.imul(oe, Pe) | 0) + Math.imul(ae, be) | 0, v = v + Math.imul(ae, Pe) | 0;
    var tt = (L + (b = b + Math.imul(Y, Te) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ne) | 0) + Math.imul(ne, Te) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ne) | 0) + (m >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, b = Math.imul(M, fe), m = (m = Math.imul(M, pe)) + Math.imul(x, fe) | 0, v = Math.imul(x, pe), b = b + Math.imul(h, me) | 0, m = (m = m + Math.imul(h, Ee) | 0) + Math.imul(y, me) | 0, v = v + Math.imul(y, Ee) | 0, b = b + Math.imul(de, ge) | 0, m = (m = m + Math.imul(de, Ae) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, Ae) | 0, b = b + Math.imul(se, $e) | 0, m = (m = m + Math.imul(se, Me) | 0) + Math.imul(we, $e) | 0, v = v + Math.imul(we, Me) | 0, b = b + Math.imul(he, ve) | 0, m = (m = m + Math.imul(he, Oe) | 0) + Math.imul(_e, ve) | 0, v = v + Math.imul(_e, Oe) | 0, b = b + Math.imul(ue, be) | 0, m = (m = m + Math.imul(ue, Pe) | 0) + Math.imul(le, be) | 0, v = v + Math.imul(le, Pe) | 0, b = b + Math.imul(oe, Te) | 0, m = (m = m + Math.imul(oe, Ne) | 0) + Math.imul(ae, Te) | 0, v = v + Math.imul(ae, Ne) | 0;
    var rt = (L + (b = b + Math.imul(Y, xe) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ue) | 0) + Math.imul(ne, xe) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ue) | 0) + (m >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, b = Math.imul(G, fe), m = (m = Math.imul(G, pe)) + Math.imul(X, fe) | 0, v = Math.imul(X, pe), b = b + Math.imul(M, me) | 0, m = (m = m + Math.imul(M, Ee) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ee) | 0, b = b + Math.imul(h, ge) | 0, m = (m = m + Math.imul(h, Ae) | 0) + Math.imul(y, ge) | 0, v = v + Math.imul(y, Ae) | 0, b = b + Math.imul(de, $e) | 0, m = (m = m + Math.imul(de, Me) | 0) + Math.imul(ke, $e) | 0, v = v + Math.imul(ke, Me) | 0, b = b + Math.imul(se, ve) | 0, m = (m = m + Math.imul(se, Oe) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Oe) | 0, b = b + Math.imul(he, be) | 0, m = (m = m + Math.imul(he, Pe) | 0) + Math.imul(_e, be) | 0, v = v + Math.imul(_e, Pe) | 0, b = b + Math.imul(ue, Te) | 0, m = (m = m + Math.imul(ue, Ne) | 0) + Math.imul(le, Te) | 0, v = v + Math.imul(le, Ne) | 0, b = b + Math.imul(oe, xe) | 0, m = (m = m + Math.imul(oe, Ue) | 0) + Math.imul(ae, xe) | 0, v = v + Math.imul(ae, Ue) | 0;
    var nt = (L + (b = b + Math.imul(Y, Be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, je) | 0) + Math.imul(ne, Be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, je) | 0) + (m >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, b = Math.imul(ee, fe), m = (m = Math.imul(ee, pe)) + Math.imul(re, fe) | 0, v = Math.imul(re, pe), b = b + Math.imul(G, me) | 0, m = (m = m + Math.imul(G, Ee) | 0) + Math.imul(X, me) | 0, v = v + Math.imul(X, Ee) | 0, b = b + Math.imul(M, ge) | 0, m = (m = m + Math.imul(M, Ae) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, Ae) | 0, b = b + Math.imul(h, $e) | 0, m = (m = m + Math.imul(h, Me) | 0) + Math.imul(y, $e) | 0, v = v + Math.imul(y, Me) | 0, b = b + Math.imul(de, ve) | 0, m = (m = m + Math.imul(de, Oe) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Oe) | 0, b = b + Math.imul(se, be) | 0, m = (m = m + Math.imul(se, Pe) | 0) + Math.imul(we, be) | 0, v = v + Math.imul(we, Pe) | 0, b = b + Math.imul(he, Te) | 0, m = (m = m + Math.imul(he, Ne) | 0) + Math.imul(_e, Te) | 0, v = v + Math.imul(_e, Ne) | 0, b = b + Math.imul(ue, xe) | 0, m = (m = m + Math.imul(ue, Ue) | 0) + Math.imul(le, xe) | 0, v = v + Math.imul(le, Ue) | 0, b = b + Math.imul(oe, Be) | 0, m = (m = m + Math.imul(oe, je) | 0) + Math.imul(ae, Be) | 0, v = v + Math.imul(ae, je) | 0;
    var it = (L + (b = b + Math.imul(Y, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, De) | 0) + Math.imul(ne, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, De) | 0) + (m >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, b = Math.imul(ee, me), m = (m = Math.imul(ee, Ee)) + Math.imul(re, me) | 0, v = Math.imul(re, Ee), b = b + Math.imul(G, ge) | 0, m = (m = m + Math.imul(G, Ae) | 0) + Math.imul(X, ge) | 0, v = v + Math.imul(X, Ae) | 0, b = b + Math.imul(M, $e) | 0, m = (m = m + Math.imul(M, Me) | 0) + Math.imul(x, $e) | 0, v = v + Math.imul(x, Me) | 0, b = b + Math.imul(h, ve) | 0, m = (m = m + Math.imul(h, Oe) | 0) + Math.imul(y, ve) | 0, v = v + Math.imul(y, Oe) | 0, b = b + Math.imul(de, be) | 0, m = (m = m + Math.imul(de, Pe) | 0) + Math.imul(ke, be) | 0, v = v + Math.imul(ke, Pe) | 0, b = b + Math.imul(se, Te) | 0, m = (m = m + Math.imul(se, Ne) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Ne) | 0, b = b + Math.imul(he, xe) | 0, m = (m = m + Math.imul(he, Ue) | 0) + Math.imul(_e, xe) | 0, v = v + Math.imul(_e, Ue) | 0, b = b + Math.imul(ue, Be) | 0, m = (m = m + Math.imul(ue, je) | 0) + Math.imul(le, Be) | 0, v = v + Math.imul(le, je) | 0;
    var ot = (L + (b = b + Math.imul(oe, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(oe, De) | 0) + Math.imul(ae, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ae, De) | 0) + (m >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, b = Math.imul(ee, ge), m = (m = Math.imul(ee, Ae)) + Math.imul(re, ge) | 0, v = Math.imul(re, Ae), b = b + Math.imul(G, $e) | 0, m = (m = m + Math.imul(G, Me) | 0) + Math.imul(X, $e) | 0, v = v + Math.imul(X, Me) | 0, b = b + Math.imul(M, ve) | 0, m = (m = m + Math.imul(M, Oe) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Oe) | 0, b = b + Math.imul(h, be) | 0, m = (m = m + Math.imul(h, Pe) | 0) + Math.imul(y, be) | 0, v = v + Math.imul(y, Pe) | 0, b = b + Math.imul(de, Te) | 0, m = (m = m + Math.imul(de, Ne) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Ne) | 0, b = b + Math.imul(se, xe) | 0, m = (m = m + Math.imul(se, Ue) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ue) | 0, b = b + Math.imul(he, Be) | 0, m = (m = m + Math.imul(he, je) | 0) + Math.imul(_e, Be) | 0, v = v + Math.imul(_e, je) | 0;
    var at = (L + (b = b + Math.imul(ue, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(ue, De) | 0) + Math.imul(le, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(le, De) | 0) + (m >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, b = Math.imul(ee, $e), m = (m = Math.imul(ee, Me)) + Math.imul(re, $e) | 0, v = Math.imul(re, Me), b = b + Math.imul(G, ve) | 0, m = (m = m + Math.imul(G, Oe) | 0) + Math.imul(X, ve) | 0, v = v + Math.imul(X, Oe) | 0, b = b + Math.imul(M, be) | 0, m = (m = m + Math.imul(M, Pe) | 0) + Math.imul(x, be) | 0, v = v + Math.imul(x, Pe) | 0, b = b + Math.imul(h, Te) | 0, m = (m = m + Math.imul(h, Ne) | 0) + Math.imul(y, Te) | 0, v = v + Math.imul(y, Ne) | 0, b = b + Math.imul(de, xe) | 0, m = (m = m + Math.imul(de, Ue) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ue) | 0, b = b + Math.imul(se, Be) | 0, m = (m = m + Math.imul(se, je) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, je) | 0;
    var st = (L + (b = b + Math.imul(he, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(he, De) | 0) + Math.imul(_e, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(_e, De) | 0) + (m >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, b = Math.imul(ee, ve), m = (m = Math.imul(ee, Oe)) + Math.imul(re, ve) | 0, v = Math.imul(re, Oe), b = b + Math.imul(G, be) | 0, m = (m = m + Math.imul(G, Pe) | 0) + Math.imul(X, be) | 0, v = v + Math.imul(X, Pe) | 0, b = b + Math.imul(M, Te) | 0, m = (m = m + Math.imul(M, Ne) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Ne) | 0, b = b + Math.imul(h, xe) | 0, m = (m = m + Math.imul(h, Ue) | 0) + Math.imul(y, xe) | 0, v = v + Math.imul(y, Ue) | 0, b = b + Math.imul(de, Be) | 0, m = (m = m + Math.imul(de, je) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (L + (b = b + Math.imul(se, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(se, De) | 0) + Math.imul(we, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(we, De) | 0) + (m >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, b = Math.imul(ee, be), m = (m = Math.imul(ee, Pe)) + Math.imul(re, be) | 0, v = Math.imul(re, Pe), b = b + Math.imul(G, Te) | 0, m = (m = m + Math.imul(G, Ne) | 0) + Math.imul(X, Te) | 0, v = v + Math.imul(X, Ne) | 0, b = b + Math.imul(M, xe) | 0, m = (m = m + Math.imul(M, Ue) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ue) | 0, b = b + Math.imul(h, Be) | 0, m = (m = m + Math.imul(h, je) | 0) + Math.imul(y, Be) | 0, v = v + Math.imul(y, je) | 0;
    var ct = (L + (b = b + Math.imul(de, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(de, De) | 0) + Math.imul(ke, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ke, De) | 0) + (m >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, b = Math.imul(ee, Te), m = (m = Math.imul(ee, Ne)) + Math.imul(re, Te) | 0, v = Math.imul(re, Ne), b = b + Math.imul(G, xe) | 0, m = (m = m + Math.imul(G, Ue) | 0) + Math.imul(X, xe) | 0, v = v + Math.imul(X, Ue) | 0, b = b + Math.imul(M, Be) | 0, m = (m = m + Math.imul(M, je) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (L + (b = b + Math.imul(h, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(h, De) | 0) + Math.imul(y, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(y, De) | 0) + (m >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, b = Math.imul(ee, xe), m = (m = Math.imul(ee, Ue)) + Math.imul(re, xe) | 0, v = Math.imul(re, Ue), b = b + Math.imul(G, Be) | 0, m = (m = m + Math.imul(G, je) | 0) + Math.imul(X, Be) | 0, v = v + Math.imul(X, je) | 0;
    var ht = (L + (b = b + Math.imul(M, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(M, De) | 0) + Math.imul(x, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(x, De) | 0) + (m >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, b = Math.imul(ee, Be), m = (m = Math.imul(ee, je)) + Math.imul(re, Be) | 0, v = Math.imul(re, je);
    var dt = (L + (b = b + Math.imul(G, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(G, De) | 0) + Math.imul(X, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(X, De) | 0) + (m >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (L + (b = Math.imul(ee, Ie)) | 0) + ((8191 & (m = (m = Math.imul(ee, De)) + Math.imul(re, Ie) | 0)) << 13) | 0;
    return L = ((v = Math.imul(re, De)) + (m >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, j[0] = Ge, j[1] = Ke, j[2] = Ye, j[3] = Ze, j[4] = Qe, j[5] = et, j[6] = tt, j[7] = rt, j[8] = nt, j[9] = it, j[10] = ot, j[11] = at, j[12] = st, j[13] = ut, j[14] = ct, j[15] = ft, j[16] = ht, j[17] = dt, j[18] = pt, L !== 0 && (j[19] = L, _.length++), _;
  };
  function q(g, $, _) {
    return new D().mulp(g, $, _);
  }
  function D(g, $) {
    this.x = g, this.y = $;
  }
  Math.imul || (P = C), c.prototype.mulTo = function(g, $) {
    var _, b = this.length + g.length;
    return _ = this.length === 10 && g.length === 10 ? P(this, g, $) : b < 63 ? C(this, g, $) : b < 1024 ? function(m, v, E) {
      E.negative = v.negative ^ m.negative, E.length = m.length + v.length;
      for (var T = 0, j = 0, L = 0; L < E.length - 1; L++) {
        var J = j;
        j = 0;
        for (var Y = 67108863 & T, ne = Math.min(L, v.length - 1), Q = Math.max(0, L - m.length + 1); Q <= ne; Q++) {
          var oe = L - Q, ae = (0 | m.words[oe]) * (0 | v.words[Q]), ce = 67108863 & ae;
          Y = 67108863 & (ce = ce + Y | 0), j += (J = (J = J + (ae / 67108864 | 0) | 0) + (ce >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[L] = Y, T = J, J = j;
      }
      return T !== 0 ? E.words[L] = T : E.length--, E.strip();
    }(this, g, $) : q(this, g, $), _;
  }, D.prototype.makeRBT = function(g) {
    for (var $ = new Array(g), _ = c.prototype._countBits(g) - 1, b = 0; b < g; b++)
      $[b] = this.revBin(b, _, g);
    return $;
  }, D.prototype.revBin = function(g, $, _) {
    if (g === 0 || g === _ - 1)
      return g;
    for (var b = 0, m = 0; m < $; m++)
      b |= (1 & g) << $ - m - 1, g >>= 1;
    return b;
  }, D.prototype.permute = function(g, $, _, b, m, v) {
    for (var E = 0; E < v; E++)
      b[E] = $[g[E]], m[E] = _[g[E]];
  }, D.prototype.transform = function(g, $, _, b, m, v) {
    this.permute(v, g, $, _, b, m);
    for (var E = 1; E < m; E <<= 1)
      for (var T = E << 1, j = Math.cos(2 * Math.PI / T), L = Math.sin(2 * Math.PI / T), J = 0; J < m; J += T)
        for (var Y = j, ne = L, Q = 0; Q < E; Q++) {
          var oe = _[J + Q], ae = b[J + Q], ce = _[J + Q + E], ue = b[J + Q + E], le = Y * ce - ne * ue;
          ue = Y * ue + ne * ce, ce = le, _[J + Q] = oe + ce, b[J + Q] = ae + ue, _[J + Q + E] = oe - ce, b[J + Q + E] = ae - ue, Q !== T && (le = j * Y - L * ne, ne = j * ne + L * Y, Y = le);
        }
  }, D.prototype.guessLen13b = function(g, $) {
    var _ = 1 | Math.max($, g), b = 1 & _, m = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      m++;
    return 1 << m + 1 + b;
  }, D.prototype.conjugate = function(g, $, _) {
    if (!(_ <= 1))
      for (var b = 0; b < _ / 2; b++) {
        var m = g[b];
        g[b] = g[_ - b - 1], g[_ - b - 1] = m, m = $[b], $[b] = -$[_ - b - 1], $[_ - b - 1] = -m;
      }
  }, D.prototype.normalize13b = function(g, $) {
    for (var _ = 0, b = 0; b < $ / 2; b++) {
      var m = 8192 * Math.round(g[2 * b + 1] / $) + Math.round(g[2 * b] / $) + _;
      g[b] = 67108863 & m, _ = m < 67108864 ? 0 : m / 67108864 | 0;
    }
    return g;
  }, D.prototype.convert13b = function(g, $, _, b) {
    for (var m = 0, v = 0; v < $; v++)
      m += 0 | g[v], _[2 * v] = 8191 & m, m >>>= 13, _[2 * v + 1] = 8191 & m, m >>>= 13;
    for (v = 2 * $; v < b; ++v)
      _[v] = 0;
    a(m === 0), a((-8192 & m) == 0);
  }, D.prototype.stub = function(g) {
    for (var $ = new Array(g), _ = 0; _ < g; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(g, $, _) {
    var b = 2 * this.guessLen13b(g.length, $.length), m = this.makeRBT(b), v = this.stub(b), E = new Array(b), T = new Array(b), j = new Array(b), L = new Array(b), J = new Array(b), Y = new Array(b), ne = _.words;
    ne.length = b, this.convert13b(g.words, g.length, E, b), this.convert13b($.words, $.length, L, b), this.transform(E, v, T, j, b, m), this.transform(L, v, J, Y, b, m);
    for (var Q = 0; Q < b; Q++) {
      var oe = T[Q] * J[Q] - j[Q] * Y[Q];
      j[Q] = T[Q] * Y[Q] + j[Q] * J[Q], T[Q] = oe;
    }
    return this.conjugate(T, j, b), this.transform(T, j, ne, v, b, m), this.conjugate(ne, v, b), this.normalize13b(ne, b), _.negative = g.negative ^ $.negative, _.length = g.length + $.length, _.strip();
  }, c.prototype.mul = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), this.mulTo(g, $);
  }, c.prototype.mulf = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), q(this, g, $);
  }, c.prototype.imul = function(g) {
    return this.clone().mulTo(g, this);
  }, c.prototype.imuln = function(g) {
    a(typeof g == "number"), a(g < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var b = (0 | this.words[_]) * g, m = (67108863 & b) + (67108863 & $);
      $ >>= 26, $ += b / 67108864 | 0, $ += m >>> 26, this.words[_] = 67108863 & m;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(g) {
    return this.clone().imuln(g);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(g) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), T = 0; T < E.length; T++) {
        var j = T / 26 | 0, L = T % 26;
        E[T] = (v.words[j] & 1 << L) >>> L;
      }
      return E;
    }(g);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, b = 0; b < $.length && $[b] === 0; b++, _ = _.sqr())
      ;
    if (++b < $.length)
      for (var m = _.sqr(); b < $.length; b++, m = m.sqr())
        $[b] !== 0 && (_ = _.mul(m));
    return _;
  }, c.prototype.iushln = function(g) {
    a(typeof g == "number" && g >= 0);
    var $, _ = g % 26, b = (g - _) / 26, m = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & m, T = (0 | this.words[$]) - E << _;
        this.words[$] = T | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (b !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + b] = this.words[$];
      for ($ = 0; $ < b; $++)
        this.words[$] = 0;
      this.length += b;
    }
    return this.strip();
  }, c.prototype.ishln = function(g) {
    return a(this.negative === 0), this.iushln(g);
  }, c.prototype.iushrn = function(g, $, _) {
    var b;
    a(typeof g == "number" && g >= 0), b = $ ? ($ - $ % 26) / 26 : 0;
    var m = g % 26, v = Math.min((g - m) / 26, this.length), E = 67108863 ^ 67108863 >>> m << m, T = _;
    if (b -= v, b = Math.max(0, b), T) {
      for (var j = 0; j < v; j++)
        T.words[j] = this.words[j];
      T.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, j = 0; j < this.length; j++)
          this.words[j] = this.words[j + v];
      else
        this.words[0] = 0, this.length = 1;
    var L = 0;
    for (j = this.length - 1; j >= 0 && (L !== 0 || j >= b); j--) {
      var J = 0 | this.words[j];
      this.words[j] = L << 26 - m | J >>> m, L = J & E;
    }
    return T && L !== 0 && (T.words[T.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(g, $, _) {
    return a(this.negative === 0), this.iushrn(g, $, _);
  }, c.prototype.shln = function(g) {
    return this.clone().ishln(g);
  }, c.prototype.ushln = function(g) {
    return this.clone().iushln(g);
  }, c.prototype.shrn = function(g) {
    return this.clone().ishrn(g);
  }, c.prototype.ushrn = function(g) {
    return this.clone().iushrn(g);
  }, c.prototype.testn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    return !(this.length <= _ || !(this.words[_] & b));
  }, c.prototype.imaskn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var b = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= b;
    }
    return this.strip();
  }, c.prototype.maskn = function(g) {
    return this.clone().imaskn(g);
  }, c.prototype.iaddn = function(g) {
    return a(typeof g == "number"), a(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < g ? (this.words[0] = g - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
  }, c.prototype._iaddn = function(g) {
    this.words[0] += g;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(g) {
    if (a(typeof g == "number"), a(g < 67108864), g < 0)
      return this.iaddn(-g);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(g), this.negative = 1, this;
    if (this.words[0] -= g, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(g) {
    return this.clone().iaddn(g);
  }, c.prototype.subn = function(g) {
    return this.clone().isubn(g);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(g, $, _) {
    var b, m, v = g.length + _;
    this._expand(v);
    var E = 0;
    for (b = 0; b < g.length; b++) {
      m = (0 | this.words[b + _]) + E;
      var T = (0 | g.words[b]) * $;
      E = ((m -= 67108863 & T) >> 26) - (T / 67108864 | 0), this.words[b + _] = 67108863 & m;
    }
    for (; b < this.length - _; b++)
      E = (m = (0 | this.words[b + _]) + E) >> 26, this.words[b + _] = 67108863 & m;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, b = 0; b < this.length; b++)
      E = (m = -(0 | this.words[b]) + E) >> 26, this.words[b] = 67108863 & m;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(g, $) {
    var _ = (this.length, g.length), b = this.clone(), m = g, v = 0 | m.words[m.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (m = m.ushln(_), b.iushln(_), v = 0 | m.words[m.length - 1]);
    var E, T = b.length - m.length;
    if ($ !== "mod") {
      (E = new c(null)).length = T + 1, E.words = new Array(E.length);
      for (var j = 0; j < E.length; j++)
        E.words[j] = 0;
    }
    var L = b.clone()._ishlnsubmul(m, 1, T);
    L.negative === 0 && (b = L, E && (E.words[T] = 1));
    for (var J = T - 1; J >= 0; J--) {
      var Y = 67108864 * (0 | b.words[m.length + J]) + (0 | b.words[m.length + J - 1]);
      for (Y = Math.min(Y / v | 0, 67108863), b._ishlnsubmul(m, Y, J); b.negative !== 0; )
        Y--, b.negative = 0, b._ishlnsubmul(m, 1, J), b.isZero() || (b.negative ^= 1);
      E && (E.words[J] = Y);
    }
    return E && E.strip(), b.strip(), $ !== "div" && _ !== 0 && b.iushrn(_), { div: E || null, mod: b };
  }, c.prototype.divmod = function(g, $, _) {
    return a(!g.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && g.negative === 0 ? (v = this.neg().divmod(g, $), $ !== "mod" && (b = v.div.neg()), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.iadd(g)), { div: b, mod: m }) : this.negative === 0 && g.negative !== 0 ? (v = this.divmod(g.neg(), $), $ !== "mod" && (b = v.div.neg()), { div: b, mod: v.mod }) : (this.negative & g.negative) != 0 ? (v = this.neg().divmod(g.neg(), $), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.isub(g)), { div: v.div, mod: m }) : g.length > this.length || this.cmp(g) < 0 ? { div: new c(0), mod: this } : g.length === 1 ? $ === "div" ? { div: this.divn(g.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new c(this.modn(g.words[0])) } : this._wordDiv(g, $);
    var b, m, v;
  }, c.prototype.div = function(g) {
    return this.divmod(g, "div", !1).div;
  }, c.prototype.mod = function(g) {
    return this.divmod(g, "mod", !1).mod;
  }, c.prototype.umod = function(g) {
    return this.divmod(g, "mod", !0).mod;
  }, c.prototype.divRound = function(g) {
    var $ = this.divmod(g);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(g) : $.mod, b = g.ushrn(1), m = g.andln(1), v = _.cmp(b);
    return v < 0 || m === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(g) {
    a(g <= 67108863);
    for (var $ = (1 << 26) % g, _ = 0, b = this.length - 1; b >= 0; b--)
      _ = ($ * _ + (0 | this.words[b])) % g;
    return _;
  }, c.prototype.idivn = function(g) {
    a(g <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = b / g | 0, $ = b % g;
    }
    return this.strip();
  }, c.prototype.divn = function(g) {
    return this.clone().idivn(g);
  }, c.prototype.egcd = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b = new c(1), m = new c(0), v = new c(0), E = new c(1), T = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++T;
    for (var j = _.clone(), L = $.clone(); !$.isZero(); ) {
      for (var J = 0, Y = 1; ($.words[0] & Y) == 0 && J < 26; ++J, Y <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (b.isOdd() || m.isOdd()) && (b.iadd(j), m.isub(L)), b.iushrn(1), m.iushrn(1);
      for (var ne = 0, Q = 1; (_.words[0] & Q) == 0 && ne < 26; ++ne, Q <<= 1)
        ;
      if (ne > 0)
        for (_.iushrn(ne); ne-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(j), E.isub(L)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), b.isub(v), m.isub(E)) : (_.isub($), v.isub(b), E.isub(m));
    }
    return { a: v, b: E, gcd: _.iushln(T) };
  }, c.prototype._invmp = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b, m = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var T = 0, j = 1; ($.words[0] & j) == 0 && T < 26; ++T, j <<= 1)
        ;
      if (T > 0)
        for ($.iushrn(T); T-- > 0; )
          m.isOdd() && m.iadd(E), m.iushrn(1);
      for (var L = 0, J = 1; (_.words[0] & J) == 0 && L < 26; ++L, J <<= 1)
        ;
      if (L > 0)
        for (_.iushrn(L); L-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), m.isub(v)) : (_.isub($), v.isub(m));
    }
    return (b = $.cmpn(1) === 0 ? m : v).cmpn(0) < 0 && b.iadd(g), b;
  }, c.prototype.gcd = function(g) {
    if (this.isZero())
      return g.abs();
    if (g.isZero())
      return this.abs();
    var $ = this.clone(), _ = g.clone();
    $.negative = 0, _.negative = 0;
    for (var b = 0; $.isEven() && _.isEven(); b++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var m = $.cmp(_);
      if (m < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (m === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(b);
  }, c.prototype.invm = function(g) {
    return this.egcd(g).a.umod(g);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(g) {
    return this.words[0] & g;
  }, c.prototype.bincn = function(g) {
    a(typeof g == "number");
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= b, this;
    for (var m = b, v = _; m !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      m = (E += m) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return m !== 0 && (this.words[v] = m, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(g) {
    var $, _ = g < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (g = -g), a(g <= 67108863, "Number is too big");
      var b = 0 | this.words[0];
      $ = b === g ? 0 : b < g ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(g) {
    if (this.negative !== 0 && g.negative === 0)
      return -1;
    if (this.negative === 0 && g.negative !== 0)
      return 1;
    var $ = this.ucmp(g);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(g) {
    if (this.length > g.length)
      return 1;
    if (this.length < g.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = 0 | this.words[_], m = 0 | g.words[_];
      if (b !== m) {
        b < m ? $ = -1 : b > m && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(g) {
    return this.cmpn(g) === 1;
  }, c.prototype.gt = function(g) {
    return this.cmp(g) === 1;
  }, c.prototype.gten = function(g) {
    return this.cmpn(g) >= 0;
  }, c.prototype.gte = function(g) {
    return this.cmp(g) >= 0;
  }, c.prototype.ltn = function(g) {
    return this.cmpn(g) === -1;
  }, c.prototype.lt = function(g) {
    return this.cmp(g) === -1;
  }, c.prototype.lten = function(g) {
    return this.cmpn(g) <= 0;
  }, c.prototype.lte = function(g) {
    return this.cmp(g) <= 0;
  }, c.prototype.eqn = function(g) {
    return this.cmpn(g) === 0;
  }, c.prototype.eq = function(g) {
    return this.cmp(g) === 0;
  }, c.red = function(g) {
    return new H(g);
  }, c.prototype.toRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(g) {
    return this.red = g, this;
  }, c.prototype.forceRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(g);
  }, c.prototype.redAdd = function(g) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
  }, c.prototype.redIAdd = function(g) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
  }, c.prototype.redSub = function(g) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
  }, c.prototype.redISub = function(g) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
  }, c.prototype.redShl = function(g) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
  }, c.prototype.redMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
  }, c.prototype.redIMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(g) {
    return a(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function F(g, $) {
    this.name = g, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    F.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Z() {
    F.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function N() {
    F.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function W() {
    F.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(g) {
    if (typeof g == "string") {
      var $ = c._prime(g);
      this.m = $.p, this.prime = $;
    } else
      a(g.gtn(1), "modulus must be greater than 1"), this.m = g, this.prime = null;
  }
  function te(g) {
    H.call(this, g), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  F.prototype._tmp = function() {
    var g = new c(null);
    return g.words = new Array(Math.ceil(this.n / 13)), g;
  }, F.prototype.ireduce = function(g) {
    var $, _ = g;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var b = $ < this.n ? -1 : _.ucmp(this.p);
    return b === 0 ? (_.words[0] = 0, _.length = 1) : b > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, F.prototype.split = function(g, $) {
    g.iushrn(this.n, 0, $);
  }, F.prototype.imulK = function(g) {
    return g.imul(this.k);
  }, u(V, F), V.prototype.split = function(g, $) {
    for (var _ = 4194303, b = Math.min(g.length, 9), m = 0; m < b; m++)
      $.words[m] = g.words[m];
    if ($.length = b, g.length <= 9)
      return g.words[0] = 0, void (g.length = 1);
    var v = g.words[9];
    for ($.words[$.length++] = v & _, m = 10; m < g.length; m++) {
      var E = 0 | g.words[m];
      g.words[m - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, g.words[m - 10] = v, v === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
  }, V.prototype.imulK = function(g) {
    g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 0 | g.words[_];
      $ += 977 * b, g.words[_] = 67108863 & $, $ = 64 * b + ($ / 67108864 | 0);
    }
    return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
  }, u(Z, F), u(N, F), u(W, F), W.prototype.imulK = function(g) {
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 19 * (0 | g.words[_]) + $, m = 67108863 & b;
      b >>>= 26, g.words[_] = m, $ = b;
    }
    return $ !== 0 && (g.words[g.length++] = $), g;
  }, c._prime = function(g) {
    if (z[g])
      return z[g];
    var $;
    if (g === "k256")
      $ = new V();
    else if (g === "p224")
      $ = new Z();
    else if (g === "p192")
      $ = new N();
    else {
      if (g !== "p25519")
        throw new Error("Unknown prime " + g);
      $ = new W();
    }
    return z[g] = $, $;
  }, H.prototype._verify1 = function(g) {
    a(g.negative === 0, "red works only with positives"), a(g.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(g, $) {
    a((g.negative | $.negative) == 0, "red works only with positives"), a(g.red && g.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(g) {
    return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(g) {
    return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
  }, H.prototype.add = function(g, $) {
    this._verify2(g, $);
    var _ = g.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(g, $) {
    this._verify2(g, $);
    var _ = g.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(g, $) {
    this._verify2(g, $);
    var _ = g.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(g, $) {
    this._verify2(g, $);
    var _ = g.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(g, $) {
    return this._verify1(g), this.imod(g.ushln($));
  }, H.prototype.imul = function(g, $) {
    return this._verify2(g, $), this.imod(g.imul($));
  }, H.prototype.mul = function(g, $) {
    return this._verify2(g, $), this.imod(g.mul($));
  }, H.prototype.isqr = function(g) {
    return this.imul(g, g.clone());
  }, H.prototype.sqr = function(g) {
    return this.mul(g, g);
  }, H.prototype.sqrt = function(g) {
    if (g.isZero())
      return g.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(g, _);
    }
    for (var b = this.m.subn(1), m = 0; !b.isZero() && b.andln(1) === 0; )
      m++, b.iushrn(1);
    a(!b.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), T = this.m.subn(1).iushrn(1), j = this.m.bitLength();
    for (j = new c(2 * j * j).toRed(this); this.pow(j, T).cmp(E) !== 0; )
      j.redIAdd(E);
    for (var L = this.pow(j, b), J = this.pow(g, b.addn(1).iushrn(1)), Y = this.pow(g, b), ne = m; Y.cmp(v) !== 0; ) {
      for (var Q = Y, oe = 0; Q.cmp(v) !== 0; oe++)
        Q = Q.redSqr();
      a(oe < ne);
      var ae = this.pow(L, new c(1).iushln(ne - oe - 1));
      J = J.redMul(ae), L = ae.redSqr(), Y = Y.redMul(L), ne = oe;
    }
    return J;
  }, H.prototype.invm = function(g) {
    var $ = g._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(g, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return g.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = g;
    for (var b = 2; b < _.length; b++)
      _[b] = this.mul(_[b - 1], g);
    var m = _[0], v = 0, E = 0, T = $.bitLength() % 26;
    for (T === 0 && (T = 26), b = $.length - 1; b >= 0; b--) {
      for (var j = $.words[b], L = T - 1; L >= 0; L--) {
        var J = j >> L & 1;
        m !== _[0] && (m = this.sqr(m)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || b === 0 && L === 0) && (m = this.mul(m, _[v]), E = 0, v = 0)) : E = 0;
      }
      T = 26;
    }
    return m;
  }, H.prototype.convertTo = function(g) {
    var $ = g.umod(this.m);
    return $ === g ? $.clone() : $;
  }, H.prototype.convertFrom = function(g) {
    var $ = g.clone();
    return $.red = null, $;
  }, c.mont = function(g) {
    return new te(g);
  }, u(te, H), te.prototype.convertTo = function(g) {
    return this.imod(g.ushln(this.shift));
  }, te.prototype.convertFrom = function(g) {
    var $ = this.imod(g.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(g, $) {
    if (g.isZero() || $.isZero())
      return g.words[0] = 0, g.length = 1, g;
    var _ = g.imul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(g, $) {
    if (g.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = g.mul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(g) {
    return this.imod(g._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var api = {}, encoders = {}, buffer$6 = {}, ieee754 = {
  read: function(n, o, a, u, c) {
    var p, d, w = 8 * c - u - 1, S = (1 << w) - 1, k = S >> 1, B = -7, I = a ? c - 1 : 0, C = a ? -1 : 1, P = n[o + I];
    for (I += C, p = P & (1 << -B) - 1, P >>= -B, B += w; B > 0; p = 256 * p + n[o + I], I += C, B -= 8)
      ;
    for (d = p & (1 << -B) - 1, p >>= -B, B += u; B > 0; d = 256 * d + n[o + I], I += C, B -= 8)
      ;
    if (p === 0)
      p = 1 - k;
    else {
      if (p === S)
        return d ? NaN : 1 / 0 * (P ? -1 : 1);
      d += Math.pow(2, u), p -= k;
    }
    return (P ? -1 : 1) * d * Math.pow(2, p - u);
  },
  write: function(n, o, a, u, c, p) {
    var d, w, S, k = 8 * p - c - 1, B = (1 << k) - 1, I = B >> 1, C = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, P = u ? 0 : p - 1, q = u ? 1 : -1, D = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
    for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, d = B) : (d = Math.floor(Math.log(o) / Math.LN2), o * (S = Math.pow(2, -d)) < 1 && (d--, S *= 2), (o += d + I >= 1 ? C / S : C * Math.pow(2, 1 - I)) * S >= 2 && (d++, S /= 2), d + I >= B ? (w = 0, d = B) : d + I >= 1 ? (w = (o * S - 1) * Math.pow(2, c), d += I) : (w = o * Math.pow(2, I - 1) * Math.pow(2, c), d = 0)); c >= 8; n[a + P] = 255 & w, P += q, w /= 256, c -= 8)
      ;
    for (d = d << c | w, k += c; k > 0; n[a + P] = 255 & d, P += q, d /= 256, k -= 8)
      ;
    n[a + P - q] |= 128 * D;
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const o = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = d, n.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function p(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, y) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return k(l);
    }
    return w(l, h, y);
  }
  function w(l, h, y) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | P(x, O);
        let X = p(G);
        const ie = X.write(x, O);
        return ie !== G && (X = X.slice(0, ie)), X;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (se(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (se(l, ArrayBuffer) || l && se(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (se(l, SharedArrayBuffer) || l && se(l.buffer, SharedArrayBuffer)))
      return I(l, h, y);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const A = l.valueOf && l.valueOf();
    if (A != null && A !== l)
      return d.from(A, h, y);
    const M = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = p(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? p(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (M)
      return M;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, y);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function k(l) {
    return S(l), p(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), y = p(h);
    for (let A = 0; A < h; A += 1)
      y[A] = 255 & l[A];
    return y;
  }
  function I(l, h, y) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (y || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return A = h === void 0 && y === void 0 ? new Uint8Array(l) : y === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, y), Object.setPrototypeOf(A, d.prototype), A;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function P(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || se(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const y = l.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && y === 0)
      return 0;
    let M = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return y;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * y;
        case "hex":
          return y >>> 1;
        case "base64":
          return _e(l).length;
        default:
          if (M)
            return A ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), M = !0;
      }
  }
  function q(l, h, y) {
    let A = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return m(this, h, y);
        case "utf8":
        case "utf-8":
          return g(this, h, y);
        case "ascii":
          return _(this, h, y);
        case "latin1":
        case "binary":
          return b(this, h, y);
        case "base64":
          return te(this, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, y);
        default:
          if (A)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), A = !0;
      }
  }
  function D(l, h, y) {
    const A = l[h];
    l[h] = l[y], l[y] = A;
  }
  function z(l, h, y, A, M) {
    if (l.length === 0)
      return -1;
    if (typeof y == "string" ? (A = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), we(y = +y) && (y = M ? 0 : l.length - 1), y < 0 && (y = l.length + y), y >= l.length) {
      if (M)
        return -1;
      y = l.length - 1;
    } else if (y < 0) {
      if (!M)
        return -1;
      y = 0;
    }
    if (typeof h == "string" && (h = d.from(h, A)), d.isBuffer(h))
      return h.length === 0 ? -1 : F(l, h, y, A, M);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? M ? Uint8Array.prototype.indexOf.call(l, h, y) : Uint8Array.prototype.lastIndexOf.call(l, h, y) : F(l, [h], y, A, M);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(l, h, y, A, M) {
    let x, O = 1, G = l.length, X = h.length;
    if (A !== void 0 && ((A = String(A).toLowerCase()) === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, X /= 2, y /= 2;
    }
    function ie(ee, re) {
      return O === 1 ? ee[re] : ee.readUInt16BE(re * O);
    }
    if (M) {
      let ee = -1;
      for (x = y; x < G; x++)
        if (ie(l, x) === ie(h, ee === -1 ? 0 : x - ee)) {
          if (ee === -1 && (ee = x), x - ee + 1 === X)
            return ee * O;
        } else
          ee !== -1 && (x -= x - ee), ee = -1;
    } else
      for (y + X > G && (y = G - X), x = y; x >= 0; x--) {
        let ee = !0;
        for (let re = 0; re < X; re++)
          if (ie(l, x + re) !== ie(h, re)) {
            ee = !1;
            break;
          }
        if (ee)
          return x;
      }
    return -1;
  }
  function V(l, h, y, A) {
    y = Number(y) || 0;
    const M = l.length - y;
    A ? (A = Number(A)) > M && (A = M) : A = M;
    const x = h.length;
    let O;
    for (A > x / 2 && (A = x / 2), O = 0; O < A; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[y + O] = G;
    }
    return O;
  }
  function Z(l, h, y, A) {
    return Le(he(h, l.length - y), l, y, A);
  }
  function N(l, h, y, A) {
    return Le(function(M) {
      const x = [];
      for (let O = 0; O < M.length; ++O)
        x.push(255 & M.charCodeAt(O));
      return x;
    }(h), l, y, A);
  }
  function W(l, h, y, A) {
    return Le(_e(h), l, y, A);
  }
  function H(l, h, y, A) {
    return Le(function(M, x) {
      let O, G, X;
      const ie = [];
      for (let ee = 0; ee < M.length && !((x -= 2) < 0); ++ee)
        O = M.charCodeAt(ee), G = O >> 8, X = O % 256, ie.push(X), ie.push(G);
      return ie;
    }(h, l.length - y), l, y, A);
  }
  function te(l, h, y) {
    return h === 0 && y === l.length ? o.fromByteArray(l) : o.fromByteArray(l.slice(h, y));
  }
  function g(l, h, y) {
    y = Math.min(l.length, y);
    const A = [];
    let M = h;
    for (; M < y; ) {
      const x = l[M];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (M + G <= y) {
        let X, ie, ee, re;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            X = l[M + 1], (192 & X) == 128 && (re = (31 & x) << 6 | 63 & X, re > 127 && (O = re));
            break;
          case 3:
            X = l[M + 1], ie = l[M + 2], (192 & X) == 128 && (192 & ie) == 128 && (re = (15 & x) << 12 | (63 & X) << 6 | 63 & ie, re > 2047 && (re < 55296 || re > 57343) && (O = re));
            break;
          case 4:
            X = l[M + 1], ie = l[M + 2], ee = l[M + 3], (192 & X) == 128 && (192 & ie) == 128 && (192 & ee) == 128 && (re = (15 & x) << 18 | (63 & X) << 12 | (63 & ie) << 6 | 63 & ee, re > 65535 && re < 1114112 && (O = re));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, A.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), A.push(O), M += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", X = 0;
      for (; X < O; )
        G += String.fromCharCode.apply(String, x.slice(X, X += $));
      return G;
    }(A);
  }
  n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, y) {
    return w(l, h, y);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, y) {
    return function(A, M, x) {
      return S(A), A <= 0 ? p(A) : M !== void 0 ? typeof x == "string" ? p(A).fill(M, x) : p(A).fill(M) : p(A);
    }(l, h, y);
  }, d.allocUnsafe = function(l) {
    return k(l);
  }, d.allocUnsafeSlow = function(l) {
    return k(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), se(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let y = l.length, A = h.length;
    for (let M = 0, x = Math.min(y, A); M < x; ++M)
      if (l[M] !== h[M]) {
        y = l[M], A = h[M];
        break;
      }
    return y < A ? -1 : A < y ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let y;
    if (h === void 0)
      for (h = 0, y = 0; y < l.length; ++y)
        h += l[y].length;
    const A = d.allocUnsafe(h);
    let M = 0;
    for (y = 0; y < l.length; ++y) {
      let x = l[y];
      if (se(x, Uint8Array))
        M + x.length > A.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(A, M)) : Uint8Array.prototype.set.call(A, x, M);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(A, M);
      }
      M += x.length;
    }
    return A;
  }, d.byteLength = P, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? g(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = n.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, y, A, M) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), y === void 0 && (y = l ? l.length : 0), A === void 0 && (A = 0), M === void 0 && (M = this.length), h < 0 || y > l.length || A < 0 || M > this.length)
      throw new RangeError("out of range index");
    if (A >= M && h >= y)
      return 0;
    if (A >= M)
      return -1;
    if (h >= y)
      return 1;
    if (this === l)
      return 0;
    let x = (M >>>= 0) - (A >>>= 0), O = (y >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), X = this.slice(A, M), ie = l.slice(h, y);
    for (let ee = 0; ee < G; ++ee)
      if (X[ee] !== ie[ee]) {
        x = X[ee], O = ie[ee];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, y) {
    return this.indexOf(l, h, y) !== -1;
  }, d.prototype.indexOf = function(l, h, y) {
    return z(this, l, h, y, !0);
  }, d.prototype.lastIndexOf = function(l, h, y) {
    return z(this, l, h, y, !1);
  }, d.prototype.write = function(l, h, y, A) {
    if (h === void 0)
      A = "utf8", y = this.length, h = 0;
    else if (y === void 0 && typeof h == "string")
      A = h, y = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(y) ? (y >>>= 0, A === void 0 && (A = "utf8")) : (A = y, y = void 0);
    }
    const M = this.length - h;
    if ((y === void 0 || y > M) && (y = M), l.length > 0 && (y < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    A || (A = "utf8");
    let x = !1;
    for (; ; )
      switch (A) {
        case "hex":
          return V(this, l, h, y);
        case "utf8":
        case "utf-8":
          return Z(this, l, h, y);
        case "ascii":
        case "latin1":
        case "binary":
          return N(this, l, h, y);
        case "base64":
          return W(this, l, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, y);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + A);
          A = ("" + A).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(127 & l[M]);
    return A;
  }
  function b(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(l[M]);
    return A;
  }
  function m(l, h, y) {
    const A = l.length;
    (!h || h < 0) && (h = 0), (!y || y < 0 || y > A) && (y = A);
    let M = "";
    for (let x = h; x < y; ++x)
      M += We[l[x]];
    return M;
  }
  function v(l, h, y) {
    const A = l.slice(h, y);
    let M = "";
    for (let x = 0; x < A.length - 1; x += 2)
      M += String.fromCharCode(A[x] + 256 * A[x + 1]);
    return M;
  }
  function E(l, h, y) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > y)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function T(l, h, y, A, M, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > M || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (y + A > l.length)
      throw new RangeError("Index out of range");
  }
  function j(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, y;
  }
  function L(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y + 7] = x, x >>= 8, l[y + 6] = x, x >>= 8, l[y + 5] = x, x >>= 8, l[y + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y + 3] = O, O >>= 8, l[y + 2] = O, O >>= 8, l[y + 1] = O, O >>= 8, l[y] = O, y + 8;
  }
  function J(l, h, y, A, M, x) {
    if (y + A > l.length)
      throw new RangeError("Index out of range");
    if (y < 0)
      throw new RangeError("Index out of range");
  }
  function Y(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 4), a.write(l, h, y, A, 23, 4), y + 4;
  }
  function ne(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 8), a.write(l, h, y, A, 52, 8), y + 8;
  }
  d.prototype.slice = function(l, h) {
    const y = this.length;
    (l = ~~l) < 0 ? (l += y) < 0 && (l = 0) : l > y && (l = y), (h = h === void 0 ? y : ~~h) < 0 ? (h += y) < 0 && (h = 0) : h > y && (h = y), h < l && (h = l);
    const A = this.subarray(l, h);
    return Object.setPrototypeOf(A, d.prototype), A;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return A;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l + --h], M = 1;
    for (; h > 0 && (M *= 256); )
      A += this[l + --h] * M;
    return A;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, M = this[++l] + 256 * this[++l] + 65536 * this[++l] + y * 2 ** 24;
    return BigInt(A) + (BigInt(M) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], M = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y;
    return (BigInt(A) << BigInt(32)) + BigInt(M);
  }), d.prototype.readIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return M *= 128, A >= M && (A -= Math.pow(2, 8 * h)), A;
  }, d.prototype.readIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = h, M = 1, x = this[l + --A];
    for (; A > 0 && (M *= 256); )
      x += this[l + --A] * M;
    return M *= 128, x >= M && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l] | this[l + 1] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l + 1] | this[l] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (y << 24);
    return (BigInt(A) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = 1, x = 0;
    for (this[h] = 255 & l; ++x < y && (M *= 256); )
      this[h + x] = l / M & 255;
    return h + y;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = y - 1, x = 1;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      this[h + M] = l / x & 255;
    return h + y;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++M < y && (x *= 256); )
      l < 0 && O === 0 && this[h + M - 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeIntBE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = y - 1, x = 1, O = 0;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + M + 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, y) {
    return Y(this, l, h, !0, y);
  }, d.prototype.writeFloatBE = function(l, h, y) {
    return Y(this, l, h, !1, y);
  }, d.prototype.writeDoubleLE = function(l, h, y) {
    return ne(this, l, h, !0, y);
  }, d.prototype.writeDoubleBE = function(l, h, y) {
    return ne(this, l, h, !1, y);
  }, d.prototype.copy = function(l, h, y, A) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (y || (y = 0), A || A === 0 || (A = this.length), h >= l.length && (h = l.length), h || (h = 0), A > 0 && A < y && (A = y), A === y || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (y < 0 || y >= this.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("sourceEnd out of bounds");
    A > this.length && (A = this.length), l.length - h < A - y && (A = l.length - h + y);
    const M = A - y;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, y, A) : Uint8Array.prototype.set.call(l, this.subarray(y, A), h), M;
  }, d.prototype.fill = function(l, h, y, A) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (A = h, h = 0, y = this.length) : typeof y == "string" && (A = y, y = this.length), A !== void 0 && typeof A != "string")
        throw new TypeError("encoding must be a string");
      if (typeof A == "string" && !d.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (A === "utf8" && x < 128 || A === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < y)
      throw new RangeError("Out of range index");
    if (y <= h)
      return this;
    let M;
    if (h >>>= 0, y = y === void 0 ? this.length : y >>> 0, l || (l = 0), typeof l == "number")
      for (M = h; M < y; ++M)
        this[M] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, A), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (M = 0; M < y - h; ++M)
        this[M + h] = x[M % O];
    }
    return this;
  };
  const Q = {};
  function oe(l, h, y) {
    Q[l] = class extends y {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(A) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: A, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function ae(l) {
    let h = "", y = l.length;
    const A = l[0] === "-" ? 1 : 0;
    for (; y >= A + 4; y -= 3)
      h = `_${l.slice(y - 3, y)}${h}`;
    return `${l.slice(0, y)}${h}`;
  }
  function ce(l, h, y, A, M, x) {
    if (l > y || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${y}${O}`, new Q.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, X) {
      ue(G, "offset"), O[G] !== void 0 && O[G + X] !== void 0 || le(G, O.length - (X + 1));
    })(A, M, x);
  }
  function ue(l, h) {
    if (typeof l != "number")
      throw new Q.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function le(l, h, y) {
    throw Math.floor(l) !== l ? (ue(l, y), new Q.ERR_OUT_OF_RANGE(y || "offset", "an integer", l)) : h < 0 ? new Q.ERR_BUFFER_OUT_OF_BOUNDS() : new Q.ERR_OUT_OF_RANGE(y || "offset", `>= ${y ? 1 : 0} and <= ${h}`, l);
  }
  oe("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), oe("ERR_OUT_OF_RANGE", function(l, h, y) {
    let A = `The value of "${l}" is out of range.`, M = y;
    return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? M = ae(String(y)) : typeof y == "bigint" && (M = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (M = ae(M)), M += "n"), A += ` It must be ${h}. Received ${M}`, A;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let y;
    h = h || 1 / 0;
    const A = l.length;
    let M = null;
    const x = [];
    for (let O = 0; O < A; ++O) {
      if (y = l.charCodeAt(O), y > 55295 && y < 57344) {
        if (!M) {
          if (y > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === A) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          M = y;
          continue;
        }
        if (y < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), M = y;
          continue;
        }
        y = 65536 + (M - 55296 << 10 | y - 56320);
      } else
        M && (h -= 3) > -1 && x.push(239, 191, 189);
      if (M = null, y < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(y);
      } else if (y < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(y >> 6 | 192, 63 & y | 128);
      } else if (y < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(y >> 12 | 224, y >> 6 & 63 | 128, 63 & y | 128);
      } else {
        if (!(y < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, 63 & y | 128);
      }
    }
    return x;
  }
  function _e(l) {
    return o.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function Le(l, h, y, A) {
    let M;
    for (M = 0; M < A && !(M + y >= h.length || M >= l.length); ++M)
      h[M + y] = l[M];
    return M;
  }
  function se(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let y = 0; y < 16; ++y) {
      const A = 16 * y;
      for (let M = 0; M < 16; ++M)
        h[A + M] = l[y] + l[M];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$6);
var buffer$5 = buffer$6, Buffer$a = buffer$5.Buffer, safer = {}, key$3;
for (key$3 in buffer$5)
  buffer$5.hasOwnProperty(key$3) && key$3 !== "SlowBuffer" && key$3 !== "Buffer" && (safer[key$3] = buffer$5[key$3]);
var Safer = safer.Buffer = {};
for (key$3 in Buffer$a)
  Buffer$a.hasOwnProperty(key$3) && key$3 !== "allocUnsafe" && key$3 !== "allocUnsafeSlow" && (Safer[key$3] = Buffer$a[key$3]);
if (safer.Buffer.prototype = Buffer$a.prototype, Safer.from && Safer.from !== Uint8Array.from || (Safer.from = function(n, o, a) {
  if (typeof n == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof n);
  if (n && n.length === void 0)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n);
  return Buffer$a(n, o, a);
}), Safer.alloc || (Safer.alloc = function(n, o, a) {
  if (typeof n != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof n);
  if (n < 0 || n >= 2 * (1 << 30))
    throw new RangeError('The value "' + n + '" is invalid for option "size"');
  var u = Buffer$a(n);
  return o && o.length !== 0 ? typeof a == "string" ? u.fill(o, a) : u.fill(o) : u.fill(0), u;
}), !safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = { MAX_LENGTH: safer.kMaxLength }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$9 = inherits_browser.exports;
function Reporter$2(n) {
  this._reporterState = { obj: null, path: [], options: n || {}, errors: [] };
}
function ReporterError(n, o) {
  this.path = n, this.rethrow(o);
}
reporter.Reporter = Reporter$2, Reporter$2.prototype.isError = function(n) {
  return n instanceof ReporterError;
}, Reporter$2.prototype.save = function() {
  const n = this._reporterState;
  return { obj: n.obj, pathLen: n.path.length };
}, Reporter$2.prototype.restore = function(n) {
  const o = this._reporterState;
  o.obj = n.obj, o.path = o.path.slice(0, n.pathLen);
}, Reporter$2.prototype.enterKey = function(n) {
  return this._reporterState.path.push(n);
}, Reporter$2.prototype.exitKey = function(n) {
  const o = this._reporterState;
  o.path = o.path.slice(0, n - 1);
}, Reporter$2.prototype.leaveKey = function(n, o, a) {
  const u = this._reporterState;
  this.exitKey(n), u.obj !== null && (u.obj[o] = a);
}, Reporter$2.prototype.path = function() {
  return this._reporterState.path.join("/");
}, Reporter$2.prototype.enterObject = function() {
  const n = this._reporterState, o = n.obj;
  return n.obj = {}, o;
}, Reporter$2.prototype.leaveObject = function(n) {
  const o = this._reporterState, a = o.obj;
  return o.obj = n, a;
}, Reporter$2.prototype.error = function(n) {
  let o;
  const a = this._reporterState, u = n instanceof ReporterError;
  if (o = u ? n : new ReporterError(a.path.map(function(c) {
    return "[" + JSON.stringify(c) + "]";
  }).join(""), n.message || n, n.stack), !a.options.partial)
    throw o;
  return u || a.errors.push(o), o;
}, Reporter$2.prototype.wrapResult = function(n) {
  const o = this._reporterState;
  return o.options.partial ? { result: this.isError(n) ? null : n, errors: o.errors } : n;
}, inherits$9(ReporterError, Error), ReporterError.prototype.rethrow = function(n) {
  if (this.message = n + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (o) {
      this.stack = o.stack;
    }
  return this;
};
var buffer$4 = {};
const inherits$8 = inherits_browser.exports, Reporter$1 = reporter.Reporter, Buffer$9 = safer_1.Buffer;
function DecoderBuffer$2(n, o) {
  Reporter$1.call(this, o), Buffer$9.isBuffer(n) ? (this.base = n, this.offset = 0, this.length = n.length) : this.error("Input not Buffer");
}
function EncoderBuffer$1(n, o) {
  if (Array.isArray(n))
    this.length = 0, this.value = n.map(function(a) {
      return EncoderBuffer$1.isEncoderBuffer(a) || (a = new EncoderBuffer$1(a, o)), this.length += a.length, a;
    }, this);
  else if (typeof n == "number") {
    if (!(0 <= n && n <= 255))
      return o.error("non-byte EncoderBuffer value");
    this.value = n, this.length = 1;
  } else if (typeof n == "string")
    this.value = n, this.length = Buffer$9.byteLength(n);
  else {
    if (!Buffer$9.isBuffer(n))
      return o.error("Unsupported type: " + typeof n);
    this.value = n, this.length = n.length;
  }
}
inherits$8(DecoderBuffer$2, Reporter$1), buffer$4.DecoderBuffer = DecoderBuffer$2, DecoderBuffer$2.isDecoderBuffer = function(n) {
  return n instanceof DecoderBuffer$2 || typeof n == "object" && Buffer$9.isBuffer(n.base) && n.constructor.name === "DecoderBuffer" && typeof n.offset == "number" && typeof n.length == "number" && typeof n.save == "function" && typeof n.restore == "function" && typeof n.isEmpty == "function" && typeof n.readUInt8 == "function" && typeof n.skip == "function" && typeof n.raw == "function";
}, DecoderBuffer$2.prototype.save = function() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
}, DecoderBuffer$2.prototype.restore = function(n) {
  const o = new DecoderBuffer$2(this.base);
  return o.offset = n.offset, o.length = this.offset, this.offset = n.offset, Reporter$1.prototype.restore.call(this, n.reporter), o;
}, DecoderBuffer$2.prototype.isEmpty = function() {
  return this.offset === this.length;
}, DecoderBuffer$2.prototype.readUInt8 = function(n) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(n || "DecoderBuffer overrun");
}, DecoderBuffer$2.prototype.skip = function(n, o) {
  if (!(this.offset + n <= this.length))
    return this.error(o || "DecoderBuffer overrun");
  const a = new DecoderBuffer$2(this.base);
  return a._reporterState = this._reporterState, a.offset = this.offset, a.length = this.offset + n, this.offset += n, a;
}, DecoderBuffer$2.prototype.raw = function(n) {
  return this.base.slice(n ? n.offset : this.offset, this.length);
}, buffer$4.EncoderBuffer = EncoderBuffer$1, EncoderBuffer$1.isEncoderBuffer = function(n) {
  return n instanceof EncoderBuffer$1 || typeof n == "object" && n.constructor.name === "EncoderBuffer" && typeof n.length == "number" && typeof n.join == "function";
}, EncoderBuffer$1.prototype.join = function(n, o) {
  return n || (n = Buffer$9.alloc(this.length)), o || (o = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(a) {
    a.join(n, o), o += a.length;
  }) : (typeof this.value == "number" ? n[o] = this.value : typeof this.value == "string" ? n.write(this.value, o) : Buffer$9.isBuffer(this.value) && this.value.copy(n, o), o += this.length)), n;
};
var minimalisticAssert = assert$g;
function assert$g(n, o) {
  if (!n)
    throw new Error(o || "Assertion failed");
}
assert$g.equal = function(n, o, a) {
  if (n != o)
    throw new Error(a || "Assertion failed: " + n + " != " + o);
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer$4.EncoderBuffer, DecoderBuffer$1 = buffer$4.DecoderBuffer, assert$f = minimalisticAssert, tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
function Node$2(n, o, a) {
  const u = {};
  this._baseState = u, u.name = a, u.enc = n, u.parent = o || null, u.children = null, u.tag = null, u.args = null, u.reverseArgs = null, u.choice = null, u.optional = !1, u.any = !1, u.obj = !1, u.use = null, u.useDecoder = null, u.key = null, u.default = null, u.explicit = null, u.implicit = null, u.contains = null, u.parent || (u.children = [], this._wrap());
}
var node = Node$2;
const stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
Node$2.prototype.clone = function() {
  const n = this._baseState, o = {};
  stateProps.forEach(function(u) {
    o[u] = n[u];
  });
  const a = new this.constructor(o.parent);
  return a._baseState = o, a;
}, Node$2.prototype._wrap = function() {
  const n = this._baseState;
  methods.forEach(function(o) {
    this[o] = function() {
      const a = new this.constructor(this);
      return n.children.push(a), a[o].apply(a, arguments);
    };
  }, this);
}, Node$2.prototype._init = function(n) {
  const o = this._baseState;
  assert$f(o.parent === null), n.call(this), o.children = o.children.filter(function(a) {
    return a._baseState.parent === this;
  }, this), assert$f.equal(o.children.length, 1, "Root node can have only one child");
}, Node$2.prototype._useArgs = function(n) {
  const o = this._baseState, a = n.filter(function(u) {
    return u instanceof this.constructor;
  }, this);
  n = n.filter(function(u) {
    return !(u instanceof this.constructor);
  }, this), a.length !== 0 && (assert$f(o.children === null), o.children = a, a.forEach(function(u) {
    u._baseState.parent = this;
  }, this)), n.length !== 0 && (assert$f(o.args === null), o.args = n, o.reverseArgs = n.map(function(u) {
    if (typeof u != "object" || u.constructor !== Object)
      return u;
    const c = {};
    return Object.keys(u).forEach(function(p) {
      p == (0 | p) && (p |= 0);
      const d = u[p];
      c[d] = p;
    }), c;
  }));
}, overrided.forEach(function(n) {
  Node$2.prototype[n] = function() {
    const o = this._baseState;
    throw new Error(n + " not implemented for encoding: " + o.enc);
  };
}), tags.forEach(function(n) {
  Node$2.prototype[n] = function() {
    const o = this._baseState, a = Array.prototype.slice.call(arguments);
    return assert$f(o.tag === null), o.tag = n, this._useArgs(a), this;
  };
}), Node$2.prototype.use = function(n) {
  assert$f(n);
  const o = this._baseState;
  return assert$f(o.use === null), o.use = n, this;
}, Node$2.prototype.optional = function() {
  return this._baseState.optional = !0, this;
}, Node$2.prototype.def = function(n) {
  const o = this._baseState;
  return assert$f(o.default === null), o.default = n, o.optional = !0, this;
}, Node$2.prototype.explicit = function(n) {
  const o = this._baseState;
  return assert$f(o.explicit === null && o.implicit === null), o.explicit = n, this;
}, Node$2.prototype.implicit = function(n) {
  const o = this._baseState;
  return assert$f(o.explicit === null && o.implicit === null), o.implicit = n, this;
}, Node$2.prototype.obj = function() {
  const n = this._baseState, o = Array.prototype.slice.call(arguments);
  return n.obj = !0, o.length !== 0 && this._useArgs(o), this;
}, Node$2.prototype.key = function(n) {
  const o = this._baseState;
  return assert$f(o.key === null), o.key = n, this;
}, Node$2.prototype.any = function() {
  return this._baseState.any = !0, this;
}, Node$2.prototype.choice = function(n) {
  const o = this._baseState;
  return assert$f(o.choice === null), o.choice = n, this._useArgs(Object.keys(n).map(function(a) {
    return n[a];
  })), this;
}, Node$2.prototype.contains = function(n) {
  const o = this._baseState;
  return assert$f(o.use === null), o.contains = n, this;
}, Node$2.prototype._decode = function(n, o) {
  const a = this._baseState;
  if (a.parent === null)
    return n.wrapResult(a.children[0]._decode(n, o));
  let u, c = a.default, p = !0, d = null;
  if (a.key !== null && (d = n.enterKey(a.key)), a.optional) {
    let w = null;
    if (a.explicit !== null ? w = a.explicit : a.implicit !== null ? w = a.implicit : a.tag !== null && (w = a.tag), w !== null || a.any) {
      if (p = this._peekTag(n, w, a.any), n.isError(p))
        return p;
    } else {
      const S = n.save();
      try {
        a.choice === null ? this._decodeGeneric(a.tag, n, o) : this._decodeChoice(n, o), p = !0;
      } catch {
        p = !1;
      }
      n.restore(S);
    }
  }
  if (a.obj && p && (u = n.enterObject()), p) {
    if (a.explicit !== null) {
      const S = this._decodeTag(n, a.explicit);
      if (n.isError(S))
        return S;
      n = S;
    }
    const w = n.offset;
    if (a.use === null && a.choice === null) {
      let S;
      a.any && (S = n.save());
      const k = this._decodeTag(n, a.implicit !== null ? a.implicit : a.tag, a.any);
      if (n.isError(k))
        return k;
      a.any ? c = n.raw(S) : n = k;
    }
    if (o && o.track && a.tag !== null && o.track(n.path(), w, n.length, "tagged"), o && o.track && a.tag !== null && o.track(n.path(), n.offset, n.length, "content"), a.any || (c = a.choice === null ? this._decodeGeneric(a.tag, n, o) : this._decodeChoice(n, o)), n.isError(c))
      return c;
    if (a.any || a.choice !== null || a.children === null || a.children.forEach(function(S) {
      S._decode(n, o);
    }), a.contains && (a.tag === "octstr" || a.tag === "bitstr")) {
      const S = new DecoderBuffer$1(c);
      c = this._getUse(a.contains, n._reporterState.obj)._decode(S, o);
    }
  }
  return a.obj && p && (c = n.leaveObject(u)), a.key === null || c === null && p !== !0 ? d !== null && n.exitKey(d) : n.leaveKey(d, a.key, c), c;
}, Node$2.prototype._decodeGeneric = function(n, o, a) {
  const u = this._baseState;
  return n === "seq" || n === "set" ? null : n === "seqof" || n === "setof" ? this._decodeList(o, n, u.args[0], a) : /str$/.test(n) ? this._decodeStr(o, n, a) : n === "objid" && u.args ? this._decodeObjid(o, u.args[0], u.args[1], a) : n === "objid" ? this._decodeObjid(o, null, null, a) : n === "gentime" || n === "utctime" ? this._decodeTime(o, n, a) : n === "null_" ? this._decodeNull(o, a) : n === "bool" ? this._decodeBool(o, a) : n === "objDesc" ? this._decodeStr(o, n, a) : n === "int" || n === "enum" ? this._decodeInt(o, u.args && u.args[0], a) : u.use !== null ? this._getUse(u.use, o._reporterState.obj)._decode(o, a) : o.error("unknown tag: " + n);
}, Node$2.prototype._getUse = function(n, o) {
  const a = this._baseState;
  return a.useDecoder = this._use(n, o), assert$f(a.useDecoder._baseState.parent === null), a.useDecoder = a.useDecoder._baseState.children[0], a.implicit !== a.useDecoder._baseState.implicit && (a.useDecoder = a.useDecoder.clone(), a.useDecoder._baseState.implicit = a.implicit), a.useDecoder;
}, Node$2.prototype._decodeChoice = function(n, o) {
  const a = this._baseState;
  let u = null, c = !1;
  return Object.keys(a.choice).some(function(p) {
    const d = n.save(), w = a.choice[p];
    try {
      const S = w._decode(n, o);
      if (n.isError(S))
        return !1;
      u = { type: p, value: S }, c = !0;
    } catch {
      return n.restore(d), !1;
    }
    return !0;
  }, this), c ? u : n.error("Choice not matched");
}, Node$2.prototype._createEncoderBuffer = function(n) {
  return new EncoderBuffer(n, this.reporter);
}, Node$2.prototype._encode = function(n, o, a) {
  const u = this._baseState;
  if (u.default !== null && u.default === n)
    return;
  const c = this._encodeValue(n, o, a);
  return c === void 0 || this._skipDefault(c, o, a) ? void 0 : c;
}, Node$2.prototype._encodeValue = function(n, o, a) {
  const u = this._baseState;
  if (u.parent === null)
    return u.children[0]._encode(n, o || new Reporter());
  let c = null;
  if (this.reporter = o, u.optional && n === void 0) {
    if (u.default === null)
      return;
    n = u.default;
  }
  let p = null, d = !1;
  if (u.any)
    c = this._createEncoderBuffer(n);
  else if (u.choice)
    c = this._encodeChoice(n, o);
  else if (u.contains)
    p = this._getUse(u.contains, a)._encode(n, o), d = !0;
  else if (u.children)
    p = u.children.map(function(w) {
      if (w._baseState.tag === "null_")
        return w._encode(null, o, n);
      if (w._baseState.key === null)
        return o.error("Child should have a key");
      const S = o.enterKey(w._baseState.key);
      if (typeof n != "object")
        return o.error("Child expected, but input is not object");
      const k = w._encode(n[w._baseState.key], o, n);
      return o.leaveKey(S), k;
    }, this).filter(function(w) {
      return w;
    }), p = this._createEncoderBuffer(p);
  else if (u.tag === "seqof" || u.tag === "setof") {
    if (!u.args || u.args.length !== 1)
      return o.error("Too many args for : " + u.tag);
    if (!Array.isArray(n))
      return o.error("seqof/setof, but data is not Array");
    const w = this.clone();
    w._baseState.implicit = null, p = this._createEncoderBuffer(n.map(function(S) {
      const k = this._baseState;
      return this._getUse(k.args[0], n)._encode(S, o);
    }, w));
  } else
    u.use !== null ? c = this._getUse(u.use, a)._encode(n, o) : (p = this._encodePrimitive(u.tag, n), d = !0);
  if (!u.any && u.choice === null) {
    const w = u.implicit !== null ? u.implicit : u.tag, S = u.implicit === null ? "universal" : "context";
    w === null ? u.use === null && o.error("Tag could be omitted only for .use()") : u.use === null && (c = this._encodeComposite(w, d, S, p));
  }
  return u.explicit !== null && (c = this._encodeComposite(u.explicit, !1, "context", c)), c;
}, Node$2.prototype._encodeChoice = function(n, o) {
  const a = this._baseState, u = a.choice[n.type];
  return u || assert$f(!1, n.type + " not found in " + JSON.stringify(Object.keys(a.choice))), u._encode(n.value, o);
}, Node$2.prototype._encodePrimitive = function(n, o) {
  const a = this._baseState;
  if (/str$/.test(n))
    return this._encodeStr(o, n);
  if (n === "objid" && a.args)
    return this._encodeObjid(o, a.reverseArgs[0], a.args[1]);
  if (n === "objid")
    return this._encodeObjid(o, null, null);
  if (n === "gentime" || n === "utctime")
    return this._encodeTime(o, n);
  if (n === "null_")
    return this._encodeNull();
  if (n === "int" || n === "enum")
    return this._encodeInt(o, a.args && a.reverseArgs[0]);
  if (n === "bool")
    return this._encodeBool(o);
  if (n === "objDesc")
    return this._encodeStr(o, n);
  throw new Error("Unsupported tag: " + n);
}, Node$2.prototype._isNumstr = function(n) {
  return /^[0-9 ]*$/.test(n);
}, Node$2.prototype._isPrintstr = function(n) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(n);
};
var der$2 = {};
(function(n) {
  function o(a) {
    const u = {};
    return Object.keys(a).forEach(function(c) {
      (0 | c) == c && (c |= 0);
      const p = a[c];
      u[p] = c;
    }), u;
  }
  n.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, n.tagClassByName = o(n.tagClass), n.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, n.tagByName = o(n.tag);
})(der$2);
const inherits$7 = inherits_browser.exports, Buffer$8 = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(n) {
  this.enc = "der", this.name = n.name, this.entity = n, this.tree = new DERNode$1(), this.tree._init(n.body);
}
var der_1$1 = DEREncoder$1;
function DERNode$1(n) {
  Node$1.call(this, "der", n);
}
function two(n) {
  return n < 10 ? "0" + n : n;
}
function encodeTag(n, o, a, u) {
  let c;
  if (n === "seqof" ? n = "seq" : n === "setof" && (n = "set"), der$1.tagByName.hasOwnProperty(n))
    c = der$1.tagByName[n];
  else {
    if (typeof n != "number" || (0 | n) !== n)
      return u.error("Unknown tag: " + n);
    c = n;
  }
  return c >= 31 ? u.error("Multi-octet tag encoding unsupported") : (o || (c |= 32), c |= der$1.tagClassByName[a || "universal"] << 6, c);
}
DEREncoder$1.prototype.encode = function(n, o) {
  return this.tree._encode(n, o).join();
}, inherits$7(DERNode$1, Node$1), DERNode$1.prototype._encodeComposite = function(n, o, a, u) {
  const c = encodeTag(n, o, a, this.reporter);
  if (u.length < 128) {
    const w = Buffer$8.alloc(2);
    return w[0] = c, w[1] = u.length, this._createEncoderBuffer([w, u]);
  }
  let p = 1;
  for (let w = u.length; w >= 256; w >>= 8)
    p++;
  const d = Buffer$8.alloc(2 + p);
  d[0] = c, d[1] = 128 | p;
  for (let w = 1 + p, S = u.length; S > 0; w--, S >>= 8)
    d[w] = 255 & S;
  return this._createEncoderBuffer([d, u]);
}, DERNode$1.prototype._encodeStr = function(n, o) {
  if (o === "bitstr")
    return this._createEncoderBuffer([0 | n.unused, n.data]);
  if (o === "bmpstr") {
    const a = Buffer$8.alloc(2 * n.length);
    for (let u = 0; u < n.length; u++)
      a.writeUInt16BE(n.charCodeAt(u), 2 * u);
    return this._createEncoderBuffer(a);
  }
  return o === "numstr" ? this._isNumstr(n) ? this._createEncoderBuffer(n) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : o === "printstr" ? this._isPrintstr(n) ? this._createEncoderBuffer(n) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(o) || o === "objDesc" ? this._createEncoderBuffer(n) : this.reporter.error("Encoding of string type: " + o + " unsupported");
}, DERNode$1.prototype._encodeObjid = function(n, o, a) {
  if (typeof n == "string") {
    if (!o)
      return this.reporter.error("string objid given, but no values map found");
    if (!o.hasOwnProperty(n))
      return this.reporter.error("objid not found in values map");
    n = o[n].split(/[\s.]+/g);
    for (let d = 0; d < n.length; d++)
      n[d] |= 0;
  } else if (Array.isArray(n)) {
    n = n.slice();
    for (let d = 0; d < n.length; d++)
      n[d] |= 0;
  }
  if (!Array.isArray(n))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(n));
  if (!a) {
    if (n[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    n.splice(0, 2, 40 * n[0] + n[1]);
  }
  let u = 0;
  for (let d = 0; d < n.length; d++) {
    let w = n[d];
    for (u++; w >= 128; w >>= 7)
      u++;
  }
  const c = Buffer$8.alloc(u);
  let p = c.length - 1;
  for (let d = n.length - 1; d >= 0; d--) {
    let w = n[d];
    for (c[p--] = 127 & w; (w >>= 7) > 0; )
      c[p--] = 128 | 127 & w;
  }
  return this._createEncoderBuffer(c);
}, DERNode$1.prototype._encodeTime = function(n, o) {
  let a;
  const u = new Date(n);
  return o === "gentime" ? a = [two(u.getUTCFullYear()), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : o === "utctime" ? a = [two(u.getUTCFullYear() % 100), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + o + " time is not supported yet"), this._encodeStr(a, "octstr");
}, DERNode$1.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
}, DERNode$1.prototype._encodeInt = function(n, o) {
  if (typeof n == "string") {
    if (!o)
      return this.reporter.error("String int or enum given, but no values map");
    if (!o.hasOwnProperty(n))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(n));
    n = o[n];
  }
  if (typeof n != "number" && !Buffer$8.isBuffer(n)) {
    const c = n.toArray();
    !n.sign && 128 & c[0] && c.unshift(0), n = Buffer$8.from(c);
  }
  if (Buffer$8.isBuffer(n)) {
    let c = n.length;
    n.length === 0 && c++;
    const p = Buffer$8.alloc(c);
    return n.copy(p), n.length === 0 && (p[0] = 0), this._createEncoderBuffer(p);
  }
  if (n < 128)
    return this._createEncoderBuffer(n);
  if (n < 256)
    return this._createEncoderBuffer([0, n]);
  let a = 1;
  for (let c = n; c >= 256; c >>= 8)
    a++;
  const u = new Array(a);
  for (let c = u.length - 1; c >= 0; c--)
    u[c] = 255 & n, n >>= 8;
  return 128 & u[0] && u.unshift(0), this._createEncoderBuffer(Buffer$8.from(u));
}, DERNode$1.prototype._encodeBool = function(n) {
  return this._createEncoderBuffer(n ? 255 : 0);
}, DERNode$1.prototype._use = function(n, o) {
  return typeof n == "function" && (n = n(o)), n._getEncoder("der").tree;
}, DERNode$1.prototype._skipDefault = function(n, o, a) {
  const u = this._baseState;
  let c;
  if (u.default === null)
    return !1;
  const p = n.join();
  if (u.defaultBuffer === void 0 && (u.defaultBuffer = this._encodeValue(u.default, o, a).join()), p.length !== u.defaultBuffer.length)
    return !1;
  for (c = 0; c < p.length; c++)
    if (p[c] !== u.defaultBuffer[c])
      return !1;
  return !0;
};
const inherits$6 = inherits_browser.exports, DEREncoder = der_1$1;
function PEMEncoder(n) {
  DEREncoder.call(this, n), this.enc = "pem";
}
inherits$6(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function(n, o) {
  const a = DEREncoder.prototype.encode.call(this, n).toString("base64"), u = ["-----BEGIN " + o.label + "-----"];
  for (let c = 0; c < a.length; c += 64)
    u.push(a.slice(c, c + 64));
  return u.push("-----END " + o.label + "-----"), u.join(`
`);
}, function(n) {
  const o = encoders;
  o.der = der_1$1, o.pem = pem$1;
}();
var decoders = {};
const inherits$5 = inherits_browser.exports, bignum = bn$3.exports, DecoderBuffer = buffer$4.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(n) {
  this.enc = "der", this.name = n.name, this.entity = n, this.tree = new DERNode(), this.tree._init(n.body);
}
var der_1 = DERDecoder$1;
function DERNode(n) {
  Node.call(this, "der", n);
}
function derDecodeTag(n, o) {
  let a = n.readUInt8(o);
  if (n.isError(a))
    return a;
  const u = der.tagClass[a >> 6], c = (32 & a) == 0;
  if ((31 & a) == 31) {
    let p = a;
    for (a = 0; (128 & p) == 128; ) {
      if (p = n.readUInt8(o), n.isError(p))
        return p;
      a <<= 7, a |= 127 & p;
    }
  } else
    a &= 31;
  return { cls: u, primitive: c, tag: a, tagStr: der.tag[a] };
}
function derDecodeLen(n, o, a) {
  let u = n.readUInt8(a);
  if (n.isError(u))
    return u;
  if (!o && u === 128)
    return null;
  if ((128 & u) == 0)
    return u;
  const c = 127 & u;
  if (c > 4)
    return n.error("length octect is too long");
  u = 0;
  for (let p = 0; p < c; p++) {
    u <<= 8;
    const d = n.readUInt8(a);
    if (n.isError(d))
      return d;
    u |= d;
  }
  return u;
}
DERDecoder$1.prototype.decode = function(n, o) {
  return DecoderBuffer.isDecoderBuffer(n) || (n = new DecoderBuffer(n, o)), this.tree._decode(n, o);
}, inherits$5(DERNode, Node), DERNode.prototype._peekTag = function(n, o, a) {
  if (n.isEmpty())
    return !1;
  const u = n.save(), c = derDecodeTag(n, 'Failed to peek tag: "' + o + '"');
  return n.isError(c) ? c : (n.restore(u), c.tag === o || c.tagStr === o || c.tagStr + "of" === o || a);
}, DERNode.prototype._decodeTag = function(n, o, a) {
  const u = derDecodeTag(n, 'Failed to decode tag of "' + o + '"');
  if (n.isError(u))
    return u;
  let c = derDecodeLen(n, u.primitive, 'Failed to get length of "' + o + '"');
  if (n.isError(c))
    return c;
  if (!a && u.tag !== o && u.tagStr !== o && u.tagStr + "of" !== o)
    return n.error('Failed to match tag: "' + o + '"');
  if (u.primitive || c !== null)
    return n.skip(c, 'Failed to match body of: "' + o + '"');
  const p = n.save(), d = this._skipUntilEnd(n, 'Failed to skip indefinite length body: "' + this.tag + '"');
  return n.isError(d) ? d : (c = n.offset - p.offset, n.restore(p), n.skip(c, 'Failed to match body of: "' + o + '"'));
}, DERNode.prototype._skipUntilEnd = function(n, o) {
  for (; ; ) {
    const a = derDecodeTag(n, o);
    if (n.isError(a))
      return a;
    const u = derDecodeLen(n, a.primitive, o);
    if (n.isError(u))
      return u;
    let c;
    if (c = a.primitive || u !== null ? n.skip(u) : this._skipUntilEnd(n, o), n.isError(c))
      return c;
    if (a.tagStr === "end")
      break;
  }
}, DERNode.prototype._decodeList = function(n, o, a, u) {
  const c = [];
  for (; !n.isEmpty(); ) {
    const p = this._peekTag(n, "end");
    if (n.isError(p))
      return p;
    const d = a.decode(n, "der", u);
    if (n.isError(d) && p)
      break;
    c.push(d);
  }
  return c;
}, DERNode.prototype._decodeStr = function(n, o) {
  if (o === "bitstr") {
    const a = n.readUInt8();
    return n.isError(a) ? a : { unused: a, data: n.raw() };
  }
  if (o === "bmpstr") {
    const a = n.raw();
    if (a.length % 2 == 1)
      return n.error("Decoding of string type: bmpstr length mismatch");
    let u = "";
    for (let c = 0; c < a.length / 2; c++)
      u += String.fromCharCode(a.readUInt16BE(2 * c));
    return u;
  }
  if (o === "numstr") {
    const a = n.raw().toString("ascii");
    return this._isNumstr(a) ? a : n.error("Decoding of string type: numstr unsupported characters");
  }
  if (o === "octstr" || o === "objDesc")
    return n.raw();
  if (o === "printstr") {
    const a = n.raw().toString("ascii");
    return this._isPrintstr(a) ? a : n.error("Decoding of string type: printstr unsupported characters");
  }
  return /str$/.test(o) ? n.raw().toString() : n.error("Decoding of string type: " + o + " unsupported");
}, DERNode.prototype._decodeObjid = function(n, o, a) {
  let u;
  const c = [];
  let p = 0, d = 0;
  for (; !n.isEmpty(); )
    d = n.readUInt8(), p <<= 7, p |= 127 & d, (128 & d) == 0 && (c.push(p), p = 0);
  128 & d && c.push(p);
  const w = c[0] / 40 | 0, S = c[0] % 40;
  if (u = a ? c : [w, S].concat(c.slice(1)), o) {
    let k = o[u.join(" ")];
    k === void 0 && (k = o[u.join(".")]), k !== void 0 && (u = k);
  }
  return u;
}, DERNode.prototype._decodeTime = function(n, o) {
  const a = n.raw().toString();
  let u, c, p, d, w, S;
  if (o === "gentime")
    u = 0 | a.slice(0, 4), c = 0 | a.slice(4, 6), p = 0 | a.slice(6, 8), d = 0 | a.slice(8, 10), w = 0 | a.slice(10, 12), S = 0 | a.slice(12, 14);
  else {
    if (o !== "utctime")
      return n.error("Decoding " + o + " time is not supported yet");
    u = 0 | a.slice(0, 2), c = 0 | a.slice(2, 4), p = 0 | a.slice(4, 6), d = 0 | a.slice(6, 8), w = 0 | a.slice(8, 10), S = 0 | a.slice(10, 12), u = u < 70 ? 2e3 + u : 1900 + u;
  }
  return Date.UTC(u, c - 1, p, d, w, S, 0);
}, DERNode.prototype._decodeNull = function() {
  return null;
}, DERNode.prototype._decodeBool = function(n) {
  const o = n.readUInt8();
  return n.isError(o) ? o : o !== 0;
}, DERNode.prototype._decodeInt = function(n, o) {
  const a = n.raw();
  let u = new bignum(a);
  return o && (u = o[u.toString(10)] || u), u;
}, DERNode.prototype._use = function(n, o) {
  return typeof n == "function" && (n = n(o)), n._getDecoder("der").tree;
};
const inherits$4 = inherits_browser.exports, Buffer$7 = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(n) {
  DERDecoder.call(this, n), this.enc = "pem";
}
inherits$4(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function(n, o) {
  const a = n.toString().split(/[\r\n]+/g), u = o.label.toUpperCase(), c = /^-----(BEGIN|END) ([^-]+)-----$/;
  let p = -1, d = -1;
  for (let k = 0; k < a.length; k++) {
    const B = a[k].match(c);
    if (B !== null && B[2] === u) {
      if (p !== -1) {
        if (B[1] !== "END")
          break;
        d = k;
        break;
      }
      if (B[1] !== "BEGIN")
        break;
      p = k;
    }
  }
  if (p === -1 || d === -1)
    throw new Error("PEM section not found for: " + u);
  const w = a.slice(p + 1, d).join("");
  w.replace(/[^a-z0-9+/=]+/gi, "");
  const S = Buffer$7.from(w, "base64");
  return DERDecoder.prototype.decode.call(this, S, o);
}, function(n) {
  const o = decoders;
  o.der = der_1, o.pem = pem;
}(), function(n) {
  const o = encoders, a = decoders, u = inherits_browser.exports;
  function c(p, d) {
    this.name = p, this.body = d, this.decoders = {}, this.encoders = {};
  }
  n.define = function(p, d) {
    return new c(p, d);
  }, c.prototype._createNamed = function(p) {
    const d = this.name;
    function w(S) {
      this._initNamed(S, d);
    }
    return u(w, p), w.prototype._initNamed = function(S, k) {
      p.call(this, S, k);
    }, new w(this);
  }, c.prototype._getDecoder = function(p) {
    return p = p || "der", this.decoders.hasOwnProperty(p) || (this.decoders[p] = this._createNamed(a[p])), this.decoders[p];
  }, c.prototype.decode = function(p, d, w) {
    return this._getDecoder(d).decode(p, w);
  }, c.prototype._getEncoder = function(p) {
    return p = p || "der", this.encoders.hasOwnProperty(p) || (this.encoders[p] = this._createNamed(o[p])), this.encoders[p];
  }, c.prototype.encode = function(p, d, w) {
    return this._getEncoder(d).encode(p, w);
  };
}(api);
var base$1 = {};
(function(n) {
  const o = base$1;
  o.Reporter = reporter.Reporter, o.DecoderBuffer = buffer$4.DecoderBuffer, o.EncoderBuffer = buffer$4.EncoderBuffer, o.Node = node;
})();
var constants$1 = {};
(function(n) {
  const o = constants$1;
  o._reverse = function(a) {
    const u = {};
    return Object.keys(a).forEach(function(c) {
      (0 | c) == c && (c |= 0);
      const p = a[c];
      u[p] = c;
    }), u;
  }, o.der = der$2;
})(), function(n) {
  const o = asn1;
  o.bignum = bn$3.exports, o.define = api.define, o.base = base$1, o.constants = constants$1, o.decoders = decoders, o.encoders = encoders;
}();
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$5(o, n, a);
  return __setModuleDefault$5(o, n), o;
};
Object.defineProperty(pem$2, "__esModule", { value: !0 }), pem$2.jwkTopem = pem$2.pemTojwk = void 0;
const asn = __importStar$5(asn1);
function urlize(n) {
  return n.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hex2b64url(n) {
  return urlize(Buffer.from(n, "hex").toString("base64"));
}
var RSAPublicKey = asn.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
}), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
}), PublicKeyInfo = asn.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
}), Version = asn.define("Version", function() {
  this.int({ 0: "two-prime", 1: "multi" });
}), OtherPrimeInfos = asn.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
}), RSAPrivateKey = asn.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
}), PrivateKeyInfo = asn.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
function addExtras(n, o) {
  return o = o || {}, Object.keys(o).forEach(function(a) {
    n[a] = o[a];
  }), n;
}
function pad(n) {
  return n.length % 2 == 1 ? "0" + n : n;
}
function decodeRsaPublic(n, o) {
  var a = RSAPublicKey.decode(n, "der"), u = pad(a.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(a.n), e: hex2b64url(u) }, o);
}
function decodeRsaPrivate(n, o) {
  var a = RSAPrivateKey.decode(n, "der"), u = pad(a.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(a.n), e: hex2b64url(u), d: bn2base64url(a.d), p: bn2base64url(a.p), q: bn2base64url(a.q), dp: bn2base64url(a.dp), dq: bn2base64url(a.dq), qi: bn2base64url(a.qi) }, o);
}
function decodePublic(n, o) {
  return decodeRsaPublic(PublicKeyInfo.decode(n, "der").publicKey.data, o);
}
function decodePrivate(n, o) {
  return decodeRsaPrivate(PrivateKeyInfo.decode(n, "der").privateKey.data, o);
}
function getDecoder(n) {
  var o = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(n);
  if (!o)
    return null;
  var a = !!o[1];
  return o[2] === "PRIVATE" ? a ? decodeRsaPrivate : decodePrivate : a ? decodeRsaPublic : decodePublic;
}
function parse(n) {
  return { n: string2bn(n.n), e: string2bn(n.e), d: n.d && string2bn(n.d), p: n.p && string2bn(n.p), q: n.q && string2bn(n.q), dp: n.dp && string2bn(n.dp), dq: n.dq && string2bn(n.dq), qi: n.qi && string2bn(n.qi) };
}
function bn2base64url(n) {
  return hex2b64url(pad(n.toString(16)));
}
function base64url2bn(n) {
  return new asn.bignum(Buffer.from(n, "base64"));
}
function string2bn(n) {
  return /^[0-9]+$/.test(n) ? new asn.bignum(n, 10) : base64url2bn(n);
}
function pemTojwk(n, o) {
  var a = n.toString().split(/(\r\n|\r|\n)+/g), u = getDecoder((a = a.filter(function(c) {
    return c.trim().length !== 0;
  }))[0]);
  return a = a.slice(1, -1).join(""), u(Buffer.from(a.replace(/[^\w\d\+\/=]+/g, ""), "base64"), o);
}
function jwkTopem(n) {
  var o = parse(n), a = !!o.d, u = a ? "PRIVATE" : "PUBLIC", c = "-----BEGIN RSA " + u + ` KEY-----
`, p = `
-----END RSA ` + u + ` KEY-----
`, d = Buffer.alloc(0);
  return a ? (o.version = "two-prime", d = RSAPrivateKey.encode(o, "der")) : d = RSAPublicKey.encode(o, "der"), c + d.toString("base64").match(/.{1,64}/g).join(`
`) + p;
}
pem$2.pemTojwk = pemTojwk, pem$2.jwkTopem = jwkTopem;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$4(o, n, a);
  return __setModuleDefault$4(o, n), o;
};
Object.defineProperty(nodeDriver, "__esModule", { value: !0 });
const pem_1 = pem$2, crypto$2 = __importStar$4(require$$2$1), constants = __importStar$4(require$$2$1);
class NodeCryptoDriver {
  constructor() {
    this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", this.encryptionAlgorithm = "aes-256-cbc";
  }
  generateJWK() {
    if (typeof crypto$2.generateKeyPair != "function")
      throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
    return new Promise((o, a) => {
      crypto$2.generateKeyPair("rsa", { modulusLength: this.keyLength, publicExponent: this.publicExponent, privateKeyEncoding: { type: "pkcs1", format: "pem" }, publicKeyEncoding: { type: "pkcs1", format: "pem" } }, (u, c, p) => {
        u && a(u), o(this.pemToJWK(p));
      });
    });
  }
  sign(o, a, { saltLength: u } = {}) {
    return new Promise((c, p) => {
      c(crypto$2.createSign(this.hashAlgorithm).update(a).sign({ key: this.jwkToPem(o), padding: constants.RSA_PKCS1_PSS_PADDING, saltLength: u }));
    });
  }
  verify(o, a, u) {
    return new Promise((c, p) => {
      const d = { kty: "RSA", e: "AQAB", n: o }, w = this.jwkToPem(d);
      c(crypto$2.createVerify(this.hashAlgorithm).update(a).verify({ key: w, padding: constants.RSA_PKCS1_PSS_PADDING }, u));
    });
  }
  hash(o, a = "SHA-256") {
    return new Promise((u, c) => {
      u(crypto$2.createHash(this.parseHashAlgorithm(a)).update(o).digest());
    });
  }
  async encrypt(o, a, u) {
    const c = crypto$2.pbkdf2Sync(a, u = u || "salt", 1e5, 32, this.hashAlgorithm), p = crypto$2.randomBytes(16), d = crypto$2.createCipheriv(this.encryptionAlgorithm, c, p);
    return Buffer.concat([p, d.update(o), d.final()]);
  }
  async decrypt(o, a, u) {
    try {
      const c = crypto$2.pbkdf2Sync(a, u = u || "salt", 1e5, 32, this.hashAlgorithm), p = o.slice(0, 16), d = o.slice(16), w = crypto$2.createDecipheriv(this.encryptionAlgorithm, c, p);
      return Buffer.concat([w.update(d), w.final()]);
    } catch {
      throw new Error("Failed to decrypt");
    }
  }
  jwkToPem(o) {
    return (0, pem_1.jwkTopem)(o);
  }
  pemToJWK(o) {
    return (0, pem_1.pemTojwk)(o);
  }
  parseHashAlgorithm(o) {
    switch (o) {
      case "SHA-256":
        return "sha256";
      case "SHA-384":
        return "sha384";
      default:
        throw new Error(`Algorithm not supported: ${o}`);
    }
  }
}
nodeDriver.default = NodeCryptoDriver;
var network = {};
Object.defineProperty(network, "__esModule", { value: !0 });
class Network {
  constructor(o) {
    this.api = o;
  }
  getInfo() {
    return this.api.get("info").then((o) => o.data);
  }
  getPeers() {
    return this.api.get("peers").then((o) => o.data);
  }
}
network.default = Network;
var transactions = {}, error = {};
Object.defineProperty(error, "__esModule", { value: !0 }), error.getError = void 0;
class ArweaveError extends Error {
  constructor(o, a = {}) {
    a.message ? super(a.message) : super(), this.type = o, this.response = a.response;
  }
  getType() {
    return this.type;
  }
}
function getError(n) {
  let o = n.data;
  if (typeof n.data == "string")
    try {
      o = JSON.parse(n.data);
    } catch {
    }
  if (n.data instanceof ArrayBuffer || n.data instanceof Uint8Array)
    try {
      o = JSON.parse(o.toString());
    } catch {
    }
  return o ? o.error || o : n.statusText || "unknown";
}
error.default = ArweaveError, error.getError = getError;
var transactionUploader = {}, merkle = {}, hasRequiredMerkle, hasRequiredTransactionUploader, hasRequiredTransactions;
function requireMerkle() {
  return hasRequiredMerkle || (hasRequiredMerkle = 1, function(n) {
    var o = commonjsGlobal && commonjsGlobal.__importDefault || function(D) {
      return D && D.__esModule ? D : { default: D };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.debug = n.validatePath = n.arrayCompare = n.bufferToInt = n.intToBuffer = n.arrayFlatten = n.generateProofs = n.buildLayers = n.generateTransactionChunks = n.generateTree = n.computeRootHash = n.generateLeaves = n.chunkData = n.MIN_CHUNK_SIZE = n.MAX_CHUNK_SIZE = void 0;
    const a = o(requireCommon()), u = utils$o;
    n.MAX_CHUNK_SIZE = 262144, n.MIN_CHUNK_SIZE = 32768;
    async function c(D) {
      let z = [], F = D, V = 0;
      for (; F.byteLength >= n.MAX_CHUNK_SIZE; ) {
        let Z = n.MAX_CHUNK_SIZE, N = F.byteLength - n.MAX_CHUNK_SIZE;
        N > 0 && N < n.MIN_CHUNK_SIZE && (Z = Math.ceil(F.byteLength / 2));
        const W = F.slice(0, Z), H = await a.default.crypto.hash(W);
        V += W.byteLength, z.push({ dataHash: H, minByteRange: V - W.byteLength, maxByteRange: V }), F = F.slice(Z);
      }
      return z.push({ dataHash: await a.default.crypto.hash(F), minByteRange: V, maxByteRange: V + F.byteLength }), z;
    }
    async function p(D) {
      return Promise.all(D.map(async ({ dataHash: z, minByteRange: F, maxByteRange: V }) => ({ type: "leaf", id: await C(await Promise.all([C(z), C(P(V))])), dataHash: z, minByteRange: F, maxByteRange: V })));
    }
    async function d(D) {
      return await w(await p(await c(D)));
    }
    async function w(D, z = 0) {
      if (D.length < 2)
        return D[0];
      const F = [];
      for (let V = 0; V < D.length; V += 2)
        F.push(await I(D[V], D[V + 1]));
      return w(F, z + 1);
    }
    function S(D) {
      const z = k(D);
      return Array.isArray(z) ? B(z) : [z];
    }
    function k(D, z = new Uint8Array(), F = 0) {
      if (D.type == "leaf")
        return { offset: D.maxByteRange - 1, proof: (0, u.concatBuffers)([z, D.dataHash, P(D.maxByteRange)]) };
      if (D.type == "branch") {
        const V = (0, u.concatBuffers)([z, D.leftChild.id, D.rightChild.id, P(D.byteRange)]);
        return [k(D.leftChild, V, F + 1), k(D.rightChild, V, F + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function B(D) {
      const z = [];
      return D.forEach((F) => {
        Array.isArray(F) ? z.push(...B(F)) : z.push(F);
      }), z;
    }
    async function I(D, z) {
      return z ? { type: "branch", id: await C([await C(D.id), await C(z.id), await C(P(D.maxByteRange))]), byteRange: D.maxByteRange, maxByteRange: z.maxByteRange, leftChild: D, rightChild: z } : D;
    }
    async function C(D) {
      return Array.isArray(D) && (D = a.default.utils.concatBuffers(D)), new Uint8Array(await a.default.crypto.hash(D));
    }
    function P(D) {
      const z = new Uint8Array(32);
      for (var F = z.length - 1; F >= 0; F--) {
        var V = D % 256;
        z[F] = V, D = (D - V) / 256;
      }
      return z;
    }
    function q(D) {
      let z = 0;
      for (var F = 0; F < D.length; F++)
        z *= 256, z += D[F];
      return z;
    }
    n.chunkData = c, n.generateLeaves = p, n.computeRootHash = async function(D) {
      return (await d(D)).id;
    }, n.generateTree = d, n.generateTransactionChunks = async function(D) {
      const z = await c(D), F = await p(z), V = await w(F), Z = await S(V), N = z.slice(-1)[0];
      return N.maxByteRange - N.minByteRange == 0 && (z.splice(z.length - 1, 1), Z.splice(Z.length - 1, 1)), { data_root: V.id, chunks: z, proofs: Z };
    }, n.buildLayers = w, n.generateProofs = S, n.arrayFlatten = B, n.intToBuffer = P, n.bufferToInt = q, n.arrayCompare = (D, z) => D.every((F, V) => z[V] === F), n.validatePath = async function D(z, F, V, Z, N) {
      if (Z <= 0)
        return !1;
      if (F >= Z)
        return D(z, 0, Z - 1, Z, N);
      if (F < 0)
        return D(z, 0, 0, Z, N);
      if (N.length == 64) {
        const b = N.slice(0, 32), m = N.slice(b.length, b.length + 32), v = await C([await C(b), await C(m)]);
        return !!(0, n.arrayCompare)(z, v) && { offset: Z - 1, leftBound: V, rightBound: Z, chunkSize: Z - V };
      }
      const W = N.slice(0, 32), H = N.slice(W.length, W.length + 32), te = N.slice(W.length + H.length, W.length + H.length + 32), g = q(te), $ = N.slice(W.length + H.length + te.length), _ = await C([await C(W), await C(H), await C(te)]);
      return !!(0, n.arrayCompare)(z, _) && (F < g ? await D(W, F, V, Math.min(Z, g), $) : await D(H, F, Math.max(V, g), Z, $));
    }, n.debug = async function D(z, F = "") {
      if (z.byteLength < 1)
        return F;
      const V = z.slice(0, 32), Z = z.slice(V.length, V.length + 32), N = z.slice(V.length + Z.length, V.length + Z.length + 32), W = q(N), H = z.slice(V.length + Z.length + N.length), te = await C([await C(V), await C(Z), await C(N)]);
      return D(H, `${F}
${JSON.stringify(Buffer.from(V))},${JSON.stringify(Buffer.from(Z))},${W} => ${JSON.stringify(te)}`);
    };
  }(merkle)), merkle;
}
function requireTransactionUploader() {
  if (hasRequiredTransactionUploader)
    return transactionUploader;
  hasRequiredTransactionUploader = 1;
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(B, I, C, P) {
    P === void 0 && (P = C);
    var q = Object.getOwnPropertyDescriptor(I, C);
    q && !("get" in q ? !I.__esModule : q.writable || q.configurable) || (q = { enumerable: !0, get: function() {
      return I[C];
    } }), Object.defineProperty(B, P, q);
  } : function(B, I, C, P) {
    P === void 0 && (P = C), B[P] = I[C];
  }), o = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(B, I) {
    Object.defineProperty(B, "default", { enumerable: !0, value: I });
  } : function(B, I) {
    B.default = I;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var I = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && n(I, B, C);
    return o(I, B), I;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(transactionUploader, "__esModule", { value: !0 }), transactionUploader.TransactionUploader = void 0;
  const c = u(requireTransaction()), p = a(utils$o), d = error, w = requireMerkle(), S = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class k {
    constructor(I, C) {
      if (this.api = I, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !C.id)
        throw new Error("Transaction is not signed");
      if (!C.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = C.data, this.transaction = new c.default(Object.assign({}, C, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(I) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let C = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (C > 0 && (C -= C * Math.random() * 0.3, await new Promise((D) => setTimeout(D, C))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      I && (this.chunkIndex = I);
      const P = this.transaction.getChunk(I || this.chunkIndex, this.data);
      if (!await (0, w.validatePath)(this.transaction.chunks.data_root, parseInt(P.offset), 0, parseInt(P.data_size), p.b64UrlToBuffer(P.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const q = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((D) => (console.error(D.message), { status: -1, data: { error: D.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = q.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, d.getError)(q), S.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized(I, C, P) {
      if (!C || typeof C.chunkIndex != "number" || typeof C.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var q = new c.default(C.transaction);
      q.chunks || await q.prepareChunks(P);
      const D = new k(I, q);
      if (D.chunkIndex = C.chunkIndex, D.lastRequestTimeEnd = C.lastRequestTimeEnd, D.lastResponseError = C.lastResponseError, D.lastResponseStatus = C.lastResponseStatus, D.txPosted = C.txPosted, D.data = P, D.transaction.data_root !== C.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return D;
    }
    static async fromTransactionId(I, C) {
      const P = await I.get(`tx/${C}`);
      if (P.status !== 200)
        throw new Error(`Tx ${C} not found: ${P.status}`);
      const q = P.data;
      return q.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: q };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const C = await this.api.post("tx", this.transaction).catch((P) => (console.error(P), { status: -1, data: { error: P.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = C.status, this.transaction.data = new Uint8Array(0), C.status >= 200 && C.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, d.getError)(C), new Error(`Unable to upload transaction: ${C.status}, ${this.lastResponseError}`);
      }
      const I = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = I.status, !(I.status >= 200 && I.status < 300))
        throw this.lastResponseError = (0, d.getError)(I), new Error(`Unable to upload transaction: ${I.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader.TransactionUploader = k, transactionUploader;
}
function requireTransactions() {
  if (hasRequiredTransactions)
    return transactions;
  hasRequiredTransactions = 1;
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(B, I, C, P) {
    P === void 0 && (P = C);
    var q = Object.getOwnPropertyDescriptor(I, C);
    q && !("get" in q ? !I.__esModule : q.writable || q.configurable) || (q = { enumerable: !0, get: function() {
      return I[C];
    } }), Object.defineProperty(B, P, q);
  } : function(B, I, C, P) {
    P === void 0 && (P = C), B[P] = I[C];
  }), o = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(B, I) {
    Object.defineProperty(B, "default", { enumerable: !0, value: I });
  } : function(B, I) {
    B.default = I;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var I = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && n(I, B, C);
    return o(I, B), I;
  }, u = commonjsGlobal && commonjsGlobal.__await || function(B) {
    return this instanceof u ? (this.v = B, this) : new u(B);
  }, c = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(B, I, C) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var P, q = C.apply(B, I || []), D = [];
    return P = {}, z("next"), z("throw"), z("return"), P[Symbol.asyncIterator] = function() {
      return this;
    }, P;
    function z(W) {
      q[W] && (P[W] = function(H) {
        return new Promise(function(te, g) {
          D.push([W, H, te, g]) > 1 || F(W, H);
        });
      });
    }
    function F(W, H) {
      try {
        (function(te) {
          te.value instanceof u ? Promise.resolve(te.value.v).then(V, Z) : N(D[0][2], te);
        })(q[W](H));
      } catch (te) {
        N(D[0][3], te);
      }
    }
    function V(W) {
      F("next", W);
    }
    function Z(W) {
      F("throw", W);
    }
    function N(W, H) {
      W(H), D.shift(), D.length && F(D[0][0], D[0][1]);
    }
  }, p = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(transactions, "__esModule", { value: !0 });
  const d = p(error), w = p(requireTransaction()), S = a(utils$o), k = requireTransactionUploader();
  return transactions.default = class {
    constructor(B, I, C) {
      this.api = B, this.crypto = I, this.chunks = C;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((B) => B.data);
    }
    getPrice(B, I) {
      let C = I ? `price/${B}/${I}` : `price/${B}`;
      return this.api.get(C, { transformResponse: [function(P) {
        return P;
      }] }).then((P) => P.data);
    }
    async get(B) {
      const I = await this.api.get(`tx/${B}`);
      if (I.status == 200) {
        const C = parseInt(I.data.data_size);
        if (I.data.format >= 2 && C > 0 && C <= 12582912) {
          const P = await this.getData(B);
          return new w.default(Object.assign(Object.assign({}, I.data), { data: P }));
        }
        return new w.default(Object.assign(Object.assign({}, I.data), { format: I.data.format || 1 }));
      }
      throw I.status == 404 ? new d.default("TX_NOT_FOUND") : I.status == 410 ? new d.default("TX_FAILED") : new d.default("TX_INVALID");
    }
    fromRaw(B) {
      return new w.default(B);
    }
    async search(B, I) {
      return this.api.post("arql", { op: "equals", expr1: B, expr2: I }).then((C) => C.data ? C.data : []);
    }
    getStatus(B) {
      return this.api.get(`tx/${B}/status`).then((I) => I.status == 200 ? { status: 200, confirmed: I.data } : { status: I.status, confirmed: null });
    }
    async getData(B, I) {
      let C;
      try {
        C = await this.chunks.downloadChunkedData(B);
      } catch (P) {
        console.error(`Error while trying to download chunked data for ${B}`), console.error(P);
      }
      if (!C) {
        console.warn(`Falling back to gateway cache for ${B}`);
        try {
          C = (await this.api.get(`/${B}`)).data;
        } catch (P) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${B}`), console.error(P);
        }
      }
      if (!C)
        throw new Error(`${B} was not found!`);
      return I && I.decode && !I.string ? C : I && I.decode && I.string ? S.bufferToString(C) : S.bufferTob64Url(C);
    }
    async sign(B, I, C) {
      if (!(I || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if (I && I !== "use_wallet") {
        B.setOwner(I.n);
        let P = await B.getSignatureData(), q = await this.crypto.sign(I, P, C), D = await this.crypto.hash(q);
        B.setSignature({ id: S.bufferTob64Url(D), owner: I.n, signature: S.bufferTob64Url(q) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const P = await window.arweaveWallet.sign(B, C);
        B.setSignature({ id: P.id, owner: P.owner, reward: P.reward, tags: P.tags, signature: P.signature });
      }
    }
    async verify(B) {
      const I = await B.getSignatureData(), C = B.get("signature", { decode: !0, string: !1 }), P = S.bufferTob64Url(await this.crypto.hash(C));
      if (B.id !== P)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(B.owner, I, C);
    }
    async post(B) {
      if (typeof B == "string" ? B = new w.default(JSON.parse(B)) : typeof B.readInt32BE == "function" ? B = new w.default(JSON.parse(B.toString())) : typeof B != "object" || B instanceof w.default || (B = new w.default(B)), !(B instanceof w.default))
        throw new Error("Must be Transaction object");
      B.chunks || await B.prepareChunks(B.data);
      const I = await this.getUploader(B, B.data);
      try {
        for (; !I.isComplete; )
          await I.uploadChunk();
      } catch (C) {
        if (I.lastResponseStatus > 0)
          return { status: I.lastResponseStatus, statusText: I.lastResponseError, data: { error: I.lastResponseError } };
        throw C;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(B, I) {
      let C;
      if (I instanceof ArrayBuffer && (I = new Uint8Array(I)), B instanceof w.default) {
        if (I || (I = B.data), !(I instanceof Uint8Array))
          throw new Error("Data format is invalid");
        B.chunks || await B.prepareChunks(I), C = new k.TransactionUploader(this.api, B), C.data && C.data.length !== 0 || (C.data = I);
      } else {
        if (typeof B == "string" && (B = await k.TransactionUploader.fromTransactionId(this.api, B)), !(I && I instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        C = await k.TransactionUploader.fromSerialized(this.api, B, I);
      }
      return C;
    }
    upload(B, I) {
      return c(this, arguments, function* () {
        const C = yield u(this.getUploader(B, I));
        for (; !C.isComplete; )
          yield u(C.uploadChunk()), yield yield u(C);
        return yield u(C);
      });
    }
  }, transactions;
}
var wallets = {}, __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$3(o, n, a);
  return __setModuleDefault$3(o, n), o;
};
Object.defineProperty(wallets, "__esModule", { value: !0 });
const ArweaveUtils$2 = __importStar$3(utils$o);
class Wallets {
  constructor(o, a) {
    this.api = o, this.crypto = a;
  }
  getBalance(o) {
    return this.api.get(`wallet/${o}/balance`, { transformResponse: [function(a) {
      return a;
    }] }).then((a) => a.data);
  }
  getLastTransactionID(o) {
    return this.api.get(`wallet/${o}/last_tx`).then((a) => a.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(o) {
    return o && o !== "use_wallet" ? this.getAddress(o) : this.getAddress();
  }
  async getAddress(o) {
    if (o && o !== "use_wallet")
      return this.ownerToAddress(o.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(o) {
    return ArweaveUtils$2.bufferTob64Url(await this.crypto.hash(ArweaveUtils$2.b64UrlToBuffer(o)));
  }
}
wallets.default = Wallets;
var silo = {}, __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$2(o, n, a);
  return __setModuleDefault$2(o, n), o;
};
Object.defineProperty(silo, "__esModule", { value: !0 }), silo.SiloResource = void 0;
const ArweaveUtils$1 = __importStar$2(utils$o);
class Silo {
  constructor(o, a, u) {
    this.api = o, this.crypto = a, this.transactions = u;
  }
  async get(o) {
    if (!o)
      throw new Error("No Silo URI specified");
    const a = await this.parseUri(o), u = await this.transactions.search("Silo-Name", a.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${o}`);
    const c = await this.transactions.get(u[0]);
    if (!c)
      throw new Error(`No data could be found for the Silo URI: ${o}`);
    const p = c.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(p, a.getEncryptionKey());
  }
  async readTransactionData(o, a) {
    if (!a)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(a), c = o.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(c, u.getEncryptionKey());
  }
  async parseUri(o) {
    const a = o.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!a)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = a[1], c = Math.pow(2, parseInt(a[2])), p = await this.hash(ArweaveUtils$1.stringToBuffer(u), c), d = ArweaveUtils$1.bufferTob64(p.slice(0, 15)), w = await this.hash(p.slice(16, 31), 1);
    return new SiloResource(o, d, w);
  }
  async hash(o, a) {
    let u = await this.crypto.hash(o);
    for (let c = 0; c < a - 1; c++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo.default = Silo;
class SiloResource {
  constructor(o, a, u) {
    this.uri = o, this.accessKey = a, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo.SiloResource = SiloResource;
var chunks = {}, __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding$1(o, n, a);
  return __setModuleDefault$1(o, n), o;
};
Object.defineProperty(chunks, "__esModule", { value: !0 });
const error_1$1 = error, ArweaveUtils = __importStar$1(utils$o);
class Chunks {
  constructor(o) {
    this.api = o;
  }
  async getTransactionOffset(o) {
    const a = await this.api.get(`tx/${o}/offset`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$1.getError)(a)}`);
  }
  async getChunk(o) {
    const a = await this.api.get(`chunk/${o}`);
    if (a.status === 200)
      return a.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$1.getError)(a)}`);
  }
  async getChunkData(o) {
    const a = await this.getChunk(o);
    return ArweaveUtils.b64UrlToBuffer(a.chunk);
  }
  firstChunkOffset(o) {
    return parseInt(o.offset) - parseInt(o.size) + 1;
  }
  async downloadChunkedData(o) {
    const a = await this.getTransactionOffset(o), u = parseInt(a.size), c = parseInt(a.offset) - u + 1, p = new Uint8Array(u);
    let d = 0;
    for (; d < u; ) {
      let w;
      this.api.config.logging && console.log(`[chunk] ${d}/${u}`);
      try {
        w = await this.getChunkData(c + d);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${c + d}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!w)
        throw new Error(`Couldn't complete data download at ${d}/${u}`);
      p.set(w, d), d += w.length;
    }
    return p;
  }
}
chunks.default = Chunks;
var blocks = {}, __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(blocks, "__esModule", { value: !0 });
const error_1 = __importDefault$7(error);
class Blocks {
  constructor(o, a) {
    this.api = o, this.network = a;
  }
  async get(o) {
    const a = await this.api.get(`${Blocks.ENDPOINT}${o}`);
    if (a.status === 200)
      return a.data;
    throw a.status === 404 ? new error_1.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${a}`);
  }
  async getCurrent() {
    const { current: o } = await this.network.getInfo();
    return await this.get(o);
  }
}
var hasRequiredCommon, hasRequiredDeepHash, hasRequiredTransaction;
function requireCommon() {
  if (hasRequiredCommon)
    return common$7;
  hasRequiredCommon = 1;
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(z, F, V, Z) {
    Z === void 0 && (Z = V);
    var N = Object.getOwnPropertyDescriptor(F, V);
    N && !("get" in N ? !F.__esModule : N.writable || N.configurable) || (N = { enumerable: !0, get: function() {
      return F[V];
    } }), Object.defineProperty(z, Z, N);
  } : function(z, F, V, Z) {
    Z === void 0 && (Z = V), z[Z] = F[V];
  }), o = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(z, F) {
    Object.defineProperty(z, "default", { enumerable: !0, value: F });
  } : function(z, F) {
    z.default = F;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(z) {
    if (z && z.__esModule)
      return z;
    var F = {};
    if (z != null)
      for (var V in z)
        V !== "default" && Object.prototype.hasOwnProperty.call(z, V) && n(F, z, V);
    return o(F, z), F;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(z) {
    return z && z.__esModule ? z : { default: z };
  };
  Object.defineProperty(common$7, "__esModule", { value: !0 });
  const c = u(ar), p = u(api$1), d = u(nodeDriver), w = u(network), S = u(requireTransactions()), k = u(wallets), B = u(requireTransaction()), I = a(utils$o), C = u(silo), P = u(chunks), q = u(blocks);
  class D {
    constructor(F) {
      this.api = new p.default(F), this.wallets = new k.default(this.api, D.crypto), this.chunks = new P.default(this.api), this.transactions = new S.default(this.api, D.crypto, this.chunks), this.silo = new C.default(this.api, this.crypto, this.transactions), this.network = new w.default(this.api), this.blocks = new q.default(this.api, this.network), this.ar = new c.default();
    }
    get crypto() {
      return D.crypto;
    }
    get utils() {
      return D.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(F, V) {
      const Z = {};
      if (Object.assign(Z, F), !(F.data || F.target && F.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (F.owner == null && V && V !== "use_wallet" && (Z.owner = V.n), F.last_tx == null && (Z.last_tx = await this.transactions.getTransactionAnchor()), typeof F.data == "string" && (F.data = I.stringToBuffer(F.data)), F.data instanceof ArrayBuffer && (F.data = new Uint8Array(F.data)), F.data && !(F.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (F.reward == null) {
        const W = F.data ? F.data.byteLength : 0;
        Z.reward = await this.transactions.getPrice(W, Z.target);
      }
      Z.data_root = "", Z.data_size = F.data ? F.data.byteLength.toString() : "0", Z.data = F.data || new Uint8Array(0);
      const N = new B.default(Z);
      return await N.getSignatureData(), N;
    }
    async createSiloTransaction(F, V, Z) {
      const N = {};
      if (Object.assign(N, F), !F.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!Z)
        throw new Error("No Silo URI specified.");
      if (F.target || F.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (F.owner == null) {
        if (!V || !V.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        N.owner = V.n;
      }
      F.last_tx == null && (N.last_tx = await this.transactions.getTransactionAnchor());
      const W = await this.silo.parseUri(Z);
      if (typeof F.data == "string") {
        const te = await this.crypto.encrypt(I.stringToBuffer(F.data), W.getEncryptionKey());
        N.reward = await this.transactions.getPrice(te.byteLength), N.data = I.bufferTob64Url(te);
      }
      if (F.data instanceof Uint8Array) {
        const te = await this.crypto.encrypt(F.data, W.getEncryptionKey());
        N.reward = await this.transactions.getPrice(te.byteLength), N.data = I.bufferTob64Url(te);
      }
      const H = new B.default(N);
      return H.addTag("Silo-Name", W.getAccessKey()), H.addTag("Silo-Version", "0.1.0"), H;
    }
    arql(F) {
      return this.api.post("/arql", F).then((V) => V.data || []);
    }
  }
  return common$7.default = D, D.crypto = new d.default(), D.utils = I, common$7;
}
function requireDeepHash() {
  if (hasRequiredDeepHash)
    return deepHash;
  hasRequiredDeepHash = 1;
  var n = commonjsGlobal && commonjsGlobal.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(deepHash, "__esModule", { value: !0 });
  const o = n(requireCommon());
  async function a(c) {
    if (Array.isArray(c)) {
      const w = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("list"), o.default.utils.stringToBuffer(c.length.toString())]);
      return await u(c, await o.default.crypto.hash(w, "SHA-384"));
    }
    const p = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("blob"), o.default.utils.stringToBuffer(c.byteLength.toString())]), d = o.default.utils.concatBuffers([await o.default.crypto.hash(p, "SHA-384"), await o.default.crypto.hash(c, "SHA-384")]);
    return await o.default.crypto.hash(d, "SHA-384");
  }
  async function u(c, p) {
    if (c.length < 1)
      return p;
    const d = o.default.utils.concatBuffers([p, await a(c[0])]), w = await o.default.crypto.hash(d, "SHA-384");
    return await u(c.slice(1), w);
  }
  return deepHash.default = a, deepHash;
}
function requireTransaction() {
  if (hasRequiredTransaction)
    return transaction;
  hasRequiredTransaction = 1;
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(k, B, I, C) {
    C === void 0 && (C = I);
    var P = Object.getOwnPropertyDescriptor(B, I);
    P && !("get" in P ? !B.__esModule : P.writable || P.configurable) || (P = { enumerable: !0, get: function() {
      return B[I];
    } }), Object.defineProperty(k, C, P);
  } : function(k, B, I, C) {
    C === void 0 && (C = I), k[C] = B[I];
  }), o = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(k, B) {
    Object.defineProperty(k, "default", { enumerable: !0, value: B });
  } : function(k, B) {
    k.default = B;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(k) {
    if (k && k.__esModule)
      return k;
    var B = {};
    if (k != null)
      for (var I in k)
        I !== "default" && Object.prototype.hasOwnProperty.call(k, I) && n(B, k, I);
    return o(B, k), B;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(k) {
    return k && k.__esModule ? k : { default: k };
  };
  Object.defineProperty(transaction, "__esModule", { value: !0 }), transaction.Tag = void 0;
  const c = a(utils$o), p = u(requireDeepHash()), d = requireMerkle();
  class w {
    get(B, I) {
      if (!Object.getOwnPropertyNames(this).includes(B))
        throw new Error(`Field "${B}" is not a property of the Arweave Transaction class.`);
      return this[B] instanceof Uint8Array ? I && I.decode && I.string ? c.bufferToString(this[B]) : I && I.decode && !I.string ? this[B] : c.bufferTob64Url(this[B]) : I && I.decode == 1 ? I && I.string ? c.b64UrlToString(this[B]) : c.b64UrlToBuffer(this[B]) : this[B];
    }
  }
  class S extends w {
    constructor(B, I, C = !1) {
      super(), this.name = B, this.value = I;
    }
  }
  return transaction.Tag = S, transaction.default = class extends w {
    constructor(k = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, k), typeof this.data == "string" && (this.data = c.b64UrlToBuffer(this.data)), k.tags && (this.tags = k.tags.map((B) => new S(B.name, B.value)));
    }
    addTag(k, B) {
      this.tags.push(new S(c.stringToB64Url(k), c.stringToB64Url(B)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: c.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(k) {
      this.owner = k;
    }
    setSignature({ id: k, owner: B, reward: I, tags: C, signature: P }) {
      this.id = k, this.owner = B, I && (this.reward = I), C && (this.tags = C), this.signature = P;
    }
    async prepareChunks(k) {
      !this.chunks && k.byteLength > 0 && (this.chunks = await (0, d.generateTransactionChunks)(k), this.data_root = c.bufferTob64Url(this.chunks.data_root)), this.chunks || k.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(k, B) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const I = this.chunks.proofs[k], C = this.chunks.chunks[k];
      return { data_root: this.data_root, data_size: this.data_size, data_path: c.bufferTob64Url(I.proof), offset: I.offset.toString(), chunk: c.bufferTob64Url(B.slice(C.minByteRange, C.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let k = this.tags.reduce((I, C) => c.concatBuffers([I, C.get("name", { decode: !0, string: !1 }), C.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return c.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), c.stringToBuffer(this.quantity), c.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), k]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const B = this.tags.map((I) => [I.get("name", { decode: !0, string: !1 }), I.get("value", { decode: !0, string: !1 })]);
          return await (0, p.default)([c.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), c.stringToBuffer(this.quantity), c.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), B, c.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction;
}
blocks.default = Blocks, Blocks.ENDPOINT = "block/hash/";
var npmBrowser$1 = {}, buffer$3 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const o = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = d, n.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function p(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, y) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return k(l);
    }
    return w(l, h, y);
  }
  function w(l, h, y) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | P(x, O);
        let X = p(G);
        const ie = X.write(x, O);
        return ie !== G && (X = X.slice(0, ie)), X;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (se(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (se(l, ArrayBuffer) || l && se(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (se(l, SharedArrayBuffer) || l && se(l.buffer, SharedArrayBuffer)))
      return I(l, h, y);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const A = l.valueOf && l.valueOf();
    if (A != null && A !== l)
      return d.from(A, h, y);
    const M = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = p(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? p(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (M)
      return M;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, y);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function k(l) {
    return S(l), p(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), y = p(h);
    for (let A = 0; A < h; A += 1)
      y[A] = 255 & l[A];
    return y;
  }
  function I(l, h, y) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (y || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return A = h === void 0 && y === void 0 ? new Uint8Array(l) : y === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, y), Object.setPrototypeOf(A, d.prototype), A;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function P(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || se(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const y = l.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && y === 0)
      return 0;
    let M = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return y;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * y;
        case "hex":
          return y >>> 1;
        case "base64":
          return _e(l).length;
        default:
          if (M)
            return A ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), M = !0;
      }
  }
  function q(l, h, y) {
    let A = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return m(this, h, y);
        case "utf8":
        case "utf-8":
          return g(this, h, y);
        case "ascii":
          return _(this, h, y);
        case "latin1":
        case "binary":
          return b(this, h, y);
        case "base64":
          return te(this, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, y);
        default:
          if (A)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), A = !0;
      }
  }
  function D(l, h, y) {
    const A = l[h];
    l[h] = l[y], l[y] = A;
  }
  function z(l, h, y, A, M) {
    if (l.length === 0)
      return -1;
    if (typeof y == "string" ? (A = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), we(y = +y) && (y = M ? 0 : l.length - 1), y < 0 && (y = l.length + y), y >= l.length) {
      if (M)
        return -1;
      y = l.length - 1;
    } else if (y < 0) {
      if (!M)
        return -1;
      y = 0;
    }
    if (typeof h == "string" && (h = d.from(h, A)), d.isBuffer(h))
      return h.length === 0 ? -1 : F(l, h, y, A, M);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? M ? Uint8Array.prototype.indexOf.call(l, h, y) : Uint8Array.prototype.lastIndexOf.call(l, h, y) : F(l, [h], y, A, M);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(l, h, y, A, M) {
    let x, O = 1, G = l.length, X = h.length;
    if (A !== void 0 && ((A = String(A).toLowerCase()) === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, X /= 2, y /= 2;
    }
    function ie(ee, re) {
      return O === 1 ? ee[re] : ee.readUInt16BE(re * O);
    }
    if (M) {
      let ee = -1;
      for (x = y; x < G; x++)
        if (ie(l, x) === ie(h, ee === -1 ? 0 : x - ee)) {
          if (ee === -1 && (ee = x), x - ee + 1 === X)
            return ee * O;
        } else
          ee !== -1 && (x -= x - ee), ee = -1;
    } else
      for (y + X > G && (y = G - X), x = y; x >= 0; x--) {
        let ee = !0;
        for (let re = 0; re < X; re++)
          if (ie(l, x + re) !== ie(h, re)) {
            ee = !1;
            break;
          }
        if (ee)
          return x;
      }
    return -1;
  }
  function V(l, h, y, A) {
    y = Number(y) || 0;
    const M = l.length - y;
    A ? (A = Number(A)) > M && (A = M) : A = M;
    const x = h.length;
    let O;
    for (A > x / 2 && (A = x / 2), O = 0; O < A; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[y + O] = G;
    }
    return O;
  }
  function Z(l, h, y, A) {
    return Le(he(h, l.length - y), l, y, A);
  }
  function N(l, h, y, A) {
    return Le(function(M) {
      const x = [];
      for (let O = 0; O < M.length; ++O)
        x.push(255 & M.charCodeAt(O));
      return x;
    }(h), l, y, A);
  }
  function W(l, h, y, A) {
    return Le(_e(h), l, y, A);
  }
  function H(l, h, y, A) {
    return Le(function(M, x) {
      let O, G, X;
      const ie = [];
      for (let ee = 0; ee < M.length && !((x -= 2) < 0); ++ee)
        O = M.charCodeAt(ee), G = O >> 8, X = O % 256, ie.push(X), ie.push(G);
      return ie;
    }(h, l.length - y), l, y, A);
  }
  function te(l, h, y) {
    return h === 0 && y === l.length ? o.fromByteArray(l) : o.fromByteArray(l.slice(h, y));
  }
  function g(l, h, y) {
    y = Math.min(l.length, y);
    const A = [];
    let M = h;
    for (; M < y; ) {
      const x = l[M];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (M + G <= y) {
        let X, ie, ee, re;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            X = l[M + 1], (192 & X) == 128 && (re = (31 & x) << 6 | 63 & X, re > 127 && (O = re));
            break;
          case 3:
            X = l[M + 1], ie = l[M + 2], (192 & X) == 128 && (192 & ie) == 128 && (re = (15 & x) << 12 | (63 & X) << 6 | 63 & ie, re > 2047 && (re < 55296 || re > 57343) && (O = re));
            break;
          case 4:
            X = l[M + 1], ie = l[M + 2], ee = l[M + 3], (192 & X) == 128 && (192 & ie) == 128 && (192 & ee) == 128 && (re = (15 & x) << 18 | (63 & X) << 12 | (63 & ie) << 6 | 63 & ee, re > 65535 && re < 1114112 && (O = re));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, A.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), A.push(O), M += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", X = 0;
      for (; X < O; )
        G += String.fromCharCode.apply(String, x.slice(X, X += $));
      return G;
    }(A);
  }
  n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, y) {
    return w(l, h, y);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, y) {
    return function(A, M, x) {
      return S(A), A <= 0 ? p(A) : M !== void 0 ? typeof x == "string" ? p(A).fill(M, x) : p(A).fill(M) : p(A);
    }(l, h, y);
  }, d.allocUnsafe = function(l) {
    return k(l);
  }, d.allocUnsafeSlow = function(l) {
    return k(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), se(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let y = l.length, A = h.length;
    for (let M = 0, x = Math.min(y, A); M < x; ++M)
      if (l[M] !== h[M]) {
        y = l[M], A = h[M];
        break;
      }
    return y < A ? -1 : A < y ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let y;
    if (h === void 0)
      for (h = 0, y = 0; y < l.length; ++y)
        h += l[y].length;
    const A = d.allocUnsafe(h);
    let M = 0;
    for (y = 0; y < l.length; ++y) {
      let x = l[y];
      if (se(x, Uint8Array))
        M + x.length > A.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(A, M)) : Uint8Array.prototype.set.call(A, x, M);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(A, M);
      }
      M += x.length;
    }
    return A;
  }, d.byteLength = P, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? g(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = n.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, y, A, M) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), y === void 0 && (y = l ? l.length : 0), A === void 0 && (A = 0), M === void 0 && (M = this.length), h < 0 || y > l.length || A < 0 || M > this.length)
      throw new RangeError("out of range index");
    if (A >= M && h >= y)
      return 0;
    if (A >= M)
      return -1;
    if (h >= y)
      return 1;
    if (this === l)
      return 0;
    let x = (M >>>= 0) - (A >>>= 0), O = (y >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), X = this.slice(A, M), ie = l.slice(h, y);
    for (let ee = 0; ee < G; ++ee)
      if (X[ee] !== ie[ee]) {
        x = X[ee], O = ie[ee];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, y) {
    return this.indexOf(l, h, y) !== -1;
  }, d.prototype.indexOf = function(l, h, y) {
    return z(this, l, h, y, !0);
  }, d.prototype.lastIndexOf = function(l, h, y) {
    return z(this, l, h, y, !1);
  }, d.prototype.write = function(l, h, y, A) {
    if (h === void 0)
      A = "utf8", y = this.length, h = 0;
    else if (y === void 0 && typeof h == "string")
      A = h, y = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(y) ? (y >>>= 0, A === void 0 && (A = "utf8")) : (A = y, y = void 0);
    }
    const M = this.length - h;
    if ((y === void 0 || y > M) && (y = M), l.length > 0 && (y < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    A || (A = "utf8");
    let x = !1;
    for (; ; )
      switch (A) {
        case "hex":
          return V(this, l, h, y);
        case "utf8":
        case "utf-8":
          return Z(this, l, h, y);
        case "ascii":
        case "latin1":
        case "binary":
          return N(this, l, h, y);
        case "base64":
          return W(this, l, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, y);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + A);
          A = ("" + A).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(127 & l[M]);
    return A;
  }
  function b(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(l[M]);
    return A;
  }
  function m(l, h, y) {
    const A = l.length;
    (!h || h < 0) && (h = 0), (!y || y < 0 || y > A) && (y = A);
    let M = "";
    for (let x = h; x < y; ++x)
      M += We[l[x]];
    return M;
  }
  function v(l, h, y) {
    const A = l.slice(h, y);
    let M = "";
    for (let x = 0; x < A.length - 1; x += 2)
      M += String.fromCharCode(A[x] + 256 * A[x + 1]);
    return M;
  }
  function E(l, h, y) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > y)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function T(l, h, y, A, M, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > M || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (y + A > l.length)
      throw new RangeError("Index out of range");
  }
  function j(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, y;
  }
  function L(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y + 7] = x, x >>= 8, l[y + 6] = x, x >>= 8, l[y + 5] = x, x >>= 8, l[y + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y + 3] = O, O >>= 8, l[y + 2] = O, O >>= 8, l[y + 1] = O, O >>= 8, l[y] = O, y + 8;
  }
  function J(l, h, y, A, M, x) {
    if (y + A > l.length)
      throw new RangeError("Index out of range");
    if (y < 0)
      throw new RangeError("Index out of range");
  }
  function Y(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 4), a.write(l, h, y, A, 23, 4), y + 4;
  }
  function ne(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 8), a.write(l, h, y, A, 52, 8), y + 8;
  }
  d.prototype.slice = function(l, h) {
    const y = this.length;
    (l = ~~l) < 0 ? (l += y) < 0 && (l = 0) : l > y && (l = y), (h = h === void 0 ? y : ~~h) < 0 ? (h += y) < 0 && (h = 0) : h > y && (h = y), h < l && (h = l);
    const A = this.subarray(l, h);
    return Object.setPrototypeOf(A, d.prototype), A;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return A;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l + --h], M = 1;
    for (; h > 0 && (M *= 256); )
      A += this[l + --h] * M;
    return A;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, M = this[++l] + 256 * this[++l] + 65536 * this[++l] + y * 2 ** 24;
    return BigInt(A) + (BigInt(M) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], M = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y;
    return (BigInt(A) << BigInt(32)) + BigInt(M);
  }), d.prototype.readIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return M *= 128, A >= M && (A -= Math.pow(2, 8 * h)), A;
  }, d.prototype.readIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = h, M = 1, x = this[l + --A];
    for (; A > 0 && (M *= 256); )
      x += this[l + --A] * M;
    return M *= 128, x >= M && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l] | this[l + 1] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l + 1] | this[l] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (y << 24);
    return (BigInt(A) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = 1, x = 0;
    for (this[h] = 255 & l; ++x < y && (M *= 256); )
      this[h + x] = l / M & 255;
    return h + y;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = y - 1, x = 1;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      this[h + M] = l / x & 255;
    return h + y;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++M < y && (x *= 256); )
      l < 0 && O === 0 && this[h + M - 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeIntBE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = y - 1, x = 1, O = 0;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + M + 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, y) {
    return Y(this, l, h, !0, y);
  }, d.prototype.writeFloatBE = function(l, h, y) {
    return Y(this, l, h, !1, y);
  }, d.prototype.writeDoubleLE = function(l, h, y) {
    return ne(this, l, h, !0, y);
  }, d.prototype.writeDoubleBE = function(l, h, y) {
    return ne(this, l, h, !1, y);
  }, d.prototype.copy = function(l, h, y, A) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (y || (y = 0), A || A === 0 || (A = this.length), h >= l.length && (h = l.length), h || (h = 0), A > 0 && A < y && (A = y), A === y || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (y < 0 || y >= this.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("sourceEnd out of bounds");
    A > this.length && (A = this.length), l.length - h < A - y && (A = l.length - h + y);
    const M = A - y;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, y, A) : Uint8Array.prototype.set.call(l, this.subarray(y, A), h), M;
  }, d.prototype.fill = function(l, h, y, A) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (A = h, h = 0, y = this.length) : typeof y == "string" && (A = y, y = this.length), A !== void 0 && typeof A != "string")
        throw new TypeError("encoding must be a string");
      if (typeof A == "string" && !d.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (A === "utf8" && x < 128 || A === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < y)
      throw new RangeError("Out of range index");
    if (y <= h)
      return this;
    let M;
    if (h >>>= 0, y = y === void 0 ? this.length : y >>> 0, l || (l = 0), typeof l == "number")
      for (M = h; M < y; ++M)
        this[M] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, A), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (M = 0; M < y - h; ++M)
        this[M + h] = x[M % O];
    }
    return this;
  };
  const Q = {};
  function oe(l, h, y) {
    Q[l] = class extends y {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(A) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: A, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function ae(l) {
    let h = "", y = l.length;
    const A = l[0] === "-" ? 1 : 0;
    for (; y >= A + 4; y -= 3)
      h = `_${l.slice(y - 3, y)}${h}`;
    return `${l.slice(0, y)}${h}`;
  }
  function ce(l, h, y, A, M, x) {
    if (l > y || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${y}${O}`, new Q.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, X) {
      ue(G, "offset"), O[G] !== void 0 && O[G + X] !== void 0 || le(G, O.length - (X + 1));
    })(A, M, x);
  }
  function ue(l, h) {
    if (typeof l != "number")
      throw new Q.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function le(l, h, y) {
    throw Math.floor(l) !== l ? (ue(l, y), new Q.ERR_OUT_OF_RANGE(y || "offset", "an integer", l)) : h < 0 ? new Q.ERR_BUFFER_OUT_OF_BOUNDS() : new Q.ERR_OUT_OF_RANGE(y || "offset", `>= ${y ? 1 : 0} and <= ${h}`, l);
  }
  oe("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), oe("ERR_OUT_OF_RANGE", function(l, h, y) {
    let A = `The value of "${l}" is out of range.`, M = y;
    return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? M = ae(String(y)) : typeof y == "bigint" && (M = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (M = ae(M)), M += "n"), A += ` It must be ${h}. Received ${M}`, A;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let y;
    h = h || 1 / 0;
    const A = l.length;
    let M = null;
    const x = [];
    for (let O = 0; O < A; ++O) {
      if (y = l.charCodeAt(O), y > 55295 && y < 57344) {
        if (!M) {
          if (y > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === A) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          M = y;
          continue;
        }
        if (y < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), M = y;
          continue;
        }
        y = 65536 + (M - 55296 << 10 | y - 56320);
      } else
        M && (h -= 3) > -1 && x.push(239, 191, 189);
      if (M = null, y < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(y);
      } else if (y < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(y >> 6 | 192, 63 & y | 128);
      } else if (y < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(y >> 12 | 224, y >> 6 & 63 | 128, 63 & y | 128);
      } else {
        if (!(y < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, 63 & y | 128);
      }
    }
    return x;
  }
  function _e(l) {
    return o.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function Le(l, h, y, A) {
    let M;
    for (M = 0; M < A && !(M + y >= h.length || M >= l.length); ++M)
      h[M + y] = l[M];
    return M;
  }
  function se(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let y = 0; y < 16; ++y) {
      const A = 16 * y;
      for (let M = 0; M < 16; ++M)
        h[A + M] = l[y] + l[M];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$3), window.global = window, commonjsGlobal.fetch = window.fetch, npmBrowser$1.Buffer = buffer$3.Buffer;
var WarpFactory = {}, LevelDbCache$1 = {}, browser = {}, browserLevel = {}, abstractLevel$1 = {}, abstractLevel = {}, levelSupports = { supports: function(...n) {
  const o = n.reduce((a, u) => Object.assign(a, u), {});
  return Object.assign(o, { snapshots: o.snapshots || !1, permanence: o.permanence || !1, seek: o.seek || !1, clear: o.clear || !1, getMany: o.getMany || !1, keyIterator: o.keyIterator || !1, valueIterator: o.valueIterator || !1, iteratorNextv: o.iteratorNextv || !1, iteratorAll: o.iteratorAll || !1, status: o.status || !1, createIfMissing: o.createIfMissing || !1, errorIfExists: o.errorIfExists || !1, deferredOpen: o.deferredOpen || !1, promises: o.promises || !1, streams: o.streams || !1, encodings: Object.assign({}, o.encodings), events: Object.assign({}, o.events), additionalMethods: Object.assign({}, o.additionalMethods) });
} }, levelTranscoder = {}, moduleError = class extends Error {
  constructor(n, o) {
    super(n || ""), typeof o == "object" && o !== null && (o.code && (this.code = String(o.code)), o.expected && (this.expected = !0), o.transient && (this.transient = !0), o.cause && (this.cause = o.cause)), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}, encodings$1 = {}, buffer$2 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const o = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = d, n.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function p(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, y) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return k(l);
    }
    return w(l, h, y);
  }
  function w(l, h, y) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | P(x, O);
        let X = p(G);
        const ie = X.write(x, O);
        return ie !== G && (X = X.slice(0, ie)), X;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (se(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (se(l, ArrayBuffer) || l && se(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (se(l, SharedArrayBuffer) || l && se(l.buffer, SharedArrayBuffer)))
      return I(l, h, y);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const A = l.valueOf && l.valueOf();
    if (A != null && A !== l)
      return d.from(A, h, y);
    const M = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = p(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? p(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (M)
      return M;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, y);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function k(l) {
    return S(l), p(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), y = p(h);
    for (let A = 0; A < h; A += 1)
      y[A] = 255 & l[A];
    return y;
  }
  function I(l, h, y) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (y || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return A = h === void 0 && y === void 0 ? new Uint8Array(l) : y === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, y), Object.setPrototypeOf(A, d.prototype), A;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function P(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || se(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const y = l.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && y === 0)
      return 0;
    let M = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return y;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * y;
        case "hex":
          return y >>> 1;
        case "base64":
          return _e(l).length;
        default:
          if (M)
            return A ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), M = !0;
      }
  }
  function q(l, h, y) {
    let A = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return m(this, h, y);
        case "utf8":
        case "utf-8":
          return g(this, h, y);
        case "ascii":
          return _(this, h, y);
        case "latin1":
        case "binary":
          return b(this, h, y);
        case "base64":
          return te(this, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, y);
        default:
          if (A)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), A = !0;
      }
  }
  function D(l, h, y) {
    const A = l[h];
    l[h] = l[y], l[y] = A;
  }
  function z(l, h, y, A, M) {
    if (l.length === 0)
      return -1;
    if (typeof y == "string" ? (A = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), we(y = +y) && (y = M ? 0 : l.length - 1), y < 0 && (y = l.length + y), y >= l.length) {
      if (M)
        return -1;
      y = l.length - 1;
    } else if (y < 0) {
      if (!M)
        return -1;
      y = 0;
    }
    if (typeof h == "string" && (h = d.from(h, A)), d.isBuffer(h))
      return h.length === 0 ? -1 : F(l, h, y, A, M);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? M ? Uint8Array.prototype.indexOf.call(l, h, y) : Uint8Array.prototype.lastIndexOf.call(l, h, y) : F(l, [h], y, A, M);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(l, h, y, A, M) {
    let x, O = 1, G = l.length, X = h.length;
    if (A !== void 0 && ((A = String(A).toLowerCase()) === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, X /= 2, y /= 2;
    }
    function ie(ee, re) {
      return O === 1 ? ee[re] : ee.readUInt16BE(re * O);
    }
    if (M) {
      let ee = -1;
      for (x = y; x < G; x++)
        if (ie(l, x) === ie(h, ee === -1 ? 0 : x - ee)) {
          if (ee === -1 && (ee = x), x - ee + 1 === X)
            return ee * O;
        } else
          ee !== -1 && (x -= x - ee), ee = -1;
    } else
      for (y + X > G && (y = G - X), x = y; x >= 0; x--) {
        let ee = !0;
        for (let re = 0; re < X; re++)
          if (ie(l, x + re) !== ie(h, re)) {
            ee = !1;
            break;
          }
        if (ee)
          return x;
      }
    return -1;
  }
  function V(l, h, y, A) {
    y = Number(y) || 0;
    const M = l.length - y;
    A ? (A = Number(A)) > M && (A = M) : A = M;
    const x = h.length;
    let O;
    for (A > x / 2 && (A = x / 2), O = 0; O < A; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[y + O] = G;
    }
    return O;
  }
  function Z(l, h, y, A) {
    return Le(he(h, l.length - y), l, y, A);
  }
  function N(l, h, y, A) {
    return Le(function(M) {
      const x = [];
      for (let O = 0; O < M.length; ++O)
        x.push(255 & M.charCodeAt(O));
      return x;
    }(h), l, y, A);
  }
  function W(l, h, y, A) {
    return Le(_e(h), l, y, A);
  }
  function H(l, h, y, A) {
    return Le(function(M, x) {
      let O, G, X;
      const ie = [];
      for (let ee = 0; ee < M.length && !((x -= 2) < 0); ++ee)
        O = M.charCodeAt(ee), G = O >> 8, X = O % 256, ie.push(X), ie.push(G);
      return ie;
    }(h, l.length - y), l, y, A);
  }
  function te(l, h, y) {
    return h === 0 && y === l.length ? o.fromByteArray(l) : o.fromByteArray(l.slice(h, y));
  }
  function g(l, h, y) {
    y = Math.min(l.length, y);
    const A = [];
    let M = h;
    for (; M < y; ) {
      const x = l[M];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (M + G <= y) {
        let X, ie, ee, re;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            X = l[M + 1], (192 & X) == 128 && (re = (31 & x) << 6 | 63 & X, re > 127 && (O = re));
            break;
          case 3:
            X = l[M + 1], ie = l[M + 2], (192 & X) == 128 && (192 & ie) == 128 && (re = (15 & x) << 12 | (63 & X) << 6 | 63 & ie, re > 2047 && (re < 55296 || re > 57343) && (O = re));
            break;
          case 4:
            X = l[M + 1], ie = l[M + 2], ee = l[M + 3], (192 & X) == 128 && (192 & ie) == 128 && (192 & ee) == 128 && (re = (15 & x) << 18 | (63 & X) << 12 | (63 & ie) << 6 | 63 & ee, re > 65535 && re < 1114112 && (O = re));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, A.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), A.push(O), M += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", X = 0;
      for (; X < O; )
        G += String.fromCharCode.apply(String, x.slice(X, X += $));
      return G;
    }(A);
  }
  n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, y) {
    return w(l, h, y);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, y) {
    return function(A, M, x) {
      return S(A), A <= 0 ? p(A) : M !== void 0 ? typeof x == "string" ? p(A).fill(M, x) : p(A).fill(M) : p(A);
    }(l, h, y);
  }, d.allocUnsafe = function(l) {
    return k(l);
  }, d.allocUnsafeSlow = function(l) {
    return k(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), se(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let y = l.length, A = h.length;
    for (let M = 0, x = Math.min(y, A); M < x; ++M)
      if (l[M] !== h[M]) {
        y = l[M], A = h[M];
        break;
      }
    return y < A ? -1 : A < y ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let y;
    if (h === void 0)
      for (h = 0, y = 0; y < l.length; ++y)
        h += l[y].length;
    const A = d.allocUnsafe(h);
    let M = 0;
    for (y = 0; y < l.length; ++y) {
      let x = l[y];
      if (se(x, Uint8Array))
        M + x.length > A.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(A, M)) : Uint8Array.prototype.set.call(A, x, M);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(A, M);
      }
      M += x.length;
    }
    return A;
  }, d.byteLength = P, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? g(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = n.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, y, A, M) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), y === void 0 && (y = l ? l.length : 0), A === void 0 && (A = 0), M === void 0 && (M = this.length), h < 0 || y > l.length || A < 0 || M > this.length)
      throw new RangeError("out of range index");
    if (A >= M && h >= y)
      return 0;
    if (A >= M)
      return -1;
    if (h >= y)
      return 1;
    if (this === l)
      return 0;
    let x = (M >>>= 0) - (A >>>= 0), O = (y >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), X = this.slice(A, M), ie = l.slice(h, y);
    for (let ee = 0; ee < G; ++ee)
      if (X[ee] !== ie[ee]) {
        x = X[ee], O = ie[ee];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, y) {
    return this.indexOf(l, h, y) !== -1;
  }, d.prototype.indexOf = function(l, h, y) {
    return z(this, l, h, y, !0);
  }, d.prototype.lastIndexOf = function(l, h, y) {
    return z(this, l, h, y, !1);
  }, d.prototype.write = function(l, h, y, A) {
    if (h === void 0)
      A = "utf8", y = this.length, h = 0;
    else if (y === void 0 && typeof h == "string")
      A = h, y = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(y) ? (y >>>= 0, A === void 0 && (A = "utf8")) : (A = y, y = void 0);
    }
    const M = this.length - h;
    if ((y === void 0 || y > M) && (y = M), l.length > 0 && (y < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    A || (A = "utf8");
    let x = !1;
    for (; ; )
      switch (A) {
        case "hex":
          return V(this, l, h, y);
        case "utf8":
        case "utf-8":
          return Z(this, l, h, y);
        case "ascii":
        case "latin1":
        case "binary":
          return N(this, l, h, y);
        case "base64":
          return W(this, l, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, y);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + A);
          A = ("" + A).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(127 & l[M]);
    return A;
  }
  function b(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(l[M]);
    return A;
  }
  function m(l, h, y) {
    const A = l.length;
    (!h || h < 0) && (h = 0), (!y || y < 0 || y > A) && (y = A);
    let M = "";
    for (let x = h; x < y; ++x)
      M += We[l[x]];
    return M;
  }
  function v(l, h, y) {
    const A = l.slice(h, y);
    let M = "";
    for (let x = 0; x < A.length - 1; x += 2)
      M += String.fromCharCode(A[x] + 256 * A[x + 1]);
    return M;
  }
  function E(l, h, y) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > y)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function T(l, h, y, A, M, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > M || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (y + A > l.length)
      throw new RangeError("Index out of range");
  }
  function j(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, y;
  }
  function L(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y + 7] = x, x >>= 8, l[y + 6] = x, x >>= 8, l[y + 5] = x, x >>= 8, l[y + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y + 3] = O, O >>= 8, l[y + 2] = O, O >>= 8, l[y + 1] = O, O >>= 8, l[y] = O, y + 8;
  }
  function J(l, h, y, A, M, x) {
    if (y + A > l.length)
      throw new RangeError("Index out of range");
    if (y < 0)
      throw new RangeError("Index out of range");
  }
  function Y(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 4), a.write(l, h, y, A, 23, 4), y + 4;
  }
  function ne(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 8), a.write(l, h, y, A, 52, 8), y + 8;
  }
  d.prototype.slice = function(l, h) {
    const y = this.length;
    (l = ~~l) < 0 ? (l += y) < 0 && (l = 0) : l > y && (l = y), (h = h === void 0 ? y : ~~h) < 0 ? (h += y) < 0 && (h = 0) : h > y && (h = y), h < l && (h = l);
    const A = this.subarray(l, h);
    return Object.setPrototypeOf(A, d.prototype), A;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return A;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l + --h], M = 1;
    for (; h > 0 && (M *= 256); )
      A += this[l + --h] * M;
    return A;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, M = this[++l] + 256 * this[++l] + 65536 * this[++l] + y * 2 ** 24;
    return BigInt(A) + (BigInt(M) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], M = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y;
    return (BigInt(A) << BigInt(32)) + BigInt(M);
  }), d.prototype.readIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return M *= 128, A >= M && (A -= Math.pow(2, 8 * h)), A;
  }, d.prototype.readIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = h, M = 1, x = this[l + --A];
    for (; A > 0 && (M *= 256); )
      x += this[l + --A] * M;
    return M *= 128, x >= M && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l] | this[l + 1] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l + 1] | this[l] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (y << 24);
    return (BigInt(A) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = 1, x = 0;
    for (this[h] = 255 & l; ++x < y && (M *= 256); )
      this[h + x] = l / M & 255;
    return h + y;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = y - 1, x = 1;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      this[h + M] = l / x & 255;
    return h + y;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++M < y && (x *= 256); )
      l < 0 && O === 0 && this[h + M - 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeIntBE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = y - 1, x = 1, O = 0;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + M + 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, y) {
    return Y(this, l, h, !0, y);
  }, d.prototype.writeFloatBE = function(l, h, y) {
    return Y(this, l, h, !1, y);
  }, d.prototype.writeDoubleLE = function(l, h, y) {
    return ne(this, l, h, !0, y);
  }, d.prototype.writeDoubleBE = function(l, h, y) {
    return ne(this, l, h, !1, y);
  }, d.prototype.copy = function(l, h, y, A) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (y || (y = 0), A || A === 0 || (A = this.length), h >= l.length && (h = l.length), h || (h = 0), A > 0 && A < y && (A = y), A === y || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (y < 0 || y >= this.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("sourceEnd out of bounds");
    A > this.length && (A = this.length), l.length - h < A - y && (A = l.length - h + y);
    const M = A - y;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, y, A) : Uint8Array.prototype.set.call(l, this.subarray(y, A), h), M;
  }, d.prototype.fill = function(l, h, y, A) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (A = h, h = 0, y = this.length) : typeof y == "string" && (A = y, y = this.length), A !== void 0 && typeof A != "string")
        throw new TypeError("encoding must be a string");
      if (typeof A == "string" && !d.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (A === "utf8" && x < 128 || A === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < y)
      throw new RangeError("Out of range index");
    if (y <= h)
      return this;
    let M;
    if (h >>>= 0, y = y === void 0 ? this.length : y >>> 0, l || (l = 0), typeof l == "number")
      for (M = h; M < y; ++M)
        this[M] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, A), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (M = 0; M < y - h; ++M)
        this[M + h] = x[M % O];
    }
    return this;
  };
  const Q = {};
  function oe(l, h, y) {
    Q[l] = class extends y {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(A) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: A, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function ae(l) {
    let h = "", y = l.length;
    const A = l[0] === "-" ? 1 : 0;
    for (; y >= A + 4; y -= 3)
      h = `_${l.slice(y - 3, y)}${h}`;
    return `${l.slice(0, y)}${h}`;
  }
  function ce(l, h, y, A, M, x) {
    if (l > y || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${y}${O}`, new Q.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, X) {
      ue(G, "offset"), O[G] !== void 0 && O[G + X] !== void 0 || le(G, O.length - (X + 1));
    })(A, M, x);
  }
  function ue(l, h) {
    if (typeof l != "number")
      throw new Q.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function le(l, h, y) {
    throw Math.floor(l) !== l ? (ue(l, y), new Q.ERR_OUT_OF_RANGE(y || "offset", "an integer", l)) : h < 0 ? new Q.ERR_BUFFER_OUT_OF_BOUNDS() : new Q.ERR_OUT_OF_RANGE(y || "offset", `>= ${y ? 1 : 0} and <= ${h}`, l);
  }
  oe("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), oe("ERR_OUT_OF_RANGE", function(l, h, y) {
    let A = `The value of "${l}" is out of range.`, M = y;
    return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? M = ae(String(y)) : typeof y == "bigint" && (M = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (M = ae(M)), M += "n"), A += ` It must be ${h}. Received ${M}`, A;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let y;
    h = h || 1 / 0;
    const A = l.length;
    let M = null;
    const x = [];
    for (let O = 0; O < A; ++O) {
      if (y = l.charCodeAt(O), y > 55295 && y < 57344) {
        if (!M) {
          if (y > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === A) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          M = y;
          continue;
        }
        if (y < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), M = y;
          continue;
        }
        y = 65536 + (M - 55296 << 10 | y - 56320);
      } else
        M && (h -= 3) > -1 && x.push(239, 191, 189);
      if (M = null, y < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(y);
      } else if (y < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(y >> 6 | 192, 63 & y | 128);
      } else if (y < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(y >> 12 | 224, y >> 6 & 63 | 128, 63 & y | 128);
      } else {
        if (!(y < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, 63 & y | 128);
      }
    }
    return x;
  }
  function _e(l) {
    return o.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function Le(l, h, y, A) {
    let M;
    for (M = 0; M < A && !(M + y >= h.length || M >= l.length); ++M)
      h[M + y] = l[M];
    return M;
  }
  function se(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let y = 0; y < 16; ++y) {
      const A = 16 * y;
      for (let M = 0; M < 16; ++M)
        h[A + M] = l[y] + l[M];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
let lazy = null;
var textEndec$1 = function() {
  return lazy === null && (lazy = { textEncoder: new TextEncoder(), textDecoder: new TextDecoder() }), lazy;
}, formats$2 = {}, encoding = {};
const ModuleError$9 = moduleError, formats$1 = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Encoding$2 {
  constructor(o) {
    if (this.encode = o.encode || this.encode, this.decode = o.decode || this.decode, this.name = o.name || this.name, this.format = o.format || this.format, typeof this.encode != "function")
      throw new TypeError("The 'encode' property must be a function");
    if (typeof this.decode != "function")
      throw new TypeError("The 'decode' property must be a function");
    if (this.encode = this.encode.bind(this), this.decode = this.decode.bind(this), typeof this.name != "string" || this.name === "")
      throw new TypeError("The 'name' property must be a string");
    if (typeof this.format != "string" || !formats$1.has(this.format))
      throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
    o.createViewTranscoder && (this.createViewTranscoder = o.createViewTranscoder), o.createBufferTranscoder && (this.createBufferTranscoder = o.createBufferTranscoder), o.createUTF8Transcoder && (this.createUTF8Transcoder = o.createUTF8Transcoder);
  }
  get commonName() {
    return this.name.split("+")[0];
  }
  createBufferTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createViewTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'view'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createUTF8Transcoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
}
encoding.Encoding = Encoding$2;
const { Buffer: Buffer$6 } = buffer$2 || {}, { Encoding: Encoding$1 } = encoding, textEndec = textEndec$1;
class BufferFormat$2 extends Encoding$1 {
  constructor(o) {
    super({ ...o, format: "buffer" });
  }
  createViewTranscoder() {
    return new ViewFormat$2({ encode: this.encode, decode: (o) => this.decode(Buffer$6.from(o.buffer, o.byteOffset, o.byteLength)), name: `${this.name}+view` });
  }
  createBufferTranscoder() {
    return this;
  }
}
class ViewFormat$2 extends Encoding$1 {
  constructor(o) {
    super({ ...o, format: "view" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (o) => {
      const a = this.encode(o);
      return Buffer$6.from(a.buffer, a.byteOffset, a.byteLength);
    }, decode: this.decode, name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    return this;
  }
}
class UTF8Format$2 extends Encoding$1 {
  constructor(o) {
    super({ ...o, format: "utf8" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (o) => Buffer$6.from(this.encode(o), "utf8"), decode: (o) => this.decode(o.toString("utf8")), name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    const { textEncoder: o, textDecoder: a } = textEndec();
    return new ViewFormat$2({ encode: (u) => o.encode(this.encode(u)), decode: (u) => this.decode(a.decode(u)), name: `${this.name}+view` });
  }
  createUTF8Transcoder() {
    return this;
  }
}
formats$2.BufferFormat = BufferFormat$2, formats$2.ViewFormat = ViewFormat$2, formats$2.UTF8Format = UTF8Format$2;
const { Buffer: Buffer$5 } = buffer$2 || { Buffer: { isBuffer: () => !1 } }, { textEncoder: textEncoder$1, textDecoder } = textEndec$1(), { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2, identity = (n) => n;
encodings$1.utf8 = new UTF8Format$1({ encode: function(n) {
  return Buffer$5.isBuffer(n) ? n.toString("utf8") : ArrayBuffer.isView(n) ? textDecoder.decode(n) : String(n);
}, decode: identity, name: "utf8", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(n) {
    return ArrayBuffer.isView(n) ? n : textEncoder$1.encode(n);
  }, decode: function(n) {
    return textDecoder.decode(n);
  }, name: `${this.name}+view` });
}, createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(n) {
    return Buffer$5.isBuffer(n) ? n : ArrayBuffer.isView(n) ? Buffer$5.from(n.buffer, n.byteOffset, n.byteLength) : Buffer$5.from(String(n), "utf8");
  }, decode: function(n) {
    return n.toString("utf8");
  }, name: `${this.name}+buffer` });
} }), encodings$1.json = new UTF8Format$1({ encode: JSON.stringify, decode: JSON.parse, name: "json" }), encodings$1.buffer = new BufferFormat$1({ encode: function(n) {
  return Buffer$5.isBuffer(n) ? n : ArrayBuffer.isView(n) ? Buffer$5.from(n.buffer, n.byteOffset, n.byteLength) : Buffer$5.from(String(n), "utf8");
}, decode: identity, name: "buffer", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(n) {
    return ArrayBuffer.isView(n) ? n : Buffer$5.from(String(n), "utf8");
  }, decode: function(n) {
    return Buffer$5.from(n.buffer, n.byteOffset, n.byteLength);
  }, name: `${this.name}+view` });
} }), encodings$1.view = new ViewFormat$1({ encode: function(n) {
  return ArrayBuffer.isView(n) ? n : textEncoder$1.encode(n);
}, decode: identity, name: "view", createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(n) {
    return Buffer$5.isBuffer(n) ? n : ArrayBuffer.isView(n) ? Buffer$5.from(n.buffer, n.byteOffset, n.byteLength) : Buffer$5.from(String(n), "utf8");
  }, decode: identity, name: `${this.name}+buffer` });
} }), encodings$1.hex = new BufferFormat$1({ encode: function(n) {
  return Buffer$5.isBuffer(n) ? n : Buffer$5.from(String(n), "hex");
}, decode: function(n) {
  return n.toString("hex");
}, name: "hex" }), encodings$1.base64 = new BufferFormat$1({ encode: function(n) {
  return Buffer$5.isBuffer(n) ? n : Buffer$5.from(String(n), "base64");
}, decode: function(n) {
  return n.toString("base64");
}, name: "base64" });
const ModuleError$8 = moduleError, encodings = encodings$1, { Encoding } = encoding, { BufferFormat, ViewFormat, UTF8Format } = formats$2, kFormats = Symbol("formats"), kEncodings = Symbol("encodings"), validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Transcoder$1 {
  constructor(o) {
    if (!Array.isArray(o))
      throw new TypeError("The first argument 'formats' must be an array");
    if (!o.every((a) => validFormats.has(a)))
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    this[kEncodings] = /* @__PURE__ */ new Map(), this[kFormats] = new Set(o);
    for (const a in encodings)
      try {
        this.encoding(a);
      } catch (u) {
        if (u.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
          throw u;
      }
  }
  encodings() {
    return Array.from(new Set(this[kEncodings].values()));
  }
  encoding(o) {
    let a = this[kEncodings].get(o);
    if (a === void 0) {
      if (typeof o == "string" && o !== "") {
        if (a = lookup[o], !a)
          throw new ModuleError$8(`Encoding '${o}' is not found`, { code: "LEVEL_ENCODING_NOT_FOUND" });
      } else {
        if (typeof o != "object" || o === null)
          throw new TypeError("First argument 'encoding' must be a string or object");
        a = from(o);
      }
      const { name: u, format: c } = a;
      if (!this[kFormats].has(c))
        if (this[kFormats].has("view"))
          a = a.createViewTranscoder();
        else if (this[kFormats].has("buffer"))
          a = a.createBufferTranscoder();
        else {
          if (!this[kFormats].has("utf8"))
            throw new ModuleError$8(`Encoding '${u}' cannot be transcoded`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
          a = a.createUTF8Transcoder();
        }
      for (const p of [o, u, a.name, a.commonName])
        this[kEncodings].set(p, a);
    }
    return a;
  }
}
function from(n) {
  if (n instanceof Encoding)
    return n;
  const o = "type" in n && typeof n.type == "string" ? n.type : void 0, a = n.name || o || "anonymous-" + anonymousCount++;
  switch (detectFormat(n)) {
    case "view":
      return new ViewFormat({ ...n, name: a });
    case "utf8":
      return new UTF8Format({ ...n, name: a });
    case "buffer":
      return new BufferFormat({ ...n, name: a });
    default:
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
  }
}
function detectFormat(n) {
  return "format" in n && n.format !== void 0 ? n.format : "buffer" in n && typeof n.buffer == "boolean" ? n.buffer ? "buffer" : "utf8" : "code" in n && Number.isInteger(n.code) ? "view" : "buffer";
}
levelTranscoder.Transcoder = Transcoder$1;
const aliases = { binary: encodings.buffer, "utf-8": encodings.utf8 }, lookup = { ...encodings, ...aliases };
let anonymousCount = 0;
var events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(n, o, a) {
  return Function.prototype.apply.call(n, o, a);
}, ReflectOwnKeys;
function ProcessEmitWarning(n) {
  console && console.warn && console.warn(n);
}
ReflectOwnKeys = R && typeof R.ownKeys == "function" ? R.ownKeys : Object.getOwnPropertySymbols ? function(n) {
  return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));
} : function(n) {
  return Object.getOwnPropertyNames(n);
};
var NumberIsNaN = Number.isNaN || function(n) {
  return n != n;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1, events.exports.once = once, EventEmitter$1.EventEmitter = EventEmitter$1, EventEmitter$1.prototype._events = void 0, EventEmitter$1.prototype._eventsCount = 0, EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
function _getMaxListeners(n) {
  return n._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : n._maxListeners;
}
function _addListener(n, o, a, u) {
  var c, p, d;
  if (checkListener(a), (p = n._events) === void 0 ? (p = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (p.newListener !== void 0 && (n.emit("newListener", o, a.listener ? a.listener : a), p = n._events), d = p[o]), d === void 0)
    d = p[o] = a, ++n._eventsCount;
  else if (typeof d == "function" ? d = p[o] = u ? [a, d] : [d, a] : u ? d.unshift(a) : d.push(a), (c = _getMaxListeners(n)) > 0 && d.length > c && !d.warned) {
    d.warned = !0;
    var w = new Error("Possible EventEmitter memory leak detected. " + d.length + " " + String(o) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    w.name = "MaxListenersExceededWarning", w.emitter = n, w.type = o, w.count = d.length, ProcessEmitWarning(w);
  }
  return n;
}
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(n, o, a) {
  var u = { fired: !1, wrapFn: void 0, target: n, type: o, listener: a }, c = onceWrapper.bind(u);
  return c.listener = a, u.wrapFn = c, c;
}
function _listeners(n, o, a) {
  var u = n._events;
  if (u === void 0)
    return [];
  var c = u[o];
  return c === void 0 ? [] : typeof c == "function" ? a ? [c.listener || c] : [c] : a ? unwrapListeners(c) : arrayClone(c, c.length);
}
function listenerCount(n) {
  var o = this._events;
  if (o !== void 0) {
    var a = o[n];
    if (typeof a == "function")
      return 1;
    if (a !== void 0)
      return a.length;
  }
  return 0;
}
function arrayClone(n, o) {
  for (var a = new Array(o), u = 0; u < o; ++u)
    a[u] = n[u];
  return a;
}
function spliceOne(n, o) {
  for (; o + 1 < n.length; o++)
    n[o] = n[o + 1];
  n.pop();
}
function unwrapListeners(n) {
  for (var o = new Array(n.length), a = 0; a < o.length; ++a)
    o[a] = n[a].listener || n[a];
  return o;
}
function once(n, o) {
  return new Promise(function(a, u) {
    function c(d) {
      n.removeListener(o, p), u(d);
    }
    function p() {
      typeof n.removeListener == "function" && n.removeListener("error", c), a([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(n, o, p, { once: !0 }), o !== "error" && addErrorHandlerIfEventEmitter(n, c, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(n, o, a) {
  typeof n.on == "function" && eventTargetAgnosticAddListener(n, "error", o, a);
}
function eventTargetAgnosticAddListener(n, o, a, u) {
  if (typeof n.on == "function")
    u.once ? n.once(o, a) : n.on(o, a);
  else {
    if (typeof n.addEventListener != "function")
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
    n.addEventListener(o, function c(p) {
      u.once && n.removeEventListener(o, c), a(p);
    });
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", { enumerable: !0, get: function() {
  return defaultMaxListeners;
}, set: function(n) {
  if (typeof n != "number" || n < 0 || NumberIsNaN(n))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
  defaultMaxListeners = n;
} }), EventEmitter$1.init = function() {
  this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, EventEmitter$1.prototype.setMaxListeners = function(n) {
  if (typeof n != "number" || n < 0 || NumberIsNaN(n))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  return this._maxListeners = n, this;
}, EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
}, EventEmitter$1.prototype.emit = function(n) {
  for (var o = [], a = 1; a < arguments.length; a++)
    o.push(arguments[a]);
  var u = n === "error", c = this._events;
  if (c !== void 0)
    u = u && c.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var p;
    if (o.length > 0 && (p = o[0]), p instanceof Error)
      throw p;
    var d = new Error("Unhandled error." + (p ? " (" + p.message + ")" : ""));
    throw d.context = p, d;
  }
  var w = c[n];
  if (w === void 0)
    return !1;
  if (typeof w == "function")
    ReflectApply(w, this, o);
  else {
    var S = w.length, k = arrayClone(w, S);
    for (a = 0; a < S; ++a)
      ReflectApply(k[a], this, o);
  }
  return !0;
}, EventEmitter$1.prototype.addListener = function(n, o) {
  return _addListener(this, n, o, !1);
}, EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener, EventEmitter$1.prototype.prependListener = function(n, o) {
  return _addListener(this, n, o, !0);
}, EventEmitter$1.prototype.once = function(n, o) {
  return checkListener(o), this.on(n, _onceWrap(this, n, o)), this;
}, EventEmitter$1.prototype.prependOnceListener = function(n, o) {
  return checkListener(o), this.prependListener(n, _onceWrap(this, n, o)), this;
}, EventEmitter$1.prototype.removeListener = function(n, o) {
  var a, u, c, p, d;
  if (checkListener(o), (u = this._events) === void 0)
    return this;
  if ((a = u[n]) === void 0)
    return this;
  if (a === o || a.listener === o)
    --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[n], u.removeListener && this.emit("removeListener", n, a.listener || o));
  else if (typeof a != "function") {
    for (c = -1, p = a.length - 1; p >= 0; p--)
      if (a[p] === o || a[p].listener === o) {
        d = a[p].listener, c = p;
        break;
      }
    if (c < 0)
      return this;
    c === 0 ? a.shift() : spliceOne(a, c), a.length === 1 && (u[n] = a[0]), u.removeListener !== void 0 && this.emit("removeListener", n, d || o);
  }
  return this;
}, EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener, EventEmitter$1.prototype.removeAllListeners = function(n) {
  var o, a, u;
  if ((a = this._events) === void 0)
    return this;
  if (a.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : a[n] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete a[n]), this;
  if (arguments.length === 0) {
    var c, p = Object.keys(a);
    for (u = 0; u < p.length; ++u)
      (c = p[u]) !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (typeof (o = a[n]) == "function")
    this.removeListener(n, o);
  else if (o !== void 0)
    for (u = o.length - 1; u >= 0; u--)
      this.removeListener(n, o[u]);
  return this;
}, EventEmitter$1.prototype.listeners = function(n) {
  return _listeners(this, n, !0);
}, EventEmitter$1.prototype.rawListeners = function(n) {
  return _listeners(this, n, !1);
}, EventEmitter$1.listenerCount = function(n, o) {
  return typeof n.listenerCount == "function" ? n.listenerCount(o) : listenerCount.call(n, o);
}, EventEmitter$1.prototype.listenerCount = listenerCount, EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
var catering = {}, nextTickBrowser$1 = typeof queueMicrotask == "function" ? queueMicrotask : (n) => Promise.resolve().then(n), nextTick = nextTickBrowser$1;
catering.fromCallback = function(n, o) {
  if (n === void 0) {
    var a = new Promise(function(u, c) {
      n = function(p, d) {
        p ? c(p) : u(d);
      };
    });
    n[o !== void 0 ? o : "promise"] = a;
  } else if (typeof n != "function")
    throw new TypeError("Callback must be a function");
  return n;
}, catering.fromPromise = function(n, o) {
  if (o === void 0)
    return n;
  n.then(function(a) {
    nextTick(() => o(null, a));
  }).catch(function(a) {
    nextTick(() => o(a));
  });
};
var abstractIterator = {}, common$6 = { getCallback: function(n, o) {
  return typeof n == "function" ? n : o;
}, getOptions: function(n, o) {
  return typeof n == "object" && n !== null ? n : o !== void 0 ? o : {};
} };
const { fromCallback: fromCallback$3 } = catering, ModuleError$7 = moduleError, { getOptions: getOptions$2, getCallback: getCallback$2 } = common$6, kPromise$3 = Symbol("promise"), kCallback$1 = Symbol("callback"), kWorking = Symbol("working"), kHandleOne$1 = Symbol("handleOne"), kHandleMany$1 = Symbol("handleMany"), kAutoClose = Symbol("autoClose"), kFinishWork = Symbol("finishWork"), kReturnMany = Symbol("returnMany"), kClosing = Symbol("closing"), kHandleClose = Symbol("handleClose"), kClosed = Symbol("closed"), kCloseCallbacks$1 = Symbol("closeCallbacks"), kKeyEncoding$1 = Symbol("keyEncoding"), kValueEncoding$1 = Symbol("valueEncoding"), kAbortOnClose = Symbol("abortOnClose"), kLegacy = Symbol("legacy"), kKeys = Symbol("keys"), kValues = Symbol("values"), kLimit = Symbol("limit"), kCount = Symbol("count"), emptyOptions$1 = Object.freeze({}), noop$1 = () => {
};
let warnedEnd = !1;
class CommonIterator {
  constructor(o, a, u) {
    if (typeof o != "object" || o === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (o === null ? "null" : typeof o));
    if (typeof a != "object" || a === null)
      throw new TypeError("The second argument must be an options object");
    this[kClosed] = !1, this[kCloseCallbacks$1] = [], this[kWorking] = !1, this[kClosing] = !1, this[kAutoClose] = !1, this[kCallback$1] = null, this[kHandleOne$1] = this[kHandleOne$1].bind(this), this[kHandleMany$1] = this[kHandleMany$1].bind(this), this[kHandleClose] = this[kHandleClose].bind(this), this[kKeyEncoding$1] = a[kKeyEncoding$1], this[kValueEncoding$1] = a[kValueEncoding$1], this[kLegacy] = u, this[kLimit] = Number.isInteger(a.limit) && a.limit >= 0 ? a.limit : 1 / 0, this[kCount] = 0, this[kAbortOnClose] = !!a.abortOnClose, this.db = o, this.db.attachResource(this), this.nextTick = o.nextTick;
  }
  get count() {
    return this[kCount];
  }
  get limit() {
    return this[kLimit];
  }
  next(o) {
    let a;
    if (o === void 0)
      a = new Promise((u, c) => {
        o = (p, d, w) => {
          p ? c(p) : this[kLegacy] ? d === void 0 && w === void 0 ? u() : u([d, w]) : u(d);
        };
      });
    else if (typeof o != "function")
      throw new TypeError("Callback must be a function");
    return this[kClosing] ? this.nextTick(o, new ModuleError$7("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(o, new ModuleError$7("Iterator is busy: cannot call next() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = o, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleOne$1], null) : this._next(this[kHandleOne$1])), a;
  }
  _next(o) {
    this.nextTick(o);
  }
  nextv(o, a, u) {
    return u = getCallback$2(a, u), u = fromCallback$3(u, kPromise$3), a = getOptions$2(a, emptyOptions$1), Number.isInteger(o) ? (this[kClosing] ? this.nextTick(u, new ModuleError$7("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(u, new ModuleError$7("Iterator is busy: cannot call nextv() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (o < 1 && (o = 1), this[kLimit] < 1 / 0 && (o = Math.min(o, this[kLimit] - this[kCount])), this[kWorking] = !0, this[kCallback$1] = u, o <= 0 ? this.nextTick(this[kHandleMany$1], null, []) : this._nextv(o, a, this[kHandleMany$1])), u[kPromise$3]) : (this.nextTick(u, new TypeError("The first argument 'size' must be an integer")), u[kPromise$3]);
  }
  _nextv(o, a, u) {
    const c = [], p = (d, w, S) => d ? u(d) : (this[kLegacy] ? w === void 0 && S === void 0 : w === void 0) ? u(null, c) : (c.push(this[kLegacy] ? [w, S] : w), void (c.length === o ? u(null, c) : this._next(p)));
    this._next(p);
  }
  all(o, a) {
    return a = getCallback$2(o, a), a = fromCallback$3(a, kPromise$3), o = getOptions$2(o, emptyOptions$1), this[kClosing] ? this.nextTick(a, new ModuleError$7("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(a, new ModuleError$7("Iterator is busy: cannot call all() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = a, this[kAutoClose] = !0, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleMany$1], null, []) : this._all(o, this[kHandleMany$1])), a[kPromise$3];
  }
  _all(o, a) {
    let u = this[kCount];
    const c = [], p = () => {
      const w = this[kLimit] < 1 / 0 ? Math.min(1e3, this[kLimit] - u) : 1e3;
      w <= 0 ? this.nextTick(a, null, c) : this._nextv(w, emptyOptions$1, d);
    }, d = (w, S) => {
      w ? a(w) : S.length === 0 ? a(null, c) : (c.push.apply(c, S), u += S.length, p());
    };
    p();
  }
  [kFinishWork]() {
    const o = this[kCallback$1];
    return this[kAbortOnClose] && o === null ? noop$1 : (this[kWorking] = !1, this[kCallback$1] = null, this[kClosing] && this._close(this[kHandleClose]), o);
  }
  [kReturnMany](o, a, u) {
    this[kAutoClose] ? this.close(o.bind(null, a, u)) : o(a, u);
  }
  seek(o, a) {
    if (a = getOptions$2(a, emptyOptions$1), !this[kClosing]) {
      if (this[kWorking])
        throw new ModuleError$7("Iterator is busy: cannot call seek() until next() has completed", { code: "LEVEL_ITERATOR_BUSY" });
      {
        const u = this.db.keyEncoding(a.keyEncoding || this[kKeyEncoding$1]), c = u.format;
        a.keyEncoding !== c && (a = { ...a, keyEncoding: c });
        const p = this.db.prefixKey(u.encode(o), c);
        this._seek(p, a);
      }
    }
  }
  _seek(o, a) {
    throw new ModuleError$7("Iterator does not support seek()", { code: "LEVEL_NOT_SUPPORTED" });
  }
  close(o) {
    return o = fromCallback$3(o, kPromise$3), this[kClosed] ? this.nextTick(o) : this[kClosing] ? this[kCloseCallbacks$1].push(o) : (this[kClosing] = !0, this[kCloseCallbacks$1].push(o), this[kWorking] ? this[kAbortOnClose] && this[kFinishWork]()(new ModuleError$7("Aborted on iterator close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this._close(this[kHandleClose])), o[kPromise$3];
  }
  _close(o) {
    this.nextTick(o);
  }
  [kHandleClose]() {
    this[kClosed] = !0, this.db.detachResource(this);
    const o = this[kCloseCallbacks$1];
    this[kCloseCallbacks$1] = [];
    for (const a of o)
      a();
  }
  async *[Symbol.asyncIterator]() {
    try {
      let o;
      for (; (o = await this.next()) !== void 0; )
        yield o;
    } finally {
      this[kClosed] || await this.close();
    }
  }
}
class AbstractIterator$4 extends CommonIterator {
  constructor(o, a) {
    super(o, a, !0), this[kKeys] = a.keys !== !1, this[kValues] = a.values !== !1;
  }
  [kHandleOne$1](o, a, u) {
    const c = this[kFinishWork]();
    if (o)
      return c(o);
    try {
      a = this[kKeys] && a !== void 0 ? this[kKeyEncoding$1].decode(a) : void 0, u = this[kValues] && u !== void 0 ? this[kValueEncoding$1].decode(u) : void 0;
    } catch (p) {
      return c(new IteratorDecodeError("entry", p));
    }
    a === void 0 && u === void 0 || this[kCount]++, c(null, a, u);
  }
  [kHandleMany$1](o, a) {
    const u = this[kFinishWork]();
    if (o)
      return this[kReturnMany](u, o);
    try {
      for (const c of a) {
        const p = c[0], d = c[1];
        c[0] = this[kKeys] && p !== void 0 ? this[kKeyEncoding$1].decode(p) : void 0, c[1] = this[kValues] && d !== void 0 ? this[kValueEncoding$1].decode(d) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("entries", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
  end(o) {
    return warnedEnd || typeof console > "u" || (warnedEnd = !0, console.warn(new ModuleError$7("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version", { code: "LEVEL_LEGACY" }))), this.close(o);
  }
}
class AbstractKeyIterator$3 extends CommonIterator {
  constructor(o, a) {
    super(o, a, !1);
  }
  [kHandleOne$1](o, a) {
    const u = this[kFinishWork]();
    if (o)
      return u(o);
    try {
      a = a !== void 0 ? this[kKeyEncoding$1].decode(a) : void 0;
    } catch (c) {
      return u(new IteratorDecodeError("key", c));
    }
    a !== void 0 && this[kCount]++, u(null, a);
  }
  [kHandleMany$1](o, a) {
    const u = this[kFinishWork]();
    if (o)
      return this[kReturnMany](u, o);
    try {
      for (let c = 0; c < a.length; c++) {
        const p = a[c];
        a[c] = p !== void 0 ? this[kKeyEncoding$1].decode(p) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("keys", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
}
class AbstractValueIterator$3 extends CommonIterator {
  constructor(o, a) {
    super(o, a, !1);
  }
  [kHandleOne$1](o, a) {
    const u = this[kFinishWork]();
    if (o)
      return u(o);
    try {
      a = a !== void 0 ? this[kValueEncoding$1].decode(a) : void 0;
    } catch (c) {
      return u(new IteratorDecodeError("value", c));
    }
    a !== void 0 && this[kCount]++, u(null, a);
  }
  [kHandleMany$1](o, a) {
    const u = this[kFinishWork]();
    if (o)
      return this[kReturnMany](u, o);
    try {
      for (let c = 0; c < a.length; c++) {
        const p = a[c];
        a[c] = p !== void 0 ? this[kValueEncoding$1].decode(p) : void 0;
      }
    } catch (c) {
      return this[kReturnMany](u, new IteratorDecodeError("values", c));
    }
    this[kCount] += a.length, this[kReturnMany](u, null, a);
  }
}
class IteratorDecodeError extends ModuleError$7 {
  constructor(o, a) {
    super(`Iterator could not decode ${o}`, { code: "LEVEL_DECODE_ERROR", cause: a });
  }
}
for (const n of ["_ended property", "_nexting property", "_end method"])
  Object.defineProperty(AbstractIterator$4.prototype, n.split(" ")[0], { get() {
    throw new ModuleError$7(`The ${n} has been removed`, { code: "LEVEL_LEGACY" });
  }, set() {
    throw new ModuleError$7(`The ${n} has been removed`, { code: "LEVEL_LEGACY" });
  } });
AbstractIterator$4.keyEncoding = kKeyEncoding$1, AbstractIterator$4.valueEncoding = kValueEncoding$1, abstractIterator.AbstractIterator = AbstractIterator$4, abstractIterator.AbstractKeyIterator = AbstractKeyIterator$3, abstractIterator.AbstractValueIterator = AbstractValueIterator$3;
var defaultKvIterator = {};
const { AbstractKeyIterator: AbstractKeyIterator$2, AbstractValueIterator: AbstractValueIterator$2 } = abstractIterator, kIterator$1 = Symbol("iterator"), kCallback = Symbol("callback"), kHandleOne = Symbol("handleOne"), kHandleMany = Symbol("handleMany");
class DefaultKeyIterator$1 extends AbstractKeyIterator$2 {
  constructor(o, a) {
    super(o, a), this[kIterator$1] = o.iterator({ ...a, keys: !0, values: !1 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
class DefaultValueIterator$1 extends AbstractValueIterator$2 {
  constructor(o, a) {
    super(o, a), this[kIterator$1] = o.iterator({ ...a, keys: !1, values: !0 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
for (const n of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
  const o = n === DefaultKeyIterator$1, a = o ? (u) => u[0] : (u) => u[1];
  n.prototype._next = function(u) {
    this[kCallback] = u, this[kIterator$1].next(this[kHandleOne]);
  }, n.prototype[kHandleOne] = function(u, c, p) {
    const d = this[kCallback];
    u ? d(u) : d(null, o ? c : p);
  }, n.prototype._nextv = function(u, c, p) {
    this[kCallback] = p, this[kIterator$1].nextv(u, c, this[kHandleMany]);
  }, n.prototype._all = function(u, c) {
    this[kCallback] = c, this[kIterator$1].all(u, this[kHandleMany]);
  }, n.prototype[kHandleMany] = function(u, c) {
    const p = this[kCallback];
    u ? p(u) : p(null, c.map(a));
  }, n.prototype._seek = function(u, c) {
    this[kIterator$1].seek(u, c);
  }, n.prototype._close = function(u) {
    this[kIterator$1].close(u);
  };
}
defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1, defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;
var deferredIterator = {};
const { AbstractIterator: AbstractIterator$3, AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator, ModuleError$6 = moduleError, kNut = Symbol("nut"), kUndefer$1 = Symbol("undefer"), kFactory = Symbol("factory");
class DeferredIterator$1 extends AbstractIterator$3 {
  constructor(o, a) {
    super(o, a), this[kNut] = null, this[kFactory] = () => o.iterator(a), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredKeyIterator$1 extends AbstractKeyIterator$1 {
  constructor(o, a) {
    super(o, a), this[kNut] = null, this[kFactory] = () => o.keys(a), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredValueIterator$1 extends AbstractValueIterator$1 {
  constructor(o, a) {
    super(o, a), this[kNut] = null, this[kFactory] = () => o.values(a), this.db.defer(() => this[kUndefer$1]());
  }
}
for (const n of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1])
  n.prototype[kUndefer$1] = function() {
    this.db.status === "open" && (this[kNut] = this[kFactory]());
  }, n.prototype._next = function(o) {
    this[kNut] !== null ? this[kNut].next(o) : this.db.status === "opening" ? this.db.defer(() => this._next(o)) : this.nextTick(o, new ModuleError$6("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, n.prototype._nextv = function(o, a, u) {
    this[kNut] !== null ? this[kNut].nextv(o, a, u) : this.db.status === "opening" ? this.db.defer(() => this._nextv(o, a, u)) : this.nextTick(u, new ModuleError$6("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, n.prototype._all = function(o, a) {
    this[kNut] !== null ? this[kNut].all(a) : this.db.status === "opening" ? this.db.defer(() => this._all(o, a)) : this.nextTick(a, new ModuleError$6("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, n.prototype._seek = function(o, a) {
    this[kNut] !== null ? this[kNut]._seek(o, a) : this.db.status === "opening" && this.db.defer(() => this._seek(o, a));
  }, n.prototype._close = function(o) {
    this[kNut] !== null ? this[kNut].close(o) : this.db.status === "opening" ? this.db.defer(() => this._close(o)) : this.nextTick(o);
  };
deferredIterator.DeferredIterator = DeferredIterator$1, deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1, deferredIterator.DeferredValueIterator = DeferredValueIterator$1;
var defaultChainedBatch = {}, abstractChainedBatch = {};
const { fromCallback: fromCallback$2 } = catering, ModuleError$5 = moduleError, { getCallback: getCallback$1, getOptions: getOptions$1 } = common$6, kPromise$2 = Symbol("promise"), kStatus$1 = Symbol("status"), kOperations$1 = Symbol("operations"), kFinishClose = Symbol("finishClose"), kCloseCallbacks = Symbol("closeCallbacks");
class AbstractChainedBatch$1 {
  constructor(o) {
    if (typeof o != "object" || o === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (o === null ? "null" : typeof o));
    this[kOperations$1] = [], this[kCloseCallbacks] = [], this[kStatus$1] = "open", this[kFinishClose] = this[kFinishClose].bind(this), this.db = o, this.db.attachResource(this), this.nextTick = o.nextTick;
  }
  get length() {
    return this[kOperations$1].length;
  }
  put(o, a, u) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call put() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const c = this.db._checkKey(o) || this.db._checkValue(a);
    if (c)
      throw c;
    const p = u && u.sublevel != null ? u.sublevel : this.db, d = u, w = p.keyEncoding(u && u.keyEncoding), S = p.valueEncoding(u && u.valueEncoding), k = w.format;
    u = { ...u, keyEncoding: k, valueEncoding: S.format }, p !== this.db && (u.sublevel = null);
    const B = p.prefixKey(w.encode(o), k), I = S.encode(a);
    return this._put(B, I, u), this[kOperations$1].push({ ...d, type: "put", key: o, value: a }), this;
  }
  _put(o, a, u) {
  }
  del(o, a) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call del() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const u = this.db._checkKey(o);
    if (u)
      throw u;
    const c = a && a.sublevel != null ? a.sublevel : this.db, p = a, d = c.keyEncoding(a && a.keyEncoding), w = d.format;
    return a = { ...a, keyEncoding: w }, c !== this.db && (a.sublevel = null), this._del(c.prefixKey(d.encode(o), w), a), this[kOperations$1].push({ ...p, type: "del", key: o }), this;
  }
  _del(o, a) {
  }
  clear() {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call clear() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    return this._clear(), this[kOperations$1] = [], this;
  }
  _clear() {
  }
  write(o, a) {
    return a = getCallback$1(o, a), a = fromCallback$2(a, kPromise$2), o = getOptions$1(o), this[kStatus$1] !== "open" ? this.nextTick(a, new ModuleError$5("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" })) : this.length === 0 ? this.close(a) : (this[kStatus$1] = "writing", this._write(o, (u) => {
      this[kStatus$1] = "closing", this[kCloseCallbacks].push(() => a(u)), u || this.db.emit("batch", this[kOperations$1]), this._close(this[kFinishClose]);
    })), a[kPromise$2];
  }
  _write(o, a) {
  }
  close(o) {
    return o = fromCallback$2(o, kPromise$2), this[kStatus$1] === "closing" ? this[kCloseCallbacks].push(o) : this[kStatus$1] === "closed" ? this.nextTick(o) : (this[kCloseCallbacks].push(o), this[kStatus$1] !== "writing" && (this[kStatus$1] = "closing", this._close(this[kFinishClose]))), o[kPromise$2];
  }
  _close(o) {
    this.nextTick(o);
  }
  [kFinishClose]() {
    this[kStatus$1] = "closed", this.db.detachResource(this);
    const o = this[kCloseCallbacks];
    this[kCloseCallbacks] = [];
    for (const a of o)
      a();
  }
}
abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;
const { AbstractChainedBatch } = abstractChainedBatch, ModuleError$4 = moduleError, kEncoded = Symbol("encoded");
class DefaultChainedBatch$1 extends AbstractChainedBatch {
  constructor(o) {
    super(o), this[kEncoded] = [];
  }
  _put(o, a, u) {
    this[kEncoded].push({ ...u, type: "put", key: o, value: a });
  }
  _del(o, a) {
    this[kEncoded].push({ ...a, type: "del", key: o });
  }
  _clear() {
    this[kEncoded] = [];
  }
  _write(o, a) {
    this.db.status === "opening" ? this.db.defer(() => this._write(o, a)) : this.db.status === "open" ? this[kEncoded].length === 0 ? this.nextTick(a) : this.db._batch(this[kEncoded], o, a) : this.nextTick(a, new ModuleError$4("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" }));
  }
}
defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;
const ModuleError$3 = moduleError, hasOwnProperty$a = Object.prototype.hasOwnProperty, rangeOptions$2 = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
var rangeOptions_1 = function(n, o) {
  const a = {};
  for (const u in n)
    if (hasOwnProperty$a.call(n, u) && u !== "keyEncoding" && u !== "valueEncoding") {
      if (u === "start" || u === "end")
        throw new ModuleError$3(`The legacy range option '${u}' has been removed`, { code: "LEVEL_LEGACY" });
      if (u === "encoding")
        throw new ModuleError$3("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", { code: "LEVEL_LEGACY" });
      rangeOptions$2.has(u) ? a[u] = o.encode(n[u]) : a[u] = n[u];
    }
  return a.reverse = !!a.reverse, a.limit = Number.isInteger(a.limit) && a.limit >= 0 ? a.limit : -1, a;
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
};
let promise;
var queueMicrotask_1 = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : commonjsGlobal) : (n) => (promise || (promise = Promise.resolve())).then(n).catch((o) => setTimeout(() => {
  throw o;
}, 0)), nextTickBrowser, hasRequiredNextTickBrowser;
function requireNextTickBrowser() {
  if (hasRequiredNextTickBrowser)
    return nextTickBrowser;
  hasRequiredNextTickBrowser = 1;
  const n = queueMicrotask_1;
  return nextTickBrowser = function(o, ...a) {
    a.length === 0 ? n(o) : n(() => o(...a));
  };
}
var buffer$1 = {}, hasRequiredBuffer;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
function requireBuffer() {
  return hasRequiredBuffer || (hasRequiredBuffer = 1, function(n) {
    const o = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    n.Buffer = d, n.SlowBuffer = function(l) {
      return +l != l && (l = 0), d.alloc(+l);
    }, n.INSPECT_MAX_BYTES = 50;
    const c = 2147483647;
    function p(l) {
      if (l > c)
        throw new RangeError('The value "' + l + '" is invalid for option "size"');
      const h = new Uint8Array(l);
      return Object.setPrototypeOf(h, d.prototype), h;
    }
    function d(l, h, y) {
      if (typeof l == "number") {
        if (typeof h == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return k(l);
      }
      return w(l, h, y);
    }
    function w(l, h, y) {
      if (typeof l == "string")
        return function(x, O) {
          if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
            throw new TypeError("Unknown encoding: " + O);
          const G = 0 | P(x, O);
          let X = p(G);
          const ie = X.write(x, O);
          return ie !== G && (X = X.slice(0, ie)), X;
        }(l, h);
      if (ArrayBuffer.isView(l))
        return function(x) {
          if (se(x, Uint8Array)) {
            const O = new Uint8Array(x);
            return I(O.buffer, O.byteOffset, O.byteLength);
          }
          return B(x);
        }(l);
      if (l == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
      if (se(l, ArrayBuffer) || l && se(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (se(l, SharedArrayBuffer) || l && se(l.buffer, SharedArrayBuffer)))
        return I(l, h, y);
      if (typeof l == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      const A = l.valueOf && l.valueOf();
      if (A != null && A !== l)
        return d.from(A, h, y);
      const M = function(x) {
        if (d.isBuffer(x)) {
          const O = 0 | C(x.length), G = p(O);
          return G.length === 0 || x.copy(G, 0, 0, O), G;
        }
        return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? p(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
      }(l);
      if (M)
        return M;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
        return d.from(l[Symbol.toPrimitive]("string"), h, y);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    }
    function S(l) {
      if (typeof l != "number")
        throw new TypeError('"size" argument must be of type number');
      if (l < 0)
        throw new RangeError('The value "' + l + '" is invalid for option "size"');
    }
    function k(l) {
      return S(l), p(l < 0 ? 0 : 0 | C(l));
    }
    function B(l) {
      const h = l.length < 0 ? 0 : 0 | C(l.length), y = p(h);
      for (let A = 0; A < h; A += 1)
        y[A] = 255 & l[A];
      return y;
    }
    function I(l, h, y) {
      if (h < 0 || l.byteLength < h)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (l.byteLength < h + (y || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let A;
      return A = h === void 0 && y === void 0 ? new Uint8Array(l) : y === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, y), Object.setPrototypeOf(A, d.prototype), A;
    }
    function C(l) {
      if (l >= c)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
      return 0 | l;
    }
    function P(l, h) {
      if (d.isBuffer(l))
        return l.length;
      if (ArrayBuffer.isView(l) || se(l, ArrayBuffer))
        return l.byteLength;
      if (typeof l != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
      const y = l.length, A = arguments.length > 2 && arguments[2] === !0;
      if (!A && y === 0)
        return 0;
      let M = !1;
      for (; ; )
        switch (h) {
          case "ascii":
          case "latin1":
          case "binary":
            return y;
          case "utf8":
          case "utf-8":
            return he(l).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * y;
          case "hex":
            return y >>> 1;
          case "base64":
            return _e(l).length;
          default:
            if (M)
              return A ? -1 : he(l).length;
            h = ("" + h).toLowerCase(), M = !0;
        }
    }
    function q(l, h, y) {
      let A = !1;
      if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0) <= (h >>>= 0))
        return "";
      for (l || (l = "utf8"); ; )
        switch (l) {
          case "hex":
            return m(this, h, y);
          case "utf8":
          case "utf-8":
            return g(this, h, y);
          case "ascii":
            return _(this, h, y);
          case "latin1":
          case "binary":
            return b(this, h, y);
          case "base64":
            return te(this, h, y);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return v(this, h, y);
          default:
            if (A)
              throw new TypeError("Unknown encoding: " + l);
            l = (l + "").toLowerCase(), A = !0;
        }
    }
    function D(l, h, y) {
      const A = l[h];
      l[h] = l[y], l[y] = A;
    }
    function z(l, h, y, A, M) {
      if (l.length === 0)
        return -1;
      if (typeof y == "string" ? (A = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), we(y = +y) && (y = M ? 0 : l.length - 1), y < 0 && (y = l.length + y), y >= l.length) {
        if (M)
          return -1;
        y = l.length - 1;
      } else if (y < 0) {
        if (!M)
          return -1;
        y = 0;
      }
      if (typeof h == "string" && (h = d.from(h, A)), d.isBuffer(h))
        return h.length === 0 ? -1 : F(l, h, y, A, M);
      if (typeof h == "number")
        return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? M ? Uint8Array.prototype.indexOf.call(l, h, y) : Uint8Array.prototype.lastIndexOf.call(l, h, y) : F(l, [h], y, A, M);
      throw new TypeError("val must be string, number or Buffer");
    }
    function F(l, h, y, A, M) {
      let x, O = 1, G = l.length, X = h.length;
      if (A !== void 0 && ((A = String(A).toLowerCase()) === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
        if (l.length < 2 || h.length < 2)
          return -1;
        O = 2, G /= 2, X /= 2, y /= 2;
      }
      function ie(ee, re) {
        return O === 1 ? ee[re] : ee.readUInt16BE(re * O);
      }
      if (M) {
        let ee = -1;
        for (x = y; x < G; x++)
          if (ie(l, x) === ie(h, ee === -1 ? 0 : x - ee)) {
            if (ee === -1 && (ee = x), x - ee + 1 === X)
              return ee * O;
          } else
            ee !== -1 && (x -= x - ee), ee = -1;
      } else
        for (y + X > G && (y = G - X), x = y; x >= 0; x--) {
          let ee = !0;
          for (let re = 0; re < X; re++)
            if (ie(l, x + re) !== ie(h, re)) {
              ee = !1;
              break;
            }
          if (ee)
            return x;
        }
      return -1;
    }
    function V(l, h, y, A) {
      y = Number(y) || 0;
      const M = l.length - y;
      A ? (A = Number(A)) > M && (A = M) : A = M;
      const x = h.length;
      let O;
      for (A > x / 2 && (A = x / 2), O = 0; O < A; ++O) {
        const G = parseInt(h.substr(2 * O, 2), 16);
        if (we(G))
          return O;
        l[y + O] = G;
      }
      return O;
    }
    function Z(l, h, y, A) {
      return Le(he(h, l.length - y), l, y, A);
    }
    function N(l, h, y, A) {
      return Le(function(M) {
        const x = [];
        for (let O = 0; O < M.length; ++O)
          x.push(255 & M.charCodeAt(O));
        return x;
      }(h), l, y, A);
    }
    function W(l, h, y, A) {
      return Le(_e(h), l, y, A);
    }
    function H(l, h, y, A) {
      return Le(function(M, x) {
        let O, G, X;
        const ie = [];
        for (let ee = 0; ee < M.length && !((x -= 2) < 0); ++ee)
          O = M.charCodeAt(ee), G = O >> 8, X = O % 256, ie.push(X), ie.push(G);
        return ie;
      }(h, l.length - y), l, y, A);
    }
    function te(l, h, y) {
      return h === 0 && y === l.length ? o.fromByteArray(l) : o.fromByteArray(l.slice(h, y));
    }
    function g(l, h, y) {
      y = Math.min(l.length, y);
      const A = [];
      let M = h;
      for (; M < y; ) {
        const x = l[M];
        let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
        if (M + G <= y) {
          let X, ie, ee, re;
          switch (G) {
            case 1:
              x < 128 && (O = x);
              break;
            case 2:
              X = l[M + 1], (192 & X) == 128 && (re = (31 & x) << 6 | 63 & X, re > 127 && (O = re));
              break;
            case 3:
              X = l[M + 1], ie = l[M + 2], (192 & X) == 128 && (192 & ie) == 128 && (re = (15 & x) << 12 | (63 & X) << 6 | 63 & ie, re > 2047 && (re < 55296 || re > 57343) && (O = re));
              break;
            case 4:
              X = l[M + 1], ie = l[M + 2], ee = l[M + 3], (192 & X) == 128 && (192 & ie) == 128 && (192 & ee) == 128 && (re = (15 & x) << 18 | (63 & X) << 12 | (63 & ie) << 6 | 63 & ee, re > 65535 && re < 1114112 && (O = re));
          }
        }
        O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, A.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), A.push(O), M += G;
      }
      return function(x) {
        const O = x.length;
        if (O <= $)
          return String.fromCharCode.apply(String, x);
        let G = "", X = 0;
        for (; X < O; )
          G += String.fromCharCode.apply(String, x.slice(X, X += $));
        return G;
      }(A);
    }
    n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
      try {
        const l = new Uint8Array(1), h = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
      } catch {
        return !1;
      }
    }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
      if (d.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
      if (d.isBuffer(this))
        return this.byteOffset;
    } }), d.poolSize = 8192, d.from = function(l, h, y) {
      return w(l, h, y);
    }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, y) {
      return function(A, M, x) {
        return S(A), A <= 0 ? p(A) : M !== void 0 ? typeof x == "string" ? p(A).fill(M, x) : p(A).fill(M) : p(A);
      }(l, h, y);
    }, d.allocUnsafe = function(l) {
      return k(l);
    }, d.allocUnsafeSlow = function(l) {
      return k(l);
    }, d.isBuffer = function(l) {
      return l != null && l._isBuffer === !0 && l !== d.prototype;
    }, d.compare = function(l, h) {
      if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), se(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (l === h)
        return 0;
      let y = l.length, A = h.length;
      for (let M = 0, x = Math.min(y, A); M < x; ++M)
        if (l[M] !== h[M]) {
          y = l[M], A = h[M];
          break;
        }
      return y < A ? -1 : A < y ? 1 : 0;
    }, d.isEncoding = function(l) {
      switch (String(l).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, d.concat = function(l, h) {
      if (!Array.isArray(l))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (l.length === 0)
        return d.alloc(0);
      let y;
      if (h === void 0)
        for (h = 0, y = 0; y < l.length; ++y)
          h += l[y].length;
      const A = d.allocUnsafe(h);
      let M = 0;
      for (y = 0; y < l.length; ++y) {
        let x = l[y];
        if (se(x, Uint8Array))
          M + x.length > A.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(A, M)) : Uint8Array.prototype.set.call(A, x, M);
        else {
          if (!d.isBuffer(x))
            throw new TypeError('"list" argument must be an Array of Buffers');
          x.copy(A, M);
        }
        M += x.length;
      }
      return A;
    }, d.byteLength = P, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
      const l = this.length;
      if (l % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let h = 0; h < l; h += 2)
        D(this, h, h + 1);
      return this;
    }, d.prototype.swap32 = function() {
      const l = this.length;
      if (l % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let h = 0; h < l; h += 4)
        D(this, h, h + 3), D(this, h + 1, h + 2);
      return this;
    }, d.prototype.swap64 = function() {
      const l = this.length;
      if (l % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let h = 0; h < l; h += 8)
        D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
      return this;
    }, d.prototype.toString = function() {
      const l = this.length;
      return l === 0 ? "" : arguments.length === 0 ? g(this, 0, l) : q.apply(this, arguments);
    }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
      if (!d.isBuffer(l))
        throw new TypeError("Argument must be a Buffer");
      return this === l || d.compare(this, l) === 0;
    }, d.prototype.inspect = function() {
      let l = "";
      const h = n.INSPECT_MAX_BYTES;
      return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
    }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, y, A, M) {
      if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
      if (h === void 0 && (h = 0), y === void 0 && (y = l ? l.length : 0), A === void 0 && (A = 0), M === void 0 && (M = this.length), h < 0 || y > l.length || A < 0 || M > this.length)
        throw new RangeError("out of range index");
      if (A >= M && h >= y)
        return 0;
      if (A >= M)
        return -1;
      if (h >= y)
        return 1;
      if (this === l)
        return 0;
      let x = (M >>>= 0) - (A >>>= 0), O = (y >>>= 0) - (h >>>= 0);
      const G = Math.min(x, O), X = this.slice(A, M), ie = l.slice(h, y);
      for (let ee = 0; ee < G; ++ee)
        if (X[ee] !== ie[ee]) {
          x = X[ee], O = ie[ee];
          break;
        }
      return x < O ? -1 : O < x ? 1 : 0;
    }, d.prototype.includes = function(l, h, y) {
      return this.indexOf(l, h, y) !== -1;
    }, d.prototype.indexOf = function(l, h, y) {
      return z(this, l, h, y, !0);
    }, d.prototype.lastIndexOf = function(l, h, y) {
      return z(this, l, h, y, !1);
    }, d.prototype.write = function(l, h, y, A) {
      if (h === void 0)
        A = "utf8", y = this.length, h = 0;
      else if (y === void 0 && typeof h == "string")
        A = h, y = this.length, h = 0;
      else {
        if (!isFinite(h))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        h >>>= 0, isFinite(y) ? (y >>>= 0, A === void 0 && (A = "utf8")) : (A = y, y = void 0);
      }
      const M = this.length - h;
      if ((y === void 0 || y > M) && (y = M), l.length > 0 && (y < 0 || h < 0) || h > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      A || (A = "utf8");
      let x = !1;
      for (; ; )
        switch (A) {
          case "hex":
            return V(this, l, h, y);
          case "utf8":
          case "utf-8":
            return Z(this, l, h, y);
          case "ascii":
          case "latin1":
          case "binary":
            return N(this, l, h, y);
          case "base64":
            return W(this, l, h, y);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return H(this, l, h, y);
          default:
            if (x)
              throw new TypeError("Unknown encoding: " + A);
            A = ("" + A).toLowerCase(), x = !0;
        }
    }, d.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    const $ = 4096;
    function _(l, h, y) {
      let A = "";
      y = Math.min(l.length, y);
      for (let M = h; M < y; ++M)
        A += String.fromCharCode(127 & l[M]);
      return A;
    }
    function b(l, h, y) {
      let A = "";
      y = Math.min(l.length, y);
      for (let M = h; M < y; ++M)
        A += String.fromCharCode(l[M]);
      return A;
    }
    function m(l, h, y) {
      const A = l.length;
      (!h || h < 0) && (h = 0), (!y || y < 0 || y > A) && (y = A);
      let M = "";
      for (let x = h; x < y; ++x)
        M += We[l[x]];
      return M;
    }
    function v(l, h, y) {
      const A = l.slice(h, y);
      let M = "";
      for (let x = 0; x < A.length - 1; x += 2)
        M += String.fromCharCode(A[x] + 256 * A[x + 1]);
      return M;
    }
    function E(l, h, y) {
      if (l % 1 != 0 || l < 0)
        throw new RangeError("offset is not uint");
      if (l + h > y)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function T(l, h, y, A, M, x) {
      if (!d.isBuffer(l))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (h > M || h < x)
        throw new RangeError('"value" argument is out of bounds');
      if (y + A > l.length)
        throw new RangeError("Index out of range");
    }
    function j(l, h, y, A, M) {
      ce(h, A, M, l, y, 7);
      let x = Number(h & BigInt(4294967295));
      l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x;
      let O = Number(h >> BigInt(32) & BigInt(4294967295));
      return l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, y;
    }
    function L(l, h, y, A, M) {
      ce(h, A, M, l, y, 7);
      let x = Number(h & BigInt(4294967295));
      l[y + 7] = x, x >>= 8, l[y + 6] = x, x >>= 8, l[y + 5] = x, x >>= 8, l[y + 4] = x;
      let O = Number(h >> BigInt(32) & BigInt(4294967295));
      return l[y + 3] = O, O >>= 8, l[y + 2] = O, O >>= 8, l[y + 1] = O, O >>= 8, l[y] = O, y + 8;
    }
    function J(l, h, y, A, M, x) {
      if (y + A > l.length)
        throw new RangeError("Index out of range");
      if (y < 0)
        throw new RangeError("Index out of range");
    }
    function Y(l, h, y, A, M) {
      return h = +h, y >>>= 0, M || J(l, 0, y, 4), a.write(l, h, y, A, 23, 4), y + 4;
    }
    function ne(l, h, y, A, M) {
      return h = +h, y >>>= 0, M || J(l, 0, y, 8), a.write(l, h, y, A, 52, 8), y + 8;
    }
    d.prototype.slice = function(l, h) {
      const y = this.length;
      (l = ~~l) < 0 ? (l += y) < 0 && (l = 0) : l > y && (l = y), (h = h === void 0 ? y : ~~h) < 0 ? (h += y) < 0 && (h = 0) : h > y && (h = y), h < l && (h = l);
      const A = this.subarray(l, h);
      return Object.setPrototypeOf(A, d.prototype), A;
    }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, y) {
      l >>>= 0, h >>>= 0, y || E(l, h, this.length);
      let A = this[l], M = 1, x = 0;
      for (; ++x < h && (M *= 256); )
        A += this[l + x] * M;
      return A;
    }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, y) {
      l >>>= 0, h >>>= 0, y || E(l, h, this.length);
      let A = this[l + --h], M = 1;
      for (; h > 0 && (M *= 256); )
        A += this[l + --h] * M;
      return A;
    }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
      return l >>>= 0, h || E(l, 1, this.length), this[l];
    }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
      return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
    }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
      return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
    }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
    }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
    }, d.prototype.readBigUInt64LE = de(function(l) {
      ue(l >>>= 0, "offset");
      const h = this[l], y = this[l + 7];
      h !== void 0 && y !== void 0 || le(l, this.length - 8);
      const A = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, M = this[++l] + 256 * this[++l] + 65536 * this[++l] + y * 2 ** 24;
      return BigInt(A) + (BigInt(M) << BigInt(32));
    }), d.prototype.readBigUInt64BE = de(function(l) {
      ue(l >>>= 0, "offset");
      const h = this[l], y = this[l + 7];
      h !== void 0 && y !== void 0 || le(l, this.length - 8);
      const A = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], M = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y;
      return (BigInt(A) << BigInt(32)) + BigInt(M);
    }), d.prototype.readIntLE = function(l, h, y) {
      l >>>= 0, h >>>= 0, y || E(l, h, this.length);
      let A = this[l], M = 1, x = 0;
      for (; ++x < h && (M *= 256); )
        A += this[l + x] * M;
      return M *= 128, A >= M && (A -= Math.pow(2, 8 * h)), A;
    }, d.prototype.readIntBE = function(l, h, y) {
      l >>>= 0, h >>>= 0, y || E(l, h, this.length);
      let A = h, M = 1, x = this[l + --A];
      for (; A > 0 && (M *= 256); )
        x += this[l + --A] * M;
      return M *= 128, x >= M && (x -= Math.pow(2, 8 * h)), x;
    }, d.prototype.readInt8 = function(l, h) {
      return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
    }, d.prototype.readInt16LE = function(l, h) {
      l >>>= 0, h || E(l, 2, this.length);
      const y = this[l] | this[l + 1] << 8;
      return 32768 & y ? 4294901760 | y : y;
    }, d.prototype.readInt16BE = function(l, h) {
      l >>>= 0, h || E(l, 2, this.length);
      const y = this[l + 1] | this[l] << 8;
      return 32768 & y ? 4294901760 | y : y;
    }, d.prototype.readInt32LE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
    }, d.prototype.readInt32BE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
    }, d.prototype.readBigInt64LE = de(function(l) {
      ue(l >>>= 0, "offset");
      const h = this[l], y = this[l + 7];
      h !== void 0 && y !== void 0 || le(l, this.length - 8);
      const A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (y << 24);
      return (BigInt(A) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
    }), d.prototype.readBigInt64BE = de(function(l) {
      ue(l >>>= 0, "offset");
      const h = this[l], y = this[l + 7];
      h !== void 0 && y !== void 0 || le(l, this.length - 8);
      const A = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
      return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y);
    }), d.prototype.readFloatLE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
    }, d.prototype.readFloatBE = function(l, h) {
      return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
    }, d.prototype.readDoubleLE = function(l, h) {
      return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
    }, d.prototype.readDoubleBE = function(l, h) {
      return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
    }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, y, A) {
      l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
      let M = 1, x = 0;
      for (this[h] = 255 & l; ++x < y && (M *= 256); )
        this[h + x] = l / M & 255;
      return h + y;
    }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, y, A) {
      l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
      let M = y - 1, x = 1;
      for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
        this[h + M] = l / x & 255;
      return h + y;
    }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
    }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
    }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
    }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
    }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
    }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
      return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
    }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
      return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
    }), d.prototype.writeIntLE = function(l, h, y, A) {
      if (l = +l, h >>>= 0, !A) {
        const G = Math.pow(2, 8 * y - 1);
        T(this, l, h, y, G - 1, -G);
      }
      let M = 0, x = 1, O = 0;
      for (this[h] = 255 & l; ++M < y && (x *= 256); )
        l < 0 && O === 0 && this[h + M - 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
      return h + y;
    }, d.prototype.writeIntBE = function(l, h, y, A) {
      if (l = +l, h >>>= 0, !A) {
        const G = Math.pow(2, 8 * y - 1);
        T(this, l, h, y, G - 1, -G);
      }
      let M = y - 1, x = 1, O = 0;
      for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
        l < 0 && O === 0 && this[h + M + 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
      return h + y;
    }, d.prototype.writeInt8 = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
    }, d.prototype.writeInt16LE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
    }, d.prototype.writeInt16BE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
    }, d.prototype.writeInt32LE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
    }, d.prototype.writeInt32BE = function(l, h, y) {
      return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
    }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
      return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
      return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), d.prototype.writeFloatLE = function(l, h, y) {
      return Y(this, l, h, !0, y);
    }, d.prototype.writeFloatBE = function(l, h, y) {
      return Y(this, l, h, !1, y);
    }, d.prototype.writeDoubleLE = function(l, h, y) {
      return ne(this, l, h, !0, y);
    }, d.prototype.writeDoubleBE = function(l, h, y) {
      return ne(this, l, h, !1, y);
    }, d.prototype.copy = function(l, h, y, A) {
      if (!d.isBuffer(l))
        throw new TypeError("argument should be a Buffer");
      if (y || (y = 0), A || A === 0 || (A = this.length), h >= l.length && (h = l.length), h || (h = 0), A > 0 && A < y && (A = y), A === y || l.length === 0 || this.length === 0)
        return 0;
      if (h < 0)
        throw new RangeError("targetStart out of bounds");
      if (y < 0 || y >= this.length)
        throw new RangeError("Index out of range");
      if (A < 0)
        throw new RangeError("sourceEnd out of bounds");
      A > this.length && (A = this.length), l.length - h < A - y && (A = l.length - h + y);
      const M = A - y;
      return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, y, A) : Uint8Array.prototype.set.call(l, this.subarray(y, A), h), M;
    }, d.prototype.fill = function(l, h, y, A) {
      if (typeof l == "string") {
        if (typeof h == "string" ? (A = h, h = 0, y = this.length) : typeof y == "string" && (A = y, y = this.length), A !== void 0 && typeof A != "string")
          throw new TypeError("encoding must be a string");
        if (typeof A == "string" && !d.isEncoding(A))
          throw new TypeError("Unknown encoding: " + A);
        if (l.length === 1) {
          const x = l.charCodeAt(0);
          (A === "utf8" && x < 128 || A === "latin1") && (l = x);
        }
      } else
        typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
      if (h < 0 || this.length < h || this.length < y)
        throw new RangeError("Out of range index");
      if (y <= h)
        return this;
      let M;
      if (h >>>= 0, y = y === void 0 ? this.length : y >>> 0, l || (l = 0), typeof l == "number")
        for (M = h; M < y; ++M)
          this[M] = l;
      else {
        const x = d.isBuffer(l) ? l : d.from(l, A), O = x.length;
        if (O === 0)
          throw new TypeError('The value "' + l + '" is invalid for argument "value"');
        for (M = 0; M < y - h; ++M)
          this[M + h] = x[M % O];
      }
      return this;
    };
    const Q = {};
    function oe(l, h, y) {
      Q[l] = class extends y {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
        }
        get code() {
          return l;
        }
        set code(A) {
          Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: A, writable: !0 });
        }
        toString() {
          return `${this.name} [${l}]: ${this.message}`;
        }
      };
    }
    function ae(l) {
      let h = "", y = l.length;
      const A = l[0] === "-" ? 1 : 0;
      for (; y >= A + 4; y -= 3)
        h = `_${l.slice(y - 3, y)}${h}`;
      return `${l.slice(0, y)}${h}`;
    }
    function ce(l, h, y, A, M, x) {
      if (l > y || l < h) {
        const O = typeof h == "bigint" ? "n" : "";
        let G;
        throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${y}${O}`, new Q.ERR_OUT_OF_RANGE("value", G, l);
      }
      (function(O, G, X) {
        ue(G, "offset"), O[G] !== void 0 && O[G + X] !== void 0 || le(G, O.length - (X + 1));
      })(A, M, x);
    }
    function ue(l, h) {
      if (typeof l != "number")
        throw new Q.ERR_INVALID_ARG_TYPE(h, "number", l);
    }
    function le(l, h, y) {
      throw Math.floor(l) !== l ? (ue(l, y), new Q.ERR_OUT_OF_RANGE(y || "offset", "an integer", l)) : h < 0 ? new Q.ERR_BUFFER_OUT_OF_BOUNDS() : new Q.ERR_OUT_OF_RANGE(y || "offset", `>= ${y ? 1 : 0} and <= ${h}`, l);
    }
    oe("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
      return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(l, h) {
      return `The "${l}" argument must be of type number. Received type ${typeof h}`;
    }, TypeError), oe("ERR_OUT_OF_RANGE", function(l, h, y) {
      let A = `The value of "${l}" is out of range.`, M = y;
      return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? M = ae(String(y)) : typeof y == "bigint" && (M = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (M = ae(M)), M += "n"), A += ` It must be ${h}. Received ${M}`, A;
    }, RangeError);
    const Se = /[^+/0-9A-Za-z-_]/g;
    function he(l, h) {
      let y;
      h = h || 1 / 0;
      const A = l.length;
      let M = null;
      const x = [];
      for (let O = 0; O < A; ++O) {
        if (y = l.charCodeAt(O), y > 55295 && y < 57344) {
          if (!M) {
            if (y > 56319) {
              (h -= 3) > -1 && x.push(239, 191, 189);
              continue;
            }
            if (O + 1 === A) {
              (h -= 3) > -1 && x.push(239, 191, 189);
              continue;
            }
            M = y;
            continue;
          }
          if (y < 56320) {
            (h -= 3) > -1 && x.push(239, 191, 189), M = y;
            continue;
          }
          y = 65536 + (M - 55296 << 10 | y - 56320);
        } else
          M && (h -= 3) > -1 && x.push(239, 191, 189);
        if (M = null, y < 128) {
          if ((h -= 1) < 0)
            break;
          x.push(y);
        } else if (y < 2048) {
          if ((h -= 2) < 0)
            break;
          x.push(y >> 6 | 192, 63 & y | 128);
        } else if (y < 65536) {
          if ((h -= 3) < 0)
            break;
          x.push(y >> 12 | 224, y >> 6 & 63 | 128, 63 & y | 128);
        } else {
          if (!(y < 1114112))
            throw new Error("Invalid code point");
          if ((h -= 4) < 0)
            break;
          x.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, 63 & y | 128);
        }
      }
      return x;
    }
    function _e(l) {
      return o.toByteArray(function(h) {
        if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
          return "";
        for (; h.length % 4 != 0; )
          h += "=";
        return h;
      }(l));
    }
    function Le(l, h, y, A) {
      let M;
      for (M = 0; M < A && !(M + y >= h.length || M >= l.length); ++M)
        h[M + y] = l[M];
      return M;
    }
    function se(l, h) {
      return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
    }
    function we(l) {
      return l != l;
    }
    const We = function() {
      const l = "0123456789abcdef", h = new Array(256);
      for (let y = 0; y < 16; ++y) {
        const A = 16 * y;
        for (let M = 0; M < 16; ++M)
          h[A + M] = l[y] + l[M];
      }
      return h;
    }();
    function de(l) {
      return typeof BigInt > "u" ? ke : l;
    }
    function ke() {
      throw new Error("BigInt not supported");
    }
  }(buffer$1)), buffer$1;
}
var abstractSublevelIterator = {}, hasRequiredAbstractSublevelIterator, abstractSublevel, hasRequiredAbstractSublevel;
function requireAbstractSublevelIterator() {
  if (hasRequiredAbstractSublevelIterator)
    return abstractSublevelIterator;
  hasRequiredAbstractSublevelIterator = 1;
  const { AbstractIterator: n, AbstractKeyIterator: o, AbstractValueIterator: a } = abstractIterator, u = Symbol("unfix"), c = Symbol("iterator"), p = Symbol("handleOne"), d = Symbol("handleMany"), w = Symbol("callback");
  class S extends n {
    constructor(C, P, q, D) {
      super(C, P), this[c] = q, this[u] = D, this[p] = this[p].bind(this), this[d] = this[d].bind(this), this[w] = null;
    }
    [p](C, P, q) {
      const D = this[w];
      if (C)
        return D(C);
      P !== void 0 && (P = this[u](P)), D(C, P, q);
    }
    [d](C, P) {
      const q = this[w];
      if (C)
        return q(C);
      for (const D of P) {
        const z = D[0];
        z !== void 0 && (D[0] = this[u](z));
      }
      q(C, P);
    }
  }
  class k extends o {
    constructor(C, P, q, D) {
      super(C, P), this[c] = q, this[u] = D, this[p] = this[p].bind(this), this[d] = this[d].bind(this), this[w] = null;
    }
    [p](C, P) {
      const q = this[w];
      if (C)
        return q(C);
      P !== void 0 && (P = this[u](P)), q(C, P);
    }
    [d](C, P) {
      const q = this[w];
      if (C)
        return q(C);
      for (let D = 0; D < P.length; D++) {
        const z = P[D];
        z !== void 0 && (P[D] = this[u](z));
      }
      q(C, P);
    }
  }
  class B extends a {
    constructor(C, P, q) {
      super(C, P), this[c] = q;
    }
  }
  for (const I of [S, k])
    I.prototype._next = function(C) {
      this[w] = C, this[c].next(this[p]);
    }, I.prototype._nextv = function(C, P, q) {
      this[w] = q, this[c].nextv(C, P, this[d]);
    }, I.prototype._all = function(C, P) {
      this[w] = P, this[c].all(C, this[d]);
    };
  for (const I of [B])
    I.prototype._next = function(C) {
      this[c].next(C);
    }, I.prototype._nextv = function(C, P, q) {
      this[c].nextv(C, P, q);
    }, I.prototype._all = function(C, P) {
      this[c].all(C, P);
    };
  for (const I of [S, k, B])
    I.prototype._seek = function(C, P) {
      this[c].seek(C, P);
    }, I.prototype._close = function(C) {
      this[c].close(C);
    };
  return abstractSublevelIterator.AbstractSublevelIterator = S, abstractSublevelIterator.AbstractSublevelKeyIterator = k, abstractSublevelIterator.AbstractSublevelValueIterator = B, abstractSublevelIterator;
}
function requireAbstractSublevel() {
  if (hasRequiredAbstractSublevel)
    return abstractSublevel;
  hasRequiredAbstractSublevel = 1;
  const n = moduleError, { Buffer: o } = requireBuffer() || {}, { AbstractSublevelIterator: a, AbstractSublevelKeyIterator: u, AbstractSublevelValueIterator: c } = requireAbstractSublevelIterator(), p = Symbol("prefix"), d = Symbol("upperBound"), w = Symbol("prefixRange"), S = Symbol("parent"), k = Symbol("unfix"), B = new TextEncoder(), I = { separator: "!" };
  abstractSublevel = function({ AbstractLevel: F }) {
    class V extends F {
      static defaults(N) {
        if (typeof N == "string")
          throw new n("The subleveldown string shorthand for { separator } has been removed", { code: "LEVEL_LEGACY" });
        if (N && N.open)
          throw new n("The subleveldown open option has been removed", { code: "LEVEL_LEGACY" });
        return N == null ? I : N.separator ? N : { ...N, separator: "!" };
      }
      constructor(N, W, H) {
        const { separator: te, manifest: g, ...$ } = V.defaults(H);
        W = z(W, te);
        const _ = te.charCodeAt(0) + 1, b = N[S] || N;
        if (!B.encode(W).every((E) => E > _ && E < 127))
          throw new n(`Prefix must use bytes > ${_} < 127`, { code: "LEVEL_INVALID_PREFIX" });
        super(C(b, g), $);
        const m = (N.prefix || "") + te + W + te, v = m.slice(0, -1) + String.fromCharCode(_);
        this[S] = b, this[p] = new q(m), this[d] = new q(v), this[k] = new D(), this.nextTick = b.nextTick;
      }
      prefixKey(N, W) {
        if (W === "utf8")
          return this[p].utf8 + N;
        if (N.byteLength === 0)
          return this[p][W];
        if (W === "view") {
          const H = this[p].view, te = new Uint8Array(H.byteLength + N.byteLength);
          return te.set(H, 0), te.set(N, H.byteLength), te;
        }
        {
          const H = this[p].buffer;
          return o.concat([H, N], H.byteLength + N.byteLength);
        }
      }
      [w](N, W) {
        N.gte !== void 0 ? N.gte = this.prefixKey(N.gte, W) : N.gt !== void 0 ? N.gt = this.prefixKey(N.gt, W) : N.gte = this[p][W], N.lte !== void 0 ? N.lte = this.prefixKey(N.lte, W) : N.lt !== void 0 ? N.lt = this.prefixKey(N.lt, W) : N.lte = this[d][W];
      }
      get prefix() {
        return this[p].utf8;
      }
      get db() {
        return this[S];
      }
      _open(N, W) {
        this[S].open({ passive: !0 }, W);
      }
      _put(N, W, H, te) {
        this[S].put(N, W, H, te);
      }
      _get(N, W, H) {
        this[S].get(N, W, H);
      }
      _getMany(N, W, H) {
        this[S].getMany(N, W, H);
      }
      _del(N, W, H) {
        this[S].del(N, W, H);
      }
      _batch(N, W, H) {
        this[S].batch(N, W, H);
      }
      _clear(N, W) {
        this[w](N, N.keyEncoding), this[S].clear(N, W);
      }
      _iterator(N) {
        this[w](N, N.keyEncoding);
        const W = this[S].iterator(N), H = this[k].get(this[p].utf8.length, N.keyEncoding);
        return new a(this, N, W, H);
      }
      _keys(N) {
        this[w](N, N.keyEncoding);
        const W = this[S].keys(N), H = this[k].get(this[p].utf8.length, N.keyEncoding);
        return new u(this, N, W, H);
      }
      _values(N) {
        this[w](N, N.keyEncoding);
        const W = this[S].values(N);
        return new c(this, N, W);
      }
    }
    return { AbstractSublevel: V };
  };
  const C = function(F, V) {
    return { ...F.supports, createIfMissing: !1, errorIfExists: !1, events: {}, additionalMethods: {}, ...V, encodings: { utf8: P(F, "utf8"), buffer: P(F, "buffer"), view: P(F, "view") } };
  }, P = function(F, V) {
    return !!F.supports.encodings[V] && F.keyEncoding(V).name === V;
  };
  class q {
    constructor(V) {
      this.utf8 = V, this.view = B.encode(V), this.buffer = o ? o.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }
  class D {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(V, Z) {
      let N = this.cache.get(Z);
      return N === void 0 && (N = Z === "view" ? function(W, H) {
        return H.subarray(W);
      }.bind(null, V) : function(W, H) {
        return H.slice(W);
      }.bind(null, V), this.cache.set(Z, N)), N;
    }
  }
  const z = function(F, V) {
    let Z = 0, N = F.length;
    for (; Z < N && F[Z] === V; )
      Z++;
    for (; N > Z && F[N - 1] === V; )
      N--;
    return F.slice(Z, N);
  };
  return abstractSublevel;
}
const { supports } = levelSupports, { Transcoder } = levelTranscoder, { EventEmitter } = events.exports, { fromCallback: fromCallback$1 } = catering, ModuleError$2 = moduleError, { AbstractIterator: AbstractIterator$2 } = abstractIterator, { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator, { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator, { DefaultChainedBatch } = defaultChainedBatch, { getCallback, getOptions } = common$6, rangeOptions$1 = rangeOptions_1, kPromise$1 = Symbol("promise"), kLanded = Symbol("landed"), kResources = Symbol("resources"), kCloseResources = Symbol("closeResources"), kOperations = Symbol("operations"), kUndefer = Symbol("undefer"), kDeferOpen = Symbol("deferOpen"), kOptions$2 = Symbol("options"), kStatus = Symbol("status"), kDefaultOptions = Symbol("defaultOptions"), kTranscoder = Symbol("transcoder"), kKeyEncoding = Symbol("keyEncoding"), kValueEncoding = Symbol("valueEncoding"), noop = () => {
};
class AbstractLevel$2 extends EventEmitter {
  constructor(o, a) {
    if (super(), typeof o != "object" || o === null)
      throw new TypeError("The first argument 'manifest' must be an object");
    a = getOptions(a);
    const { keyEncoding: u, valueEncoding: c, passive: p, ...d } = a;
    this[kResources] = /* @__PURE__ */ new Set(), this[kOperations] = [], this[kDeferOpen] = !0, this[kOptions$2] = d, this[kStatus] = "opening", this.supports = supports(o, { status: !0, promises: !0, clear: !0, getMany: !0, deferredOpen: !0, snapshots: o.snapshots !== !1, permanence: o.permanence !== !1, keyIterator: !0, valueIterator: !0, iteratorNextv: !0, iteratorAll: !0, encodings: o.encodings || {}, events: Object.assign({}, o.events, { opening: !0, open: !0, closing: !0, closed: !0, put: !0, del: !0, batch: !0, clear: !0 }) }), this[kTranscoder] = new Transcoder(formats(this)), this[kKeyEncoding] = this[kTranscoder].encoding(u || "utf8"), this[kValueEncoding] = this[kTranscoder].encoding(c || "utf8");
    for (const w of this[kTranscoder].encodings())
      this.supports.encodings[w.commonName] || (this.supports.encodings[w.commonName] = !0);
    this[kDefaultOptions] = { empty: Object.freeze({}), entry: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName, valueEncoding: this[kValueEncoding].commonName }), key: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName }) }, this.nextTick(() => {
      this[kDeferOpen] && this.open({ passive: !1 }, noop);
    });
  }
  get status() {
    return this[kStatus];
  }
  keyEncoding(o) {
    return this[kTranscoder].encoding(o != null ? o : this[kKeyEncoding]);
  }
  valueEncoding(o) {
    return this[kTranscoder].encoding(o != null ? o : this[kValueEncoding]);
  }
  open(o, a) {
    a = getCallback(o, a), a = fromCallback$1(a, kPromise$1), (o = { ...this[kOptions$2], ...getOptions(o) }).createIfMissing = o.createIfMissing !== !1, o.errorIfExists = !!o.errorIfExists;
    const u = (c) => {
      this[kStatus] === "closing" || this[kStatus] === "opening" ? this.once(kLanded, c ? () => u(c) : u) : this[kStatus] !== "open" ? a(new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN", cause: c })) : a();
    };
    return o.passive ? this[kStatus] === "opening" ? this.once(kLanded, u) : this.nextTick(u) : this[kStatus] === "closed" || this[kDeferOpen] ? (this[kDeferOpen] = !1, this[kStatus] = "opening", this.emit("opening"), this._open(o, (c) => {
      if (c)
        return this[kStatus] = "closed", this[kCloseResources](() => {
          this.emit(kLanded), u(c);
        }), void this[kUndefer]();
      this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), this[kStatus] === "open" && this.emit("open"), this[kStatus] === "open" && this.emit("ready"), u();
    })) : this[kStatus] === "open" ? this.nextTick(u) : this.once(kLanded, () => this.open(o, a)), a[kPromise$1];
  }
  _open(o, a) {
    this.nextTick(a);
  }
  close(o) {
    o = fromCallback$1(o, kPromise$1);
    const a = (u) => {
      this[kStatus] === "opening" || this[kStatus] === "closing" ? this.once(kLanded, u ? a(u) : a) : this[kStatus] !== "closed" ? o(new ModuleError$2("Database is not closed", { code: "LEVEL_DATABASE_NOT_CLOSED", cause: u })) : o();
    };
    if (this[kStatus] === "open") {
      this[kStatus] = "closing", this.emit("closing");
      const u = (c) => {
        this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), a(c);
      };
      this[kCloseResources](() => {
        this._close((c) => {
          if (c)
            return u(c);
          this[kStatus] = "closed", this[kUndefer](), this.emit(kLanded), this[kStatus] === "closed" && this.emit("closed"), a();
        });
      });
    } else
      this[kStatus] === "closed" ? this.nextTick(a) : this.once(kLanded, () => this.close(o));
    return o[kPromise$1];
  }
  [kCloseResources](o) {
    if (this[kResources].size === 0)
      return this.nextTick(o);
    let a = this[kResources].size, u = !0;
    const c = () => {
      --a == 0 && (u ? this.nextTick(o) : o());
    };
    for (const p of this[kResources])
      p.close(c);
    u = !1, this[kResources].clear();
  }
  _close(o) {
    this.nextTick(o);
  }
  get(o, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.get(o, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const c = this._checkKey(o);
    if (c)
      return this.nextTick(u, c), u[kPromise$1];
    const p = this.keyEncoding(a.keyEncoding), d = this.valueEncoding(a.valueEncoding), w = p.format, S = d.format;
    return a.keyEncoding === w && a.valueEncoding === S || (a = Object.assign({}, a, { keyEncoding: w, valueEncoding: S })), this._get(this.prefixKey(p.encode(o), w), a, (k, B) => {
      if (k)
        return (k.code === "LEVEL_NOT_FOUND" || k.notFound || /NotFound/i.test(k)) && (k.code || (k.code = "LEVEL_NOT_FOUND"), k.notFound || (k.notFound = !0), k.status || (k.status = 404)), u(k);
      try {
        B = d.decode(B);
      } catch (I) {
        return u(new ModuleError$2("Could not decode value", { code: "LEVEL_DECODE_ERROR", cause: I }));
      }
      u(null, B);
    }), u[kPromise$1];
  }
  _get(o, a, u) {
    this.nextTick(u, new Error("NotFound"));
  }
  getMany(o, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.getMany(o, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(o))
      return this.nextTick(u, new TypeError("The first argument 'keys' must be an array")), u[kPromise$1];
    if (o.length === 0)
      return this.nextTick(u, null, []), u[kPromise$1];
    const c = this.keyEncoding(a.keyEncoding), p = this.valueEncoding(a.valueEncoding), d = c.format, w = p.format;
    a.keyEncoding === d && a.valueEncoding === w || (a = Object.assign({}, a, { keyEncoding: d, valueEncoding: w }));
    const S = new Array(o.length);
    for (let k = 0; k < o.length; k++) {
      const B = o[k], I = this._checkKey(B);
      if (I)
        return this.nextTick(u, I), u[kPromise$1];
      S[k] = this.prefixKey(c.encode(B), d);
    }
    return this._getMany(S, a, (k, B) => {
      if (k)
        return u(k);
      try {
        for (let I = 0; I < B.length; I++)
          B[I] !== void 0 && (B[I] = p.decode(B[I]));
      } catch (I) {
        return u(new ModuleError$2(`Could not decode one or more of ${B.length} value(s)`, { code: "LEVEL_DECODE_ERROR", cause: I }));
      }
      u(null, B);
    }), u[kPromise$1];
  }
  _getMany(o, a, u) {
    this.nextTick(u, null, new Array(o.length).fill(void 0));
  }
  put(o, a, u, c) {
    if (c = getCallback(u, c), c = fromCallback$1(c, kPromise$1), u = getOptions(u, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.put(o, a, u, c)), c[kPromise$1];
    if (maybeError(this, c))
      return c[kPromise$1];
    const p = this._checkKey(o) || this._checkValue(a);
    if (p)
      return this.nextTick(c, p), c[kPromise$1];
    const d = this.keyEncoding(u.keyEncoding), w = this.valueEncoding(u.valueEncoding), S = d.format, k = w.format;
    u.keyEncoding === S && u.valueEncoding === k || (u = Object.assign({}, u, { keyEncoding: S, valueEncoding: k }));
    const B = this.prefixKey(d.encode(o), S), I = w.encode(a);
    return this._put(B, I, u, (C) => {
      if (C)
        return c(C);
      this.emit("put", o, a), c();
    }), c[kPromise$1];
  }
  _put(o, a, u, c) {
    this.nextTick(c);
  }
  del(o, a, u) {
    if (u = getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].key), this[kStatus] === "opening")
      return this.defer(() => this.del(o, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const c = this._checkKey(o);
    if (c)
      return this.nextTick(u, c), u[kPromise$1];
    const p = this.keyEncoding(a.keyEncoding), d = p.format;
    return a.keyEncoding !== d && (a = Object.assign({}, a, { keyEncoding: d })), this._del(this.prefixKey(p.encode(o), d), a, (w) => {
      if (w)
        return u(w);
      this.emit("del", o), u();
    }), u[kPromise$1];
  }
  _del(o, a, u) {
    this.nextTick(u);
  }
  batch(o, a, u) {
    if (!arguments.length) {
      if (this[kStatus] === "opening")
        return new DefaultChainedBatch(this);
      if (this[kStatus] !== "open")
        throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
      return this._chainedBatch();
    }
    if (u = typeof o == "function" ? o : getCallback(a, u), u = fromCallback$1(u, kPromise$1), a = getOptions(a, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.batch(o, a, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(o))
      return this.nextTick(u, new TypeError("The first argument 'operations' must be an array")), u[kPromise$1];
    if (o.length === 0)
      return this.nextTick(u), u[kPromise$1];
    const c = new Array(o.length), { keyEncoding: p, valueEncoding: d, ...w } = a;
    for (let S = 0; S < o.length; S++) {
      if (typeof o[S] != "object" || o[S] === null)
        return this.nextTick(u, new TypeError("A batch operation must be an object")), u[kPromise$1];
      const k = Object.assign({}, o[S]);
      if (k.type !== "put" && k.type !== "del")
        return this.nextTick(u, new TypeError("A batch operation must have a type property that is 'put' or 'del'")), u[kPromise$1];
      const B = this._checkKey(k.key);
      if (B)
        return this.nextTick(u, B), u[kPromise$1];
      const I = k.sublevel != null ? k.sublevel : this, C = I.keyEncoding(k.keyEncoding || p), P = C.format;
      if (k.key = I.prefixKey(C.encode(k.key), P), k.keyEncoding = P, k.type === "put") {
        const q = this._checkValue(k.value);
        if (q)
          return this.nextTick(u, q), u[kPromise$1];
        const D = I.valueEncoding(k.valueEncoding || d);
        k.value = D.encode(k.value), k.valueEncoding = D.format;
      }
      I !== this && (k.sublevel = null), c[S] = k;
    }
    return this._batch(c, w, (S) => {
      if (S)
        return u(S);
      this.emit("batch", o), u();
    }), u[kPromise$1];
  }
  _batch(o, a, u) {
    this.nextTick(u);
  }
  sublevel(o, a) {
    return this._sublevel(o, AbstractSublevel.defaults(a));
  }
  _sublevel(o, a) {
    return new AbstractSublevel(this, o, a);
  }
  prefixKey(o, a) {
    return o;
  }
  clear(o, a) {
    if (a = getCallback(o, a), a = fromCallback$1(a, kPromise$1), o = getOptions(o, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.clear(o, a)), a[kPromise$1];
    if (maybeError(this, a))
      return a[kPromise$1];
    const u = o, c = this.keyEncoding(o.keyEncoding);
    return (o = rangeOptions$1(o, c)).keyEncoding = c.format, o.limit === 0 ? this.nextTick(a) : this._clear(o, (p) => {
      if (p)
        return a(p);
      this.emit("clear", u), a();
    }), a[kPromise$1];
  }
  _clear(o, a) {
    this.nextTick(a);
  }
  iterator(o) {
    const a = this.keyEncoding(o && o.keyEncoding), u = this.valueEncoding(o && o.valueEncoding);
    if ((o = rangeOptions$1(o, a)).keys = o.keys !== !1, o.values = o.values !== !1, o[AbstractIterator$2.keyEncoding] = a, o[AbstractIterator$2.valueEncoding] = u, o.keyEncoding = a.format, o.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredIterator(this, o);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._iterator(o);
  }
  _iterator(o) {
    return new AbstractIterator$2(this, o);
  }
  keys(o) {
    const a = this.keyEncoding(o && o.keyEncoding), u = this.valueEncoding(o && o.valueEncoding);
    if ((o = rangeOptions$1(o, a))[AbstractIterator$2.keyEncoding] = a, o[AbstractIterator$2.valueEncoding] = u, o.keyEncoding = a.format, o.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredKeyIterator(this, o);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._keys(o);
  }
  _keys(o) {
    return new DefaultKeyIterator(this, o);
  }
  values(o) {
    const a = this.keyEncoding(o && o.keyEncoding), u = this.valueEncoding(o && o.valueEncoding);
    if ((o = rangeOptions$1(o, a))[AbstractIterator$2.keyEncoding] = a, o[AbstractIterator$2.valueEncoding] = u, o.keyEncoding = a.format, o.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredValueIterator(this, o);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._values(o);
  }
  _values(o) {
    return new DefaultValueIterator(this, o);
  }
  defer(o) {
    if (typeof o != "function")
      throw new TypeError("The first argument must be a function");
    this[kOperations].push(o);
  }
  [kUndefer]() {
    if (this[kOperations].length === 0)
      return;
    const o = this[kOperations];
    this[kOperations] = [];
    for (const a of o)
      a();
  }
  attachResource(o) {
    if (typeof o != "object" || o === null || typeof o.close != "function")
      throw new TypeError("The first argument must be a resource object");
    this[kResources].add(o);
  }
  detachResource(o) {
    this[kResources].delete(o);
  }
  _chainedBatch() {
    return new DefaultChainedBatch(this);
  }
  _checkKey(o) {
    if (o == null)
      return new ModuleError$2("Key cannot be null or undefined", { code: "LEVEL_INVALID_KEY" });
  }
  _checkValue(o) {
    if (o == null)
      return new ModuleError$2("Value cannot be null or undefined", { code: "LEVEL_INVALID_VALUE" });
  }
}
AbstractLevel$2.prototype.nextTick = requireNextTickBrowser();
const { AbstractSublevel } = requireAbstractSublevel()({ AbstractLevel: AbstractLevel$2 });
abstractLevel.AbstractLevel = AbstractLevel$2, abstractLevel.AbstractSublevel = AbstractSublevel;
const maybeError = function(n, o) {
  return n[kStatus] !== "open" && (n.nextTick(o, new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" })), !0);
}, formats = function(n) {
  return Object.keys(n.supports.encodings).filter((o) => !!n.supports.encodings[o]);
};
abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel, abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel, abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator, abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator, abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator, abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var runParallelLimit_1 = runParallelLimit;
const queueMicrotask$1 = queueMicrotask_1;
function runParallelLimit(n, o, a) {
  if (typeof o != "number")
    throw new Error("second argument must be a Number");
  let u, c, p, d, w, S, k = !0;
  function B(C) {
    function P() {
      a && a(C, u), a = null;
    }
    k ? queueMicrotask$1(P) : P();
  }
  function I(C, P, q) {
    if (u[C] = q, P && (w = !0), --p == 0 || P)
      B(P);
    else if (!w && S < c) {
      let D;
      d ? (D = d[S], S += 1, n[D](function(z, F) {
        I(D, z, F);
      })) : (D = S, S += 1, n[D](function(z, F) {
        I(D, z, F);
      }));
    }
  }
  Array.isArray(n) ? (u = [], p = c = n.length) : (d = Object.keys(n), u = {}, p = c = d.length), S = o, p ? d ? d.some(function(C, P) {
    return n[C](function(q, D) {
      I(C, q, D);
    }), P === o - 1;
  }) : n.some(function(C, P) {
    return C(function(q, D) {
      I(P, q, D);
    }), P === o - 1;
  }) : B(null), k = !1;
}
var iterator$1 = {}, keyRange = function(n) {
  const o = n.gte !== void 0 ? n.gte : n.gt !== void 0 ? n.gt : void 0, a = n.lte !== void 0 ? n.lte : n.lt !== void 0 ? n.lt : void 0, u = n.gte === void 0, c = n.lte === void 0;
  return o !== void 0 && a !== void 0 ? IDBKeyRange.bound(o, a, u, c) : o !== void 0 ? IDBKeyRange.lowerBound(o, u) : a !== void 0 ? IDBKeyRange.upperBound(a, c) : null;
};
const textEncoder = new TextEncoder();
var deserialize$2 = function(n) {
  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : textEncoder.encode(n);
};
const { AbstractIterator: AbstractIterator$1 } = abstractLevel$1, createKeyRange$1 = keyRange, deserialize$1 = deserialize$2, kCache = Symbol("cache"), kFinished = Symbol("finished"), kOptions$1 = Symbol("options"), kCurrentOptions = Symbol("currentOptions"), kPosition = Symbol("position"), kLocation$1 = Symbol("location"), kFirst = Symbol("first"), emptyOptions = {};
class Iterator$1 extends AbstractIterator$1 {
  constructor(o, a, u) {
    super(o, u), this[kCache] = [], this[kFinished] = this.limit === 0, this[kOptions$1] = u, this[kCurrentOptions] = { ...u }, this[kPosition] = void 0, this[kLocation$1] = a, this[kFirst] = !0;
  }
  _nextv(o, a, u) {
    if (this[kFirst] = !1, this[kFinished])
      return this.nextTick(u, null, []);
    if (this[kCache].length > 0)
      return o = Math.min(o, this[kCache].length), this.nextTick(u, null, this[kCache].splice(0, o));
    let c;
    this[kPosition] !== void 0 && (this[kOptions$1].reverse ? (this[kCurrentOptions].lt = this[kPosition], this[kCurrentOptions].lte = void 0) : (this[kCurrentOptions].gt = this[kPosition], this[kCurrentOptions].gte = void 0));
    try {
      c = createKeyRange$1(this[kCurrentOptions]);
    } catch {
      return this[kFinished] = !0, this.nextTick(u, null, []);
    }
    const p = this.db.db.transaction([this[kLocation$1]], "readonly"), d = p.objectStore(this[kLocation$1]), w = [];
    if (this[kOptions$1].reverse)
      d[!this[kOptions$1].values && d.openKeyCursor ? "openKeyCursor" : "openCursor"](c, "prev").onsuccess = (S) => {
        const k = S.target.result;
        if (k) {
          const { key: B, value: I } = k;
          this[kPosition] = B, w.push([this[kOptions$1].keys && B !== void 0 ? deserialize$1(B) : void 0, this[kOptions$1].values && I !== void 0 ? deserialize$1(I) : void 0]), w.length < o ? k.continue() : maybeCommit(p);
        } else
          this[kFinished] = !0;
      };
    else {
      let S, k;
      const B = () => {
        if (S === void 0 || k === void 0)
          return;
        const I = Math.max(S.length, k.length);
        I === 0 || o === 1 / 0 ? this[kFinished] = !0 : this[kPosition] = S[I - 1], w.length = I;
        for (let C = 0; C < I; C++) {
          const P = S[C], q = k[C];
          w[C] = [this[kOptions$1].keys && P !== void 0 ? deserialize$1(P) : void 0, this[kOptions$1].values && q !== void 0 ? deserialize$1(q) : void 0];
        }
        maybeCommit(p);
      };
      this[kOptions$1].keys || o < 1 / 0 ? d.getAllKeys(c, o < 1 / 0 ? o : void 0).onsuccess = (I) => {
        S = I.target.result, B();
      } : (S = [], this.nextTick(B)), this[kOptions$1].values ? d.getAll(c, o < 1 / 0 ? o : void 0).onsuccess = (I) => {
        k = I.target.result, B();
      } : (k = [], this.nextTick(B));
    }
    p.onabort = () => {
      u(p.error || new Error("aborted by user")), u = null;
    }, p.oncomplete = () => {
      u(null, w), u = null;
    };
  }
  _next(o) {
    if (this[kCache].length > 0) {
      const [a, u] = this[kCache].shift();
      this.nextTick(o, null, a, u);
    } else if (this[kFinished])
      this.nextTick(o);
    else {
      let a = Math.min(100, this.limit - this.count);
      this[kFirst] && (this[kFirst] = !1, a = 1), this._nextv(a, emptyOptions, (u, c) => {
        if (u)
          return o(u);
        this[kCache] = c, this._next(o);
      });
    }
  }
  _all(o, a) {
    this[kFirst] = !1;
    const u = this[kCache].splice(0, this[kCache].length), c = this.limit - this.count - u.length;
    if (c <= 0)
      return this.nextTick(a, null, u);
    this._nextv(c, emptyOptions, (p, d) => {
      if (p)
        return a(p);
      u.length > 0 && (d = u.concat(d)), a(null, d);
    });
  }
  _seek(o, a) {
    let u;
    this[kFirst] = !0, this[kCache] = [], this[kFinished] = !1, this[kPosition] = void 0, this[kCurrentOptions] = { ...this[kOptions$1] };
    try {
      u = createKeyRange$1(this[kOptions$1]);
    } catch {
      return void (this[kFinished] = !0);
    }
    u === null || u.includes(o) ? this[kOptions$1].reverse ? this[kCurrentOptions].lte = o : this[kCurrentOptions].gte = o : this[kFinished] = !0;
  }
}
function maybeCommit(n) {
  typeof n.commit == "function" && n.commit();
}
iterator$1.Iterator = Iterator$1;
var clear$1 = function(n, o, a, u, c) {
  if (u.limit === 0)
    return n.nextTick(c);
  const p = n.db.transaction([o], "readwrite"), d = p.objectStore(o);
  let w = 0;
  p.oncomplete = function() {
    c();
  }, p.onabort = function() {
    c(p.error || new Error("aborted by user"));
  };
  const S = d.openKeyCursor ? "openKeyCursor" : "openCursor", k = u.reverse ? "prev" : "next";
  d[S](a, k).onsuccess = function(B) {
    const I = B.target.result;
    I && (d.delete(I.key).onsuccess = function() {
      (u.limit <= 0 || ++w < u.limit) && I.continue();
    });
  };
};
const { AbstractLevel: AbstractLevel$1 } = abstractLevel$1, ModuleError$1 = moduleError, parallel = runParallelLimit_1, { fromCallback } = catering, { Iterator } = iterator$1, deserialize = deserialize$2, clear = clear$1, createKeyRange = keyRange, DEFAULT_PREFIX = "level-js-", kIDB = Symbol("idb"), kNamePrefix = Symbol("namePrefix"), kLocation = Symbol("location"), kVersion = Symbol("version"), kStore = Symbol("store"), kOnComplete = Symbol("onComplete"), kPromise = Symbol("promise");
class BrowserLevel extends AbstractLevel$1 {
  constructor(o, a, u) {
    if (typeof a == "function" || typeof u == "function")
      throw new ModuleError$1("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    const { prefix: c, version: p, ...d } = a || {};
    if (super({ encodings: { view: !0 }, snapshots: !1, createIfMissing: !1, errorIfExists: !1, seek: !0 }, d), typeof o != "string")
      throw new Error("constructor requires a location string argument");
    this[kLocation] = o, this[kNamePrefix] = c == null ? DEFAULT_PREFIX : c, this[kVersion] = parseInt(p || 1, 10), this[kIDB] = null;
  }
  get location() {
    return this[kLocation];
  }
  get namePrefix() {
    return this[kNamePrefix];
  }
  get version() {
    return this[kVersion];
  }
  get db() {
    return this[kIDB];
  }
  get type() {
    return "browser-level";
  }
  _open(o, a) {
    const u = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
    u.onerror = function() {
      a(u.error || new Error("unknown error"));
    }, u.onsuccess = () => {
      this[kIDB] = u.result, a();
    }, u.onupgradeneeded = (c) => {
      const p = c.target.result;
      p.objectStoreNames.contains(this[kLocation]) || p.createObjectStore(this[kLocation]);
    };
  }
  [kStore](o) {
    return this[kIDB].transaction([this[kLocation]], o).objectStore(this[kLocation]);
  }
  [kOnComplete](o, a) {
    const u = o.transaction;
    u.onabort = function() {
      a(u.error || new Error("aborted by user"));
    }, u.oncomplete = function() {
      a(null, o.result);
    };
  }
  _get(o, a, u) {
    const c = this[kStore]("readonly");
    let p;
    try {
      p = c.get(o);
    } catch (d) {
      return this.nextTick(u, d);
    }
    this[kOnComplete](p, function(d, w) {
      return d ? u(d) : w === void 0 ? u(new ModuleError$1("Entry not found", { code: "LEVEL_NOT_FOUND" })) : void u(null, deserialize(w));
    });
  }
  _getMany(o, a, u) {
    const c = this[kStore]("readonly"), p = o.map((d) => (w) => {
      let S;
      try {
        S = c.get(d);
      } catch (k) {
        return w(k);
      }
      S.onsuccess = () => {
        const k = S.result;
        w(null, k === void 0 ? k : deserialize(k));
      }, S.onerror = (k) => {
        k.stopPropagation(), w(S.error);
      };
    });
    parallel(p, 16, u);
  }
  _del(o, a, u) {
    const c = this[kStore]("readwrite");
    let p;
    try {
      p = c.delete(o);
    } catch (d) {
      return this.nextTick(u, d);
    }
    this[kOnComplete](p, u);
  }
  _put(o, a, u, c) {
    const p = this[kStore]("readwrite");
    let d;
    try {
      d = p.put(a, o);
    } catch (w) {
      return this.nextTick(c, w);
    }
    this[kOnComplete](d, c);
  }
  _iterator(o) {
    return new Iterator(this, this[kLocation], o);
  }
  _batch(o, a, u) {
    const c = this[kStore]("readwrite"), p = c.transaction;
    let d, w = 0;
    p.onabort = function() {
      u(d || p.error || new Error("aborted by user"));
    }, p.oncomplete = function() {
      u();
    }, function S() {
      const k = o[w++], B = k.key;
      let I;
      try {
        I = k.type === "del" ? c.delete(B) : c.put(k.value, B);
      } catch (C) {
        return d = C, void p.abort();
      }
      w < o.length ? I.onsuccess = S : typeof p.commit == "function" && p.commit();
    }();
  }
  _clear(o, a) {
    let u, c;
    try {
      u = createKeyRange(o);
    } catch {
      return this.nextTick(a);
    }
    if (o.limit >= 0)
      return clear(this, this[kLocation], u, o, a);
    try {
      const p = this[kStore]("readwrite");
      c = u ? p.delete(u) : p.clear();
    } catch (p) {
      return this.nextTick(a, p);
    }
    this[kOnComplete](c, a);
  }
  _close(o) {
    this[kIDB].close(), this.nextTick(o);
  }
}
BrowserLevel.destroy = function(n, o, a) {
  typeof o == "function" && (a = o, o = DEFAULT_PREFIX), a = fromCallback(a, kPromise);
  const u = indexedDB.deleteDatabase(o + n);
  return u.onsuccess = function() {
    a();
  }, u.onerror = function(c) {
    a(c);
  }, a[kPromise];
}, browserLevel.BrowserLevel = BrowserLevel, browser.Level = browserLevel.BrowserLevel;
var memoryLevel = {}, rbtree = createRBTree, RED = 0, BLACK = 1;
function RBNode(n, o, a, u, c, p) {
  this._color = n, this.key = o, this.value = a, this.left = u, this.right = c, this._count = p;
}
function cloneNode(n) {
  return new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
}
function repaint(n, o) {
  return new RBNode(n, o.key, o.value, o.left, o.right, o._count);
}
function recount(n) {
  n._count = 1 + (n.left ? n.left._count : 0) + (n.right ? n.right._count : 0);
}
function RedBlackTree(n, o) {
  this._compare = n, this.root = o;
}
var proto = RedBlackTree.prototype;
function doVisitFull(n, o) {
  var a;
  return o.left && (a = doVisitFull(n, o.left)) ? a : (a = n(o.key, o.value)) || (o.right ? doVisitFull(n, o.right) : void 0);
}
function doVisitHalf(n, o, a, u) {
  if (o(n, u.key) <= 0) {
    var c;
    if (u.left && (c = doVisitHalf(n, o, a, u.left)) || (c = a(u.key, u.value)))
      return c;
  }
  if (u.right)
    return doVisitHalf(n, o, a, u.right);
}
function doVisit(n, o, a, u, c) {
  var p, d = a(n, c.key), w = a(o, c.key);
  if (d <= 0 && (c.left && (p = doVisit(n, o, a, u, c.left)) || w > 0 && (p = u(c.key, c.value))))
    return p;
  if (w > 0 && c.right)
    return doVisit(n, o, a, u, c.right);
}
function RedBlackTreeIterator(n, o) {
  this.tree = n, this._stack = o;
}
Object.defineProperty(proto, "keys", { get: function() {
  var n = [];
  return this.forEach(function(o, a) {
    n.push(o);
  }), n;
} }), Object.defineProperty(proto, "values", { get: function() {
  var n = [];
  return this.forEach(function(o, a) {
    n.push(a);
  }), n;
} }), Object.defineProperty(proto, "length", { get: function() {
  return this.root ? this.root._count : 0;
} }), proto.insert = function(n, o) {
  for (var a = this._compare, u = this.root, c = [], p = []; u; ) {
    var d = a(n, u.key);
    c.push(u), p.push(d), u = d <= 0 ? u.left : u.right;
  }
  c.push(new RBNode(RED, n, o, null, null, 1));
  for (var w = c.length - 2; w >= 0; --w)
    u = c[w], p[w] <= 0 ? c[w] = new RBNode(u._color, u.key, u.value, c[w + 1], u.right, u._count + 1) : c[w] = new RBNode(u._color, u.key, u.value, u.left, c[w + 1], u._count + 1);
  for (w = c.length - 1; w > 1; --w) {
    var S = c[w - 1];
    if (u = c[w], S._color === BLACK || u._color === BLACK)
      break;
    var k = c[w - 2];
    if (k.left === S)
      if (S.left === u) {
        if (!(B = k.right) || B._color !== RED) {
          k._color = RED, k.left = S.right, S._color = BLACK, S.right = k, c[w - 2] = S, c[w - 1] = u, recount(k), recount(S), w >= 3 && ((I = c[w - 3]).left === k ? I.left = S : I.right = S);
          break;
        }
        S._color = BLACK, k.right = repaint(BLACK, B), k._color = RED, w -= 1;
      } else {
        if (!(B = k.right) || B._color !== RED) {
          S.right = u.left, k._color = RED, k.left = u.right, u._color = BLACK, u.left = S, u.right = k, c[w - 2] = u, c[w - 1] = S, recount(k), recount(S), recount(u), w >= 3 && ((I = c[w - 3]).left === k ? I.left = u : I.right = u);
          break;
        }
        S._color = BLACK, k.right = repaint(BLACK, B), k._color = RED, w -= 1;
      }
    else if (S.right === u) {
      if (!(B = k.left) || B._color !== RED) {
        k._color = RED, k.right = S.left, S._color = BLACK, S.left = k, c[w - 2] = S, c[w - 1] = u, recount(k), recount(S), w >= 3 && ((I = c[w - 3]).right === k ? I.right = S : I.left = S);
        break;
      }
      S._color = BLACK, k.left = repaint(BLACK, B), k._color = RED, w -= 1;
    } else {
      var B;
      if (!(B = k.left) || B._color !== RED) {
        var I;
        S.left = u.right, k._color = RED, k.right = u.left, u._color = BLACK, u.right = S, u.left = k, c[w - 2] = u, c[w - 1] = S, recount(k), recount(S), recount(u), w >= 3 && ((I = c[w - 3]).right === k ? I.right = u : I.left = u);
        break;
      }
      S._color = BLACK, k.left = repaint(BLACK, B), k._color = RED, w -= 1;
    }
  }
  return c[0]._color = BLACK, new RedBlackTree(a, c[0]);
}, proto.forEach = function(n, o, a) {
  if (this.root)
    switch (arguments.length) {
      case 1:
        return doVisitFull(n, this.root);
      case 2:
        return doVisitHalf(o, this._compare, n, this.root);
      case 3:
        return this._compare(o, a) >= 0 ? void 0 : doVisit(o, a, this._compare, n, this.root);
    }
}, Object.defineProperty(proto, "begin", { get: function() {
  for (var n = [], o = this.root; o; )
    n.push(o), o = o.left;
  return new RedBlackTreeIterator(this, n);
} }), Object.defineProperty(proto, "end", { get: function() {
  for (var n = [], o = this.root; o; )
    n.push(o), o = o.right;
  return new RedBlackTreeIterator(this, n);
} }), proto.at = function(n) {
  if (n < 0)
    return new RedBlackTreeIterator(this, []);
  for (var o = this.root, a = []; ; ) {
    if (a.push(o), o.left) {
      if (n < o.left._count) {
        o = o.left;
        continue;
      }
      n -= o.left._count;
    }
    if (!n)
      return new RedBlackTreeIterator(this, a);
    if (n -= 1, !o.right || n >= o.right._count)
      break;
    o = o.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.ge = function(n) {
  for (var o = this._compare, a = this.root, u = [], c = 0; a; ) {
    var p = o(n, a.key);
    u.push(a), p <= 0 && (c = u.length), a = p <= 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.gt = function(n) {
  for (var o = this._compare, a = this.root, u = [], c = 0; a; ) {
    var p = o(n, a.key);
    u.push(a), p < 0 && (c = u.length), a = p < 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.lt = function(n) {
  for (var o = this._compare, a = this.root, u = [], c = 0; a; ) {
    var p = o(n, a.key);
    u.push(a), p > 0 && (c = u.length), a = p <= 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.le = function(n) {
  for (var o = this._compare, a = this.root, u = [], c = 0; a; ) {
    var p = o(n, a.key);
    u.push(a), p >= 0 && (c = u.length), a = p < 0 ? a.left : a.right;
  }
  return u.length = c, new RedBlackTreeIterator(this, u);
}, proto.find = function(n) {
  for (var o = this._compare, a = this.root, u = []; a; ) {
    var c = o(n, a.key);
    if (u.push(a), c === 0)
      return new RedBlackTreeIterator(this, u);
    a = c <= 0 ? a.left : a.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.remove = function(n) {
  var o = this.find(n);
  return o ? o.remove() : this;
}, proto.get = function(n) {
  for (var o = this._compare, a = this.root; a; ) {
    var u = o(n, a.key);
    if (u === 0)
      return a.value;
    a = u <= 0 ? a.left : a.right;
  }
};
var iproto = RedBlackTreeIterator.prototype;
function swapNode(n, o) {
  n.key = o.key, n.value = o.value, n.left = o.left, n.right = o.right, n._color = o._color, n._count = o._count;
}
function fixDoubleBlack(n) {
  for (var o, a, u, c, p = n.length - 1; p >= 0; --p) {
    if (o = n[p], p === 0)
      return void (o._color = BLACK);
    if ((a = n[p - 1]).left === o) {
      if ((u = a.right).right && u.right._color === RED)
        return c = (u = a.right = cloneNode(u)).right = cloneNode(u.right), a.right = u.left, u.left = a, u.right = c, u._color = a._color, o._color = BLACK, a._color = BLACK, c._color = BLACK, recount(a), recount(u), p > 1 && ((d = n[p - 2]).left === a ? d.left = u : d.right = u), void (n[p - 1] = u);
      if (u.left && u.left._color === RED)
        return c = (u = a.right = cloneNode(u)).left = cloneNode(u.left), a.right = c.left, u.left = c.right, c.left = a, c.right = u, c._color = a._color, a._color = BLACK, u._color = BLACK, o._color = BLACK, recount(a), recount(u), recount(c), p > 1 && ((d = n[p - 2]).left === a ? d.left = c : d.right = c), void (n[p - 1] = c);
      if (u._color === BLACK) {
        if (a._color === RED)
          return a._color = BLACK, void (a.right = repaint(RED, u));
        a.right = repaint(RED, u);
        continue;
      }
      u = cloneNode(u), a.right = u.left, u.left = a, u._color = a._color, a._color = RED, recount(a), recount(u), p > 1 && ((d = n[p - 2]).left === a ? d.left = u : d.right = u), n[p - 1] = u, n[p] = a, p + 1 < n.length ? n[p + 1] = o : n.push(o), p += 2;
    } else {
      if ((u = a.left).left && u.left._color === RED)
        return c = (u = a.left = cloneNode(u)).left = cloneNode(u.left), a.left = u.right, u.right = a, u.left = c, u._color = a._color, o._color = BLACK, a._color = BLACK, c._color = BLACK, recount(a), recount(u), p > 1 && ((d = n[p - 2]).right === a ? d.right = u : d.left = u), void (n[p - 1] = u);
      if (u.right && u.right._color === RED)
        return c = (u = a.left = cloneNode(u)).right = cloneNode(u.right), a.left = c.right, u.right = c.left, c.right = a, c.left = u, c._color = a._color, a._color = BLACK, u._color = BLACK, o._color = BLACK, recount(a), recount(u), recount(c), p > 1 && ((d = n[p - 2]).right === a ? d.right = c : d.left = c), void (n[p - 1] = c);
      if (u._color === BLACK) {
        if (a._color === RED)
          return a._color = BLACK, void (a.left = repaint(RED, u));
        a.left = repaint(RED, u);
        continue;
      }
      var d;
      u = cloneNode(u), a.left = u.right, u.right = a, u._color = a._color, a._color = RED, recount(a), recount(u), p > 1 && ((d = n[p - 2]).right === a ? d.right = u : d.left = u), n[p - 1] = u, n[p] = a, p + 1 < n.length ? n[p + 1] = o : n.push(o), p += 2;
    }
  }
}
function defaultCompare(n, o) {
  return n < o ? -1 : n > o ? 1 : 0;
}
function createRBTree(n) {
  return new RedBlackTree(n || defaultCompare, null);
}
Object.defineProperty(iproto, "valid", { get: function() {
  return this._stack.length > 0;
} }), Object.defineProperty(iproto, "node", { get: function() {
  return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
}, enumerable: !0 }), iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
}, iproto.remove = function() {
  var n = this._stack;
  if (n.length === 0)
    return this.tree;
  var o = new Array(n.length), a = n[n.length - 1];
  o[o.length - 1] = new RBNode(a._color, a.key, a.value, a.left, a.right, a._count);
  for (var u = n.length - 2; u >= 0; --u)
    (a = n[u]).left === n[u + 1] ? o[u] = new RBNode(a._color, a.key, a.value, o[u + 1], a.right, a._count) : o[u] = new RBNode(a._color, a.key, a.value, a.left, o[u + 1], a._count);
  if ((a = o[o.length - 1]).left && a.right) {
    var c = o.length;
    for (a = a.left; a.right; )
      o.push(a), a = a.right;
    var p = o[c - 1];
    for (o.push(new RBNode(a._color, p.key, p.value, a.left, a.right, a._count)), o[c - 1].key = a.key, o[c - 1].value = a.value, u = o.length - 2; u >= c; --u)
      a = o[u], o[u] = new RBNode(a._color, a.key, a.value, a.left, o[u + 1], a._count);
    o[c - 1].left = o[c];
  }
  if ((a = o[o.length - 1])._color === RED) {
    var d = o[o.length - 2];
    for (d.left === a ? d.left = null : d.right === a && (d.right = null), o.pop(), u = 0; u < o.length; ++u)
      o[u]._count--;
    return new RedBlackTree(this.tree._compare, o[0]);
  }
  if (a.left || a.right) {
    for (a.left ? swapNode(a, a.left) : a.right && swapNode(a, a.right), a._color = BLACK, u = 0; u < o.length - 1; ++u)
      o[u]._count--;
    return new RedBlackTree(this.tree._compare, o[0]);
  }
  if (o.length === 1)
    return new RedBlackTree(this.tree._compare, null);
  for (u = 0; u < o.length; ++u)
    o[u]._count--;
  var w = o[o.length - 2];
  return fixDoubleBlack(o), w.left === a ? w.left = null : w.right = null, new RedBlackTree(this.tree._compare, o[0]);
}, Object.defineProperty(iproto, "key", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].key;
}, enumerable: !0 }), Object.defineProperty(iproto, "value", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].value;
}, enumerable: !0 }), Object.defineProperty(iproto, "index", { get: function() {
  var n = 0, o = this._stack;
  if (o.length === 0) {
    var a = this.tree.root;
    return a ? a._count : 0;
  }
  o[o.length - 1].left && (n = o[o.length - 1].left._count);
  for (var u = o.length - 2; u >= 0; --u)
    o[u + 1] === o[u].right && (++n, o[u].left && (n += o[u].left._count));
  return n;
}, enumerable: !0 }), iproto.next = function() {
  var n = this._stack;
  if (n.length !== 0) {
    var o = n[n.length - 1];
    if (o.right)
      for (o = o.right; o; )
        n.push(o), o = o.left;
    else
      for (n.pop(); n.length > 0 && n[n.length - 1].right === o; )
        o = n[n.length - 1], n.pop();
  }
}, Object.defineProperty(iproto, "hasNext", { get: function() {
  var n = this._stack;
  if (n.length === 0)
    return !1;
  if (n[n.length - 1].right)
    return !0;
  for (var o = n.length - 1; o > 0; --o)
    if (n[o - 1].left === n[o])
      return !0;
  return !1;
} }), iproto.update = function(n) {
  var o = this._stack;
  if (o.length === 0)
    throw new Error("Can't update empty node!");
  var a = new Array(o.length), u = o[o.length - 1];
  a[a.length - 1] = new RBNode(u._color, u.key, n, u.left, u.right, u._count);
  for (var c = o.length - 2; c >= 0; --c)
    (u = o[c]).left === o[c + 1] ? a[c] = new RBNode(u._color, u.key, u.value, a[c + 1], u.right, u._count) : a[c] = new RBNode(u._color, u.key, u.value, u.left, a[c + 1], u._count);
  return new RedBlackTree(this.tree._compare, a[0]);
}, iproto.prev = function() {
  var n = this._stack;
  if (n.length !== 0) {
    var o = n[n.length - 1];
    if (o.left)
      for (o = o.left; o; )
        n.push(o), o = o.right;
    else
      for (n.pop(); n.length > 0 && n[n.length - 1].left === o; )
        o = n[n.length - 1], n.pop();
  }
}, Object.defineProperty(iproto, "hasPrev", { get: function() {
  var n = this._stack;
  if (n.length === 0)
    return !1;
  if (n[n.length - 1].left)
    return !0;
  for (var o = n.length - 1; o > 0; --o)
    if (n[o - 1].right === n[o])
      return !0;
  return !1;
} });
const { AbstractLevel, AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = abstractLevel$1, ModuleError = moduleError, createRBT = rbtree, rangeOptions = /* @__PURE__ */ new Set(["gt", "gte", "lt", "lte"]), kNone = Symbol("none"), kTree = Symbol("tree"), kIterator = Symbol("iterator"), kLowerBound = Symbol("lowerBound"), kUpperBound = Symbol("upperBound"), kOutOfRange = Symbol("outOfRange"), kReverse = Symbol("reverse"), kOptions = Symbol("options"), kTest = Symbol("test"), kAdvance = Symbol("advance"), kInit = Symbol("init");
function compare(n, o) {
  if (typeof n == "string")
    return n < o ? -1 : n > o ? 1 : 0;
  const a = Math.min(n.byteLength, o.byteLength);
  for (let u = 0; u < a; u++) {
    const c = n[u] - o[u];
    if (c !== 0)
      return c;
  }
  return n.byteLength - o.byteLength;
}
function gt(n) {
  return compare(n, this[kUpperBound]) > 0;
}
function gte(n) {
  return compare(n, this[kUpperBound]) >= 0;
}
function lt(n) {
  return compare(n, this[kUpperBound]) < 0;
}
function lte(n) {
  return compare(n, this[kUpperBound]) <= 0;
}
class MemoryIterator extends AbstractIterator {
  constructor(o, a) {
    super(o, a), this[kInit](o[kTree], a);
  }
  _next(o) {
    if (!this[kIterator].valid)
      return this.nextTick(o);
    const a = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](a))
      return this.nextTick(o);
    this[kIterator][this[kAdvance]](), this.nextTick(o, null, a, u);
  }
  _nextv(o, a, u) {
    const c = this[kIterator], p = [];
    for (; c.valid && p.length < o && this[kTest](c.key); )
      p.push([c.key, c.value]), c[this[kAdvance]]();
    this.nextTick(u, null, p);
  }
  _all(o, a) {
    const u = this.limit - this.count, c = this[kIterator], p = [];
    for (; c.valid && p.length < u && this[kTest](c.key); )
      p.push([c.key, c.value]), c[this[kAdvance]]();
    this.nextTick(a, null, p);
  }
}
class MemoryKeyIterator extends AbstractKeyIterator {
  constructor(o, a) {
    super(o, a), this[kInit](o[kTree], a);
  }
  _next(o) {
    if (!this[kIterator].valid)
      return this.nextTick(o);
    const a = this[kIterator].key;
    if (!this[kTest](a))
      return this.nextTick(o);
    this[kIterator][this[kAdvance]](), this.nextTick(o, null, a);
  }
  _nextv(o, a, u) {
    const c = this[kIterator], p = [];
    for (; c.valid && p.length < o && this[kTest](c.key); )
      p.push(c.key), c[this[kAdvance]]();
    this.nextTick(u, null, p);
  }
  _all(o, a) {
    const u = this.limit - this.count, c = this[kIterator], p = [];
    for (; c.valid && p.length < u && this[kTest](c.key); )
      p.push(c.key), c[this[kAdvance]]();
    this.nextTick(a, null, p);
  }
}
class MemoryValueIterator extends AbstractValueIterator {
  constructor(o, a) {
    super(o, a), this[kInit](o[kTree], a);
  }
  _next(o) {
    if (!this[kIterator].valid)
      return this.nextTick(o);
    const a = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](a))
      return this.nextTick(o);
    this[kIterator][this[kAdvance]](), this.nextTick(o, null, u);
  }
  _nextv(o, a, u) {
    const c = this[kIterator], p = [];
    for (; c.valid && p.length < o && this[kTest](c.key); )
      p.push(c.value), c[this[kAdvance]]();
    this.nextTick(u, null, p);
  }
  _all(o, a) {
    const u = this.limit - this.count, c = this[kIterator], p = [];
    for (; c.valid && p.length < u && this[kTest](c.key); )
      p.push(c.value), c[this[kAdvance]]();
    this.nextTick(a, null, p);
  }
}
for (const n of [MemoryIterator, MemoryKeyIterator, MemoryValueIterator])
  n.prototype[kInit] = function(o, a) {
    this[kReverse] = a.reverse, this[kOptions] = a, this[kReverse] ? (this[kAdvance] = "prev", this[kLowerBound] = "lte" in a ? a.lte : "lt" in a ? a.lt : kNone, this[kUpperBound] = "gte" in a ? a.gte : "gt" in a ? a.gt : kNone, this[kLowerBound] === kNone ? this[kIterator] = o.end : this[kIterator] = "lte" in a ? o.le(this[kLowerBound]) : o.lt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "gte" in a ? gte : gt)) : (this[kAdvance] = "next", this[kLowerBound] = "gte" in a ? a.gte : "gt" in a ? a.gt : kNone, this[kUpperBound] = "lte" in a ? a.lte : "lt" in a ? a.lt : kNone, this[kLowerBound] === kNone ? this[kIterator] = o.begin : this[kIterator] = "gte" in a ? o.ge(this[kLowerBound]) : o.gt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "lte" in a ? lte : lt));
  }, n.prototype[kTest] = function() {
    return !0;
  }, n.prototype[kOutOfRange] = function(o) {
    return !this[kTest](o) || this[kLowerBound] !== kNone && (this[kReverse] ? "lte" in this[kOptions] ? compare(o, this[kLowerBound]) > 0 : compare(o, this[kLowerBound]) >= 0 : "gte" in this[kOptions] ? compare(o, this[kLowerBound]) < 0 : compare(o, this[kLowerBound]) <= 0);
  }, n.prototype._seek = function(o, a) {
    this[kOutOfRange](o) ? (this[kIterator] = this[kIterator].tree.end, this[kIterator].next()) : this[kReverse] ? this[kIterator] = this[kIterator].tree.le(o) : this[kIterator] = this[kIterator].tree.ge(o);
  };
class MemoryLevel extends AbstractLevel {
  constructor(o, a, u) {
    if (typeof o == "object" && o !== null && (a = o), typeof o == "function" || typeof a == "function" || typeof u == "function")
      throw new ModuleError("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    let { storeEncoding: c, ...p } = a || {};
    if (c = c || "buffer", !["buffer", "view", "utf8"].includes(c))
      throw new ModuleError("The storeEncoding option must be 'buffer', 'view' or 'utf8'", { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
    super({ seek: !0, permanence: !1, createIfMissing: !1, errorIfExists: !1, encodings: { [c]: !0 } }, p), this[kTree] = createRBT(compare);
  }
  _put(o, a, u, c) {
    const p = this[kTree].find(o);
    p.valid ? this[kTree] = p.update(a) : this[kTree] = this[kTree].insert(o, a), this.nextTick(c);
  }
  _get(o, a, u) {
    const c = this[kTree].get(o);
    if (c === void 0)
      return this.nextTick(u, new Error("NotFound"));
    this.nextTick(u, null, c);
  }
  _getMany(o, a, u) {
    this.nextTick(u, null, o.map((c) => this[kTree].get(c)));
  }
  _del(o, a, u) {
    this[kTree] = this[kTree].remove(o), this.nextTick(u);
  }
  _batch(o, a, u) {
    let c = this[kTree];
    for (const p of o) {
      const d = p.key, w = c.find(d);
      c = p.type === "put" ? w.valid ? w.update(p.value) : c.insert(d, p.value) : w.remove();
    }
    this[kTree] = c, this.nextTick(u);
  }
  _clear(o, a) {
    if (o.limit === -1 && !Object.keys(o).some(isRangeOption))
      return this[kTree] = createRBT(compare), this.nextTick(a);
    const u = this._keys({ ...o }), c = u.limit;
    let p = 0;
    const d = () => {
      for (let w = 0; w < 500; w++) {
        if (++p > c || !u[kIterator].valid || !u[kTest](u[kIterator].key))
          return a();
        this[kTree] = this[kTree].remove(u[kIterator].key), u[kIterator][u[kAdvance]]();
      }
      this.nextTick(d);
    };
    this.nextTick(d);
  }
  _iterator(o) {
    return new MemoryIterator(this, o);
  }
  _keys(o) {
    return new MemoryKeyIterator(this, o);
  }
  _values(o) {
    return new MemoryValueIterator(this, o);
  }
}
if (memoryLevel.MemoryLevel = MemoryLevel, typeof process < "u" && !process.browser && commonjsGlobal !== void 0 && typeof commonjsGlobal.setImmediate == "function") {
  const n = commonjsGlobal.setImmediate;
  MemoryLevel.prototype.nextTick = function(o, ...a) {
    a.length === 0 ? n(o) : n(() => o(...a));
  };
}
function isRangeOption(n) {
  return rangeOptions.has(n);
}
Object.defineProperty(LevelDbCache$1, "__esModule", { value: !0 }), LevelDbCache$1.LevelDbCache = void 0;
const level_1 = browser, memory_level_1 = memoryLevel, LoggerFactory_1$e = LoggerFactory$1;
class LevelDbCache {
  constructor(o) {
    if (this.logger = LoggerFactory_1$e.LoggerFactory.INST.create("LevelDbCache"), o.inMemory)
      this.db = new memory_level_1.MemoryLevel({ valueEncoding: "json" });
    else {
      if (!o.dbLocation)
        throw new Error("LevelDb cache configuration error - no db location specified");
      const a = o.dbLocation;
      this.logger.info(`Using location ${a}`), this.db = new level_1.Level(a, { valueEncoding: "json" });
    }
  }
  async get(o, a, u) {
    const c = this.db.sublevel(o, { valueEncoding: "json" });
    try {
      return { sortKey: a, cachedValue: await c.get(a) };
    } catch (p) {
      if (p.code == "LEVEL_NOT_FOUND")
        return null;
      throw p;
    }
  }
  async getLast(o) {
    const a = this.db.sublevel(o, { valueEncoding: "json" }), u = await a.keys({ reverse: !0, limit: 1 }).all();
    return u.length ? { sortKey: u[0], cachedValue: await a.get(u[0]) } : null;
  }
  async getLessOrEqual(o, a) {
    const u = this.db.sublevel(o, { valueEncoding: "json" }), c = await u.keys({ reverse: !0, lte: a, limit: 1 }).all();
    return c.length ? { sortKey: c[0], cachedValue: await u.get(c[0]) } : null;
  }
  async put(o, a) {
    const u = this.db.sublevel(o.contractTxId, { valueEncoding: "json" });
    await u.open(), await u.put(o.sortKey, a);
  }
  close() {
    return this.db.close();
  }
  async dump() {
    return await this.db.iterator().all();
  }
  async getLastSortKey() {
    let o = "";
    const a = await this.db.keys().all();
    for (const u of a) {
      const c = u.substring(45);
      c.localeCompare(o) > 0 && (o = c);
    }
    return o == "" ? null : o;
  }
  async allContracts() {
    const o = await this.db.keys().all(), a = /* @__PURE__ */ new Set();
    return o.forEach((u) => a.add(u.substring(1, 44))), Array.from(a);
  }
}
LevelDbCache$1.LevelDbCache = LevelDbCache;
var MemCache$1 = {};
Object.defineProperty(MemCache$1, "__esModule", { value: !0 }), MemCache$1.MemCache = void 0;
class MemCache {
  constructor() {
    this.storage = {};
  }
  clearAll() {
    Object.keys(this.storage).forEach((o) => {
      delete this.storage[o];
    });
  }
  contains(o) {
    return Object.prototype.hasOwnProperty.call(this.storage, o);
  }
  get(o) {
    return this.storage[o];
  }
  put(o, a) {
    this.storage[o] = a;
  }
  remove(o) {
    delete this.storage[o];
  }
}
MemCache$1.MemCache = MemCache;
var CacheableExecutorFactory$1 = {};
Object.defineProperty(CacheableExecutorFactory$1, "__esModule", { value: !0 }), CacheableExecutorFactory$1.CacheableExecutorFactory = void 0;
const LoggerFactory_1$d = LoggerFactory$1;
class CacheableExecutorFactory {
  constructor(o, a, u) {
    this.arweave = o, this.baseImplementation = a, this.cache = u, this.logger = LoggerFactory_1$d.LoggerFactory.INST.create("CacheableExecutorFactory");
  }
  async create(o, a) {
    return await this.baseImplementation.create(o, a);
  }
}
CacheableExecutorFactory$1.CacheableExecutorFactory = CacheableExecutorFactory;
var Evolve$1 = {}, errors = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.SmartWeaveError = n.SmartWeaveErrorType = void 0, (n.SmartWeaveErrorType || (n.SmartWeaveErrorType = {})).CONTRACT_NOT_FOUND = "CONTRACT_NOT_FOUND";
  class o extends Error {
    constructor(u, c = {}) {
      c.message ? super(c.message) : super(), this.type = u, this.otherInfo = c;
    }
    getType() {
      return this.type;
    }
  }
  n.SmartWeaveError = o;
})(errors), Object.defineProperty(Evolve$1, "__esModule", { value: !0 }), Evolve$1.Evolve = void 0;
const LoggerFactory_1$c = LoggerFactory$1, errors_1 = errors;
function isEvolveCompatible(n) {
  if (!n)
    return !1;
  const o = evalSettings(n);
  return n.evolve !== void 0 || o.has("evolve");
}
class Evolve {
  constructor() {
    this.logger = LoggerFactory_1$c.LoggerFactory.INST.create("Evolve"), this.modify = this.modify.bind(this);
  }
  async modify(o, a) {
    const { definitionLoader: u, executorFactory: c } = a.warp, p = a.contractDefinition.txId, d = Evolve.evolvedSrcTxId(o), w = a.contractDefinition.srcTxId;
    if (d && (this.logger.debug("Checking evolve:", { current: w, evolvedSrcTxId: d }), w !== d))
      try {
        this.logger.info("Evolving to: ", d);
        const S = await u.load(p, d), k = await c.create(S, a.evaluationOptions);
        return a.contractDefinition = S, a.handler = k, a.handler.initState(o), this.logger.debug("evolved to:", { evolve: d, newSrcTxId: a.contractDefinition.srcTxId, current: w, txId: a.contractDefinition.txId }), a;
      } catch {
        throw new errors_1.SmartWeaveError(errors_1.SmartWeaveErrorType.CONTRACT_NOT_FOUND, { message: `Contract having txId: ${p} not found`, requestedTxId: p });
      }
    return a;
  }
  static evolvedSrcTxId(o) {
    if (!isEvolveCompatible(o))
      return;
    const a = evalSettings(o), u = o.evolve || a.get("evolve");
    let c = o.canEvolve || a.get("canEvolve");
    return c == null && (c = !0), u && /[a-z0-9_-]{43}/i.test(u) && c ? u : void 0;
  }
}
function evalSettings(n) {
  let o = /* @__PURE__ */ new Map();
  return n.settings && (isIterable(n.settings) ? o = new Map(n.settings) : isObject$6(n.settings) && (o = new Map(Object.entries(n.settings)))), o;
}
function isIterable(n) {
  return n != null && typeof n[Symbol.iterator] == "function";
}
function isObject$6(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
Evolve$1.Evolve = Evolve;
var CacheableStateEvaluator$1 = {}, SortKeyCache = {};
Object.defineProperty(SortKeyCache, "__esModule", { value: !0 }), SortKeyCache.SortKeyCacheResult = SortKeyCache.CacheKey = void 0;
class CacheKey {
  constructor(o, a) {
    this.contractTxId = o, this.sortKey = a;
  }
}
SortKeyCache.CacheKey = CacheKey;
class SortKeyCacheResult {
  constructor(o, a) {
    this.sortKey = o, this.cachedValue = a;
  }
}
SortKeyCache.SortKeyCacheResult = SortKeyCacheResult;
var utils$n = {};
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(n, o) {
  return n === o || n != n && o != o;
}
var eq_1 = eq$2, eq$1 = eq_1;
function assocIndexOf$4(n, o) {
  for (var a = n.length; a--; )
    if (eq$1(n[a][0], o))
      return a;
  return -1;
}
var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete$1(n) {
  var o = this.__data__, a = assocIndexOf$3(o, n);
  return !(a < 0 || (a == o.length - 1 ? o.pop() : splice.call(o, a, 1), --this.size, 0));
}
var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(n) {
  var o = this.__data__, a = assocIndexOf$2(o, n);
  return a < 0 ? void 0 : o[a][1];
}
var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(n) {
  return assocIndexOf$1(this.__data__, n) > -1;
}
var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
function listCacheSet$1(n, o) {
  var a = this.__data__, u = assocIndexOf(a, n);
  return u < 0 ? (++this.size, a.push([n, o])) : a[u][1] = o, this;
}
var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(n) {
  var o = -1, a = n == null ? 0 : n.length;
  for (this.clear(); ++o < a; ) {
    var u = n[o];
    this.set(u[0], u[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear, ListCache$4.prototype.delete = listCacheDelete, ListCache$4.prototype.get = listCacheGet, ListCache$4.prototype.has = listCacheHas, ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4, ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(n) {
  var o = this.__data__, a = o.delete(n);
  return this.size = o.size, a;
}
var _stackDelete = stackDelete$1;
function stackGet$1(n) {
  return this.__data__.get(n);
}
var _stackGet = stackGet$1;
function stackHas$1(n) {
  return this.__data__.has(n);
}
var _stackHas = stackHas$1, freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$8 = freeGlobal || freeSelf || Function("return this")(), _root = root$8, root$7 = _root, Symbol$4 = root$7.Symbol, _Symbol = Symbol$4, Symbol$3 = _Symbol, objectProto$c = Object.prototype, hasOwnProperty$9 = objectProto$c.hasOwnProperty, nativeObjectToString$1 = objectProto$c.toString, symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(n) {
  var o = hasOwnProperty$9.call(n, symToStringTag$1), a = n[symToStringTag$1];
  try {
    n[symToStringTag$1] = void 0;
    var u = !0;
  } catch {
  }
  var c = nativeObjectToString$1.call(n);
  return u && (o ? n[symToStringTag$1] = a : delete n[symToStringTag$1]), c;
}
var _getRawTag = getRawTag$1, objectProto$b = Object.prototype, nativeObjectToString = objectProto$b.toString;
function objectToString$1(n) {
  return nativeObjectToString.call(n);
}
var _objectToString = objectToString$1, Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(n) {
  return n == null ? n === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(n) ? getRawTag(n) : objectToString(n);
}
var _baseGetTag = baseGetTag$4;
function isObject$5(n) {
  var o = typeof n;
  return n != null && (o == "object" || o == "function");
}
var isObject_1 = isObject$5, baseGetTag$3 = _baseGetTag, isObject$4 = isObject_1, asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(n) {
  if (!isObject$4(n))
    return !1;
  var o = baseGetTag$3(n);
  return o == funcTag$2 || o == genTag$1 || o == asyncTag || o == proxyTag;
}
var isFunction_1 = isFunction$2, root$6 = _root, coreJsData$1 = root$6["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid;
function isMasked$1(n) {
  return !!maskSrcKey && maskSrcKey in n;
}
var _isMasked = isMasked$1, funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource$2(n) {
  if (n != null) {
    try {
      return funcToString$1.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource$2, isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$3 = isObject_1, toSource$1 = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$a = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$8 = objectProto$a.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(n) {
  return !(!isObject$3(n) || isMasked(n)) && (isFunction$1(n) ? reIsNative : reIsHostCtor).test(toSource$1(n));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(n, o) {
  return n == null ? void 0 : n[o];
}
var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(n, o) {
  var a = getValue(n, o);
  return baseIsNative(a) ? a : void 0;
}
var _getNative = getNative$7, getNative$6 = _getNative, root$5 = _root, Map$4 = getNative$6(root$5, "Map"), _Map = Map$4, getNative$5 = _getNative, nativeCreate$4 = getNative$5(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(n) {
  var o = this.has(n) && delete this.__data__[n];
  return this.size -= o ? 1 : 0, o;
}
var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__", objectProto$9 = Object.prototype, hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet$1(n) {
  var o = this.__data__;
  if (nativeCreate$2) {
    var a = o[n];
    return a === HASH_UNDEFINED$1 ? void 0 : a;
  }
  return hasOwnProperty$7.call(o, n) ? o[n] : void 0;
}
var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$8 = Object.prototype, hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas$1(n) {
  var o = this.__data__;
  return nativeCreate$1 ? o[n] !== void 0 : hasOwnProperty$6.call(o, n);
}
var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(n, o) {
  var a = this.__data__;
  return this.size += this.has(n) ? 0 : 1, a[n] = nativeCreate && o === void 0 ? HASH_UNDEFINED : o, this;
}
var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(n) {
  var o = -1, a = n == null ? 0 : n.length;
  for (this.clear(); ++o < a; ) {
    var u = n[o];
    this.set(u[0], u[1]);
  }
}
Hash$1.prototype.clear = hashClear, Hash$1.prototype.delete = hashDelete, Hash$1.prototype.get = hashGet, Hash$1.prototype.has = hashHas, Hash$1.prototype.set = hashSet;
var _Hash = Hash$1, Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map$3 || ListCache$2)(), string: new Hash() };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(n) {
  var o = typeof n;
  return o == "string" || o == "number" || o == "symbol" || o == "boolean" ? n !== "__proto__" : n === null;
}
var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
function getMapData$4(n, o) {
  var a = n.__data__;
  return isKeyable(o) ? a[typeof o == "string" ? "string" : "hash"] : a.map;
}
var _getMapData = getMapData$4, getMapData$3 = _getMapData;
function mapCacheDelete$1(n) {
  var o = getMapData$3(this, n).delete(n);
  return this.size -= o ? 1 : 0, o;
}
var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
function mapCacheGet$1(n) {
  return getMapData$2(this, n).get(n);
}
var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
function mapCacheHas$1(n) {
  return getMapData$1(this, n).has(n);
}
var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
function mapCacheSet$1(n, o) {
  var a = getMapData(this, n), u = a.size;
  return a.set(n, o), this.size += a.size == u ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(n) {
  var o = -1, a = n == null ? 0 : n.length;
  for (this.clear(); ++o < a; ) {
    var u = n[o];
    this.set(u[0], u[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear, MapCache$1.prototype.delete = mapCacheDelete, MapCache$1.prototype.get = mapCacheGet, MapCache$1.prototype.has = mapCacheHas, MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1, ListCache$1 = _ListCache, Map$2 = _Map, MapCache = _MapCache, LARGE_ARRAY_SIZE = 200;
function stackSet$1(n, o) {
  var a = this.__data__;
  if (a instanceof ListCache$1) {
    var u = a.__data__;
    if (!Map$2 || u.length < LARGE_ARRAY_SIZE - 1)
      return u.push([n, o]), this.size = ++a.size, this;
    a = this.__data__ = new MapCache(u);
  }
  return a.set(n, o), this.size = a.size, this;
}
var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(n) {
  var o = this.__data__ = new ListCache(n);
  this.size = o.size;
}
Stack$1.prototype.clear = stackClear, Stack$1.prototype.delete = stackDelete, Stack$1.prototype.get = stackGet, Stack$1.prototype.has = stackHas, Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
function arrayEach$1(n, o) {
  for (var a = -1, u = n == null ? 0 : n.length; ++a < u && o(n[a], a, n) !== !1; )
    ;
  return n;
}
var _arrayEach = arrayEach$1, getNative$4 = _getNative, defineProperty$1 = function() {
  try {
    var n = getNative$4(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), _defineProperty = defineProperty$1, defineProperty = _defineProperty;
function baseAssignValue$2(n, o, a) {
  o == "__proto__" && defineProperty ? defineProperty(n, o, { configurable: !0, enumerable: !0, value: a, writable: !0 }) : n[o] = a;
}
var _baseAssignValue = baseAssignValue$2, baseAssignValue$1 = _baseAssignValue, eq = eq_1, objectProto$7 = Object.prototype, hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue$2(n, o, a) {
  var u = n[o];
  hasOwnProperty$5.call(n, o) && eq(u, a) && (a !== void 0 || o in n) || baseAssignValue$1(n, o, a);
}
var _assignValue = assignValue$2, assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(n, o, a, u) {
  var c = !a;
  a || (a = {});
  for (var p = -1, d = o.length; ++p < d; ) {
    var w = o[p], S = u ? u(a[w], n[w], w, a, n) : void 0;
    S === void 0 && (S = n[w]), c ? baseAssignValue(a, w, S) : assignValue$1(a, w, S);
  }
  return a;
}
var _copyObject = copyObject$4;
function baseTimes$1(n, o) {
  for (var a = -1, u = Array(n); ++a < n; )
    u[a] = o(a);
  return u;
}
var _baseTimes = baseTimes$1;
function isObjectLike$5(n) {
  return n != null && typeof n == "object";
}
var isObjectLike_1 = isObjectLike$5, baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1, argsTag$2 = "[object Arguments]";
function baseIsArguments$1(n) {
  return isObjectLike$4(n) && baseGetTag$2(n) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1, objectProto$6 = Object.prototype, hasOwnProperty$4 = objectProto$6.hasOwnProperty, propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable, isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(n) {
  return isObjectLike$3(n) && hasOwnProperty$4.call(n, "callee") && !propertyIsEnumerable$1.call(n, "callee");
}, isArguments_1 = isArguments$1, isArray$3 = Array.isArray, isArray_1 = isArray$3, isBuffer$2 = { exports: {} };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse;
(function(n, o) {
  var a = _root, u = stubFalse_1, c = o && !o.nodeType && o, p = c && n && !n.nodeType && n, d = p && p.exports === c ? a.Buffer : void 0, w = (d ? d.isBuffer : void 0) || u;
  n.exports = w;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(n, o) {
  var a = typeof n;
  return !!(o = o == null ? MAX_SAFE_INTEGER$1 : o) && (a == "number" || a != "symbol" && reIsUint.test(n)) && n > -1 && n % 1 == 0 && n < o;
}
var _isIndex = isIndex$1, MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2, baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
function baseIsTypedArray$1(n) {
  return isObjectLike$2(n) && isLength$1(n.length) && !!typedArrayTags[baseGetTag$1(n)];
}
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(n) {
  return function(o) {
    return n(o);
  };
}
var _baseUnary = baseUnary$3, _nodeUtil = { exports: {} };
(function(n, o) {
  var a = _freeGlobal, u = o && !o.nodeType && o, c = u && n && !n.nodeType && n, p = c && c.exports === u && a.process, d = function() {
    try {
      return c && c.require && c.require("util").types || p && p.binding && p.binding("util");
    } catch {
    }
  }();
  n.exports = d;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports, nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$1, baseTimes = _baseTimes, isArguments = isArguments_1, isArray$2 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1, objectProto$5 = Object.prototype, hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$2(n, o) {
  var a = isArray$2(n), u = !a && isArguments(n), c = !a && !u && isBuffer$1(n), p = !a && !u && !c && isTypedArray(n), d = a || u || c || p, w = d ? baseTimes(n.length, String) : [], S = w.length;
  for (var k in n)
    !o && !hasOwnProperty$3.call(n, k) || d && (k == "length" || c && (k == "offset" || k == "parent") || p && (k == "buffer" || k == "byteLength" || k == "byteOffset") || isIndex(k, S)) || w.push(k);
  return w;
}
var _arrayLikeKeys = arrayLikeKeys$2, objectProto$4 = Object.prototype;
function isPrototype$3(n) {
  var o = n && n.constructor;
  return n === (typeof o == "function" && o.prototype || objectProto$4);
}
var _isPrototype = isPrototype$3;
function overArg$2(n, o) {
  return function(a) {
    return n(o(a));
  };
}
var _overArg = overArg$2, overArg$1 = _overArg, nativeKeys$1 = overArg$1(Object.keys, Object), _nativeKeys = nativeKeys$1, isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys, objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys$1(n) {
  if (!isPrototype$2(n))
    return nativeKeys(n);
  var o = [];
  for (var a in Object(n))
    hasOwnProperty$2.call(n, a) && a != "constructor" && o.push(a);
  return o;
}
var _baseKeys = baseKeys$1, isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(n) {
  return n != null && isLength(n.length) && !isFunction(n);
}
var isArrayLike_1 = isArrayLike$2, arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$3(n) {
  return isArrayLike$1(n) ? arrayLikeKeys$1(n) : baseKeys(n);
}
var keys_1 = keys$3, copyObject$3 = _copyObject, keys$2 = keys_1;
function baseAssign$1(n, o) {
  return n && copyObject$3(o, keys$2(o), n);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(n) {
  var o = [];
  if (n != null)
    for (var a in Object(n))
      o.push(a);
  return o;
}
var _nativeKeysIn = nativeKeysIn$1, isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn, objectProto$2 = Object.prototype, hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn$1(n) {
  if (!isObject$2(n))
    return nativeKeysIn(n);
  var o = isPrototype$1(n), a = [];
  for (var u in n)
    (u != "constructor" || !o && hasOwnProperty$1.call(n, u)) && a.push(u);
  return a;
}
var _baseKeysIn = baseKeysIn$1, arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(n) {
  return isArrayLike(n) ? arrayLikeKeys(n, !0) : baseKeysIn(n);
}
var keysIn_1 = keysIn$3, copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(n, o) {
  return n && copyObject$2(o, keysIn$2(o), n);
}
var _baseAssignIn = baseAssignIn$1, _cloneBuffer = { exports: {} };
function copyArray$1(n, o) {
  var a = -1, u = n.length;
  for (o || (o = Array(u)); ++a < u; )
    o[a] = n[a];
  return o;
}
(function(n, o) {
  var a = _root, u = o && !o.nodeType && o, c = u && n && !n.nodeType && n, p = c && c.exports === u ? a.Buffer : void 0, d = p ? p.allocUnsafe : void 0;
  n.exports = function(w, S) {
    if (S)
      return w.slice();
    var k = w.length, B = d ? d(k) : new w.constructor(k);
    return w.copy(B), B;
  };
})(_cloneBuffer, _cloneBuffer.exports);
var _copyArray = copyArray$1;
function arrayFilter$1(n, o) {
  for (var a = -1, u = n == null ? 0 : n.length, c = 0, p = []; ++a < u; ) {
    var d = n[a];
    o(d, a, n) && (p[c++] = d);
  }
  return p;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2, arrayFilter = _arrayFilter, stubArray$1 = stubArray_1, objectProto$1 = Object.prototype, propertyIsEnumerable = objectProto$1.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols$3 = nativeGetSymbols$1 ? function(n) {
  return n == null ? [] : (n = Object(n), arrayFilter(nativeGetSymbols$1(n), function(o) {
    return propertyIsEnumerable.call(n, o);
  }));
} : stubArray$1, _getSymbols = getSymbols$3, copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(n, o) {
  return copyObject$1(n, getSymbols$2(n), o);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(n, o) {
  for (var a = -1, u = o.length, c = n.length; ++a < u; )
    n[c + a] = o[a];
  return n;
}
var _arrayPush = arrayPush$2, overArg = _overArg, getPrototype$2 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$2, arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn$2 = nativeGetSymbols ? function(n) {
  for (var o = []; n; )
    arrayPush$1(o, getSymbols$1(n)), n = getPrototype$1(n);
  return o;
} : stubArray, _getSymbolsIn = getSymbolsIn$2, copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(n, o) {
  return copyObject(n, getSymbolsIn$1(n), o);
}
var _copySymbolsIn = copySymbolsIn$1, arrayPush = _arrayPush, isArray$1 = isArray_1;
function baseGetAllKeys$2(n, o, a) {
  var u = o(n);
  return isArray$1(n) ? u : arrayPush(u, a(n));
}
var _baseGetAllKeys = baseGetAllKeys$2, baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(n) {
  return baseGetAllKeys$1(n, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1, baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(n) {
  return baseGetAllKeys(n, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1, getNative$3 = _getNative, root$4 = _root, DataView$2 = getNative$3(root$4, "DataView"), _DataView = DataView$2, getNative$2 = _getNative, root$3 = _root, Promise$2 = getNative$2(root$3, "Promise"), _Promise = Promise$2, getNative$1 = _getNative, root$2 = _root, Set$2 = getNative$1(root$2, "Set"), _Set = Set$2, getNative = _getNative, root$1 = _root, WeakMap$2 = getNative(root$1, "WeakMap"), _WeakMap = WeakMap$2, DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource, mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$2 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag$3 = baseGetTag;
(DataView$1 && getTag$3(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) && (getTag$3 = function(n) {
  var o = baseGetTag(n), a = o == objectTag$1 ? n.constructor : void 0, u = a ? toSource(a) : "";
  if (u)
    switch (u) {
      case dataViewCtorString:
        return dataViewTag$2;
      case mapCtorString:
        return mapTag$3;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$3;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return o;
});
var _getTag = getTag$3, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(n) {
  var o = n.length, a = new n.constructor(o);
  return o && typeof n[0] == "string" && hasOwnProperty.call(n, "index") && (a.index = n.index, a.input = n.input), a;
}
var _initCloneArray = initCloneArray$1, root = _root, Uint8Array$2 = root.Uint8Array, _Uint8Array = Uint8Array$2, Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(n) {
  var o = new n.constructor(n.byteLength);
  return new Uint8Array$1(o).set(new Uint8Array$1(n)), o;
}
var _cloneArrayBuffer = cloneArrayBuffer$3, cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(n, o) {
  var a = o ? cloneArrayBuffer$2(n.buffer) : n.buffer;
  return new n.constructor(a, n.byteOffset, n.byteLength);
}
var _cloneDataView = cloneDataView$1, reFlags = /\w*$/;
function cloneRegExp$1(n) {
  var o = new n.constructor(n.source, reFlags.exec(n));
  return o.lastIndex = n.lastIndex, o;
}
var _cloneRegExp = cloneRegExp$1, Symbol$1 = _Symbol, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(n) {
  return symbolValueOf ? Object(symbolValueOf.call(n)) : {};
}
var _cloneSymbol = cloneSymbol$1, cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(n, o) {
  var a = o ? cloneArrayBuffer$1(n.buffer) : n.buffer;
  return new n.constructor(a, n.byteOffset, n.length);
}
var _cloneTypedArray = cloneTypedArray$1, cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(n, o, a) {
  var u = n.constructor;
  switch (o) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(n);
    case boolTag$1:
    case dateTag$1:
      return new u(+n);
    case dataViewTag$1:
      return cloneDataView(n, a);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(n, a);
    case mapTag$2:
      return new u();
    case numberTag$1:
    case stringTag$1:
      return new u(n);
    case regexpTag$1:
      return cloneRegExp(n);
    case setTag$2:
      return new u();
    case symbolTag$1:
      return cloneSymbol(n);
  }
}
var _initCloneByTag = initCloneByTag$1, isObject$1 = isObject_1, objectCreate = Object.create, baseCreate$1 = function() {
  function n() {
  }
  return function(o) {
    if (!isObject$1(o))
      return {};
    if (objectCreate)
      return objectCreate(o);
    n.prototype = o;
    var a = new n();
    return n.prototype = void 0, a;
  };
}(), _baseCreate = baseCreate$1, baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(n) {
  return typeof n.constructor != "function" || isPrototype(n) ? {} : baseCreate(getPrototype(n));
}
var _initCloneObject = initCloneObject$1, getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1, mapTag$1 = "[object Map]";
function baseIsMap$1(n) {
  return isObjectLike$1(n) && getTag$2(n) == mapTag$1;
}
var _baseIsMap = baseIsMap$1, baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports, nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap, isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap, isMap_1 = isMap$1, getTag$1 = _getTag, isObjectLike = isObjectLike_1, setTag$1 = "[object Set]";
function baseIsSet$1(n) {
  return isObjectLike(n) && getTag$1(n) == setTag$1;
}
var _baseIsSet = baseIsSet$1, baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports, nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isSet_1 = isSet$1, Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBuffer$2.exports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1, CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
function baseClone$1(n, o, a, u, c, p) {
  var d, w = o & CLONE_DEEP_FLAG$1, S = o & CLONE_FLAT_FLAG, k = o & CLONE_SYMBOLS_FLAG$1;
  if (a && (d = c ? a(n, u, c, p) : a(n)), d !== void 0)
    return d;
  if (!isObject(n))
    return n;
  var B = isArray(n);
  if (B) {
    if (d = initCloneArray(n), !w)
      return copyArray(n, d);
  } else {
    var I = getTag(n), C = I == funcTag || I == genTag;
    if (isBuffer(n))
      return cloneBuffer(n, w);
    if (I == objectTag || I == argsTag || C && !c) {
      if (d = S || C ? {} : initCloneObject(n), !w)
        return S ? copySymbolsIn(n, baseAssignIn(d, n)) : copySymbols(n, baseAssign(d, n));
    } else {
      if (!cloneableTags[I])
        return c ? n : {};
      d = initCloneByTag(n, I, w);
    }
  }
  p || (p = new Stack());
  var P = p.get(n);
  if (P)
    return P;
  p.set(n, d), isSet(n) ? n.forEach(function(D) {
    d.add(baseClone$1(D, o, a, D, n, p));
  }) : isMap(n) && n.forEach(function(D, z) {
    d.set(z, baseClone$1(D, o, a, z, n, p));
  });
  var q = B ? void 0 : (k ? S ? getAllKeysIn : getAllKeys : S ? keysIn : keys)(n);
  return arrayEach(q || n, function(D, z) {
    q && (D = n[z = D]), assignValue(d, z, baseClone$1(D, o, a, z, n, p));
  }), d;
}
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
var _baseClone = baseClone$1, baseClone = _baseClone, CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(n) {
  return baseClone(n, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1$1 = cloneDeep, fastCopy = { exports: {} };
fastCopy.exports = function() {
  var n = Function.prototype.toString, o = Object.create, a = Object.defineProperty, u = Object.getOwnPropertyDescriptor, c = Object.getOwnPropertyNames, p = Object.getOwnPropertySymbols, d = Object.getPrototypeOf, w = Object.prototype, S = w.hasOwnProperty, k = w.propertyIsEnumerable, B = typeof p == "function", I = typeof WeakMap == "function", C = function() {
    if (I)
      return function() {
        return /* @__PURE__ */ new WeakMap();
      };
    var N = function() {
      function W() {
        this._keys = [], this._values = [];
      }
      return W.prototype.has = function(H) {
        return !!~this._keys.indexOf(H);
      }, W.prototype.get = function(H) {
        return this._values[this._keys.indexOf(H)];
      }, W.prototype.set = function(H, te) {
        this._keys.push(H), this._values.push(te);
      }, W;
    }();
    return function() {
      return new N();
    };
  }(), P = function(N, W) {
    var H = N.__proto__ || d(N);
    if (!H)
      return o(null);
    var te = H.constructor;
    if (te === W.Object)
      return H === W.Object.prototype ? {} : o(H);
    if (~n.call(te).indexOf("[native code]"))
      try {
        return new te();
      } catch {
      }
    return o(H);
  }, q = function(N, W, H, te) {
    var g = P(N, W);
    for (var $ in te.set(N, g), N)
      S.call(N, $) && (g[$] = H(N[$], te));
    if (B)
      for (var _ = p(N), b = 0, m = _.length, v = void 0; b < m; ++b)
        v = _[b], k.call(N, v) && (g[v] = H(N[v], te));
    return g;
  }, D = function(N, W, H, te) {
    var g = P(N, W);
    te.set(N, g);
    for (var $ = B ? c(N).concat(p(N)) : c(N), _ = 0, b = $.length, m = void 0, v = void 0; _ < b; ++_)
      if ((m = $[_]) !== "callee" && m !== "caller")
        if (v = u(N, m)) {
          v.get || v.set || (v.value = H(N[m], te));
          try {
            a(g, m, v);
          } catch {
            g[m] = v.value;
          }
        } else
          g[m] = H(N[m], te);
    return g;
  }, z = Array.isArray, F = Object.getPrototypeOf, V = function() {
    return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal !== void 0 ? commonjsGlobal : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
  }();
  function Z(N, W) {
    var H = !(!W || !W.isStrict), te = W && W.realm || V, g = H ? D : q, $ = function(_, b) {
      if (!_ || typeof _ != "object")
        return _;
      if (b.has(_))
        return b.get(_);
      var m, v = _.__proto__ || F(_), E = v && v.constructor;
      if (!E || E === te.Object)
        return g(_, te, $, b);
      if (z(_)) {
        if (H)
          return D(_, te, $, b);
        m = new E(), b.set(_, m);
        for (var T = 0, j = _.length; T < j; ++T)
          m[T] = $(_[T], b);
        return m;
      }
      if (_ instanceof te.Date)
        return new E(_.getTime());
      if (_ instanceof te.RegExp)
        return (m = new E(_.source, _.flags || function(L) {
          var J = "";
          return L.global && (J += "g"), L.ignoreCase && (J += "i"), L.multiline && (J += "m"), L.unicode && (J += "u"), L.sticky && (J += "y"), J;
        }(_))).lastIndex = _.lastIndex, m;
      if (te.Map && _ instanceof te.Map)
        return m = new E(), b.set(_, m), _.forEach(function(L, J) {
          m.set(J, $(L, b));
        }), m;
      if (te.Set && _ instanceof te.Set)
        return m = new E(), b.set(_, m), _.forEach(function(L) {
          m.add($(L, b));
        }), m;
      if (te.Blob && _ instanceof te.Blob)
        return _.slice(0, _.size, _.type);
      if (te.Buffer && te.Buffer.isBuffer(_))
        return m = te.Buffer.allocUnsafe ? te.Buffer.allocUnsafe(_.length) : new E(_.length), b.set(_, m), _.copy(m), m;
      if (te.ArrayBuffer) {
        if (te.ArrayBuffer.isView(_))
          return m = new E(_.buffer.slice(0)), b.set(_, m), m;
        if (_ instanceof te.ArrayBuffer)
          return m = _.slice(0), b.set(_, m), m;
      }
      return typeof _.then == "function" || _ instanceof Error || te.WeakMap && _ instanceof te.WeakMap || te.WeakSet && _ instanceof te.WeakSet ? _ : g(_, te, $, b);
    };
    return $(N, C());
  }
  return Z.default = Z, Z.strict = function(N, W) {
    return Z(N, { isStrict: !0, realm: W ? W.realm : void 0 });
  }, Z;
}();
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(utils$n, "__esModule", { value: !0 }), utils$n.isomorphicRandomUUID = utils$n.bufToBn = utils$n.indent = utils$n.stripTrailingSlash = utils$n.timeout = utils$n.descS = utils$n.desc = utils$n.ascS = utils$n.asc = utils$n.mapReviver = utils$n.mapReplacer = utils$n.deepCopy = utils$n.sleep = void 0;
const cloneDeep_1 = __importDefault$6(cloneDeep_1$1), fast_copy_1 = __importDefault$6(fastCopy.exports), crypto_1 = require$$2$1, sleep = (n) => new Promise((o) => setTimeout(o, n));
utils$n.sleep = sleep;
const deepCopy = (n, o = !1) => o ? (0, fast_copy_1.default)(n) : (0, cloneDeep_1.default)(n);
utils$n.deepCopy = deepCopy;
const mapReplacer = (n, o) => o instanceof Map ? { dataType: "Map", value: Array.from(o.entries()) } : o;
utils$n.mapReplacer = mapReplacer;
const mapReviver = (n, o) => typeof o == "object" && o !== null && o.dataType === "Map" ? new Map(o.value) : o;
utils$n.mapReviver = mapReviver;
const asc = (n, o) => n - o;
utils$n.asc = asc;
const ascS = (n, o) => +n - +o;
utils$n.ascS = ascS;
const desc = (n, o) => o - n;
utils$n.desc = desc;
const descS = (n, o) => +o - +n;
function timeout(n) {
  let o = null;
  const a = new Promise((u, c) => {
    o = setTimeout(() => {
      clearTimeout(o), c("timeout");
    }, 1e3 * n);
  });
  return { timeoutId: o, timeoutPromise: a };
}
function stripTrailingSlash(n) {
  return n.endsWith("/") ? n.slice(0, -1) : n;
}
function indent(n) {
  return "".padEnd(2 * n, " ");
}
function bufToBn(n) {
  const o = [];
  return Uint8Array.from(n).forEach(function(a) {
    let u = a.toString(16);
    u.length % 2 && (u = "0" + u), o.push(u);
  }), BigInt("0x" + o.join(""));
}
function isomorphicRandomUUID() {
  return isBrowser() && self.crypto ? self.crypto.randomUUID() : (0, crypto_1.randomUUID)();
}
utils$n.descS = descS, utils$n.timeout = timeout, utils$n.stripTrailingSlash = stripTrailingSlash, utils$n.indent = indent, utils$n.bufToBn = bufToBn, utils$n.isomorphicRandomUUID = isomorphicRandomUUID;
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
var DefaultStateEvaluator$1 = {}, elliptic$1 = {};
const name = "elliptic", version = "6.5.4", description = "EC cryptography", main = "lib/elliptic.js", files = ["lib"], scripts = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository = { type: "git", url: "git@github.com:indutny/elliptic" }, keywords = ["EC", "Elliptic", "curve", "Cryptography"], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = { url: "https://github.com/indutny/elliptic/issues" }, homepage = "https://github.com/indutny/elliptic", devDependencies = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" }, require$$0$2 = { name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies };
var utils$m = {}, bn$2 = { exports: {} };
(function(n, o) {
  function a(g, $) {
    if (!g)
      throw new Error($ || "Assertion failed");
  }
  function u(g, $) {
    g.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, g.prototype = new _(), g.prototype.constructor = g;
  }
  function c(g, $, _) {
    if (c.isBN(g))
      return g;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, g !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(g || 0, $ || 10, _ || "be"));
  }
  var p;
  typeof bn$2 == "object" ? bn$2.exports = c : o.BN = c, c.BN = c, c.wordSize = 26;
  try {
    p = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(g, $) {
    var _ = g.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(g, $, _) {
    var b = d(g, _);
    return _ - 1 >= $ && (b |= d(g, _ - 1) << 4), b;
  }
  function S(g, $, _, b) {
    for (var m = 0, v = Math.min(g.length, _), E = $; E < v; E++) {
      var T = g.charCodeAt(E) - 48;
      m *= b, m += T >= 49 ? T - 49 + 10 : T >= 17 ? T - 17 + 10 : T;
    }
    return m;
  }
  c.isBN = function(g) {
    return g instanceof c || g !== null && typeof g == "object" && g.constructor.wordSize === c.wordSize && Array.isArray(g.words);
  }, c.max = function(g, $) {
    return g.cmp($) > 0 ? g : $;
  }, c.min = function(g, $) {
    return g.cmp($) < 0 ? g : $;
  }, c.prototype._init = function(g, $, _) {
    if (typeof g == "number")
      return this._initNumber(g, $, _);
    if (typeof g == "object")
      return this._initArray(g, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var b = 0;
    (g = g.toString().replace(/\s+/g, ""))[0] === "-" && (b++, this.negative = 1), b < g.length && ($ === 16 ? this._parseHex(g, b, _) : (this._parseBase(g, $, b), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(g, $, _) {
    g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [67108863 & g], this.length = 1) : g < 4503599627370496 ? (this.words = [67108863 & g, g / 67108864 & 67108863], this.length = 2) : (a(g < 9007199254740992), this.words = [67108863 & g, g / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(g, $, _) {
    if (a(typeof g.length == "number"), g.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v, E = 0;
    if (_ === "be")
      for (b = g.length - 1, m = 0; b >= 0; b -= 3)
        v = g[b] | g[b - 1] << 8 | g[b - 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    else if (_ === "le")
      for (b = 0, m = 0; b < g.length; b += 3)
        v = g[b] | g[b + 1] << 8 | g[b + 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    return this.strip();
  }, c.prototype._parseHex = function(g, $, _) {
    this.length = Math.ceil((g.length - $) / 6), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v = 0, E = 0;
    if (_ === "be")
      for (b = g.length - 1; b >= $; b -= 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    else
      for (b = (g.length - $) % 2 == 0 ? $ + 1 : $; b < g.length; b += 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(g, $, _) {
    this.words = [0], this.length = 1;
    for (var b = 0, m = 1; m <= 67108863; m *= $)
      b++;
    b--, m = m / $ | 0;
    for (var v = g.length - _, E = v % b, T = Math.min(v, v - E) + _, j = 0, L = _; L < T; L += b)
      j = S(g, L, L + b, $), this.imuln(m), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    if (E !== 0) {
      var J = 1;
      for (j = S(g, L, g.length, $), L = 0; L < E; L++)
        J *= $;
      this.imuln(J), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    }
    this.strip();
  }, c.prototype.copy = function(g) {
    g.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      g.words[$] = this.words[$];
    g.length = this.length, g.negative = this.negative, g.red = this.red;
  }, c.prototype.clone = function() {
    var g = new c(null);
    return this.copy(g), g;
  }, c.prototype._expand = function(g) {
    for (; this.length < g; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var k = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(g, $, _) {
    _.negative = $.negative ^ g.negative;
    var b = g.length + $.length | 0;
    _.length = b, b = b - 1 | 0;
    var m = 0 | g.words[0], v = 0 | $.words[0], E = m * v, T = 67108863 & E, j = E / 67108864 | 0;
    _.words[0] = T;
    for (var L = 1; L < b; L++) {
      for (var J = j >>> 26, Y = 67108863 & j, ne = Math.min(L, $.length - 1), Q = Math.max(0, L - g.length + 1); Q <= ne; Q++) {
        var oe = L - Q | 0;
        J += (E = (m = 0 | g.words[oe]) * (v = 0 | $.words[Q]) + Y) / 67108864 | 0, Y = 67108863 & E;
      }
      _.words[L] = 0 | Y, j = 0 | J;
    }
    return j !== 0 ? _.words[L] = 0 | j : _.length--, _.strip();
  }
  c.prototype.toString = function(g, $) {
    var _;
    if ($ = 0 | $ || 1, (g = g || 10) === 16 || g === "hex") {
      _ = "";
      for (var b = 0, m = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], T = (16777215 & (E << b | m)).toString(16);
        _ = (m = E >>> 24 - b & 16777215) != 0 || v !== this.length - 1 ? k[6 - T.length] + T + _ : T + _, (b += 2) >= 26 && (b -= 26, v--);
      }
      for (m !== 0 && (_ = m.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (g === (0 | g) && g >= 2 && g <= 36) {
      var j = B[g], L = I[g];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var Y = J.modn(L).toString(g);
        _ = (J = J.idivn(L)).isZero() ? Y + _ : k[j - Y.length] + Y + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var g = this.words[0];
    return this.length === 2 ? g += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(g, $) {
    return a(p !== void 0), this.toArrayLike(p, g, $);
  }, c.prototype.toArray = function(g, $) {
    return this.toArrayLike(Array, g, $);
  }, c.prototype.toArrayLike = function(g, $, _) {
    var b = this.byteLength(), m = _ || Math.max(1, b);
    a(b <= m, "byte array longer than desired length"), a(m > 0, "Requested array length <= 0"), this.strip();
    var v, E, T = $ === "le", j = new g(m), L = this.clone();
    if (T) {
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[E] = v;
      for (; E < m; E++)
        j[E] = 0;
    } else {
      for (E = 0; E < m - b; E++)
        j[E] = 0;
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[m - E - 1] = v;
    }
    return j;
  }, Math.clz32 ? c.prototype._countBits = function(g) {
    return 32 - Math.clz32(g);
  } : c.prototype._countBits = function(g) {
    var $ = g, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(g) {
    if (g === 0)
      return 26;
    var $ = g, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var g = this.words[this.length - 1], $ = this._countBits(g);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var g = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (g += _, _ !== 26)
        break;
    }
    return g;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(g) {
    return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(g) {
    return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(g) {
    for (; this.length < g.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < g.length; $++)
      this.words[$] = this.words[$] | g.words[$];
    return this.strip();
  }, c.prototype.ior = function(g) {
    return a((this.negative | g.negative) == 0), this.iuor(g);
  }, c.prototype.or = function(g) {
    return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
  }, c.prototype.uor = function(g) {
    return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
  }, c.prototype.iuand = function(g) {
    var $;
    $ = this.length > g.length ? g : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & g.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(g) {
    return a((this.negative | g.negative) == 0), this.iuand(g);
  }, c.prototype.and = function(g) {
    return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
  }, c.prototype.uand = function(g) {
    return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
  }, c.prototype.iuxor = function(g) {
    var $, _;
    this.length > g.length ? ($ = this, _ = g) : ($ = g, _ = this);
    for (var b = 0; b < _.length; b++)
      this.words[b] = $.words[b] ^ _.words[b];
    if (this !== $)
      for (; b < $.length; b++)
        this.words[b] = $.words[b];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(g) {
    return a((this.negative | g.negative) == 0), this.iuxor(g);
  }, c.prototype.xor = function(g) {
    return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
  }, c.prototype.uxor = function(g) {
    return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
  }, c.prototype.inotn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = 0 | Math.ceil(g / 26), _ = g % 26;
    this._expand($), _ > 0 && $--;
    for (var b = 0; b < $; b++)
      this.words[b] = 67108863 & ~this.words[b];
    return _ > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(g) {
    return this.clone().inotn(g);
  }, c.prototype.setn = function(g, $) {
    a(typeof g == "number" && g >= 0);
    var _ = g / 26 | 0, b = g % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << b : this.words[_] & ~(1 << b), this.strip();
  }, c.prototype.iadd = function(g) {
    var $, _, b;
    if (this.negative !== 0 && g.negative === 0)
      return this.negative = 0, $ = this.isub(g), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && g.negative !== 0)
      return g.negative = 0, $ = this.isub(g), g.negative = 1, $._normSign();
    this.length > g.length ? (_ = this, b = g) : (_ = g, b = this);
    for (var m = 0, v = 0; v < b.length; v++)
      $ = (0 | _.words[v]) + (0 | b.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    for (; m !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    if (this.length = _.length, m !== 0)
      this.words[this.length] = m, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(g) {
    var $;
    return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, $ = this.sub(g), g.negative ^= 1, $) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = g.sub(this), this.negative = 1, $) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
  }, c.prototype.isub = function(g) {
    if (g.negative !== 0) {
      g.negative = 0;
      var $ = this.iadd(g);
      return g.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
    var _, b, m = this.cmp(g);
    if (m === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    m > 0 ? (_ = this, b = g) : (_ = g, b = this);
    for (var v = 0, E = 0; E < b.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | b.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(g) {
    return this.clone().isub(g);
  };
  var P = function(g, $, _) {
    var b, m, v, E = g.words, T = $.words, j = _.words, L = 0, J = 0 | E[0], Y = 8191 & J, ne = J >>> 13, Q = 0 | E[1], oe = 8191 & Q, ae = Q >>> 13, ce = 0 | E[2], ue = 8191 & ce, le = ce >>> 13, Se = 0 | E[3], he = 8191 & Se, _e = Se >>> 13, Le = 0 | E[4], se = 8191 & Le, we = Le >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, y = l >>> 13, A = 0 | E[7], M = 8191 & A, x = A >>> 13, O = 0 | E[8], G = 8191 & O, X = O >>> 13, ie = 0 | E[9], ee = 8191 & ie, re = ie >>> 13, ye = 0 | T[0], fe = 8191 & ye, pe = ye >>> 13, Re = 0 | T[1], me = 8191 & Re, Ee = Re >>> 13, Ce = 0 | T[2], ge = 8191 & Ce, Ae = Ce >>> 13, Fe = 0 | T[3], $e = 8191 & Fe, Me = Fe >>> 13, qe = 0 | T[4], ve = 8191 & qe, Oe = qe >>> 13, He = 0 | T[5], be = 8191 & He, Pe = He >>> 13, ze = 0 | T[6], Te = 8191 & ze, Ne = ze >>> 13, Ve = 0 | T[7], xe = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | T[8], Be = 8191 & Je, je = Je >>> 13, Xe = 0 | T[9], Ie = 8191 & Xe, De = Xe >>> 13;
    _.negative = g.negative ^ $.negative, _.length = 19;
    var Ge = (L + (b = Math.imul(Y, fe)) | 0) + ((8191 & (m = (m = Math.imul(Y, pe)) + Math.imul(ne, fe) | 0)) << 13) | 0;
    L = ((v = Math.imul(ne, pe)) + (m >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, b = Math.imul(oe, fe), m = (m = Math.imul(oe, pe)) + Math.imul(ae, fe) | 0, v = Math.imul(ae, pe);
    var Ke = (L + (b = b + Math.imul(Y, me) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ee) | 0) + Math.imul(ne, me) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ee) | 0) + (m >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, b = Math.imul(ue, fe), m = (m = Math.imul(ue, pe)) + Math.imul(le, fe) | 0, v = Math.imul(le, pe), b = b + Math.imul(oe, me) | 0, m = (m = m + Math.imul(oe, Ee) | 0) + Math.imul(ae, me) | 0, v = v + Math.imul(ae, Ee) | 0;
    var Ye = (L + (b = b + Math.imul(Y, ge) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ae) | 0) + Math.imul(ne, ge) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ae) | 0) + (m >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, b = Math.imul(he, fe), m = (m = Math.imul(he, pe)) + Math.imul(_e, fe) | 0, v = Math.imul(_e, pe), b = b + Math.imul(ue, me) | 0, m = (m = m + Math.imul(ue, Ee) | 0) + Math.imul(le, me) | 0, v = v + Math.imul(le, Ee) | 0, b = b + Math.imul(oe, ge) | 0, m = (m = m + Math.imul(oe, Ae) | 0) + Math.imul(ae, ge) | 0, v = v + Math.imul(ae, Ae) | 0;
    var Ze = (L + (b = b + Math.imul(Y, $e) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Me) | 0) + Math.imul(ne, $e) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Me) | 0) + (m >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, b = Math.imul(se, fe), m = (m = Math.imul(se, pe)) + Math.imul(we, fe) | 0, v = Math.imul(we, pe), b = b + Math.imul(he, me) | 0, m = (m = m + Math.imul(he, Ee) | 0) + Math.imul(_e, me) | 0, v = v + Math.imul(_e, Ee) | 0, b = b + Math.imul(ue, ge) | 0, m = (m = m + Math.imul(ue, Ae) | 0) + Math.imul(le, ge) | 0, v = v + Math.imul(le, Ae) | 0, b = b + Math.imul(oe, $e) | 0, m = (m = m + Math.imul(oe, Me) | 0) + Math.imul(ae, $e) | 0, v = v + Math.imul(ae, Me) | 0;
    var Qe = (L + (b = b + Math.imul(Y, ve) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Oe) | 0) + Math.imul(ne, ve) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Oe) | 0) + (m >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, b = Math.imul(de, fe), m = (m = Math.imul(de, pe)) + Math.imul(ke, fe) | 0, v = Math.imul(ke, pe), b = b + Math.imul(se, me) | 0, m = (m = m + Math.imul(se, Ee) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ee) | 0, b = b + Math.imul(he, ge) | 0, m = (m = m + Math.imul(he, Ae) | 0) + Math.imul(_e, ge) | 0, v = v + Math.imul(_e, Ae) | 0, b = b + Math.imul(ue, $e) | 0, m = (m = m + Math.imul(ue, Me) | 0) + Math.imul(le, $e) | 0, v = v + Math.imul(le, Me) | 0, b = b + Math.imul(oe, ve) | 0, m = (m = m + Math.imul(oe, Oe) | 0) + Math.imul(ae, ve) | 0, v = v + Math.imul(ae, Oe) | 0;
    var et = (L + (b = b + Math.imul(Y, be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Pe) | 0) + Math.imul(ne, be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Pe) | 0) + (m >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, b = Math.imul(h, fe), m = (m = Math.imul(h, pe)) + Math.imul(y, fe) | 0, v = Math.imul(y, pe), b = b + Math.imul(de, me) | 0, m = (m = m + Math.imul(de, Ee) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ee) | 0, b = b + Math.imul(se, ge) | 0, m = (m = m + Math.imul(se, Ae) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, Ae) | 0, b = b + Math.imul(he, $e) | 0, m = (m = m + Math.imul(he, Me) | 0) + Math.imul(_e, $e) | 0, v = v + Math.imul(_e, Me) | 0, b = b + Math.imul(ue, ve) | 0, m = (m = m + Math.imul(ue, Oe) | 0) + Math.imul(le, ve) | 0, v = v + Math.imul(le, Oe) | 0, b = b + Math.imul(oe, be) | 0, m = (m = m + Math.imul(oe, Pe) | 0) + Math.imul(ae, be) | 0, v = v + Math.imul(ae, Pe) | 0;
    var tt = (L + (b = b + Math.imul(Y, Te) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ne) | 0) + Math.imul(ne, Te) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ne) | 0) + (m >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, b = Math.imul(M, fe), m = (m = Math.imul(M, pe)) + Math.imul(x, fe) | 0, v = Math.imul(x, pe), b = b + Math.imul(h, me) | 0, m = (m = m + Math.imul(h, Ee) | 0) + Math.imul(y, me) | 0, v = v + Math.imul(y, Ee) | 0, b = b + Math.imul(de, ge) | 0, m = (m = m + Math.imul(de, Ae) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, Ae) | 0, b = b + Math.imul(se, $e) | 0, m = (m = m + Math.imul(se, Me) | 0) + Math.imul(we, $e) | 0, v = v + Math.imul(we, Me) | 0, b = b + Math.imul(he, ve) | 0, m = (m = m + Math.imul(he, Oe) | 0) + Math.imul(_e, ve) | 0, v = v + Math.imul(_e, Oe) | 0, b = b + Math.imul(ue, be) | 0, m = (m = m + Math.imul(ue, Pe) | 0) + Math.imul(le, be) | 0, v = v + Math.imul(le, Pe) | 0, b = b + Math.imul(oe, Te) | 0, m = (m = m + Math.imul(oe, Ne) | 0) + Math.imul(ae, Te) | 0, v = v + Math.imul(ae, Ne) | 0;
    var rt = (L + (b = b + Math.imul(Y, xe) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ue) | 0) + Math.imul(ne, xe) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ue) | 0) + (m >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, b = Math.imul(G, fe), m = (m = Math.imul(G, pe)) + Math.imul(X, fe) | 0, v = Math.imul(X, pe), b = b + Math.imul(M, me) | 0, m = (m = m + Math.imul(M, Ee) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ee) | 0, b = b + Math.imul(h, ge) | 0, m = (m = m + Math.imul(h, Ae) | 0) + Math.imul(y, ge) | 0, v = v + Math.imul(y, Ae) | 0, b = b + Math.imul(de, $e) | 0, m = (m = m + Math.imul(de, Me) | 0) + Math.imul(ke, $e) | 0, v = v + Math.imul(ke, Me) | 0, b = b + Math.imul(se, ve) | 0, m = (m = m + Math.imul(se, Oe) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Oe) | 0, b = b + Math.imul(he, be) | 0, m = (m = m + Math.imul(he, Pe) | 0) + Math.imul(_e, be) | 0, v = v + Math.imul(_e, Pe) | 0, b = b + Math.imul(ue, Te) | 0, m = (m = m + Math.imul(ue, Ne) | 0) + Math.imul(le, Te) | 0, v = v + Math.imul(le, Ne) | 0, b = b + Math.imul(oe, xe) | 0, m = (m = m + Math.imul(oe, Ue) | 0) + Math.imul(ae, xe) | 0, v = v + Math.imul(ae, Ue) | 0;
    var nt = (L + (b = b + Math.imul(Y, Be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, je) | 0) + Math.imul(ne, Be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, je) | 0) + (m >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, b = Math.imul(ee, fe), m = (m = Math.imul(ee, pe)) + Math.imul(re, fe) | 0, v = Math.imul(re, pe), b = b + Math.imul(G, me) | 0, m = (m = m + Math.imul(G, Ee) | 0) + Math.imul(X, me) | 0, v = v + Math.imul(X, Ee) | 0, b = b + Math.imul(M, ge) | 0, m = (m = m + Math.imul(M, Ae) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, Ae) | 0, b = b + Math.imul(h, $e) | 0, m = (m = m + Math.imul(h, Me) | 0) + Math.imul(y, $e) | 0, v = v + Math.imul(y, Me) | 0, b = b + Math.imul(de, ve) | 0, m = (m = m + Math.imul(de, Oe) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Oe) | 0, b = b + Math.imul(se, be) | 0, m = (m = m + Math.imul(se, Pe) | 0) + Math.imul(we, be) | 0, v = v + Math.imul(we, Pe) | 0, b = b + Math.imul(he, Te) | 0, m = (m = m + Math.imul(he, Ne) | 0) + Math.imul(_e, Te) | 0, v = v + Math.imul(_e, Ne) | 0, b = b + Math.imul(ue, xe) | 0, m = (m = m + Math.imul(ue, Ue) | 0) + Math.imul(le, xe) | 0, v = v + Math.imul(le, Ue) | 0, b = b + Math.imul(oe, Be) | 0, m = (m = m + Math.imul(oe, je) | 0) + Math.imul(ae, Be) | 0, v = v + Math.imul(ae, je) | 0;
    var it = (L + (b = b + Math.imul(Y, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, De) | 0) + Math.imul(ne, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, De) | 0) + (m >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, b = Math.imul(ee, me), m = (m = Math.imul(ee, Ee)) + Math.imul(re, me) | 0, v = Math.imul(re, Ee), b = b + Math.imul(G, ge) | 0, m = (m = m + Math.imul(G, Ae) | 0) + Math.imul(X, ge) | 0, v = v + Math.imul(X, Ae) | 0, b = b + Math.imul(M, $e) | 0, m = (m = m + Math.imul(M, Me) | 0) + Math.imul(x, $e) | 0, v = v + Math.imul(x, Me) | 0, b = b + Math.imul(h, ve) | 0, m = (m = m + Math.imul(h, Oe) | 0) + Math.imul(y, ve) | 0, v = v + Math.imul(y, Oe) | 0, b = b + Math.imul(de, be) | 0, m = (m = m + Math.imul(de, Pe) | 0) + Math.imul(ke, be) | 0, v = v + Math.imul(ke, Pe) | 0, b = b + Math.imul(se, Te) | 0, m = (m = m + Math.imul(se, Ne) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Ne) | 0, b = b + Math.imul(he, xe) | 0, m = (m = m + Math.imul(he, Ue) | 0) + Math.imul(_e, xe) | 0, v = v + Math.imul(_e, Ue) | 0, b = b + Math.imul(ue, Be) | 0, m = (m = m + Math.imul(ue, je) | 0) + Math.imul(le, Be) | 0, v = v + Math.imul(le, je) | 0;
    var ot = (L + (b = b + Math.imul(oe, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(oe, De) | 0) + Math.imul(ae, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ae, De) | 0) + (m >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, b = Math.imul(ee, ge), m = (m = Math.imul(ee, Ae)) + Math.imul(re, ge) | 0, v = Math.imul(re, Ae), b = b + Math.imul(G, $e) | 0, m = (m = m + Math.imul(G, Me) | 0) + Math.imul(X, $e) | 0, v = v + Math.imul(X, Me) | 0, b = b + Math.imul(M, ve) | 0, m = (m = m + Math.imul(M, Oe) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Oe) | 0, b = b + Math.imul(h, be) | 0, m = (m = m + Math.imul(h, Pe) | 0) + Math.imul(y, be) | 0, v = v + Math.imul(y, Pe) | 0, b = b + Math.imul(de, Te) | 0, m = (m = m + Math.imul(de, Ne) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Ne) | 0, b = b + Math.imul(se, xe) | 0, m = (m = m + Math.imul(se, Ue) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ue) | 0, b = b + Math.imul(he, Be) | 0, m = (m = m + Math.imul(he, je) | 0) + Math.imul(_e, Be) | 0, v = v + Math.imul(_e, je) | 0;
    var at = (L + (b = b + Math.imul(ue, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(ue, De) | 0) + Math.imul(le, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(le, De) | 0) + (m >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, b = Math.imul(ee, $e), m = (m = Math.imul(ee, Me)) + Math.imul(re, $e) | 0, v = Math.imul(re, Me), b = b + Math.imul(G, ve) | 0, m = (m = m + Math.imul(G, Oe) | 0) + Math.imul(X, ve) | 0, v = v + Math.imul(X, Oe) | 0, b = b + Math.imul(M, be) | 0, m = (m = m + Math.imul(M, Pe) | 0) + Math.imul(x, be) | 0, v = v + Math.imul(x, Pe) | 0, b = b + Math.imul(h, Te) | 0, m = (m = m + Math.imul(h, Ne) | 0) + Math.imul(y, Te) | 0, v = v + Math.imul(y, Ne) | 0, b = b + Math.imul(de, xe) | 0, m = (m = m + Math.imul(de, Ue) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ue) | 0, b = b + Math.imul(se, Be) | 0, m = (m = m + Math.imul(se, je) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, je) | 0;
    var st = (L + (b = b + Math.imul(he, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(he, De) | 0) + Math.imul(_e, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(_e, De) | 0) + (m >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, b = Math.imul(ee, ve), m = (m = Math.imul(ee, Oe)) + Math.imul(re, ve) | 0, v = Math.imul(re, Oe), b = b + Math.imul(G, be) | 0, m = (m = m + Math.imul(G, Pe) | 0) + Math.imul(X, be) | 0, v = v + Math.imul(X, Pe) | 0, b = b + Math.imul(M, Te) | 0, m = (m = m + Math.imul(M, Ne) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Ne) | 0, b = b + Math.imul(h, xe) | 0, m = (m = m + Math.imul(h, Ue) | 0) + Math.imul(y, xe) | 0, v = v + Math.imul(y, Ue) | 0, b = b + Math.imul(de, Be) | 0, m = (m = m + Math.imul(de, je) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (L + (b = b + Math.imul(se, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(se, De) | 0) + Math.imul(we, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(we, De) | 0) + (m >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, b = Math.imul(ee, be), m = (m = Math.imul(ee, Pe)) + Math.imul(re, be) | 0, v = Math.imul(re, Pe), b = b + Math.imul(G, Te) | 0, m = (m = m + Math.imul(G, Ne) | 0) + Math.imul(X, Te) | 0, v = v + Math.imul(X, Ne) | 0, b = b + Math.imul(M, xe) | 0, m = (m = m + Math.imul(M, Ue) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ue) | 0, b = b + Math.imul(h, Be) | 0, m = (m = m + Math.imul(h, je) | 0) + Math.imul(y, Be) | 0, v = v + Math.imul(y, je) | 0;
    var ct = (L + (b = b + Math.imul(de, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(de, De) | 0) + Math.imul(ke, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ke, De) | 0) + (m >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, b = Math.imul(ee, Te), m = (m = Math.imul(ee, Ne)) + Math.imul(re, Te) | 0, v = Math.imul(re, Ne), b = b + Math.imul(G, xe) | 0, m = (m = m + Math.imul(G, Ue) | 0) + Math.imul(X, xe) | 0, v = v + Math.imul(X, Ue) | 0, b = b + Math.imul(M, Be) | 0, m = (m = m + Math.imul(M, je) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (L + (b = b + Math.imul(h, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(h, De) | 0) + Math.imul(y, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(y, De) | 0) + (m >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, b = Math.imul(ee, xe), m = (m = Math.imul(ee, Ue)) + Math.imul(re, xe) | 0, v = Math.imul(re, Ue), b = b + Math.imul(G, Be) | 0, m = (m = m + Math.imul(G, je) | 0) + Math.imul(X, Be) | 0, v = v + Math.imul(X, je) | 0;
    var ht = (L + (b = b + Math.imul(M, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(M, De) | 0) + Math.imul(x, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(x, De) | 0) + (m >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, b = Math.imul(ee, Be), m = (m = Math.imul(ee, je)) + Math.imul(re, Be) | 0, v = Math.imul(re, je);
    var dt = (L + (b = b + Math.imul(G, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(G, De) | 0) + Math.imul(X, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(X, De) | 0) + (m >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (L + (b = Math.imul(ee, Ie)) | 0) + ((8191 & (m = (m = Math.imul(ee, De)) + Math.imul(re, Ie) | 0)) << 13) | 0;
    return L = ((v = Math.imul(re, De)) + (m >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, j[0] = Ge, j[1] = Ke, j[2] = Ye, j[3] = Ze, j[4] = Qe, j[5] = et, j[6] = tt, j[7] = rt, j[8] = nt, j[9] = it, j[10] = ot, j[11] = at, j[12] = st, j[13] = ut, j[14] = ct, j[15] = ft, j[16] = ht, j[17] = dt, j[18] = pt, L !== 0 && (j[19] = L, _.length++), _;
  };
  function q(g, $, _) {
    return new D().mulp(g, $, _);
  }
  function D(g, $) {
    this.x = g, this.y = $;
  }
  Math.imul || (P = C), c.prototype.mulTo = function(g, $) {
    var _, b = this.length + g.length;
    return _ = this.length === 10 && g.length === 10 ? P(this, g, $) : b < 63 ? C(this, g, $) : b < 1024 ? function(m, v, E) {
      E.negative = v.negative ^ m.negative, E.length = m.length + v.length;
      for (var T = 0, j = 0, L = 0; L < E.length - 1; L++) {
        var J = j;
        j = 0;
        for (var Y = 67108863 & T, ne = Math.min(L, v.length - 1), Q = Math.max(0, L - m.length + 1); Q <= ne; Q++) {
          var oe = L - Q, ae = (0 | m.words[oe]) * (0 | v.words[Q]), ce = 67108863 & ae;
          Y = 67108863 & (ce = ce + Y | 0), j += (J = (J = J + (ae / 67108864 | 0) | 0) + (ce >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[L] = Y, T = J, J = j;
      }
      return T !== 0 ? E.words[L] = T : E.length--, E.strip();
    }(this, g, $) : q(this, g, $), _;
  }, D.prototype.makeRBT = function(g) {
    for (var $ = new Array(g), _ = c.prototype._countBits(g) - 1, b = 0; b < g; b++)
      $[b] = this.revBin(b, _, g);
    return $;
  }, D.prototype.revBin = function(g, $, _) {
    if (g === 0 || g === _ - 1)
      return g;
    for (var b = 0, m = 0; m < $; m++)
      b |= (1 & g) << $ - m - 1, g >>= 1;
    return b;
  }, D.prototype.permute = function(g, $, _, b, m, v) {
    for (var E = 0; E < v; E++)
      b[E] = $[g[E]], m[E] = _[g[E]];
  }, D.prototype.transform = function(g, $, _, b, m, v) {
    this.permute(v, g, $, _, b, m);
    for (var E = 1; E < m; E <<= 1)
      for (var T = E << 1, j = Math.cos(2 * Math.PI / T), L = Math.sin(2 * Math.PI / T), J = 0; J < m; J += T)
        for (var Y = j, ne = L, Q = 0; Q < E; Q++) {
          var oe = _[J + Q], ae = b[J + Q], ce = _[J + Q + E], ue = b[J + Q + E], le = Y * ce - ne * ue;
          ue = Y * ue + ne * ce, ce = le, _[J + Q] = oe + ce, b[J + Q] = ae + ue, _[J + Q + E] = oe - ce, b[J + Q + E] = ae - ue, Q !== T && (le = j * Y - L * ne, ne = j * ne + L * Y, Y = le);
        }
  }, D.prototype.guessLen13b = function(g, $) {
    var _ = 1 | Math.max($, g), b = 1 & _, m = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      m++;
    return 1 << m + 1 + b;
  }, D.prototype.conjugate = function(g, $, _) {
    if (!(_ <= 1))
      for (var b = 0; b < _ / 2; b++) {
        var m = g[b];
        g[b] = g[_ - b - 1], g[_ - b - 1] = m, m = $[b], $[b] = -$[_ - b - 1], $[_ - b - 1] = -m;
      }
  }, D.prototype.normalize13b = function(g, $) {
    for (var _ = 0, b = 0; b < $ / 2; b++) {
      var m = 8192 * Math.round(g[2 * b + 1] / $) + Math.round(g[2 * b] / $) + _;
      g[b] = 67108863 & m, _ = m < 67108864 ? 0 : m / 67108864 | 0;
    }
    return g;
  }, D.prototype.convert13b = function(g, $, _, b) {
    for (var m = 0, v = 0; v < $; v++)
      m += 0 | g[v], _[2 * v] = 8191 & m, m >>>= 13, _[2 * v + 1] = 8191 & m, m >>>= 13;
    for (v = 2 * $; v < b; ++v)
      _[v] = 0;
    a(m === 0), a((-8192 & m) == 0);
  }, D.prototype.stub = function(g) {
    for (var $ = new Array(g), _ = 0; _ < g; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(g, $, _) {
    var b = 2 * this.guessLen13b(g.length, $.length), m = this.makeRBT(b), v = this.stub(b), E = new Array(b), T = new Array(b), j = new Array(b), L = new Array(b), J = new Array(b), Y = new Array(b), ne = _.words;
    ne.length = b, this.convert13b(g.words, g.length, E, b), this.convert13b($.words, $.length, L, b), this.transform(E, v, T, j, b, m), this.transform(L, v, J, Y, b, m);
    for (var Q = 0; Q < b; Q++) {
      var oe = T[Q] * J[Q] - j[Q] * Y[Q];
      j[Q] = T[Q] * Y[Q] + j[Q] * J[Q], T[Q] = oe;
    }
    return this.conjugate(T, j, b), this.transform(T, j, ne, v, b, m), this.conjugate(ne, v, b), this.normalize13b(ne, b), _.negative = g.negative ^ $.negative, _.length = g.length + $.length, _.strip();
  }, c.prototype.mul = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), this.mulTo(g, $);
  }, c.prototype.mulf = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), q(this, g, $);
  }, c.prototype.imul = function(g) {
    return this.clone().mulTo(g, this);
  }, c.prototype.imuln = function(g) {
    a(typeof g == "number"), a(g < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var b = (0 | this.words[_]) * g, m = (67108863 & b) + (67108863 & $);
      $ >>= 26, $ += b / 67108864 | 0, $ += m >>> 26, this.words[_] = 67108863 & m;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(g) {
    return this.clone().imuln(g);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(g) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), T = 0; T < E.length; T++) {
        var j = T / 26 | 0, L = T % 26;
        E[T] = (v.words[j] & 1 << L) >>> L;
      }
      return E;
    }(g);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, b = 0; b < $.length && $[b] === 0; b++, _ = _.sqr())
      ;
    if (++b < $.length)
      for (var m = _.sqr(); b < $.length; b++, m = m.sqr())
        $[b] !== 0 && (_ = _.mul(m));
    return _;
  }, c.prototype.iushln = function(g) {
    a(typeof g == "number" && g >= 0);
    var $, _ = g % 26, b = (g - _) / 26, m = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & m, T = (0 | this.words[$]) - E << _;
        this.words[$] = T | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (b !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + b] = this.words[$];
      for ($ = 0; $ < b; $++)
        this.words[$] = 0;
      this.length += b;
    }
    return this.strip();
  }, c.prototype.ishln = function(g) {
    return a(this.negative === 0), this.iushln(g);
  }, c.prototype.iushrn = function(g, $, _) {
    var b;
    a(typeof g == "number" && g >= 0), b = $ ? ($ - $ % 26) / 26 : 0;
    var m = g % 26, v = Math.min((g - m) / 26, this.length), E = 67108863 ^ 67108863 >>> m << m, T = _;
    if (b -= v, b = Math.max(0, b), T) {
      for (var j = 0; j < v; j++)
        T.words[j] = this.words[j];
      T.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, j = 0; j < this.length; j++)
          this.words[j] = this.words[j + v];
      else
        this.words[0] = 0, this.length = 1;
    var L = 0;
    for (j = this.length - 1; j >= 0 && (L !== 0 || j >= b); j--) {
      var J = 0 | this.words[j];
      this.words[j] = L << 26 - m | J >>> m, L = J & E;
    }
    return T && L !== 0 && (T.words[T.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(g, $, _) {
    return a(this.negative === 0), this.iushrn(g, $, _);
  }, c.prototype.shln = function(g) {
    return this.clone().ishln(g);
  }, c.prototype.ushln = function(g) {
    return this.clone().iushln(g);
  }, c.prototype.shrn = function(g) {
    return this.clone().ishrn(g);
  }, c.prototype.ushrn = function(g) {
    return this.clone().iushrn(g);
  }, c.prototype.testn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    return !(this.length <= _ || !(this.words[_] & b));
  }, c.prototype.imaskn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var b = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= b;
    }
    return this.strip();
  }, c.prototype.maskn = function(g) {
    return this.clone().imaskn(g);
  }, c.prototype.iaddn = function(g) {
    return a(typeof g == "number"), a(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < g ? (this.words[0] = g - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
  }, c.prototype._iaddn = function(g) {
    this.words[0] += g;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(g) {
    if (a(typeof g == "number"), a(g < 67108864), g < 0)
      return this.iaddn(-g);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(g), this.negative = 1, this;
    if (this.words[0] -= g, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(g) {
    return this.clone().iaddn(g);
  }, c.prototype.subn = function(g) {
    return this.clone().isubn(g);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(g, $, _) {
    var b, m, v = g.length + _;
    this._expand(v);
    var E = 0;
    for (b = 0; b < g.length; b++) {
      m = (0 | this.words[b + _]) + E;
      var T = (0 | g.words[b]) * $;
      E = ((m -= 67108863 & T) >> 26) - (T / 67108864 | 0), this.words[b + _] = 67108863 & m;
    }
    for (; b < this.length - _; b++)
      E = (m = (0 | this.words[b + _]) + E) >> 26, this.words[b + _] = 67108863 & m;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, b = 0; b < this.length; b++)
      E = (m = -(0 | this.words[b]) + E) >> 26, this.words[b] = 67108863 & m;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(g, $) {
    var _ = (this.length, g.length), b = this.clone(), m = g, v = 0 | m.words[m.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (m = m.ushln(_), b.iushln(_), v = 0 | m.words[m.length - 1]);
    var E, T = b.length - m.length;
    if ($ !== "mod") {
      (E = new c(null)).length = T + 1, E.words = new Array(E.length);
      for (var j = 0; j < E.length; j++)
        E.words[j] = 0;
    }
    var L = b.clone()._ishlnsubmul(m, 1, T);
    L.negative === 0 && (b = L, E && (E.words[T] = 1));
    for (var J = T - 1; J >= 0; J--) {
      var Y = 67108864 * (0 | b.words[m.length + J]) + (0 | b.words[m.length + J - 1]);
      for (Y = Math.min(Y / v | 0, 67108863), b._ishlnsubmul(m, Y, J); b.negative !== 0; )
        Y--, b.negative = 0, b._ishlnsubmul(m, 1, J), b.isZero() || (b.negative ^= 1);
      E && (E.words[J] = Y);
    }
    return E && E.strip(), b.strip(), $ !== "div" && _ !== 0 && b.iushrn(_), { div: E || null, mod: b };
  }, c.prototype.divmod = function(g, $, _) {
    return a(!g.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && g.negative === 0 ? (v = this.neg().divmod(g, $), $ !== "mod" && (b = v.div.neg()), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.iadd(g)), { div: b, mod: m }) : this.negative === 0 && g.negative !== 0 ? (v = this.divmod(g.neg(), $), $ !== "mod" && (b = v.div.neg()), { div: b, mod: v.mod }) : (this.negative & g.negative) != 0 ? (v = this.neg().divmod(g.neg(), $), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.isub(g)), { div: v.div, mod: m }) : g.length > this.length || this.cmp(g) < 0 ? { div: new c(0), mod: this } : g.length === 1 ? $ === "div" ? { div: this.divn(g.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new c(this.modn(g.words[0])) } : this._wordDiv(g, $);
    var b, m, v;
  }, c.prototype.div = function(g) {
    return this.divmod(g, "div", !1).div;
  }, c.prototype.mod = function(g) {
    return this.divmod(g, "mod", !1).mod;
  }, c.prototype.umod = function(g) {
    return this.divmod(g, "mod", !0).mod;
  }, c.prototype.divRound = function(g) {
    var $ = this.divmod(g);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(g) : $.mod, b = g.ushrn(1), m = g.andln(1), v = _.cmp(b);
    return v < 0 || m === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(g) {
    a(g <= 67108863);
    for (var $ = (1 << 26) % g, _ = 0, b = this.length - 1; b >= 0; b--)
      _ = ($ * _ + (0 | this.words[b])) % g;
    return _;
  }, c.prototype.idivn = function(g) {
    a(g <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = b / g | 0, $ = b % g;
    }
    return this.strip();
  }, c.prototype.divn = function(g) {
    return this.clone().idivn(g);
  }, c.prototype.egcd = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b = new c(1), m = new c(0), v = new c(0), E = new c(1), T = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++T;
    for (var j = _.clone(), L = $.clone(); !$.isZero(); ) {
      for (var J = 0, Y = 1; ($.words[0] & Y) == 0 && J < 26; ++J, Y <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (b.isOdd() || m.isOdd()) && (b.iadd(j), m.isub(L)), b.iushrn(1), m.iushrn(1);
      for (var ne = 0, Q = 1; (_.words[0] & Q) == 0 && ne < 26; ++ne, Q <<= 1)
        ;
      if (ne > 0)
        for (_.iushrn(ne); ne-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(j), E.isub(L)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), b.isub(v), m.isub(E)) : (_.isub($), v.isub(b), E.isub(m));
    }
    return { a: v, b: E, gcd: _.iushln(T) };
  }, c.prototype._invmp = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b, m = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var T = 0, j = 1; ($.words[0] & j) == 0 && T < 26; ++T, j <<= 1)
        ;
      if (T > 0)
        for ($.iushrn(T); T-- > 0; )
          m.isOdd() && m.iadd(E), m.iushrn(1);
      for (var L = 0, J = 1; (_.words[0] & J) == 0 && L < 26; ++L, J <<= 1)
        ;
      if (L > 0)
        for (_.iushrn(L); L-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), m.isub(v)) : (_.isub($), v.isub(m));
    }
    return (b = $.cmpn(1) === 0 ? m : v).cmpn(0) < 0 && b.iadd(g), b;
  }, c.prototype.gcd = function(g) {
    if (this.isZero())
      return g.abs();
    if (g.isZero())
      return this.abs();
    var $ = this.clone(), _ = g.clone();
    $.negative = 0, _.negative = 0;
    for (var b = 0; $.isEven() && _.isEven(); b++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var m = $.cmp(_);
      if (m < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (m === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(b);
  }, c.prototype.invm = function(g) {
    return this.egcd(g).a.umod(g);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(g) {
    return this.words[0] & g;
  }, c.prototype.bincn = function(g) {
    a(typeof g == "number");
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= b, this;
    for (var m = b, v = _; m !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      m = (E += m) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return m !== 0 && (this.words[v] = m, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(g) {
    var $, _ = g < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (g = -g), a(g <= 67108863, "Number is too big");
      var b = 0 | this.words[0];
      $ = b === g ? 0 : b < g ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(g) {
    if (this.negative !== 0 && g.negative === 0)
      return -1;
    if (this.negative === 0 && g.negative !== 0)
      return 1;
    var $ = this.ucmp(g);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(g) {
    if (this.length > g.length)
      return 1;
    if (this.length < g.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = 0 | this.words[_], m = 0 | g.words[_];
      if (b !== m) {
        b < m ? $ = -1 : b > m && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(g) {
    return this.cmpn(g) === 1;
  }, c.prototype.gt = function(g) {
    return this.cmp(g) === 1;
  }, c.prototype.gten = function(g) {
    return this.cmpn(g) >= 0;
  }, c.prototype.gte = function(g) {
    return this.cmp(g) >= 0;
  }, c.prototype.ltn = function(g) {
    return this.cmpn(g) === -1;
  }, c.prototype.lt = function(g) {
    return this.cmp(g) === -1;
  }, c.prototype.lten = function(g) {
    return this.cmpn(g) <= 0;
  }, c.prototype.lte = function(g) {
    return this.cmp(g) <= 0;
  }, c.prototype.eqn = function(g) {
    return this.cmpn(g) === 0;
  }, c.prototype.eq = function(g) {
    return this.cmp(g) === 0;
  }, c.red = function(g) {
    return new H(g);
  }, c.prototype.toRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(g) {
    return this.red = g, this;
  }, c.prototype.forceRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(g);
  }, c.prototype.redAdd = function(g) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
  }, c.prototype.redIAdd = function(g) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
  }, c.prototype.redSub = function(g) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
  }, c.prototype.redISub = function(g) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
  }, c.prototype.redShl = function(g) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
  }, c.prototype.redMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
  }, c.prototype.redIMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(g) {
    return a(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function F(g, $) {
    this.name = g, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    F.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Z() {
    F.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function N() {
    F.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function W() {
    F.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(g) {
    if (typeof g == "string") {
      var $ = c._prime(g);
      this.m = $.p, this.prime = $;
    } else
      a(g.gtn(1), "modulus must be greater than 1"), this.m = g, this.prime = null;
  }
  function te(g) {
    H.call(this, g), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  F.prototype._tmp = function() {
    var g = new c(null);
    return g.words = new Array(Math.ceil(this.n / 13)), g;
  }, F.prototype.ireduce = function(g) {
    var $, _ = g;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var b = $ < this.n ? -1 : _.ucmp(this.p);
    return b === 0 ? (_.words[0] = 0, _.length = 1) : b > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, F.prototype.split = function(g, $) {
    g.iushrn(this.n, 0, $);
  }, F.prototype.imulK = function(g) {
    return g.imul(this.k);
  }, u(V, F), V.prototype.split = function(g, $) {
    for (var _ = 4194303, b = Math.min(g.length, 9), m = 0; m < b; m++)
      $.words[m] = g.words[m];
    if ($.length = b, g.length <= 9)
      return g.words[0] = 0, void (g.length = 1);
    var v = g.words[9];
    for ($.words[$.length++] = v & _, m = 10; m < g.length; m++) {
      var E = 0 | g.words[m];
      g.words[m - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, g.words[m - 10] = v, v === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
  }, V.prototype.imulK = function(g) {
    g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 0 | g.words[_];
      $ += 977 * b, g.words[_] = 67108863 & $, $ = 64 * b + ($ / 67108864 | 0);
    }
    return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
  }, u(Z, F), u(N, F), u(W, F), W.prototype.imulK = function(g) {
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 19 * (0 | g.words[_]) + $, m = 67108863 & b;
      b >>>= 26, g.words[_] = m, $ = b;
    }
    return $ !== 0 && (g.words[g.length++] = $), g;
  }, c._prime = function(g) {
    if (z[g])
      return z[g];
    var $;
    if (g === "k256")
      $ = new V();
    else if (g === "p224")
      $ = new Z();
    else if (g === "p192")
      $ = new N();
    else {
      if (g !== "p25519")
        throw new Error("Unknown prime " + g);
      $ = new W();
    }
    return z[g] = $, $;
  }, H.prototype._verify1 = function(g) {
    a(g.negative === 0, "red works only with positives"), a(g.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(g, $) {
    a((g.negative | $.negative) == 0, "red works only with positives"), a(g.red && g.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(g) {
    return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(g) {
    return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
  }, H.prototype.add = function(g, $) {
    this._verify2(g, $);
    var _ = g.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(g, $) {
    this._verify2(g, $);
    var _ = g.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(g, $) {
    this._verify2(g, $);
    var _ = g.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(g, $) {
    this._verify2(g, $);
    var _ = g.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(g, $) {
    return this._verify1(g), this.imod(g.ushln($));
  }, H.prototype.imul = function(g, $) {
    return this._verify2(g, $), this.imod(g.imul($));
  }, H.prototype.mul = function(g, $) {
    return this._verify2(g, $), this.imod(g.mul($));
  }, H.prototype.isqr = function(g) {
    return this.imul(g, g.clone());
  }, H.prototype.sqr = function(g) {
    return this.mul(g, g);
  }, H.prototype.sqrt = function(g) {
    if (g.isZero())
      return g.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(g, _);
    }
    for (var b = this.m.subn(1), m = 0; !b.isZero() && b.andln(1) === 0; )
      m++, b.iushrn(1);
    a(!b.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), T = this.m.subn(1).iushrn(1), j = this.m.bitLength();
    for (j = new c(2 * j * j).toRed(this); this.pow(j, T).cmp(E) !== 0; )
      j.redIAdd(E);
    for (var L = this.pow(j, b), J = this.pow(g, b.addn(1).iushrn(1)), Y = this.pow(g, b), ne = m; Y.cmp(v) !== 0; ) {
      for (var Q = Y, oe = 0; Q.cmp(v) !== 0; oe++)
        Q = Q.redSqr();
      a(oe < ne);
      var ae = this.pow(L, new c(1).iushln(ne - oe - 1));
      J = J.redMul(ae), L = ae.redSqr(), Y = Y.redMul(L), ne = oe;
    }
    return J;
  }, H.prototype.invm = function(g) {
    var $ = g._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(g, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return g.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = g;
    for (var b = 2; b < _.length; b++)
      _[b] = this.mul(_[b - 1], g);
    var m = _[0], v = 0, E = 0, T = $.bitLength() % 26;
    for (T === 0 && (T = 26), b = $.length - 1; b >= 0; b--) {
      for (var j = $.words[b], L = T - 1; L >= 0; L--) {
        var J = j >> L & 1;
        m !== _[0] && (m = this.sqr(m)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || b === 0 && L === 0) && (m = this.mul(m, _[v]), E = 0, v = 0)) : E = 0;
      }
      T = 26;
    }
    return m;
  }, H.prototype.convertTo = function(g) {
    var $ = g.umod(this.m);
    return $ === g ? $.clone() : $;
  }, H.prototype.convertFrom = function(g) {
    var $ = g.clone();
    return $.red = null, $;
  }, c.mont = function(g) {
    return new te(g);
  }, u(te, H), te.prototype.convertTo = function(g) {
    return this.imod(g.ushln(this.shift));
  }, te.prototype.convertFrom = function(g) {
    var $ = this.imod(g.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(g, $) {
    if (g.isZero() || $.isZero())
      return g.words[0] = 0, g.length = 1, g;
    var _ = g.imul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(g, $) {
    if (g.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = g.mul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(g) {
    return this.imod(g._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var utils$l = {};
(function(n) {
  var o = utils$l;
  function a(c) {
    return c.length === 1 ? "0" + c : c;
  }
  function u(c) {
    for (var p = "", d = 0; d < c.length; d++)
      p += a(c[d].toString(16));
    return p;
  }
  o.toArray = function(c, p) {
    if (Array.isArray(c))
      return c.slice();
    if (!c)
      return [];
    var d = [];
    if (typeof c != "string") {
      for (var w = 0; w < c.length; w++)
        d[w] = 0 | c[w];
      return d;
    }
    if (p === "hex")
      for ((c = c.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (c = "0" + c), w = 0; w < c.length; w += 2)
        d.push(parseInt(c[w] + c[w + 1], 16));
    else
      for (w = 0; w < c.length; w++) {
        var S = c.charCodeAt(w), k = S >> 8, B = 255 & S;
        k ? d.push(k, B) : d.push(B);
      }
    return d;
  }, o.zero2 = a, o.toHex = u, o.encode = function(c, p) {
    return p === "hex" ? u(c) : c;
  };
})(), function(n) {
  var o = utils$m, a = bn$2.exports, u = minimalisticAssert, c = utils$l;
  o.assert = u, o.toArray = c.toArray, o.zero2 = c.zero2, o.toHex = c.toHex, o.encode = c.encode, o.getNAF = function(p, d, w) {
    var S = new Array(Math.max(p.bitLength(), w) + 1);
    S.fill(0);
    for (var k = 1 << d + 1, B = p.clone(), I = 0; I < S.length; I++) {
      var C, P = B.andln(k - 1);
      B.isOdd() ? (C = P > (k >> 1) - 1 ? (k >> 1) - P : P, B.isubn(C)) : C = 0, S[I] = C, B.iushrn(1);
    }
    return S;
  }, o.getJSF = function(p, d) {
    var w = [[], []];
    p = p.clone(), d = d.clone();
    for (var S, k = 0, B = 0; p.cmpn(-k) > 0 || d.cmpn(-B) > 0; ) {
      var I, C, P = p.andln(3) + k & 3, q = d.andln(3) + B & 3;
      P === 3 && (P = -1), q === 3 && (q = -1), I = (1 & P) == 0 ? 0 : (S = p.andln(7) + k & 7) != 3 && S !== 5 || q !== 2 ? P : -P, w[0].push(I), C = (1 & q) == 0 ? 0 : (S = d.andln(7) + B & 7) != 3 && S !== 5 || P !== 2 ? q : -q, w[1].push(C), 2 * k === I + 1 && (k = 1 - k), 2 * B === C + 1 && (B = 1 - B), p.iushrn(1), d.iushrn(1);
    }
    return w;
  }, o.cachedProperty = function(p, d, w) {
    var S = "_" + d;
    p.prototype[d] = function() {
      return this[S] !== void 0 ? this[S] : this[S] = w.call(this);
    };
  }, o.parseBytes = function(p) {
    return typeof p == "string" ? o.toArray(p, "hex") : p;
  }, o.intFromLE = function(p) {
    return new a(p, "hex", "le");
  };
}();
var brorand = { exports: {} }, r$1;
function Rand(n) {
  this.rand = n;
}
if (brorand.exports = function(n) {
  return r$1 || (r$1 = new Rand(null)), r$1.generate(n);
}, brorand.exports.Rand = Rand, Rand.prototype.generate = function(n) {
  return this._rand(n);
}, Rand.prototype._rand = function(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);
  for (var o = new Uint8Array(n), a = 0; a < o.length; a++)
    o[a] = this.rand.getByte();
  return o;
}, typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(n) {
    var o = new Uint8Array(n);
    return self.crypto.getRandomValues(o), o;
  } : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(n) {
    var o = new Uint8Array(n);
    return self.msCrypto.getRandomValues(o), o;
  } : typeof window == "object" && (Rand.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var crypto$1 = require$$2$1;
    if (typeof crypto$1.randomBytes != "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function(n) {
      return crypto$1.randomBytes(n);
    };
  } catch {
  }
var curve = {}, BN$8 = bn$2.exports, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(n, o) {
  this.type = n, this.p = new BN$8(o.p, 16), this.red = o.prime ? BN$8.red(o.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = o.n && new BN$8(o.n, 16), this.g = o.g && this.pointFromJSON(o.g, o.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var a = this.n && this.p.div(this.n);
  !a || a.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
function BasePoint(n, o) {
  this.curve = n, this.type = o, this.precomputed = null;
}
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype._fixedNafMul = function(n, o) {
  assert$e(n.precomputed);
  var a = n._getDoubles(), u = getNAF(o, 1, this._bitLength), c = (1 << a.step + 1) - (a.step % 2 == 0 ? 2 : 1);
  c /= 3;
  var p, d, w = [];
  for (p = 0; p < u.length; p += a.step) {
    d = 0;
    for (var S = p + a.step - 1; S >= p; S--)
      d = (d << 1) + u[S];
    w.push(d);
  }
  for (var k = this.jpoint(null, null, null), B = this.jpoint(null, null, null), I = c; I > 0; I--) {
    for (p = 0; p < w.length; p++)
      (d = w[p]) === I ? B = B.mixedAdd(a.points[p]) : d === -I && (B = B.mixedAdd(a.points[p].neg()));
    k = k.add(B);
  }
  return k.toP();
}, BaseCurve.prototype._wnafMul = function(n, o) {
  var a = 4, u = n._getNAFPoints(a);
  a = u.wnd;
  for (var c = u.points, p = getNAF(o, a, this._bitLength), d = this.jpoint(null, null, null), w = p.length - 1; w >= 0; w--) {
    for (var S = 0; w >= 0 && p[w] === 0; w--)
      S++;
    if (w >= 0 && S++, d = d.dblp(S), w < 0)
      break;
    var k = p[w];
    assert$e(k !== 0), d = n.type === "affine" ? k > 0 ? d.mixedAdd(c[k - 1 >> 1]) : d.mixedAdd(c[-k - 1 >> 1].neg()) : k > 0 ? d.add(c[k - 1 >> 1]) : d.add(c[-k - 1 >> 1].neg());
  }
  return n.type === "affine" ? d.toP() : d;
}, BaseCurve.prototype._wnafMulAdd = function(n, o, a, u, c) {
  var p, d, w, S = this._wnafT1, k = this._wnafT2, B = this._wnafT3, I = 0;
  for (p = 0; p < u; p++) {
    var C = (w = o[p])._getNAFPoints(n);
    S[p] = C.wnd, k[p] = C.points;
  }
  for (p = u - 1; p >= 1; p -= 2) {
    var P = p - 1, q = p;
    if (S[P] === 1 && S[q] === 1) {
      var D = [o[P], null, null, o[q]];
      o[P].y.cmp(o[q].y) === 0 ? (D[1] = o[P].add(o[q]), D[2] = o[P].toJ().mixedAdd(o[q].neg())) : o[P].y.cmp(o[q].y.redNeg()) === 0 ? (D[1] = o[P].toJ().mixedAdd(o[q]), D[2] = o[P].add(o[q].neg())) : (D[1] = o[P].toJ().mixedAdd(o[q]), D[2] = o[P].toJ().mixedAdd(o[q].neg()));
      var z = [-3, -1, -5, -7, 0, 7, 5, 1, 3], F = getJSF(a[P], a[q]);
      for (I = Math.max(F[0].length, I), B[P] = new Array(I), B[q] = new Array(I), d = 0; d < I; d++) {
        var V = 0 | F[0][d], Z = 0 | F[1][d];
        B[P][d] = z[3 * (V + 1) + (Z + 1)], B[q][d] = 0, k[P] = D;
      }
    } else
      B[P] = getNAF(a[P], S[P], this._bitLength), B[q] = getNAF(a[q], S[q], this._bitLength), I = Math.max(B[P].length, I), I = Math.max(B[q].length, I);
  }
  var N = this.jpoint(null, null, null), W = this._wnafT4;
  for (p = I; p >= 0; p--) {
    for (var H = 0; p >= 0; ) {
      var te = !0;
      for (d = 0; d < u; d++)
        W[d] = 0 | B[d][p], W[d] !== 0 && (te = !1);
      if (!te)
        break;
      H++, p--;
    }
    if (p >= 0 && H++, N = N.dblp(H), p < 0)
      break;
    for (d = 0; d < u; d++) {
      var g = W[d];
      g !== 0 && (g > 0 ? w = k[d][g - 1 >> 1] : g < 0 && (w = k[d][-g - 1 >> 1].neg()), N = w.type === "affine" ? N.mixedAdd(w) : N.add(w));
    }
  }
  for (p = 0; p < u; p++)
    k[p] = null;
  return c ? N : N.toP();
}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
}, BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
}, BaseCurve.prototype.decodePoint = function(n, o) {
  n = utils$k.toArray(n, o);
  var a = this.p.byteLength();
  if ((n[0] === 4 || n[0] === 6 || n[0] === 7) && n.length - 1 == 2 * a)
    return n[0] === 6 ? assert$e(n[n.length - 1] % 2 == 0) : n[0] === 7 && assert$e(n[n.length - 1] % 2 == 1), this.point(n.slice(1, 1 + a), n.slice(1 + a, 1 + 2 * a));
  if ((n[0] === 2 || n[0] === 3) && n.length - 1 === a)
    return this.pointFromX(n.slice(1, 1 + a), n[0] === 3);
  throw new Error("Unknown point format");
}, BasePoint.prototype.encodeCompressed = function(n) {
  return this.encode(n, !0);
}, BasePoint.prototype._encode = function(n) {
  var o = this.curve.p.byteLength(), a = this.getX().toArray("be", o);
  return n ? [this.getY().isEven() ? 2 : 3].concat(a) : [4].concat(a, this.getY().toArray("be", o));
}, BasePoint.prototype.encode = function(n, o) {
  return utils$k.encode(this._encode(o), n);
}, BasePoint.prototype.precompute = function(n) {
  if (this.precomputed)
    return this;
  var o = { doubles: null, naf: null, beta: null };
  return o.naf = this._getNAFPoints(8), o.doubles = this._getDoubles(4, n), o.beta = this._getBeta(), this.precomputed = o, this;
}, BasePoint.prototype._hasDoubles = function(n) {
  if (!this.precomputed)
    return !1;
  var o = this.precomputed.doubles;
  return !!o && o.points.length >= Math.ceil((n.bitLength() + 1) / o.step);
}, BasePoint.prototype._getDoubles = function(n, o) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var a = [this], u = this, c = 0; c < o; c += n) {
    for (var p = 0; p < n; p++)
      u = u.dbl();
    a.push(u);
  }
  return { step: n, points: a };
}, BasePoint.prototype._getNAFPoints = function(n) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var o = [this], a = (1 << n) - 1, u = a === 1 ? null : this.dbl(), c = 1; c < a; c++)
    o[c] = o[c - 1].add(u);
  return { wnd: n, points: o };
}, BasePoint.prototype._getBeta = function() {
  return null;
}, BasePoint.prototype.dblp = function(n) {
  for (var o = this, a = 0; a < n; a++)
    o = o.dbl();
  return o;
};
var utils$j = utils$m, BN$7 = bn$2.exports, inherits$3 = inherits_browser.exports, Base$2 = base, assert$d = utils$j.assert;
function ShortCurve(n) {
  Base$2.call(this, "short", n), this.a = new BN$7(n.a, 16).toRed(this.red), this.b = new BN$7(n.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(n), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve, Base$2);
var short = ShortCurve;
function Point$2(n, o, a, u) {
  Base$2.BasePoint.call(this, n, "affine"), o === null && a === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$7(o, 16), this.y = new BN$7(a, 16), u && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
function JPoint(n, o, a, u) {
  Base$2.BasePoint.call(this, n, "jacobian"), o === null && a === null && u === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$7(0)) : (this.x = new BN$7(o, 16), this.y = new BN$7(a, 16), this.z = new BN$7(u, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
ShortCurve.prototype._getEndomorphism = function(n) {
  if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
    var o, a;
    if (n.beta)
      o = new BN$7(n.beta, 16).toRed(this.red);
    else {
      var u = this._getEndoRoots(this.p);
      o = (o = u[0].cmp(u[1]) < 0 ? u[0] : u[1]).toRed(this.red);
    }
    if (n.lambda)
      a = new BN$7(n.lambda, 16);
    else {
      var c = this._getEndoRoots(this.n);
      this.g.mul(c[0]).x.cmp(this.g.x.redMul(o)) === 0 ? a = c[0] : (a = c[1], assert$d(this.g.mul(a).x.cmp(this.g.x.redMul(o)) === 0));
    }
    return { beta: o, lambda: a, basis: n.basis ? n.basis.map(function(p) {
      return { a: new BN$7(p.a, 16), b: new BN$7(p.b, 16) };
    }) : this._getEndoBasis(a) };
  }
}, ShortCurve.prototype._getEndoRoots = function(n) {
  var o = n === this.p ? this.red : BN$7.mont(n), a = new BN$7(2).toRed(o).redInvm(), u = a.redNeg(), c = new BN$7(3).toRed(o).redNeg().redSqrt().redMul(a);
  return [u.redAdd(c).fromRed(), u.redSub(c).fromRed()];
}, ShortCurve.prototype._getEndoBasis = function(n) {
  for (var o, a, u, c, p, d, w, S, k, B = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), I = n, C = this.n.clone(), P = new BN$7(1), q = new BN$7(0), D = new BN$7(0), z = new BN$7(1), F = 0; I.cmpn(0) !== 0; ) {
    var V = C.div(I);
    S = C.sub(V.mul(I)), k = D.sub(V.mul(P));
    var Z = z.sub(V.mul(q));
    if (!u && S.cmp(B) < 0)
      o = w.neg(), a = P, u = S.neg(), c = k;
    else if (u && ++F == 2)
      break;
    w = S, C = I, I = S, D = P, P = k, z = q, q = Z;
  }
  p = S.neg(), d = k;
  var N = u.sqr().add(c.sqr());
  return p.sqr().add(d.sqr()).cmp(N) >= 0 && (p = o, d = a), u.negative && (u = u.neg(), c = c.neg()), p.negative && (p = p.neg(), d = d.neg()), [{ a: u, b: c }, { a: p, b: d }];
}, ShortCurve.prototype._endoSplit = function(n) {
  var o = this.endo.basis, a = o[0], u = o[1], c = u.b.mul(n).divRound(this.n), p = a.b.neg().mul(n).divRound(this.n), d = c.mul(a.a), w = p.mul(u.a), S = c.mul(a.b), k = p.mul(u.b);
  return { k1: n.sub(d).sub(w), k2: S.add(k).neg() };
}, ShortCurve.prototype.pointFromX = function(n, o) {
  (n = new BN$7(n, 16)).red || (n = n.toRed(this.red));
  var a = n.redSqr().redMul(n).redIAdd(n.redMul(this.a)).redIAdd(this.b), u = a.redSqrt();
  if (u.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var c = u.fromRed().isOdd();
  return (o && !c || !o && c) && (u = u.redNeg()), this.point(n, u);
}, ShortCurve.prototype.validate = function(n) {
  if (n.inf)
    return !0;
  var o = n.x, a = n.y, u = this.a.redMul(o), c = o.redSqr().redMul(o).redIAdd(u).redIAdd(this.b);
  return a.redSqr().redISub(c).cmpn(0) === 0;
}, ShortCurve.prototype._endoWnafMulAdd = function(n, o, a) {
  for (var u = this._endoWnafT1, c = this._endoWnafT2, p = 0; p < n.length; p++) {
    var d = this._endoSplit(o[p]), w = n[p], S = w._getBeta();
    d.k1.negative && (d.k1.ineg(), w = w.neg(!0)), d.k2.negative && (d.k2.ineg(), S = S.neg(!0)), u[2 * p] = w, u[2 * p + 1] = S, c[2 * p] = d.k1, c[2 * p + 1] = d.k2;
  }
  for (var k = this._wnafMulAdd(1, u, c, 2 * p, a), B = 0; B < 2 * p; B++)
    u[B] = null, c[B] = null;
  return k;
}, inherits$3(Point$2, Base$2.BasePoint), ShortCurve.prototype.point = function(n, o, a) {
  return new Point$2(this, n, o, a);
}, ShortCurve.prototype.pointFromJSON = function(n, o) {
  return Point$2.fromJSON(this, n, o);
}, Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var n = this.precomputed;
    if (n && n.beta)
      return n.beta;
    var o = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (n) {
      var a = this.curve, u = function(c) {
        return a.point(c.x.redMul(a.endo.beta), c.y);
      };
      n.beta = o, o.precomputed = { beta: null, naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(u) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(u) } };
    }
    return o;
  }
}, Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, Point$2.fromJSON = function(n, o, a) {
  typeof o == "string" && (o = JSON.parse(o));
  var u = n.point(o[0], o[1], a);
  if (!o[2])
    return u;
  function c(d) {
    return n.point(d[0], d[1], a);
  }
  var p = o[2];
  return u.precomputed = { beta: null, doubles: p.doubles && { step: p.doubles.step, points: [u].concat(p.doubles.points.map(c)) }, naf: p.naf && { wnd: p.naf.wnd, points: [u].concat(p.naf.points.map(c)) } }, u;
}, Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, Point$2.prototype.isInfinity = function() {
  return this.inf;
}, Point$2.prototype.add = function(n) {
  if (this.inf)
    return n;
  if (n.inf)
    return this;
  if (this.eq(n))
    return this.dbl();
  if (this.neg().eq(n))
    return this.curve.point(null, null);
  if (this.x.cmp(n.x) === 0)
    return this.curve.point(null, null);
  var o = this.y.redSub(n.y);
  o.cmpn(0) !== 0 && (o = o.redMul(this.x.redSub(n.x).redInvm()));
  var a = o.redSqr().redISub(this.x).redISub(n.x), u = o.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, u);
}, Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var n = this.y.redAdd(this.y);
  if (n.cmpn(0) === 0)
    return this.curve.point(null, null);
  var o = this.curve.a, a = this.x.redSqr(), u = n.redInvm(), c = a.redAdd(a).redIAdd(a).redIAdd(o).redMul(u), p = c.redSqr().redISub(this.x.redAdd(this.x)), d = c.redMul(this.x.redSub(p)).redISub(this.y);
  return this.curve.point(p, d);
}, Point$2.prototype.getX = function() {
  return this.x.fromRed();
}, Point$2.prototype.getY = function() {
  return this.y.fromRed();
}, Point$2.prototype.mul = function(n) {
  return n = new BN$7(n, 16), this.isInfinity() ? this : this._hasDoubles(n) ? this.curve._fixedNafMul(this, n) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [n]) : this.curve._wnafMul(this, n);
}, Point$2.prototype.mulAdd = function(n, o, a) {
  var u = [this, o], c = [n, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, c) : this.curve._wnafMulAdd(1, u, c, 2);
}, Point$2.prototype.jmulAdd = function(n, o, a) {
  var u = [this, o], c = [n, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, c, !0) : this.curve._wnafMulAdd(1, u, c, 2, !0);
}, Point$2.prototype.eq = function(n) {
  return this === n || this.inf === n.inf && (this.inf || this.x.cmp(n.x) === 0 && this.y.cmp(n.y) === 0);
}, Point$2.prototype.neg = function(n) {
  if (this.inf)
    return this;
  var o = this.curve.point(this.x, this.y.redNeg());
  if (n && this.precomputed) {
    var a = this.precomputed, u = function(c) {
      return c.neg();
    };
    o.precomputed = { naf: a.naf && { wnd: a.naf.wnd, points: a.naf.points.map(u) }, doubles: a.doubles && { step: a.doubles.step, points: a.doubles.points.map(u) } };
  }
  return o;
}, Point$2.prototype.toJ = function() {
  return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
}, inherits$3(JPoint, Base$2.BasePoint), ShortCurve.prototype.jpoint = function(n, o, a) {
  return new JPoint(this, n, o, a);
}, JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var n = this.z.redInvm(), o = n.redSqr(), a = this.x.redMul(o), u = this.y.redMul(o).redMul(n);
  return this.curve.point(a, u);
}, JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, JPoint.prototype.add = function(n) {
  if (this.isInfinity())
    return n;
  if (n.isInfinity())
    return this;
  var o = n.z.redSqr(), a = this.z.redSqr(), u = this.x.redMul(o), c = n.x.redMul(a), p = this.y.redMul(o.redMul(n.z)), d = n.y.redMul(a.redMul(this.z)), w = u.redSub(c), S = p.redSub(d);
  if (w.cmpn(0) === 0)
    return S.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var k = w.redSqr(), B = k.redMul(w), I = u.redMul(k), C = S.redSqr().redIAdd(B).redISub(I).redISub(I), P = S.redMul(I.redISub(C)).redISub(p.redMul(B)), q = this.z.redMul(n.z).redMul(w);
  return this.curve.jpoint(C, P, q);
}, JPoint.prototype.mixedAdd = function(n) {
  if (this.isInfinity())
    return n.toJ();
  if (n.isInfinity())
    return this;
  var o = this.z.redSqr(), a = this.x, u = n.x.redMul(o), c = this.y, p = n.y.redMul(o).redMul(this.z), d = a.redSub(u), w = c.redSub(p);
  if (d.cmpn(0) === 0)
    return w.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var S = d.redSqr(), k = S.redMul(d), B = a.redMul(S), I = w.redSqr().redIAdd(k).redISub(B).redISub(B), C = w.redMul(B.redISub(I)).redISub(c.redMul(k)), P = this.z.redMul(d);
  return this.curve.jpoint(I, C, P);
}, JPoint.prototype.dblp = function(n) {
  if (n === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!n)
    return this.dbl();
  var o;
  if (this.curve.zeroA || this.curve.threeA) {
    var a = this;
    for (o = 0; o < n; o++)
      a = a.dbl();
    return a;
  }
  var u = this.curve.a, c = this.curve.tinv, p = this.x, d = this.y, w = this.z, S = w.redSqr().redSqr(), k = d.redAdd(d);
  for (o = 0; o < n; o++) {
    var B = p.redSqr(), I = k.redSqr(), C = I.redSqr(), P = B.redAdd(B).redIAdd(B).redIAdd(u.redMul(S)), q = p.redMul(I), D = P.redSqr().redISub(q.redAdd(q)), z = q.redISub(D), F = P.redMul(z);
    F = F.redIAdd(F).redISub(C);
    var V = k.redMul(w);
    o + 1 < n && (S = S.redMul(C)), p = D, w = V, k = F;
  }
  return this.curve.jpoint(p, k.redMul(c), w);
}, JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, JPoint.prototype._zeroDbl = function() {
  var n, o, a;
  if (this.zOne) {
    var u = this.x.redSqr(), c = this.y.redSqr(), p = c.redSqr(), d = this.x.redAdd(c).redSqr().redISub(u).redISub(p);
    d = d.redIAdd(d);
    var w = u.redAdd(u).redIAdd(u), S = w.redSqr().redISub(d).redISub(d), k = p.redIAdd(p);
    k = (k = k.redIAdd(k)).redIAdd(k), n = S, o = w.redMul(d.redISub(S)).redISub(k), a = this.y.redAdd(this.y);
  } else {
    var B = this.x.redSqr(), I = this.y.redSqr(), C = I.redSqr(), P = this.x.redAdd(I).redSqr().redISub(B).redISub(C);
    P = P.redIAdd(P);
    var q = B.redAdd(B).redIAdd(B), D = q.redSqr(), z = C.redIAdd(C);
    z = (z = z.redIAdd(z)).redIAdd(z), n = D.redISub(P).redISub(P), o = q.redMul(P.redISub(n)).redISub(z), a = (a = this.y.redMul(this.z)).redIAdd(a);
  }
  return this.curve.jpoint(n, o, a);
}, JPoint.prototype._threeDbl = function() {
  var n, o, a;
  if (this.zOne) {
    var u = this.x.redSqr(), c = this.y.redSqr(), p = c.redSqr(), d = this.x.redAdd(c).redSqr().redISub(u).redISub(p);
    d = d.redIAdd(d);
    var w = u.redAdd(u).redIAdd(u).redIAdd(this.curve.a), S = w.redSqr().redISub(d).redISub(d);
    n = S;
    var k = p.redIAdd(p);
    k = (k = k.redIAdd(k)).redIAdd(k), o = w.redMul(d.redISub(S)).redISub(k), a = this.y.redAdd(this.y);
  } else {
    var B = this.z.redSqr(), I = this.y.redSqr(), C = this.x.redMul(I), P = this.x.redSub(B).redMul(this.x.redAdd(B));
    P = P.redAdd(P).redIAdd(P);
    var q = C.redIAdd(C), D = (q = q.redIAdd(q)).redAdd(q);
    n = P.redSqr().redISub(D), a = this.y.redAdd(this.z).redSqr().redISub(I).redISub(B);
    var z = I.redSqr();
    z = (z = (z = z.redIAdd(z)).redIAdd(z)).redIAdd(z), o = P.redMul(q.redISub(n)).redISub(z);
  }
  return this.curve.jpoint(n, o, a);
}, JPoint.prototype._dbl = function() {
  var n = this.curve.a, o = this.x, a = this.y, u = this.z, c = u.redSqr().redSqr(), p = o.redSqr(), d = a.redSqr(), w = p.redAdd(p).redIAdd(p).redIAdd(n.redMul(c)), S = o.redAdd(o), k = (S = S.redIAdd(S)).redMul(d), B = w.redSqr().redISub(k.redAdd(k)), I = k.redISub(B), C = d.redSqr();
  C = (C = (C = C.redIAdd(C)).redIAdd(C)).redIAdd(C);
  var P = w.redMul(I).redISub(C), q = a.redAdd(a).redMul(u);
  return this.curve.jpoint(B, P, q);
}, JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var n = this.x.redSqr(), o = this.y.redSqr(), a = this.z.redSqr(), u = o.redSqr(), c = n.redAdd(n).redIAdd(n), p = c.redSqr(), d = this.x.redAdd(o).redSqr().redISub(n).redISub(u), w = (d = (d = (d = d.redIAdd(d)).redAdd(d).redIAdd(d)).redISub(p)).redSqr(), S = u.redIAdd(u);
  S = (S = (S = S.redIAdd(S)).redIAdd(S)).redIAdd(S);
  var k = c.redIAdd(d).redSqr().redISub(p).redISub(w).redISub(S), B = o.redMul(k);
  B = (B = B.redIAdd(B)).redIAdd(B);
  var I = this.x.redMul(w).redISub(B);
  I = (I = I.redIAdd(I)).redIAdd(I);
  var C = this.y.redMul(k.redMul(S.redISub(k)).redISub(d.redMul(w)));
  C = (C = (C = C.redIAdd(C)).redIAdd(C)).redIAdd(C);
  var P = this.z.redAdd(d).redSqr().redISub(a).redISub(w);
  return this.curve.jpoint(I, C, P);
}, JPoint.prototype.mul = function(n, o) {
  return n = new BN$7(n, o), this.curve._wnafMul(this, n);
}, JPoint.prototype.eq = function(n) {
  if (n.type === "affine")
    return this.eq(n.toJ());
  if (this === n)
    return !0;
  var o = this.z.redSqr(), a = n.z.redSqr();
  if (this.x.redMul(a).redISub(n.x.redMul(o)).cmpn(0) !== 0)
    return !1;
  var u = o.redMul(this.z), c = a.redMul(n.z);
  return this.y.redMul(c).redISub(n.y.redMul(u)).cmpn(0) === 0;
}, JPoint.prototype.eqXToP = function(n) {
  var o = this.z.redSqr(), a = n.toRed(this.curve.red).redMul(o);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var u = n.clone(), c = this.curve.redN.redMul(o); ; ) {
    if (u.iadd(this.curve.n), u.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(c), this.x.cmp(a) === 0)
      return !0;
  }
}, JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$6 = bn$2.exports, inherits$2 = inherits_browser.exports, Base$1 = base, utils$i = utils$m;
function MontCurve(n) {
  Base$1.call(this, "mont", n), this.a = new BN$6(n.a, 16).toRed(this.red), this.b = new BN$6(n.b, 16).toRed(this.red), this.i4 = new BN$6(4).toRed(this.red).redInvm(), this.two = new BN$6(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;
function Point$1(n, o, a) {
  Base$1.BasePoint.call(this, n, "projective"), o === null && a === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$6(o, 16), this.z = new BN$6(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
MontCurve.prototype.validate = function(n) {
  var o = n.normalize().x, a = o.redSqr(), u = a.redMul(o).redAdd(a.redMul(this.a)).redAdd(o);
  return u.redSqrt().redSqr().cmp(u) === 0;
}, inherits$2(Point$1, Base$1.BasePoint), MontCurve.prototype.decodePoint = function(n, o) {
  return this.point(utils$i.toArray(n, o), 1);
}, MontCurve.prototype.point = function(n, o) {
  return new Point$1(this, n, o);
}, MontCurve.prototype.pointFromJSON = function(n) {
  return Point$1.fromJSON(this, n);
}, Point$1.prototype.precompute = function() {
}, Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
}, Point$1.fromJSON = function(n, o) {
  return new Point$1(n, o[0], o[1] || n.one);
}, Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
}, Point$1.prototype.dbl = function() {
  var n = this.x.redAdd(this.z).redSqr(), o = this.x.redSub(this.z).redSqr(), a = n.redSub(o), u = n.redMul(o), c = a.redMul(o.redAdd(this.curve.a24.redMul(a)));
  return this.curve.point(u, c);
}, Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.diffAdd = function(n, o) {
  var a = this.x.redAdd(this.z), u = this.x.redSub(this.z), c = n.x.redAdd(n.z), p = n.x.redSub(n.z).redMul(a), d = c.redMul(u), w = o.z.redMul(p.redAdd(d).redSqr()), S = o.x.redMul(p.redISub(d).redSqr());
  return this.curve.point(w, S);
}, Point$1.prototype.mul = function(n) {
  for (var o = n.clone(), a = this, u = this.curve.point(null, null), c = []; o.cmpn(0) !== 0; o.iushrn(1))
    c.push(o.andln(1));
  for (var p = c.length - 1; p >= 0; p--)
    c[p] === 0 ? (a = a.diffAdd(u, this), u = u.dbl()) : (u = a.diffAdd(u, this), a = a.dbl());
  return u;
}, Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.eq = function(n) {
  return this.getX().cmp(n.getX()) === 0;
}, Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
}, Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$5 = bn$2.exports, inherits$1 = inherits_browser.exports, Base = base, assert$c = utils$h.assert;
function EdwardsCurve(n) {
  this.twisted = (0 | n.a) != 1, this.mOneA = this.twisted && (0 | n.a) == -1, this.extended = this.mOneA, Base.call(this, "edwards", n), this.a = new BN$5(n.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$5(n.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$5(n.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | n.c) == 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve, e;
function Point(n, o, a, u, c) {
  Base.BasePoint.call(this, n, "projective"), o === null && a === null && u === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$5(o, 16), this.y = new BN$5(a, 16), this.z = u ? new BN$5(u, 16) : this.curve.one, this.t = c && new BN$5(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
EdwardsCurve.prototype._mulA = function(n) {
  return this.mOneA ? n.redNeg() : this.a.redMul(n);
}, EdwardsCurve.prototype._mulC = function(n) {
  return this.oneC ? n : this.c.redMul(n);
}, EdwardsCurve.prototype.jpoint = function(n, o, a, u) {
  return this.point(n, o, a, u);
}, EdwardsCurve.prototype.pointFromX = function(n, o) {
  (n = new BN$5(n, 16)).red || (n = n.toRed(this.red));
  var a = n.redSqr(), u = this.c2.redSub(this.a.redMul(a)), c = this.one.redSub(this.c2.redMul(this.d).redMul(a)), p = u.redMul(c.redInvm()), d = p.redSqrt();
  if (d.redSqr().redSub(p).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var w = d.fromRed().isOdd();
  return (o && !w || !o && w) && (d = d.redNeg()), this.point(n, d);
}, EdwardsCurve.prototype.pointFromY = function(n, o) {
  (n = new BN$5(n, 16)).red || (n = n.toRed(this.red));
  var a = n.redSqr(), u = a.redSub(this.c2), c = a.redMul(this.d).redMul(this.c2).redSub(this.a), p = u.redMul(c.redInvm());
  if (p.cmp(this.zero) === 0) {
    if (o)
      throw new Error("invalid point");
    return this.point(this.zero, n);
  }
  var d = p.redSqrt();
  if (d.redSqr().redSub(p).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return d.fromRed().isOdd() !== o && (d = d.redNeg()), this.point(d, n);
}, EdwardsCurve.prototype.validate = function(n) {
  if (n.isInfinity())
    return !0;
  n.normalize();
  var o = n.x.redSqr(), a = n.y.redSqr(), u = o.redMul(this.a).redAdd(a), c = this.c2.redMul(this.one.redAdd(this.d.redMul(o).redMul(a)));
  return u.cmp(c) === 0;
}, inherits$1(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(n) {
  return Point.fromJSON(this, n);
}, EdwardsCurve.prototype.point = function(n, o, a, u) {
  return new Point(this, n, o, a, u);
}, Point.fromJSON = function(n, o) {
  return new Point(n, o[0], o[1], o[2]);
}, Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
}, Point.prototype._extDbl = function() {
  var n = this.x.redSqr(), o = this.y.redSqr(), a = this.z.redSqr();
  a = a.redIAdd(a);
  var u = this.curve._mulA(n), c = this.x.redAdd(this.y).redSqr().redISub(n).redISub(o), p = u.redAdd(o), d = p.redSub(a), w = u.redSub(o), S = c.redMul(d), k = p.redMul(w), B = c.redMul(w), I = d.redMul(p);
  return this.curve.point(S, k, I, B);
}, Point.prototype._projDbl = function() {
  var n, o, a, u, c, p, d = this.x.redAdd(this.y).redSqr(), w = this.x.redSqr(), S = this.y.redSqr();
  if (this.curve.twisted) {
    var k = (u = this.curve._mulA(w)).redAdd(S);
    this.zOne ? (n = d.redSub(w).redSub(S).redMul(k.redSub(this.curve.two)), o = k.redMul(u.redSub(S)), a = k.redSqr().redSub(k).redSub(k)) : (c = this.z.redSqr(), p = k.redSub(c).redISub(c), n = d.redSub(w).redISub(S).redMul(p), o = k.redMul(u.redSub(S)), a = k.redMul(p));
  } else
    u = w.redAdd(S), c = this.curve._mulC(this.z).redSqr(), p = u.redSub(c).redSub(c), n = this.curve._mulC(d.redISub(u)).redMul(p), o = this.curve._mulC(u).redMul(w.redISub(S)), a = u.redMul(p);
  return this.curve.point(n, o, a);
}, Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
}, Point.prototype._extAdd = function(n) {
  var o = this.y.redSub(this.x).redMul(n.y.redSub(n.x)), a = this.y.redAdd(this.x).redMul(n.y.redAdd(n.x)), u = this.t.redMul(this.curve.dd).redMul(n.t), c = this.z.redMul(n.z.redAdd(n.z)), p = a.redSub(o), d = c.redSub(u), w = c.redAdd(u), S = a.redAdd(o), k = p.redMul(d), B = w.redMul(S), I = p.redMul(S), C = d.redMul(w);
  return this.curve.point(k, B, C, I);
}, Point.prototype._projAdd = function(n) {
  var o, a, u = this.z.redMul(n.z), c = u.redSqr(), p = this.x.redMul(n.x), d = this.y.redMul(n.y), w = this.curve.d.redMul(p).redMul(d), S = c.redSub(w), k = c.redAdd(w), B = this.x.redAdd(this.y).redMul(n.x.redAdd(n.y)).redISub(p).redISub(d), I = u.redMul(S).redMul(B);
  return this.curve.twisted ? (o = u.redMul(k).redMul(d.redSub(this.curve._mulA(p))), a = S.redMul(k)) : (o = u.redMul(k).redMul(d.redSub(p)), a = this.curve._mulC(S).redMul(k)), this.curve.point(I, o, a);
}, Point.prototype.add = function(n) {
  return this.isInfinity() ? n : n.isInfinity() ? this : this.curve.extended ? this._extAdd(n) : this._projAdd(n);
}, Point.prototype.mul = function(n) {
  return this._hasDoubles(n) ? this.curve._fixedNafMul(this, n) : this.curve._wnafMul(this, n);
}, Point.prototype.mulAdd = function(n, o, a) {
  return this.curve._wnafMulAdd(1, [this, o], [n, a], 2, !1);
}, Point.prototype.jmulAdd = function(n, o, a) {
  return this.curve._wnafMulAdd(1, [this, o], [n, a], 2, !0);
}, Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var n = this.z.redInvm();
  return this.x = this.x.redMul(n), this.y = this.y.redMul(n), this.t && (this.t = this.t.redMul(n)), this.z = this.curve.one, this.zOne = !0, this;
}, Point.prototype.neg = function() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
}, Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
}, Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
}, Point.prototype.eq = function(n) {
  return this === n || this.getX().cmp(n.getX()) === 0 && this.getY().cmp(n.getY()) === 0;
}, Point.prototype.eqXToP = function(n) {
  var o = n.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(o) === 0)
    return !0;
  for (var a = n.clone(), u = this.curve.redN.redMul(this.z); ; ) {
    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
      return !1;
    if (o.redIAdd(u), this.x.cmp(o) === 0)
      return !0;
  }
}, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add, e = curve, e.base = base, e.short = short, e.mont = mont, e.edwards = edwards;
var curves$2 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits = inherits_browser.exports;
function isSurrogatePair(n, o) {
  return (64512 & n.charCodeAt(o)) == 55296 && !(o < 0 || o + 1 >= n.length) && (64512 & n.charCodeAt(o + 1)) == 56320;
}
function toArray(n, o) {
  if (Array.isArray(n))
    return n.slice();
  if (!n)
    return [];
  var a = [];
  if (typeof n == "string")
    if (o) {
      if (o === "hex")
        for ((n = n.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (n = "0" + n), c = 0; c < n.length; c += 2)
          a.push(parseInt(n[c] + n[c + 1], 16));
    } else
      for (var u = 0, c = 0; c < n.length; c++) {
        var p = n.charCodeAt(c);
        p < 128 ? a[u++] = p : p < 2048 ? (a[u++] = p >> 6 | 192, a[u++] = 63 & p | 128) : isSurrogatePair(n, c) ? (p = 65536 + ((1023 & p) << 10) + (1023 & n.charCodeAt(++c)), a[u++] = p >> 18 | 240, a[u++] = p >> 12 & 63 | 128, a[u++] = p >> 6 & 63 | 128, a[u++] = 63 & p | 128) : (a[u++] = p >> 12 | 224, a[u++] = p >> 6 & 63 | 128, a[u++] = 63 & p | 128);
      }
  else
    for (c = 0; c < n.length; c++)
      a[c] = 0 | n[c];
  return a;
}
function toHex(n) {
  for (var o = "", a = 0; a < n.length; a++)
    o += zero2(n[a].toString(16));
  return o;
}
function htonl(n) {
  return (n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (255 & n) << 24) >>> 0;
}
function toHex32(n, o) {
  for (var a = "", u = 0; u < n.length; u++) {
    var c = n[u];
    o === "little" && (c = htonl(c)), a += zero8(c.toString(16));
  }
  return a;
}
function zero2(n) {
  return n.length === 1 ? "0" + n : n;
}
function zero8(n) {
  return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n;
}
function join32(n, o, a, u) {
  var c = a - o;
  assert$b(c % 4 == 0);
  for (var p = new Array(c / 4), d = 0, w = o; d < p.length; d++, w += 4) {
    var S;
    S = u === "big" ? n[w] << 24 | n[w + 1] << 16 | n[w + 2] << 8 | n[w + 3] : n[w + 3] << 24 | n[w + 2] << 16 | n[w + 1] << 8 | n[w], p[d] = S >>> 0;
  }
  return p;
}
function split32(n, o) {
  for (var a = new Array(4 * n.length), u = 0, c = 0; u < n.length; u++, c += 4) {
    var p = n[u];
    o === "big" ? (a[c] = p >>> 24, a[c + 1] = p >>> 16 & 255, a[c + 2] = p >>> 8 & 255, a[c + 3] = 255 & p) : (a[c + 3] = p >>> 24, a[c + 2] = p >>> 16 & 255, a[c + 1] = p >>> 8 & 255, a[c] = 255 & p);
  }
  return a;
}
function rotr32$1(n, o) {
  return n >>> o | n << 32 - o;
}
function rotl32$2(n, o) {
  return n << o | n >>> 32 - o;
}
function sum32$3(n, o) {
  return n + o >>> 0;
}
function sum32_3$1(n, o, a) {
  return n + o + a >>> 0;
}
function sum32_4$2(n, o, a, u) {
  return n + o + a + u >>> 0;
}
function sum32_5$2(n, o, a, u, c) {
  return n + o + a + u + c >>> 0;
}
function sum64$1(n, o, a, u) {
  var c = n[o], p = u + n[o + 1] >>> 0, d = (p < u ? 1 : 0) + a + c;
  n[o] = d >>> 0, n[o + 1] = p;
}
function sum64_hi$1(n, o, a, u) {
  return (o + u >>> 0 < o ? 1 : 0) + n + a >>> 0;
}
function sum64_lo$1(n, o, a, u) {
  return o + u >>> 0;
}
function sum64_4_hi$1(n, o, a, u, c, p, d, w) {
  var S = 0, k = o;
  return S += (k = k + u >>> 0) < o ? 1 : 0, S += (k = k + p >>> 0) < p ? 1 : 0, n + a + c + d + (S += (k = k + w >>> 0) < w ? 1 : 0) >>> 0;
}
function sum64_4_lo$1(n, o, a, u, c, p, d, w) {
  return o + u + p + w >>> 0;
}
function sum64_5_hi$1(n, o, a, u, c, p, d, w, S, k) {
  var B = 0, I = o;
  return B += (I = I + u >>> 0) < o ? 1 : 0, B += (I = I + p >>> 0) < p ? 1 : 0, B += (I = I + w >>> 0) < w ? 1 : 0, n + a + c + d + S + (B += (I = I + k >>> 0) < k ? 1 : 0) >>> 0;
}
function sum64_5_lo$1(n, o, a, u, c, p, d, w, S, k) {
  return o + u + p + w + k >>> 0;
}
function rotr64_hi$1(n, o, a) {
  return (o << 32 - a | n >>> a) >>> 0;
}
function rotr64_lo$1(n, o, a) {
  return (n << 32 - a | o >>> a) >>> 0;
}
function shr64_hi$1(n, o, a) {
  return n >>> a;
}
function shr64_lo$1(n, o, a) {
  return (n << 32 - a | o >>> a) >>> 0;
}
utils$g.inherits = inherits, utils$g.toArray = toArray, utils$g.toHex = toHex, utils$g.htonl = htonl, utils$g.toHex32 = toHex32, utils$g.zero2 = zero2, utils$g.zero8 = zero8, utils$g.join32 = join32, utils$g.split32 = split32, utils$g.rotr32 = rotr32$1, utils$g.rotl32 = rotl32$2, utils$g.sum32 = sum32$3, utils$g.sum32_3 = sum32_3$1, utils$g.sum32_4 = sum32_4$2, utils$g.sum32_5 = sum32_5$2, utils$g.sum64 = sum64$1, utils$g.sum64_hi = sum64_hi$1, utils$g.sum64_lo = sum64_lo$1, utils$g.sum64_4_hi = sum64_4_hi$1, utils$g.sum64_4_lo = sum64_4_lo$1, utils$g.sum64_5_hi = sum64_5_hi$1, utils$g.sum64_5_lo = sum64_5_lo$1, utils$g.rotr64_hi = rotr64_hi$1, utils$g.rotr64_lo = rotr64_lo$1, utils$g.shr64_hi = shr64_hi$1, utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4, BlockHash$4.prototype.update = function(n, o) {
  if (n = utils$f.toArray(n, o), this.pending ? this.pending = this.pending.concat(n) : this.pending = n, this.pendingTotal += n.length, this.pending.length >= this._delta8) {
    var a = (n = this.pending).length % this._delta8;
    this.pending = n.slice(n.length - a, n.length), this.pending.length === 0 && (this.pending = null), n = utils$f.join32(n, 0, n.length - a, this.endian);
    for (var u = 0; u < n.length; u += this._delta32)
      this._update(n, u, u + this._delta32);
  }
  return this;
}, BlockHash$4.prototype.digest = function(n) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(n);
}, BlockHash$4.prototype._pad = function() {
  var n = this.pendingTotal, o = this._delta8, a = o - (n + this.padLength) % o, u = new Array(a + this.padLength);
  u[0] = 128;
  for (var c = 1; c < a; c++)
    u[c] = 0;
  if (n <<= 3, this.endian === "big") {
    for (var p = 8; p < this.padLength; p++)
      u[c++] = 0;
    u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = n >>> 24 & 255, u[c++] = n >>> 16 & 255, u[c++] = n >>> 8 & 255, u[c++] = 255 & n;
  } else
    for (u[c++] = 255 & n, u[c++] = n >>> 8 & 255, u[c++] = n >>> 16 & 255, u[c++] = n >>> 24 & 255, u[c++] = 0, u[c++] = 0, u[c++] = 0, u[c++] = 0, p = 8; p < this.padLength; p++)
      u[c++] = 0;
  return u;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(n, o, a, u) {
  return n === 0 ? ch32$1(o, a, u) : n === 1 || n === 3 ? p32(o, a, u) : n === 2 ? maj32$1(o, a, u) : void 0;
}
function ch32$1(n, o, a) {
  return n & o ^ ~n & a;
}
function maj32$1(n, o, a) {
  return n & o ^ n & a ^ o & a;
}
function p32(n, o, a) {
  return n ^ o ^ a;
}
function s0_256$1(n) {
  return rotr32(n, 2) ^ rotr32(n, 13) ^ rotr32(n, 22);
}
function s1_256$1(n) {
  return rotr32(n, 6) ^ rotr32(n, 11) ^ rotr32(n, 25);
}
function g0_256$1(n) {
  return rotr32(n, 7) ^ rotr32(n, 18) ^ n >>> 3;
}
function g1_256$1(n) {
  return rotr32(n, 17) ^ rotr32(n, 19) ^ n >>> 10;
}
common$4.ft_1 = ft_1$1, common$4.ch32 = ch32$1, common$4.maj32 = maj32$1, common$4.p32 = p32, common$4.s0_256 = s0_256$1, common$4.s1_256 = s1_256$1, common$4.g0_256 = g0_256$1, common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(n, o) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = n[o + u];
  for (; u < a.length; u++)
    a[u] = rotl32$1(a[u - 3] ^ a[u - 8] ^ a[u - 14] ^ a[u - 16], 1);
  var c = this.h[0], p = this.h[1], d = this.h[2], w = this.h[3], S = this.h[4];
  for (u = 0; u < a.length; u++) {
    var k = ~~(u / 20), B = sum32_5$1(rotl32$1(c, 5), ft_1(k, p, d, w), S, a[u], sha1_K[k]);
    S = w, w = d, d = rotl32$1(p, 30), p = c, c = B;
  }
  this.h[0] = sum32$2(this.h[0], c), this.h[1] = sum32$2(this.h[1], p), this.h[2] = sum32$2(this.h[2], d), this.h[3] = sum32$2(this.h[3], w), this.h[4] = sum32$2(this.h[4], S);
}, SHA1.prototype._digest = function(n) {
  return n === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512, SHA256$1.outSize = 256, SHA256$1.hmacStrength = 192, SHA256$1.padLength = 64, SHA256$1.prototype._update = function(n, o) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = n[o + u];
  for (; u < a.length; u++)
    a[u] = sum32_4$1(g1_256(a[u - 2]), a[u - 7], g0_256(a[u - 15]), a[u - 16]);
  var c = this.h[0], p = this.h[1], d = this.h[2], w = this.h[3], S = this.h[4], k = this.h[5], B = this.h[6], I = this.h[7];
  for (assert$9(this.k.length === a.length), u = 0; u < a.length; u++) {
    var C = sum32_5(I, s1_256(S), ch32(S, k, B), this.k[u], a[u]), P = sum32$1(s0_256(c), maj32(c, p, d));
    I = B, B = k, k = S, S = sum32$1(w, C), w = d, d = p, p = c, c = sum32$1(C, P);
  }
  this.h[0] = sum32$1(this.h[0], c), this.h[1] = sum32$1(this.h[1], p), this.h[2] = sum32$1(this.h[2], d), this.h[3] = sum32$1(this.h[3], w), this.h[4] = sum32$1(this.h[4], S), this.h[5] = sum32$1(this.h[5], k), this.h[6] = sum32$1(this.h[6], B), this.h[7] = sum32$1(this.h[7], I);
}, SHA256$1.prototype._digest = function(n) {
  return n === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(n) {
  return n === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
function ch64_hi(n, o, a, u, c) {
  var p = n & a ^ ~n & c;
  return p < 0 && (p += 4294967296), p;
}
function ch64_lo(n, o, a, u, c, p) {
  var d = o & u ^ ~o & p;
  return d < 0 && (d += 4294967296), d;
}
function maj64_hi(n, o, a, u, c) {
  var p = n & a ^ n & c ^ a & c;
  return p < 0 && (p += 4294967296), p;
}
function maj64_lo(n, o, a, u, c, p) {
  var d = o & u ^ o & p ^ u & p;
  return d < 0 && (d += 4294967296), d;
}
function s0_512_hi(n, o) {
  var a = rotr64_hi(n, o, 28) ^ rotr64_hi(o, n, 2) ^ rotr64_hi(o, n, 7);
  return a < 0 && (a += 4294967296), a;
}
function s0_512_lo(n, o) {
  var a = rotr64_lo(n, o, 28) ^ rotr64_lo(o, n, 2) ^ rotr64_lo(o, n, 7);
  return a < 0 && (a += 4294967296), a;
}
function s1_512_hi(n, o) {
  var a = rotr64_hi(n, o, 14) ^ rotr64_hi(n, o, 18) ^ rotr64_hi(o, n, 9);
  return a < 0 && (a += 4294967296), a;
}
function s1_512_lo(n, o) {
  var a = rotr64_lo(n, o, 14) ^ rotr64_lo(n, o, 18) ^ rotr64_lo(o, n, 9);
  return a < 0 && (a += 4294967296), a;
}
function g0_512_hi(n, o) {
  var a = rotr64_hi(n, o, 1) ^ rotr64_hi(n, o, 8) ^ shr64_hi(n, o, 7);
  return a < 0 && (a += 4294967296), a;
}
function g0_512_lo(n, o) {
  var a = rotr64_lo(n, o, 1) ^ rotr64_lo(n, o, 8) ^ shr64_lo(n, o, 7);
  return a < 0 && (a += 4294967296), a;
}
function g1_512_hi(n, o) {
  var a = rotr64_hi(n, o, 19) ^ rotr64_hi(o, n, 29) ^ shr64_hi(n, o, 6);
  return a < 0 && (a += 4294967296), a;
}
function g1_512_lo(n, o) {
  var a = rotr64_lo(n, o, 19) ^ rotr64_lo(o, n, 29) ^ shr64_lo(n, o, 6);
  return a < 0 && (a += 4294967296), a;
}
SHA512$1.blockSize = 1024, SHA512$1.outSize = 512, SHA512$1.hmacStrength = 192, SHA512$1.padLength = 128, SHA512$1.prototype._prepareBlock = function(n, o) {
  for (var a = this.W, u = 0; u < 32; u++)
    a[u] = n[o + u];
  for (; u < a.length; u += 2) {
    var c = g1_512_hi(a[u - 4], a[u - 3]), p = g1_512_lo(a[u - 4], a[u - 3]), d = a[u - 14], w = a[u - 13], S = g0_512_hi(a[u - 30], a[u - 29]), k = g0_512_lo(a[u - 30], a[u - 29]), B = a[u - 32], I = a[u - 31];
    a[u] = sum64_4_hi(c, p, d, w, S, k, B, I), a[u + 1] = sum64_4_lo(c, p, d, w, S, k, B, I);
  }
}, SHA512$1.prototype._update = function(n, o) {
  this._prepareBlock(n, o);
  var a = this.W, u = this.h[0], c = this.h[1], p = this.h[2], d = this.h[3], w = this.h[4], S = this.h[5], k = this.h[6], B = this.h[7], I = this.h[8], C = this.h[9], P = this.h[10], q = this.h[11], D = this.h[12], z = this.h[13], F = this.h[14], V = this.h[15];
  assert$8(this.k.length === a.length);
  for (var Z = 0; Z < a.length; Z += 2) {
    var N = F, W = V, H = s1_512_hi(I, C), te = s1_512_lo(I, C), g = ch64_hi(I, C, P, q, D), $ = ch64_lo(I, C, P, q, D, z), _ = this.k[Z], b = this.k[Z + 1], m = a[Z], v = a[Z + 1], E = sum64_5_hi(N, W, H, te, g, $, _, b, m, v), T = sum64_5_lo(N, W, H, te, g, $, _, b, m, v);
    N = s0_512_hi(u, c), W = s0_512_lo(u, c), H = maj64_hi(u, c, p, d, w), te = maj64_lo(u, c, p, d, w, S);
    var j = sum64_hi(N, W, H, te), L = sum64_lo(N, W, H, te);
    F = D, V = z, D = P, z = q, P = I, q = C, I = sum64_hi(k, B, E, T), C = sum64_lo(B, B, E, T), k = w, B = S, w = p, S = d, p = u, d = c, u = sum64_hi(E, T, j, L), c = sum64_lo(E, T, j, L);
  }
  sum64(this.h, 0, u, c), sum64(this.h, 2, p, d), sum64(this.h, 4, w, S), sum64(this.h, 6, k, B), sum64(this.h, 8, I, C), sum64(this.h, 10, P, q), sum64(this.h, 12, D, z), sum64(this.h, 14, F, V);
}, SHA512$1.prototype._digest = function(n) {
  return n === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(n) {
  return n === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
}, sha.sha1 = _1, sha.sha224 = _224, sha.sha256 = _256, sha.sha384 = _384, sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
function f(n, o, a, u) {
  return n <= 15 ? o ^ a ^ u : n <= 31 ? o & a | ~o & u : n <= 47 ? (o | ~a) ^ u : n <= 63 ? o & u | a & ~u : o ^ (a | ~u);
}
function K(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function Kh(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
utils$8.inherits(RIPEMD160, BlockHash), ripemd.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(n, o) {
  for (var a = this.h[0], u = this.h[1], c = this.h[2], p = this.h[3], d = this.h[4], w = a, S = u, k = c, B = p, I = d, C = 0; C < 80; C++) {
    var P = sum32(rotl32(sum32_4(a, f(C, u, c, p), n[r[C] + o], K(C)), s[C]), d);
    a = d, d = p, p = rotl32(c, 10), c = u, u = P, P = sum32(rotl32(sum32_4(w, f(79 - C, S, k, B), n[rh[C] + o], Kh(C)), sh[C]), I), w = I, I = B, B = rotl32(k, 10), k = S, S = P;
  }
  P = sum32_3(this.h[1], c, B), this.h[1] = sum32_3(this.h[2], p, I), this.h[2] = sum32_3(this.h[3], d, w), this.h[3] = sum32_3(this.h[4], a, S), this.h[4] = sum32_3(this.h[0], u, k), this.h[0] = P;
}, RIPEMD160.prototype._digest = function(n) {
  return n === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(n, o, a) {
  if (!(this instanceof Hmac))
    return new Hmac(n, o, a);
  this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(o, a));
}
var hmac = Hmac, secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 ? secp256k1 : (hasRequiredSecp256k1 = 1, secp256k1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } });
}
Hmac.prototype._init = function(n) {
  n.length > this.blockSize && (n = new this.Hash().update(n).digest()), assert$7(n.length <= this.blockSize);
  for (var o = n.length; o < this.blockSize; o++)
    n.push(0);
  for (o = 0; o < n.length; o++)
    n[o] ^= 54;
  for (this.inner = new this.Hash().update(n), o = 0; o < n.length; o++)
    n[o] ^= 106;
  this.outer = new this.Hash().update(n);
}, Hmac.prototype.update = function(n, o) {
  return this.inner.update(n, o), this;
}, Hmac.prototype.digest = function(n) {
  return this.outer.update(this.inner.digest()), this.outer.digest(n);
}, function(n) {
  var o = hash$2;
  o.utils = utils$g, o.common = common$5, o.sha = sha, o.ripemd = ripemd, o.hmac = hmac, o.sha1 = o.sha.sha1, o.sha256 = o.sha.sha256, o.sha224 = o.sha.sha224, o.sha384 = o.sha.sha384, o.sha512 = o.sha.sha512, o.ripemd160 = o.ripemd.ripemd160;
}(), function(n) {
  var o, a = curves$2, u = hash$2, c = curve, p = utils$m.assert;
  function d(S) {
    S.type === "short" ? this.curve = new c.short(S) : S.type === "edwards" ? this.curve = new c.edwards(S) : this.curve = new c.mont(S), this.g = this.curve.g, this.n = this.curve.n, this.hash = S.hash, p(this.g.validate(), "Invalid curve"), p(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  function w(S, k) {
    Object.defineProperty(a, S, { configurable: !0, enumerable: !0, get: function() {
      var B = new d(k);
      return Object.defineProperty(a, S, { configurable: !0, enumerable: !0, value: B }), B;
    } });
  }
  a.PresetCurve = d, w("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: u.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), w("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: u.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), w("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: u.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), w("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: u.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), w("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: u.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), w("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["9"] }), w("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  try {
    o = requireSecp256k1();
  } catch {
    o = void 0;
  }
  w("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: u.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", o] });
}();
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG$1(n) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(n);
  this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var o = utils$6.toArray(n.entropy, n.entropyEnc || "hex"), a = utils$6.toArray(n.nonce, n.nonceEnc || "hex"), u = utils$6.toArray(n.pers, n.persEnc || "hex");
  assert$6(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(o, a, u);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(n, o, a) {
  var u = n.concat(o).concat(a);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var c = 0; c < this.V.length; c++)
    this.K[c] = 0, this.V[c] = 1;
  this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
}, HmacDRBG$1.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
}, HmacDRBG$1.prototype._update = function(n) {
  var o = this._hmac().update(this.V).update([0]);
  n && (o = o.update(n)), this.K = o.digest(), this.V = this._hmac().update(this.V).digest(), n && (this.K = this._hmac().update(this.V).update([1]).update(n).digest(), this.V = this._hmac().update(this.V).digest());
}, HmacDRBG$1.prototype.reseed = function(n, o, a, u) {
  typeof o != "string" && (u = a, a = o, o = null), n = utils$6.toArray(n, o), a = utils$6.toArray(a, u), assert$6(n.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(n.concat(a || [])), this._reseed = 1;
}, HmacDRBG$1.prototype.generate = function(n, o, a, u) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof o != "string" && (u = a, a = o, o = null), a && (a = utils$6.toArray(a, u || "hex"), this._update(a));
  for (var c = []; c.length < n; )
    this.V = this._hmac().update(this.V).digest(), c = c.concat(this.V);
  var p = c.slice(0, n);
  return this._update(a), this._reseed++, utils$6.encode(p, o);
};
var BN$4 = bn$2.exports, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$3(n, o) {
  this.ec = n, this.priv = null, this.pub = null, o.priv && this._importPrivate(o.priv, o.privEnc), o.pub && this._importPublic(o.pub, o.pubEnc);
}
var key$2 = KeyPair$3;
KeyPair$3.fromPublic = function(n, o, a) {
  return o instanceof KeyPair$3 ? o : new KeyPair$3(n, { pub: o, pubEnc: a });
}, KeyPair$3.fromPrivate = function(n, o, a) {
  return o instanceof KeyPair$3 ? o : new KeyPair$3(n, { priv: o, privEnc: a });
}, KeyPair$3.prototype.validate = function() {
  var n = this.getPublic();
  return n.isInfinity() ? { result: !1, reason: "Invalid public key" } : n.validate() ? n.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
}, KeyPair$3.prototype.getPublic = function(n, o) {
  return typeof n == "string" && (o = n, n = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), o ? this.pub.encode(o, n) : this.pub;
}, KeyPair$3.prototype.getPrivate = function(n) {
  return n === "hex" ? this.priv.toString(16, 2) : this.priv;
}, KeyPair$3.prototype._importPrivate = function(n, o) {
  this.priv = new BN$4(n, o || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, KeyPair$3.prototype._importPublic = function(n, o) {
  if (n.x || n.y)
    return this.ec.curve.type === "mont" ? assert$5(n.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || assert$5(n.x && n.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(n.x, n.y));
  this.pub = this.ec.curve.decodePoint(n, o);
}, KeyPair$3.prototype.derive = function(n) {
  return n.validate() || assert$5(n.validate(), "public point not validated"), n.mul(this.priv).getX();
}, KeyPair$3.prototype.sign = function(n, o, a) {
  return this.ec.sign(n, this, o, a);
}, KeyPair$3.prototype.verify = function(n, o) {
  return this.ec.verify(n, o, this);
}, KeyPair$3.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$3 = bn$2.exports, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$3(n, o) {
  if (n instanceof Signature$3)
    return n;
  this._importDER(n, o) || (assert$4(n.r && n.s, "Signature without r or s"), this.r = new BN$3(n.r, 16), this.s = new BN$3(n.s, 16), n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam);
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(n, o) {
  var a = n[o.place++];
  if (!(128 & a))
    return a;
  var u = 15 & a;
  if (u === 0 || u > 4)
    return !1;
  for (var c = 0, p = 0, d = o.place; p < u; p++, d++)
    c <<= 8, c |= n[d], c >>>= 0;
  return !(c <= 127) && (o.place = d, c);
}
function rmPadding(n) {
  for (var o = 0, a = n.length - 1; !n[o] && !(128 & n[o + 1]) && o < a; )
    o++;
  return o === 0 ? n : n.slice(o);
}
function constructLength(n, o) {
  if (o < 128)
    n.push(o);
  else {
    var a = 1 + (Math.log(o) / Math.LN2 >>> 3);
    for (n.push(128 | a); --a; )
      n.push(o >>> (a << 3) & 255);
    n.push(o);
  }
}
Signature$3.prototype._importDER = function(n, o) {
  n = utils$4.toArray(n, o);
  var a = new Position();
  if (n[a.place++] !== 48)
    return !1;
  var u = getLength(n, a);
  if (u === !1 || u + a.place !== n.length || n[a.place++] !== 2)
    return !1;
  var c = getLength(n, a);
  if (c === !1)
    return !1;
  var p = n.slice(a.place, c + a.place);
  if (a.place += c, n[a.place++] !== 2)
    return !1;
  var d = getLength(n, a);
  if (d === !1 || n.length !== d + a.place)
    return !1;
  var w = n.slice(a.place, d + a.place);
  if (p[0] === 0) {
    if (!(128 & p[1]))
      return !1;
    p = p.slice(1);
  }
  if (w[0] === 0) {
    if (!(128 & w[1]))
      return !1;
    w = w.slice(1);
  }
  return this.r = new BN$3(p), this.s = new BN$3(w), this.recoveryParam = null, !0;
}, Signature$3.prototype.toDER = function(n) {
  var o = this.r.toArray(), a = this.s.toArray();
  for (128 & o[0] && (o = [0].concat(o)), 128 & a[0] && (a = [0].concat(a)), o = rmPadding(o), a = rmPadding(a); !(a[0] || 128 & a[1]); )
    a = a.slice(1);
  var u = [2];
  constructLength(u, o.length), (u = u.concat(o)).push(2), constructLength(u, a.length);
  var c = u.concat(a), p = [48];
  return constructLength(p, c.length), p = p.concat(c), utils$4.encode(p, n);
};
var BN$2 = bn$2.exports, HmacDRBG = hmacDrbg, utils$3 = utils$m, curves$1 = curves$2, rand = brorand.exports, assert$3 = utils$3.assert, KeyPair$2 = key$2, Signature$2 = signature$1;
function EC$3(n) {
  if (!(this instanceof EC$3))
    return new EC$3(n);
  typeof n == "string" && (assert$3(Object.prototype.hasOwnProperty.call(curves$1, n), "Unknown curve " + n), n = curves$1[n]), n instanceof curves$1.PresetCurve && (n = { curve: n }), this.curve = n.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = n.curve.g, this.g.precompute(n.curve.n.bitLength() + 1), this.hash = n.hash || n.curve.hash;
}
var ec = EC$3;
EC$3.prototype.keyPair = function(n) {
  return new KeyPair$2(this, n);
}, EC$3.prototype.keyFromPrivate = function(n, o) {
  return KeyPair$2.fromPrivate(this, n, o);
}, EC$3.prototype.keyFromPublic = function(n, o) {
  return KeyPair$2.fromPublic(this, n, o);
}, EC$3.prototype.genKeyPair = function(n) {
  n || (n = {});
  for (var o = new HmacDRBG({ hash: this.hash, pers: n.pers, persEnc: n.persEnc || "utf8", entropy: n.entropy || rand(this.hash.hmacStrength), entropyEnc: n.entropy && n.entropyEnc || "utf8", nonce: this.n.toArray() }), a = this.n.byteLength(), u = this.n.sub(new BN$2(2)); ; ) {
    var c = new BN$2(o.generate(a));
    if (!(c.cmp(u) > 0))
      return c.iaddn(1), this.keyFromPrivate(c);
  }
}, EC$3.prototype._truncateToN = function(n, o) {
  var a = 8 * n.byteLength() - this.n.bitLength();
  return a > 0 && (n = n.ushrn(a)), !o && n.cmp(this.n) >= 0 ? n.sub(this.n) : n;
}, EC$3.prototype.sign = function(n, o, a, u) {
  typeof a == "object" && (u = a, a = null), u || (u = {}), o = this.keyFromPrivate(o, a), n = this._truncateToN(new BN$2(n, 16));
  for (var c = this.n.byteLength(), p = o.getPrivate().toArray("be", c), d = n.toArray("be", c), w = new HmacDRBG({ hash: this.hash, entropy: p, nonce: d, pers: u.pers, persEnc: u.persEnc || "utf8" }), S = this.n.sub(new BN$2(1)), k = 0; ; k++) {
    var B = u.k ? u.k(k) : new BN$2(w.generate(this.n.byteLength()));
    if (!((B = this._truncateToN(B, !0)).cmpn(1) <= 0 || B.cmp(S) >= 0)) {
      var I = this.g.mul(B);
      if (!I.isInfinity()) {
        var C = I.getX(), P = C.umod(this.n);
        if (P.cmpn(0) !== 0) {
          var q = B.invm(this.n).mul(P.mul(o.getPrivate()).iadd(n));
          if ((q = q.umod(this.n)).cmpn(0) !== 0) {
            var D = (I.getY().isOdd() ? 1 : 0) | (C.cmp(P) !== 0 ? 2 : 0);
            return u.canonical && q.cmp(this.nh) > 0 && (q = this.n.sub(q), D ^= 1), new Signature$2({ r: P, s: q, recoveryParam: D });
          }
        }
      }
    }
  }
}, EC$3.prototype.verify = function(n, o, a, u) {
  n = this._truncateToN(new BN$2(n, 16)), a = this.keyFromPublic(a, u);
  var c = (o = new Signature$2(o, "hex")).r, p = o.s;
  if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0 || p.cmpn(1) < 0 || p.cmp(this.n) >= 0)
    return !1;
  var d, w = p.invm(this.n), S = w.mul(n).umod(this.n), k = w.mul(c).umod(this.n);
  return this.curve._maxwellTrick ? !(d = this.g.jmulAdd(S, a.getPublic(), k)).isInfinity() && d.eqXToP(c) : !(d = this.g.mulAdd(S, a.getPublic(), k)).isInfinity() && d.getX().umod(this.n).cmp(c) === 0;
}, EC$3.prototype.recoverPubKey = function(n, o, a, u) {
  assert$3((3 & a) === a, "The recovery param is more than two bits"), o = new Signature$2(o, u);
  var c = this.n, p = new BN$2(n), d = o.r, w = o.s, S = 1 & a, k = a >> 1;
  if (d.cmp(this.curve.p.umod(this.curve.n)) >= 0 && k)
    throw new Error("Unable to find sencond key candinate");
  d = k ? this.curve.pointFromX(d.add(this.curve.n), S) : this.curve.pointFromX(d, S);
  var B = o.r.invm(c), I = c.sub(p).mul(B).umod(c), C = w.mul(B).umod(c);
  return this.g.mulAdd(I, d, C);
}, EC$3.prototype.getKeyRecoveryParam = function(n, o, a, u) {
  if ((o = new Signature$2(o, u)).recoveryParam !== null)
    return o.recoveryParam;
  for (var c = 0; c < 4; c++) {
    var p;
    try {
      p = this.recoverPubKey(n, o, c);
    } catch {
      continue;
    }
    if (p.eq(a))
      return c;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$2 = utils$m, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(n, o) {
  this.eddsa = n, this._secret = parseBytes$2(o.secret), n.isPoint(o.pub) ? this._pub = o.pub : this._pubBytes = parseBytes$2(o.pub);
}
KeyPair$1.fromPublic = function(n, o) {
  return o instanceof KeyPair$1 ? o : new KeyPair$1(n, { pub: o });
}, KeyPair$1.fromSecret = function(n, o) {
  return o instanceof KeyPair$1 ? o : new KeyPair$1(n, { secret: o });
}, KeyPair$1.prototype.secret = function() {
  return this._secret;
}, cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
}), cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
}), cachedProperty$1(KeyPair$1, "privBytes", function() {
  var n = this.eddsa, o = this.hash(), a = n.encodingLength - 1, u = o.slice(0, n.encodingLength);
  return u[0] &= 248, u[a] &= 127, u[a] |= 64, u;
}), cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
}), cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
}), cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
}), KeyPair$1.prototype.sign = function(n) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(n, this);
}, KeyPair$1.prototype.verify = function(n, o) {
  return this.eddsa.verify(n, o, this);
}, KeyPair$1.prototype.getSecret = function(n) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), n);
}, KeyPair$1.prototype.getPublic = function(n) {
  return utils$2.encode(this.pubBytes(), n);
};
var key$1 = KeyPair$1, BN$1 = bn$2.exports, utils$1 = utils$m, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(n, o) {
  this.eddsa = n, typeof o != "object" && (o = parseBytes$1(o)), Array.isArray(o) && (o = { R: o.slice(0, n.encodingLength), S: o.slice(n.encodingLength) }), assert$1(o.R && o.S, "Signature without R or S"), n.isPoint(o.R) && (this._R = o.R), o.S instanceof BN$1 && (this._S = o.S), this._Rencoded = Array.isArray(o.R) ? o.R : o.Rencoded, this._Sencoded = Array.isArray(o.S) ? o.S : o.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
}), cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
}), cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
}), cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
}), Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
}, Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$2, utils = utils$m, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(n) {
  if (assert(n === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(n);
  n = curves[n].curve, this.curve = n, this.g = n.g, this.g.precompute(n.n.bitLength() + 1), this.pointClass = n.point().constructor, this.encodingLength = Math.ceil(n.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(n, o) {
  n = parseBytes(n);
  var a = this.keyFromSecret(o), u = this.hashInt(a.messagePrefix(), n), c = this.g.mul(u), p = this.encodePoint(c), d = this.hashInt(p, a.pubBytes(), n).mul(a.priv()), w = u.add(d).umod(this.curve.n);
  return this.makeSignature({ R: c, S: w, Rencoded: p });
}, EDDSA.prototype.verify = function(n, o, a) {
  n = parseBytes(n), o = this.makeSignature(o);
  var u = this.keyFromPublic(a), c = this.hashInt(o.Rencoded(), u.pubBytes(), n), p = this.g.mul(o.S());
  return o.R().add(u.pub().mul(c)).eq(p);
}, EDDSA.prototype.hashInt = function() {
  for (var n = this.hash(), o = 0; o < arguments.length; o++)
    n.update(arguments[o]);
  return utils.intFromLE(n.digest()).umod(this.curve.n);
}, EDDSA.prototype.keyFromPublic = function(n) {
  return KeyPair.fromPublic(this, n);
}, EDDSA.prototype.keyFromSecret = function(n) {
  return KeyPair.fromSecret(this, n);
}, EDDSA.prototype.makeSignature = function(n) {
  return n instanceof Signature ? n : new Signature(this, n);
}, EDDSA.prototype.encodePoint = function(n) {
  var o = n.getY().toArray("le", this.encodingLength);
  return o[this.encodingLength - 1] |= n.getX().isOdd() ? 128 : 0, o;
}, EDDSA.prototype.decodePoint = function(n) {
  var o = (n = utils.parseBytes(n)).length - 1, a = n.slice(0, o).concat(-129 & n[o]), u = (128 & n[o]) != 0, c = utils.intFromLE(a);
  return this.curve.pointFromY(c, u);
}, EDDSA.prototype.encodeInt = function(n) {
  return n.toArray("le", this.encodingLength);
}, EDDSA.prototype.decodeInt = function(n) {
  return utils.intFromLE(n);
}, EDDSA.prototype.isPoint = function(n) {
  return n instanceof this.pointClass;
}, function(n) {
  var o = elliptic$1;
  o.version = require$$0$2.version, o.utils = utils$m, o.rand = brorand.exports, o.curve = curve, o.curves = curves$2, o.ec = ec, o.eddsa = eddsa;
}();
var bn$1 = { exports: {} };
(function(n, o) {
  function a(_, b) {
    if (!_)
      throw new Error(b || "Assertion failed");
  }
  function u(_, b) {
    _.super_ = b;
    var m = function() {
    };
    m.prototype = b.prototype, _.prototype = new m(), _.prototype.constructor = _;
  }
  function c(_, b, m) {
    if (c.isBN(_))
      return _;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null && (b !== "le" && b !== "be" || (m = b, b = 10), this._init(_ || 0, b || 10, m || "be"));
  }
  var p;
  typeof bn$1 == "object" ? bn$1.exports = c : o.BN = c, c.BN = c, c.wordSize = 26;
  try {
    p = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(_, b) {
    var m = _.charCodeAt(b);
    return m >= 48 && m <= 57 ? m - 48 : m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : void a(!1, "Invalid character in " + _);
  }
  function w(_, b, m) {
    var v = d(_, m);
    return m - 1 >= b && (v |= d(_, m - 1) << 4), v;
  }
  function S(_, b, m, v) {
    for (var E = 0, T = 0, j = Math.min(_.length, m), L = b; L < j; L++) {
      var J = _.charCodeAt(L) - 48;
      E *= v, T = J >= 49 ? J - 49 + 10 : J >= 17 ? J - 17 + 10 : J, a(J >= 0 && T < v, "Invalid character"), E += T;
    }
    return E;
  }
  function k(_, b) {
    _.words = b.words, _.length = b.length, _.negative = b.negative, _.red = b.red;
  }
  if (c.isBN = function(_) {
    return _ instanceof c || _ !== null && typeof _ == "object" && _.constructor.wordSize === c.wordSize && Array.isArray(_.words);
  }, c.max = function(_, b) {
    return _.cmp(b) > 0 ? _ : b;
  }, c.min = function(_, b) {
    return _.cmp(b) < 0 ? _ : b;
  }, c.prototype._init = function(_, b, m) {
    if (typeof _ == "number")
      return this._initNumber(_, b, m);
    if (typeof _ == "object")
      return this._initArray(_, b, m);
    b === "hex" && (b = 16), a(b === (0 | b) && b >= 2 && b <= 36);
    var v = 0;
    (_ = _.toString().replace(/\s+/g, ""))[0] === "-" && (v++, this.negative = 1), v < _.length && (b === 16 ? this._parseHex(_, v, m) : (this._parseBase(_, b, v), m === "le" && this._initArray(this.toArray(), b, m)));
  }, c.prototype._initNumber = function(_, b, m) {
    _ < 0 && (this.negative = 1, _ = -_), _ < 67108864 ? (this.words = [67108863 & _], this.length = 1) : _ < 4503599627370496 ? (this.words = [67108863 & _, _ / 67108864 & 67108863], this.length = 2) : (a(_ < 9007199254740992), this.words = [67108863 & _, _ / 67108864 & 67108863, 1], this.length = 3), m === "le" && this._initArray(this.toArray(), b, m);
  }, c.prototype._initArray = function(_, b, m) {
    if (a(typeof _.length == "number"), _.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(_.length / 3), this.words = new Array(this.length);
    for (var v = 0; v < this.length; v++)
      this.words[v] = 0;
    var E, T, j = 0;
    if (m === "be")
      for (v = _.length - 1, E = 0; v >= 0; v -= 3)
        T = _[v] | _[v - 1] << 8 | _[v - 2] << 16, this.words[E] |= T << j & 67108863, this.words[E + 1] = T >>> 26 - j & 67108863, (j += 24) >= 26 && (j -= 26, E++);
    else if (m === "le")
      for (v = 0, E = 0; v < _.length; v += 3)
        T = _[v] | _[v + 1] << 8 | _[v + 2] << 16, this.words[E] |= T << j & 67108863, this.words[E + 1] = T >>> 26 - j & 67108863, (j += 24) >= 26 && (j -= 26, E++);
    return this._strip();
  }, c.prototype._parseHex = function(_, b, m) {
    this.length = Math.ceil((_.length - b) / 6), this.words = new Array(this.length);
    for (var v = 0; v < this.length; v++)
      this.words[v] = 0;
    var E, T = 0, j = 0;
    if (m === "be")
      for (v = _.length - 1; v >= b; v -= 2)
        E = w(_, b, v) << T, this.words[j] |= 67108863 & E, T >= 18 ? (T -= 18, j += 1, this.words[j] |= E >>> 26) : T += 8;
    else
      for (v = (_.length - b) % 2 == 0 ? b + 1 : b; v < _.length; v += 2)
        E = w(_, b, v) << T, this.words[j] |= 67108863 & E, T >= 18 ? (T -= 18, j += 1, this.words[j] |= E >>> 26) : T += 8;
    this._strip();
  }, c.prototype._parseBase = function(_, b, m) {
    this.words = [0], this.length = 1;
    for (var v = 0, E = 1; E <= 67108863; E *= b)
      v++;
    v--, E = E / b | 0;
    for (var T = _.length - m, j = T % v, L = Math.min(T, T - j) + m, J = 0, Y = m; Y < L; Y += v)
      J = S(_, Y, Y + v, b), this.imuln(E), this.words[0] + J < 67108864 ? this.words[0] += J : this._iaddn(J);
    if (j !== 0) {
      var ne = 1;
      for (J = S(_, Y, _.length, b), Y = 0; Y < j; Y++)
        ne *= b;
      this.imuln(ne), this.words[0] + J < 67108864 ? this.words[0] += J : this._iaddn(J);
    }
    this._strip();
  }, c.prototype.copy = function(_) {
    _.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      _.words[b] = this.words[b];
    _.length = this.length, _.negative = this.negative, _.red = this.red;
  }, c.prototype._move = function(_) {
    k(_, this);
  }, c.prototype.clone = function() {
    var _ = new c(null);
    return this.copy(_), _;
  }, c.prototype._expand = function(_) {
    for (; this.length < _; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype._strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, typeof Symbol < "u" && typeof Symbol.for == "function")
    try {
      c.prototype[Symbol.for("nodejs.util.inspect.custom")] = B;
    } catch {
      c.prototype.inspect = B;
    }
  else
    c.prototype.inspect = B;
  function B() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  }
  var I = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], C = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], P = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function q(_, b, m) {
    m.negative = b.negative ^ _.negative;
    var v = _.length + b.length | 0;
    m.length = v, v = v - 1 | 0;
    var E = 0 | _.words[0], T = 0 | b.words[0], j = E * T, L = 67108863 & j, J = j / 67108864 | 0;
    m.words[0] = L;
    for (var Y = 1; Y < v; Y++) {
      for (var ne = J >>> 26, Q = 67108863 & J, oe = Math.min(Y, b.length - 1), ae = Math.max(0, Y - _.length + 1); ae <= oe; ae++) {
        var ce = Y - ae | 0;
        ne += (j = (E = 0 | _.words[ce]) * (T = 0 | b.words[ae]) + Q) / 67108864 | 0, Q = 67108863 & j;
      }
      m.words[Y] = 0 | Q, J = 0 | ne;
    }
    return J !== 0 ? m.words[Y] = 0 | J : m.length--, m._strip();
  }
  c.prototype.toString = function(_, b) {
    var m;
    if (b = 0 | b || 1, (_ = _ || 10) === 16 || _ === "hex") {
      m = "";
      for (var v = 0, E = 0, T = 0; T < this.length; T++) {
        var j = this.words[T], L = (16777215 & (j << v | E)).toString(16);
        E = j >>> 24 - v & 16777215, (v += 2) >= 26 && (v -= 26, T--), m = E !== 0 || T !== this.length - 1 ? I[6 - L.length] + L + m : L + m;
      }
      for (E !== 0 && (m = E.toString(16) + m); m.length % b != 0; )
        m = "0" + m;
      return this.negative !== 0 && (m = "-" + m), m;
    }
    if (_ === (0 | _) && _ >= 2 && _ <= 36) {
      var J = C[_], Y = P[_];
      m = "";
      var ne = this.clone();
      for (ne.negative = 0; !ne.isZero(); ) {
        var Q = ne.modrn(Y).toString(_);
        m = (ne = ne.idivn(Y)).isZero() ? Q + m : I[J - Q.length] + Q + m;
      }
      for (this.isZero() && (m = "0" + m); m.length % b != 0; )
        m = "0" + m;
      return this.negative !== 0 && (m = "-" + m), m;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var _ = this.words[0];
    return this.length === 2 ? _ += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? _ += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -_ : _;
  }, c.prototype.toJSON = function() {
    return this.toString(16, 2);
  }, p && (c.prototype.toBuffer = function(_, b) {
    return this.toArrayLike(p, _, b);
  }), c.prototype.toArray = function(_, b) {
    return this.toArrayLike(Array, _, b);
  }, c.prototype.toArrayLike = function(_, b, m) {
    this._strip();
    var v = this.byteLength(), E = m || Math.max(1, v);
    a(v <= E, "byte array longer than desired length"), a(E > 0, "Requested array length <= 0");
    var T = function(j, L) {
      return j.allocUnsafe ? j.allocUnsafe(L) : new j(L);
    }(_, E);
    return this["_toArrayLike" + (b === "le" ? "LE" : "BE")](T, v), T;
  }, c.prototype._toArrayLikeLE = function(_, b) {
    for (var m = 0, v = 0, E = 0, T = 0; E < this.length; E++) {
      var j = this.words[E] << T | v;
      _[m++] = 255 & j, m < _.length && (_[m++] = j >> 8 & 255), m < _.length && (_[m++] = j >> 16 & 255), T === 6 ? (m < _.length && (_[m++] = j >> 24 & 255), v = 0, T = 0) : (v = j >>> 24, T += 2);
    }
    if (m < _.length)
      for (_[m++] = v; m < _.length; )
        _[m++] = 0;
  }, c.prototype._toArrayLikeBE = function(_, b) {
    for (var m = _.length - 1, v = 0, E = 0, T = 0; E < this.length; E++) {
      var j = this.words[E] << T | v;
      _[m--] = 255 & j, m >= 0 && (_[m--] = j >> 8 & 255), m >= 0 && (_[m--] = j >> 16 & 255), T === 6 ? (m >= 0 && (_[m--] = j >> 24 & 255), v = 0, T = 0) : (v = j >>> 24, T += 2);
    }
    if (m >= 0)
      for (_[m--] = v; m >= 0; )
        _[m--] = 0;
  }, Math.clz32 ? c.prototype._countBits = function(_) {
    return 32 - Math.clz32(_);
  } : c.prototype._countBits = function(_) {
    var b = _, m = 0;
    return b >= 4096 && (m += 13, b >>>= 13), b >= 64 && (m += 7, b >>>= 7), b >= 8 && (m += 4, b >>>= 4), b >= 2 && (m += 2, b >>>= 2), m + b;
  }, c.prototype._zeroBits = function(_) {
    if (_ === 0)
      return 26;
    var b = _, m = 0;
    return (8191 & b) == 0 && (m += 13, b >>>= 13), (127 & b) == 0 && (m += 7, b >>>= 7), (15 & b) == 0 && (m += 4, b >>>= 4), (3 & b) == 0 && (m += 2, b >>>= 2), (1 & b) == 0 && m++, m;
  }, c.prototype.bitLength = function() {
    var _ = this.words[this.length - 1], b = this._countBits(_);
    return 26 * (this.length - 1) + b;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var _ = 0, b = 0; b < this.length; b++) {
      var m = this._zeroBits(this.words[b]);
      if (_ += m, m !== 26)
        break;
    }
    return _;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(_) {
    return this.negative !== 0 ? this.abs().inotn(_).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(_) {
    return this.testn(_ - 1) ? this.notn(_).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(_) {
    for (; this.length < _.length; )
      this.words[this.length++] = 0;
    for (var b = 0; b < _.length; b++)
      this.words[b] = this.words[b] | _.words[b];
    return this._strip();
  }, c.prototype.ior = function(_) {
    return a((this.negative | _.negative) == 0), this.iuor(_);
  }, c.prototype.or = function(_) {
    return this.length > _.length ? this.clone().ior(_) : _.clone().ior(this);
  }, c.prototype.uor = function(_) {
    return this.length > _.length ? this.clone().iuor(_) : _.clone().iuor(this);
  }, c.prototype.iuand = function(_) {
    var b;
    b = this.length > _.length ? _ : this;
    for (var m = 0; m < b.length; m++)
      this.words[m] = this.words[m] & _.words[m];
    return this.length = b.length, this._strip();
  }, c.prototype.iand = function(_) {
    return a((this.negative | _.negative) == 0), this.iuand(_);
  }, c.prototype.and = function(_) {
    return this.length > _.length ? this.clone().iand(_) : _.clone().iand(this);
  }, c.prototype.uand = function(_) {
    return this.length > _.length ? this.clone().iuand(_) : _.clone().iuand(this);
  }, c.prototype.iuxor = function(_) {
    var b, m;
    this.length > _.length ? (b = this, m = _) : (b = _, m = this);
    for (var v = 0; v < m.length; v++)
      this.words[v] = b.words[v] ^ m.words[v];
    if (this !== b)
      for (; v < b.length; v++)
        this.words[v] = b.words[v];
    return this.length = b.length, this._strip();
  }, c.prototype.ixor = function(_) {
    return a((this.negative | _.negative) == 0), this.iuxor(_);
  }, c.prototype.xor = function(_) {
    return this.length > _.length ? this.clone().ixor(_) : _.clone().ixor(this);
  }, c.prototype.uxor = function(_) {
    return this.length > _.length ? this.clone().iuxor(_) : _.clone().iuxor(this);
  }, c.prototype.inotn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var b = 0 | Math.ceil(_ / 26), m = _ % 26;
    this._expand(b), m > 0 && b--;
    for (var v = 0; v < b; v++)
      this.words[v] = 67108863 & ~this.words[v];
    return m > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - m), this._strip();
  }, c.prototype.notn = function(_) {
    return this.clone().inotn(_);
  }, c.prototype.setn = function(_, b) {
    a(typeof _ == "number" && _ >= 0);
    var m = _ / 26 | 0, v = _ % 26;
    return this._expand(m + 1), this.words[m] = b ? this.words[m] | 1 << v : this.words[m] & ~(1 << v), this._strip();
  }, c.prototype.iadd = function(_) {
    var b, m, v;
    if (this.negative !== 0 && _.negative === 0)
      return this.negative = 0, b = this.isub(_), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && _.negative !== 0)
      return _.negative = 0, b = this.isub(_), _.negative = 1, b._normSign();
    this.length > _.length ? (m = this, v = _) : (m = _, v = this);
    for (var E = 0, T = 0; T < v.length; T++)
      b = (0 | m.words[T]) + (0 | v.words[T]) + E, this.words[T] = 67108863 & b, E = b >>> 26;
    for (; E !== 0 && T < m.length; T++)
      b = (0 | m.words[T]) + E, this.words[T] = 67108863 & b, E = b >>> 26;
    if (this.length = m.length, E !== 0)
      this.words[this.length] = E, this.length++;
    else if (m !== this)
      for (; T < m.length; T++)
        this.words[T] = m.words[T];
    return this;
  }, c.prototype.add = function(_) {
    var b;
    return _.negative !== 0 && this.negative === 0 ? (_.negative = 0, b = this.sub(_), _.negative ^= 1, b) : _.negative === 0 && this.negative !== 0 ? (this.negative = 0, b = _.sub(this), this.negative = 1, b) : this.length > _.length ? this.clone().iadd(_) : _.clone().iadd(this);
  }, c.prototype.isub = function(_) {
    if (_.negative !== 0) {
      _.negative = 0;
      var b = this.iadd(_);
      return _.negative = 1, b._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(_), this.negative = 1, this._normSign();
    var m, v, E = this.cmp(_);
    if (E === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    E > 0 ? (m = this, v = _) : (m = _, v = this);
    for (var T = 0, j = 0; j < v.length; j++)
      T = (b = (0 | m.words[j]) - (0 | v.words[j]) + T) >> 26, this.words[j] = 67108863 & b;
    for (; T !== 0 && j < m.length; j++)
      T = (b = (0 | m.words[j]) + T) >> 26, this.words[j] = 67108863 & b;
    if (T === 0 && j < m.length && m !== this)
      for (; j < m.length; j++)
        this.words[j] = m.words[j];
    return this.length = Math.max(this.length, j), m !== this && (this.negative = 1), this._strip();
  }, c.prototype.sub = function(_) {
    return this.clone().isub(_);
  };
  var D = function(_, b, m) {
    var v, E, T, j = _.words, L = b.words, J = m.words, Y = 0, ne = 0 | j[0], Q = 8191 & ne, oe = ne >>> 13, ae = 0 | j[1], ce = 8191 & ae, ue = ae >>> 13, le = 0 | j[2], Se = 8191 & le, he = le >>> 13, _e = 0 | j[3], Le = 8191 & _e, se = _e >>> 13, we = 0 | j[4], We = 8191 & we, de = we >>> 13, ke = 0 | j[5], l = 8191 & ke, h = ke >>> 13, y = 0 | j[6], A = 8191 & y, M = y >>> 13, x = 0 | j[7], O = 8191 & x, G = x >>> 13, X = 0 | j[8], ie = 8191 & X, ee = X >>> 13, re = 0 | j[9], ye = 8191 & re, fe = re >>> 13, pe = 0 | L[0], Re = 8191 & pe, me = pe >>> 13, Ee = 0 | L[1], Ce = 8191 & Ee, ge = Ee >>> 13, Ae = 0 | L[2], Fe = 8191 & Ae, $e = Ae >>> 13, Me = 0 | L[3], qe = 8191 & Me, ve = Me >>> 13, Oe = 0 | L[4], He = 8191 & Oe, be = Oe >>> 13, Pe = 0 | L[5], ze = 8191 & Pe, Te = Pe >>> 13, Ne = 0 | L[6], Ve = 8191 & Ne, xe = Ne >>> 13, Ue = 0 | L[7], Je = 8191 & Ue, Be = Ue >>> 13, je = 0 | L[8], Xe = 8191 & je, Ie = je >>> 13, De = 0 | L[9], Ge = 8191 & De, Ke = De >>> 13;
    m.negative = _.negative ^ b.negative, m.length = 19;
    var Ye = (Y + (v = Math.imul(Q, Re)) | 0) + ((8191 & (E = (E = Math.imul(Q, me)) + Math.imul(oe, Re) | 0)) << 13) | 0;
    Y = ((T = Math.imul(oe, me)) + (E >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, v = Math.imul(ce, Re), E = (E = Math.imul(ce, me)) + Math.imul(ue, Re) | 0, T = Math.imul(ue, me);
    var Ze = (Y + (v = v + Math.imul(Q, Ce) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, ge) | 0) + Math.imul(oe, Ce) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, ge) | 0) + (E >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, v = Math.imul(Se, Re), E = (E = Math.imul(Se, me)) + Math.imul(he, Re) | 0, T = Math.imul(he, me), v = v + Math.imul(ce, Ce) | 0, E = (E = E + Math.imul(ce, ge) | 0) + Math.imul(ue, Ce) | 0, T = T + Math.imul(ue, ge) | 0;
    var Qe = (Y + (v = v + Math.imul(Q, Fe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, $e) | 0) + Math.imul(oe, Fe) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, $e) | 0) + (E >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, v = Math.imul(Le, Re), E = (E = Math.imul(Le, me)) + Math.imul(se, Re) | 0, T = Math.imul(se, me), v = v + Math.imul(Se, Ce) | 0, E = (E = E + Math.imul(Se, ge) | 0) + Math.imul(he, Ce) | 0, T = T + Math.imul(he, ge) | 0, v = v + Math.imul(ce, Fe) | 0, E = (E = E + Math.imul(ce, $e) | 0) + Math.imul(ue, Fe) | 0, T = T + Math.imul(ue, $e) | 0;
    var et = (Y + (v = v + Math.imul(Q, qe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, ve) | 0) + Math.imul(oe, qe) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, ve) | 0) + (E >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, v = Math.imul(We, Re), E = (E = Math.imul(We, me)) + Math.imul(de, Re) | 0, T = Math.imul(de, me), v = v + Math.imul(Le, Ce) | 0, E = (E = E + Math.imul(Le, ge) | 0) + Math.imul(se, Ce) | 0, T = T + Math.imul(se, ge) | 0, v = v + Math.imul(Se, Fe) | 0, E = (E = E + Math.imul(Se, $e) | 0) + Math.imul(he, Fe) | 0, T = T + Math.imul(he, $e) | 0, v = v + Math.imul(ce, qe) | 0, E = (E = E + Math.imul(ce, ve) | 0) + Math.imul(ue, qe) | 0, T = T + Math.imul(ue, ve) | 0;
    var tt = (Y + (v = v + Math.imul(Q, He) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, be) | 0) + Math.imul(oe, He) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, be) | 0) + (E >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, v = Math.imul(l, Re), E = (E = Math.imul(l, me)) + Math.imul(h, Re) | 0, T = Math.imul(h, me), v = v + Math.imul(We, Ce) | 0, E = (E = E + Math.imul(We, ge) | 0) + Math.imul(de, Ce) | 0, T = T + Math.imul(de, ge) | 0, v = v + Math.imul(Le, Fe) | 0, E = (E = E + Math.imul(Le, $e) | 0) + Math.imul(se, Fe) | 0, T = T + Math.imul(se, $e) | 0, v = v + Math.imul(Se, qe) | 0, E = (E = E + Math.imul(Se, ve) | 0) + Math.imul(he, qe) | 0, T = T + Math.imul(he, ve) | 0, v = v + Math.imul(ce, He) | 0, E = (E = E + Math.imul(ce, be) | 0) + Math.imul(ue, He) | 0, T = T + Math.imul(ue, be) | 0;
    var rt = (Y + (v = v + Math.imul(Q, ze) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, Te) | 0) + Math.imul(oe, ze) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, Te) | 0) + (E >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, v = Math.imul(A, Re), E = (E = Math.imul(A, me)) + Math.imul(M, Re) | 0, T = Math.imul(M, me), v = v + Math.imul(l, Ce) | 0, E = (E = E + Math.imul(l, ge) | 0) + Math.imul(h, Ce) | 0, T = T + Math.imul(h, ge) | 0, v = v + Math.imul(We, Fe) | 0, E = (E = E + Math.imul(We, $e) | 0) + Math.imul(de, Fe) | 0, T = T + Math.imul(de, $e) | 0, v = v + Math.imul(Le, qe) | 0, E = (E = E + Math.imul(Le, ve) | 0) + Math.imul(se, qe) | 0, T = T + Math.imul(se, ve) | 0, v = v + Math.imul(Se, He) | 0, E = (E = E + Math.imul(Se, be) | 0) + Math.imul(he, He) | 0, T = T + Math.imul(he, be) | 0, v = v + Math.imul(ce, ze) | 0, E = (E = E + Math.imul(ce, Te) | 0) + Math.imul(ue, ze) | 0, T = T + Math.imul(ue, Te) | 0;
    var nt = (Y + (v = v + Math.imul(Q, Ve) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, xe) | 0) + Math.imul(oe, Ve) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, xe) | 0) + (E >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, v = Math.imul(O, Re), E = (E = Math.imul(O, me)) + Math.imul(G, Re) | 0, T = Math.imul(G, me), v = v + Math.imul(A, Ce) | 0, E = (E = E + Math.imul(A, ge) | 0) + Math.imul(M, Ce) | 0, T = T + Math.imul(M, ge) | 0, v = v + Math.imul(l, Fe) | 0, E = (E = E + Math.imul(l, $e) | 0) + Math.imul(h, Fe) | 0, T = T + Math.imul(h, $e) | 0, v = v + Math.imul(We, qe) | 0, E = (E = E + Math.imul(We, ve) | 0) + Math.imul(de, qe) | 0, T = T + Math.imul(de, ve) | 0, v = v + Math.imul(Le, He) | 0, E = (E = E + Math.imul(Le, be) | 0) + Math.imul(se, He) | 0, T = T + Math.imul(se, be) | 0, v = v + Math.imul(Se, ze) | 0, E = (E = E + Math.imul(Se, Te) | 0) + Math.imul(he, ze) | 0, T = T + Math.imul(he, Te) | 0, v = v + Math.imul(ce, Ve) | 0, E = (E = E + Math.imul(ce, xe) | 0) + Math.imul(ue, Ve) | 0, T = T + Math.imul(ue, xe) | 0;
    var it = (Y + (v = v + Math.imul(Q, Je) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, Be) | 0) + Math.imul(oe, Je) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, Be) | 0) + (E >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, v = Math.imul(ie, Re), E = (E = Math.imul(ie, me)) + Math.imul(ee, Re) | 0, T = Math.imul(ee, me), v = v + Math.imul(O, Ce) | 0, E = (E = E + Math.imul(O, ge) | 0) + Math.imul(G, Ce) | 0, T = T + Math.imul(G, ge) | 0, v = v + Math.imul(A, Fe) | 0, E = (E = E + Math.imul(A, $e) | 0) + Math.imul(M, Fe) | 0, T = T + Math.imul(M, $e) | 0, v = v + Math.imul(l, qe) | 0, E = (E = E + Math.imul(l, ve) | 0) + Math.imul(h, qe) | 0, T = T + Math.imul(h, ve) | 0, v = v + Math.imul(We, He) | 0, E = (E = E + Math.imul(We, be) | 0) + Math.imul(de, He) | 0, T = T + Math.imul(de, be) | 0, v = v + Math.imul(Le, ze) | 0, E = (E = E + Math.imul(Le, Te) | 0) + Math.imul(se, ze) | 0, T = T + Math.imul(se, Te) | 0, v = v + Math.imul(Se, Ve) | 0, E = (E = E + Math.imul(Se, xe) | 0) + Math.imul(he, Ve) | 0, T = T + Math.imul(he, xe) | 0, v = v + Math.imul(ce, Je) | 0, E = (E = E + Math.imul(ce, Be) | 0) + Math.imul(ue, Je) | 0, T = T + Math.imul(ue, Be) | 0;
    var ot = (Y + (v = v + Math.imul(Q, Xe) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, Ie) | 0) + Math.imul(oe, Xe) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, Ie) | 0) + (E >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, v = Math.imul(ye, Re), E = (E = Math.imul(ye, me)) + Math.imul(fe, Re) | 0, T = Math.imul(fe, me), v = v + Math.imul(ie, Ce) | 0, E = (E = E + Math.imul(ie, ge) | 0) + Math.imul(ee, Ce) | 0, T = T + Math.imul(ee, ge) | 0, v = v + Math.imul(O, Fe) | 0, E = (E = E + Math.imul(O, $e) | 0) + Math.imul(G, Fe) | 0, T = T + Math.imul(G, $e) | 0, v = v + Math.imul(A, qe) | 0, E = (E = E + Math.imul(A, ve) | 0) + Math.imul(M, qe) | 0, T = T + Math.imul(M, ve) | 0, v = v + Math.imul(l, He) | 0, E = (E = E + Math.imul(l, be) | 0) + Math.imul(h, He) | 0, T = T + Math.imul(h, be) | 0, v = v + Math.imul(We, ze) | 0, E = (E = E + Math.imul(We, Te) | 0) + Math.imul(de, ze) | 0, T = T + Math.imul(de, Te) | 0, v = v + Math.imul(Le, Ve) | 0, E = (E = E + Math.imul(Le, xe) | 0) + Math.imul(se, Ve) | 0, T = T + Math.imul(se, xe) | 0, v = v + Math.imul(Se, Je) | 0, E = (E = E + Math.imul(Se, Be) | 0) + Math.imul(he, Je) | 0, T = T + Math.imul(he, Be) | 0, v = v + Math.imul(ce, Xe) | 0, E = (E = E + Math.imul(ce, Ie) | 0) + Math.imul(ue, Xe) | 0, T = T + Math.imul(ue, Ie) | 0;
    var at = (Y + (v = v + Math.imul(Q, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Q, Ke) | 0) + Math.imul(oe, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(oe, Ke) | 0) + (E >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, v = Math.imul(ye, Ce), E = (E = Math.imul(ye, ge)) + Math.imul(fe, Ce) | 0, T = Math.imul(fe, ge), v = v + Math.imul(ie, Fe) | 0, E = (E = E + Math.imul(ie, $e) | 0) + Math.imul(ee, Fe) | 0, T = T + Math.imul(ee, $e) | 0, v = v + Math.imul(O, qe) | 0, E = (E = E + Math.imul(O, ve) | 0) + Math.imul(G, qe) | 0, T = T + Math.imul(G, ve) | 0, v = v + Math.imul(A, He) | 0, E = (E = E + Math.imul(A, be) | 0) + Math.imul(M, He) | 0, T = T + Math.imul(M, be) | 0, v = v + Math.imul(l, ze) | 0, E = (E = E + Math.imul(l, Te) | 0) + Math.imul(h, ze) | 0, T = T + Math.imul(h, Te) | 0, v = v + Math.imul(We, Ve) | 0, E = (E = E + Math.imul(We, xe) | 0) + Math.imul(de, Ve) | 0, T = T + Math.imul(de, xe) | 0, v = v + Math.imul(Le, Je) | 0, E = (E = E + Math.imul(Le, Be) | 0) + Math.imul(se, Je) | 0, T = T + Math.imul(se, Be) | 0, v = v + Math.imul(Se, Xe) | 0, E = (E = E + Math.imul(Se, Ie) | 0) + Math.imul(he, Xe) | 0, T = T + Math.imul(he, Ie) | 0;
    var st = (Y + (v = v + Math.imul(ce, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(ce, Ke) | 0) + Math.imul(ue, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(ue, Ke) | 0) + (E >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, v = Math.imul(ye, Fe), E = (E = Math.imul(ye, $e)) + Math.imul(fe, Fe) | 0, T = Math.imul(fe, $e), v = v + Math.imul(ie, qe) | 0, E = (E = E + Math.imul(ie, ve) | 0) + Math.imul(ee, qe) | 0, T = T + Math.imul(ee, ve) | 0, v = v + Math.imul(O, He) | 0, E = (E = E + Math.imul(O, be) | 0) + Math.imul(G, He) | 0, T = T + Math.imul(G, be) | 0, v = v + Math.imul(A, ze) | 0, E = (E = E + Math.imul(A, Te) | 0) + Math.imul(M, ze) | 0, T = T + Math.imul(M, Te) | 0, v = v + Math.imul(l, Ve) | 0, E = (E = E + Math.imul(l, xe) | 0) + Math.imul(h, Ve) | 0, T = T + Math.imul(h, xe) | 0, v = v + Math.imul(We, Je) | 0, E = (E = E + Math.imul(We, Be) | 0) + Math.imul(de, Je) | 0, T = T + Math.imul(de, Be) | 0, v = v + Math.imul(Le, Xe) | 0, E = (E = E + Math.imul(Le, Ie) | 0) + Math.imul(se, Xe) | 0, T = T + Math.imul(se, Ie) | 0;
    var ut = (Y + (v = v + Math.imul(Se, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Se, Ke) | 0) + Math.imul(he, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(he, Ke) | 0) + (E >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, v = Math.imul(ye, qe), E = (E = Math.imul(ye, ve)) + Math.imul(fe, qe) | 0, T = Math.imul(fe, ve), v = v + Math.imul(ie, He) | 0, E = (E = E + Math.imul(ie, be) | 0) + Math.imul(ee, He) | 0, T = T + Math.imul(ee, be) | 0, v = v + Math.imul(O, ze) | 0, E = (E = E + Math.imul(O, Te) | 0) + Math.imul(G, ze) | 0, T = T + Math.imul(G, Te) | 0, v = v + Math.imul(A, Ve) | 0, E = (E = E + Math.imul(A, xe) | 0) + Math.imul(M, Ve) | 0, T = T + Math.imul(M, xe) | 0, v = v + Math.imul(l, Je) | 0, E = (E = E + Math.imul(l, Be) | 0) + Math.imul(h, Je) | 0, T = T + Math.imul(h, Be) | 0, v = v + Math.imul(We, Xe) | 0, E = (E = E + Math.imul(We, Ie) | 0) + Math.imul(de, Xe) | 0, T = T + Math.imul(de, Ie) | 0;
    var ct = (Y + (v = v + Math.imul(Le, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(Le, Ke) | 0) + Math.imul(se, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(se, Ke) | 0) + (E >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, v = Math.imul(ye, He), E = (E = Math.imul(ye, be)) + Math.imul(fe, He) | 0, T = Math.imul(fe, be), v = v + Math.imul(ie, ze) | 0, E = (E = E + Math.imul(ie, Te) | 0) + Math.imul(ee, ze) | 0, T = T + Math.imul(ee, Te) | 0, v = v + Math.imul(O, Ve) | 0, E = (E = E + Math.imul(O, xe) | 0) + Math.imul(G, Ve) | 0, T = T + Math.imul(G, xe) | 0, v = v + Math.imul(A, Je) | 0, E = (E = E + Math.imul(A, Be) | 0) + Math.imul(M, Je) | 0, T = T + Math.imul(M, Be) | 0, v = v + Math.imul(l, Xe) | 0, E = (E = E + Math.imul(l, Ie) | 0) + Math.imul(h, Xe) | 0, T = T + Math.imul(h, Ie) | 0;
    var ft = (Y + (v = v + Math.imul(We, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(We, Ke) | 0) + Math.imul(de, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(de, Ke) | 0) + (E >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, v = Math.imul(ye, ze), E = (E = Math.imul(ye, Te)) + Math.imul(fe, ze) | 0, T = Math.imul(fe, Te), v = v + Math.imul(ie, Ve) | 0, E = (E = E + Math.imul(ie, xe) | 0) + Math.imul(ee, Ve) | 0, T = T + Math.imul(ee, xe) | 0, v = v + Math.imul(O, Je) | 0, E = (E = E + Math.imul(O, Be) | 0) + Math.imul(G, Je) | 0, T = T + Math.imul(G, Be) | 0, v = v + Math.imul(A, Xe) | 0, E = (E = E + Math.imul(A, Ie) | 0) + Math.imul(M, Xe) | 0, T = T + Math.imul(M, Ie) | 0;
    var ht = (Y + (v = v + Math.imul(l, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(l, Ke) | 0) + Math.imul(h, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(h, Ke) | 0) + (E >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, v = Math.imul(ye, Ve), E = (E = Math.imul(ye, xe)) + Math.imul(fe, Ve) | 0, T = Math.imul(fe, xe), v = v + Math.imul(ie, Je) | 0, E = (E = E + Math.imul(ie, Be) | 0) + Math.imul(ee, Je) | 0, T = T + Math.imul(ee, Be) | 0, v = v + Math.imul(O, Xe) | 0, E = (E = E + Math.imul(O, Ie) | 0) + Math.imul(G, Xe) | 0, T = T + Math.imul(G, Ie) | 0;
    var dt = (Y + (v = v + Math.imul(A, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(A, Ke) | 0) + Math.imul(M, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(M, Ke) | 0) + (E >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, v = Math.imul(ye, Je), E = (E = Math.imul(ye, Be)) + Math.imul(fe, Je) | 0, T = Math.imul(fe, Be), v = v + Math.imul(ie, Xe) | 0, E = (E = E + Math.imul(ie, Ie) | 0) + Math.imul(ee, Xe) | 0, T = T + Math.imul(ee, Ie) | 0;
    var pt = (Y + (v = v + Math.imul(O, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(O, Ke) | 0) + Math.imul(G, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(G, Ke) | 0) + (E >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, v = Math.imul(ye, Xe), E = (E = Math.imul(ye, Ie)) + Math.imul(fe, Xe) | 0, T = Math.imul(fe, Ie);
    var mt = (Y + (v = v + Math.imul(ie, Ge) | 0) | 0) + ((8191 & (E = (E = E + Math.imul(ie, Ke) | 0) + Math.imul(ee, Ge) | 0)) << 13) | 0;
    Y = ((T = T + Math.imul(ee, Ke) | 0) + (E >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863;
    var yt = (Y + (v = Math.imul(ye, Ge)) | 0) + ((8191 & (E = (E = Math.imul(ye, Ke)) + Math.imul(fe, Ge) | 0)) << 13) | 0;
    return Y = ((T = Math.imul(fe, Ke)) + (E >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, J[0] = Ye, J[1] = Ze, J[2] = Qe, J[3] = et, J[4] = tt, J[5] = rt, J[6] = nt, J[7] = it, J[8] = ot, J[9] = at, J[10] = st, J[11] = ut, J[12] = ct, J[13] = ft, J[14] = ht, J[15] = dt, J[16] = pt, J[17] = mt, J[18] = yt, Y !== 0 && (J[19] = Y, m.length++), m;
  };
  function z(_, b, m) {
    m.negative = b.negative ^ _.negative, m.length = _.length + b.length;
    for (var v = 0, E = 0, T = 0; T < m.length - 1; T++) {
      var j = E;
      E = 0;
      for (var L = 67108863 & v, J = Math.min(T, b.length - 1), Y = Math.max(0, T - _.length + 1); Y <= J; Y++) {
        var ne = T - Y, Q = (0 | _.words[ne]) * (0 | b.words[Y]), oe = 67108863 & Q;
        L = 67108863 & (oe = oe + L | 0), E += (j = (j = j + (Q / 67108864 | 0) | 0) + (oe >>> 26) | 0) >>> 26, j &= 67108863;
      }
      m.words[T] = L, v = j, j = E;
    }
    return v !== 0 ? m.words[T] = v : m.length--, m._strip();
  }
  function F(_, b, m) {
    return z(_, b, m);
  }
  Math.imul || (D = q), c.prototype.mulTo = function(_, b) {
    var m = this.length + _.length;
    return this.length === 10 && _.length === 10 ? D(this, _, b) : m < 63 ? q(this, _, b) : m < 1024 ? z(this, _, b) : F(this, _, b);
  }, c.prototype.mul = function(_) {
    var b = new c(null);
    return b.words = new Array(this.length + _.length), this.mulTo(_, b);
  }, c.prototype.mulf = function(_) {
    var b = new c(null);
    return b.words = new Array(this.length + _.length), F(this, _, b);
  }, c.prototype.imul = function(_) {
    return this.clone().mulTo(_, this);
  }, c.prototype.imuln = function(_) {
    var b = _ < 0;
    b && (_ = -_), a(typeof _ == "number"), a(_ < 67108864);
    for (var m = 0, v = 0; v < this.length; v++) {
      var E = (0 | this.words[v]) * _, T = (67108863 & E) + (67108863 & m);
      m >>= 26, m += E / 67108864 | 0, m += T >>> 26, this.words[v] = 67108863 & T;
    }
    return m !== 0 && (this.words[v] = m, this.length++), b ? this.ineg() : this;
  }, c.prototype.muln = function(_) {
    return this.clone().imuln(_);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(_) {
    var b = function(T) {
      for (var j = new Array(T.bitLength()), L = 0; L < j.length; L++) {
        var J = L / 26 | 0, Y = L % 26;
        j[L] = T.words[J] >>> Y & 1;
      }
      return j;
    }(_);
    if (b.length === 0)
      return new c(1);
    for (var m = this, v = 0; v < b.length && b[v] === 0; v++, m = m.sqr())
      ;
    if (++v < b.length)
      for (var E = m.sqr(); v < b.length; v++, E = E.sqr())
        b[v] !== 0 && (m = m.mul(E));
    return m;
  }, c.prototype.iushln = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var b, m = _ % 26, v = (_ - m) / 26, E = 67108863 >>> 26 - m << 26 - m;
    if (m !== 0) {
      var T = 0;
      for (b = 0; b < this.length; b++) {
        var j = this.words[b] & E, L = (0 | this.words[b]) - j << m;
        this.words[b] = L | T, T = j >>> 26 - m;
      }
      T && (this.words[b] = T, this.length++);
    }
    if (v !== 0) {
      for (b = this.length - 1; b >= 0; b--)
        this.words[b + v] = this.words[b];
      for (b = 0; b < v; b++)
        this.words[b] = 0;
      this.length += v;
    }
    return this._strip();
  }, c.prototype.ishln = function(_) {
    return a(this.negative === 0), this.iushln(_);
  }, c.prototype.iushrn = function(_, b, m) {
    var v;
    a(typeof _ == "number" && _ >= 0), v = b ? (b - b % 26) / 26 : 0;
    var E = _ % 26, T = Math.min((_ - E) / 26, this.length), j = 67108863 ^ 67108863 >>> E << E, L = m;
    if (v -= T, v = Math.max(0, v), L) {
      for (var J = 0; J < T; J++)
        L.words[J] = this.words[J];
      L.length = T;
    }
    if (T !== 0)
      if (this.length > T)
        for (this.length -= T, J = 0; J < this.length; J++)
          this.words[J] = this.words[J + T];
      else
        this.words[0] = 0, this.length = 1;
    var Y = 0;
    for (J = this.length - 1; J >= 0 && (Y !== 0 || J >= v); J--) {
      var ne = 0 | this.words[J];
      this.words[J] = Y << 26 - E | ne >>> E, Y = ne & j;
    }
    return L && Y !== 0 && (L.words[L.length++] = Y), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
  }, c.prototype.ishrn = function(_, b, m) {
    return a(this.negative === 0), this.iushrn(_, b, m);
  }, c.prototype.shln = function(_) {
    return this.clone().ishln(_);
  }, c.prototype.ushln = function(_) {
    return this.clone().iushln(_);
  }, c.prototype.shrn = function(_) {
    return this.clone().ishrn(_);
  }, c.prototype.ushrn = function(_) {
    return this.clone().iushrn(_);
  }, c.prototype.testn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var b = _ % 26, m = (_ - b) / 26, v = 1 << b;
    return !(this.length <= m || !(this.words[m] & v));
  }, c.prototype.imaskn = function(_) {
    a(typeof _ == "number" && _ >= 0);
    var b = _ % 26, m = (_ - b) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)
      return this;
    if (b !== 0 && m++, this.length = Math.min(m, this.length), b !== 0) {
      var v = 67108863 ^ 67108863 >>> b << b;
      this.words[this.length - 1] &= v;
    }
    return this._strip();
  }, c.prototype.maskn = function(_) {
    return this.clone().imaskn(_);
  }, c.prototype.iaddn = function(_) {
    return a(typeof _ == "number"), a(_ < 67108864), _ < 0 ? this.isubn(-_) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) <= _ ? (this.words[0] = _ - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(_), this.negative = 1, this) : this._iaddn(_);
  }, c.prototype._iaddn = function(_) {
    this.words[0] += _;
    for (var b = 0; b < this.length && this.words[b] >= 67108864; b++)
      this.words[b] -= 67108864, b === this.length - 1 ? this.words[b + 1] = 1 : this.words[b + 1]++;
    return this.length = Math.max(this.length, b + 1), this;
  }, c.prototype.isubn = function(_) {
    if (a(typeof _ == "number"), a(_ < 67108864), _ < 0)
      return this.iaddn(-_);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(_), this.negative = 1, this;
    if (this.words[0] -= _, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var b = 0; b < this.length && this.words[b] < 0; b++)
        this.words[b] += 67108864, this.words[b + 1] -= 1;
    return this._strip();
  }, c.prototype.addn = function(_) {
    return this.clone().iaddn(_);
  }, c.prototype.subn = function(_) {
    return this.clone().isubn(_);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(_, b, m) {
    var v, E, T = _.length + m;
    this._expand(T);
    var j = 0;
    for (v = 0; v < _.length; v++) {
      E = (0 | this.words[v + m]) + j;
      var L = (0 | _.words[v]) * b;
      j = ((E -= 67108863 & L) >> 26) - (L / 67108864 | 0), this.words[v + m] = 67108863 & E;
    }
    for (; v < this.length - m; v++)
      j = (E = (0 | this.words[v + m]) + j) >> 26, this.words[v + m] = 67108863 & E;
    if (j === 0)
      return this._strip();
    for (a(j === -1), j = 0, v = 0; v < this.length; v++)
      j = (E = -(0 | this.words[v]) + j) >> 26, this.words[v] = 67108863 & E;
    return this.negative = 1, this._strip();
  }, c.prototype._wordDiv = function(_, b) {
    var m = (this.length, _.length), v = this.clone(), E = _, T = 0 | E.words[E.length - 1];
    (m = 26 - this._countBits(T)) != 0 && (E = E.ushln(m), v.iushln(m), T = 0 | E.words[E.length - 1]);
    var j, L = v.length - E.length;
    if (b !== "mod") {
      (j = new c(null)).length = L + 1, j.words = new Array(j.length);
      for (var J = 0; J < j.length; J++)
        j.words[J] = 0;
    }
    var Y = v.clone()._ishlnsubmul(E, 1, L);
    Y.negative === 0 && (v = Y, j && (j.words[L] = 1));
    for (var ne = L - 1; ne >= 0; ne--) {
      var Q = 67108864 * (0 | v.words[E.length + ne]) + (0 | v.words[E.length + ne - 1]);
      for (Q = Math.min(Q / T | 0, 67108863), v._ishlnsubmul(E, Q, ne); v.negative !== 0; )
        Q--, v.negative = 0, v._ishlnsubmul(E, 1, ne), v.isZero() || (v.negative ^= 1);
      j && (j.words[ne] = Q);
    }
    return j && j._strip(), v._strip(), b !== "div" && m !== 0 && v.iushrn(m), { div: j || null, mod: v };
  }, c.prototype.divmod = function(_, b, m) {
    return a(!_.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && _.negative === 0 ? (T = this.neg().divmod(_, b), b !== "mod" && (v = T.div.neg()), b !== "div" && (E = T.mod.neg(), m && E.negative !== 0 && E.iadd(_)), { div: v, mod: E }) : this.negative === 0 && _.negative !== 0 ? (T = this.divmod(_.neg(), b), b !== "mod" && (v = T.div.neg()), { div: v, mod: T.mod }) : (this.negative & _.negative) != 0 ? (T = this.neg().divmod(_.neg(), b), b !== "div" && (E = T.mod.neg(), m && E.negative !== 0 && E.isub(_)), { div: T.div, mod: E }) : _.length > this.length || this.cmp(_) < 0 ? { div: new c(0), mod: this } : _.length === 1 ? b === "div" ? { div: this.divn(_.words[0]), mod: null } : b === "mod" ? { div: null, mod: new c(this.modrn(_.words[0])) } : { div: this.divn(_.words[0]), mod: new c(this.modrn(_.words[0])) } : this._wordDiv(_, b);
    var v, E, T;
  }, c.prototype.div = function(_) {
    return this.divmod(_, "div", !1).div;
  }, c.prototype.mod = function(_) {
    return this.divmod(_, "mod", !1).mod;
  }, c.prototype.umod = function(_) {
    return this.divmod(_, "mod", !0).mod;
  }, c.prototype.divRound = function(_) {
    var b = this.divmod(_);
    if (b.mod.isZero())
      return b.div;
    var m = b.div.negative !== 0 ? b.mod.isub(_) : b.mod, v = _.ushrn(1), E = _.andln(1), T = m.cmp(v);
    return T < 0 || E === 1 && T === 0 ? b.div : b.div.negative !== 0 ? b.div.isubn(1) : b.div.iaddn(1);
  }, c.prototype.modrn = function(_) {
    var b = _ < 0;
    b && (_ = -_), a(_ <= 67108863);
    for (var m = (1 << 26) % _, v = 0, E = this.length - 1; E >= 0; E--)
      v = (m * v + (0 | this.words[E])) % _;
    return b ? -v : v;
  }, c.prototype.modn = function(_) {
    return this.modrn(_);
  }, c.prototype.idivn = function(_) {
    var b = _ < 0;
    b && (_ = -_), a(_ <= 67108863);
    for (var m = 0, v = this.length - 1; v >= 0; v--) {
      var E = (0 | this.words[v]) + 67108864 * m;
      this.words[v] = E / _ | 0, m = E % _;
    }
    return this._strip(), b ? this.ineg() : this;
  }, c.prototype.divn = function(_) {
    return this.clone().idivn(_);
  }, c.prototype.egcd = function(_) {
    a(_.negative === 0), a(!_.isZero());
    var b = this, m = _.clone();
    b = b.negative !== 0 ? b.umod(_) : b.clone();
    for (var v = new c(1), E = new c(0), T = new c(0), j = new c(1), L = 0; b.isEven() && m.isEven(); )
      b.iushrn(1), m.iushrn(1), ++L;
    for (var J = m.clone(), Y = b.clone(); !b.isZero(); ) {
      for (var ne = 0, Q = 1; (b.words[0] & Q) == 0 && ne < 26; ++ne, Q <<= 1)
        ;
      if (ne > 0)
        for (b.iushrn(ne); ne-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(J), E.isub(Y)), v.iushrn(1), E.iushrn(1);
      for (var oe = 0, ae = 1; (m.words[0] & ae) == 0 && oe < 26; ++oe, ae <<= 1)
        ;
      if (oe > 0)
        for (m.iushrn(oe); oe-- > 0; )
          (T.isOdd() || j.isOdd()) && (T.iadd(J), j.isub(Y)), T.iushrn(1), j.iushrn(1);
      b.cmp(m) >= 0 ? (b.isub(m), v.isub(T), E.isub(j)) : (m.isub(b), T.isub(v), j.isub(E));
    }
    return { a: T, b: j, gcd: m.iushln(L) };
  }, c.prototype._invmp = function(_) {
    a(_.negative === 0), a(!_.isZero());
    var b = this, m = _.clone();
    b = b.negative !== 0 ? b.umod(_) : b.clone();
    for (var v, E = new c(1), T = new c(0), j = m.clone(); b.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
      for (var L = 0, J = 1; (b.words[0] & J) == 0 && L < 26; ++L, J <<= 1)
        ;
      if (L > 0)
        for (b.iushrn(L); L-- > 0; )
          E.isOdd() && E.iadd(j), E.iushrn(1);
      for (var Y = 0, ne = 1; (m.words[0] & ne) == 0 && Y < 26; ++Y, ne <<= 1)
        ;
      if (Y > 0)
        for (m.iushrn(Y); Y-- > 0; )
          T.isOdd() && T.iadd(j), T.iushrn(1);
      b.cmp(m) >= 0 ? (b.isub(m), E.isub(T)) : (m.isub(b), T.isub(E));
    }
    return (v = b.cmpn(1) === 0 ? E : T).cmpn(0) < 0 && v.iadd(_), v;
  }, c.prototype.gcd = function(_) {
    if (this.isZero())
      return _.abs();
    if (_.isZero())
      return this.abs();
    var b = this.clone(), m = _.clone();
    b.negative = 0, m.negative = 0;
    for (var v = 0; b.isEven() && m.isEven(); v++)
      b.iushrn(1), m.iushrn(1);
    for (; ; ) {
      for (; b.isEven(); )
        b.iushrn(1);
      for (; m.isEven(); )
        m.iushrn(1);
      var E = b.cmp(m);
      if (E < 0) {
        var T = b;
        b = m, m = T;
      } else if (E === 0 || m.cmpn(1) === 0)
        break;
      b.isub(m);
    }
    return m.iushln(v);
  }, c.prototype.invm = function(_) {
    return this.egcd(_).a.umod(_);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(_) {
    return this.words[0] & _;
  }, c.prototype.bincn = function(_) {
    a(typeof _ == "number");
    var b = _ % 26, m = (_ - b) / 26, v = 1 << b;
    if (this.length <= m)
      return this._expand(m + 1), this.words[m] |= v, this;
    for (var E = v, T = m; E !== 0 && T < this.length; T++) {
      var j = 0 | this.words[T];
      E = (j += E) >>> 26, j &= 67108863, this.words[T] = j;
    }
    return E !== 0 && (this.words[T] = E, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(_) {
    var b, m = _ < 0;
    if (this.negative !== 0 && !m)
      return -1;
    if (this.negative === 0 && m)
      return 1;
    if (this._strip(), this.length > 1)
      b = 1;
    else {
      m && (_ = -_), a(_ <= 67108863, "Number is too big");
      var v = 0 | this.words[0];
      b = v === _ ? 0 : v < _ ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -b : b;
  }, c.prototype.cmp = function(_) {
    if (this.negative !== 0 && _.negative === 0)
      return -1;
    if (this.negative === 0 && _.negative !== 0)
      return 1;
    var b = this.ucmp(_);
    return this.negative !== 0 ? 0 | -b : b;
  }, c.prototype.ucmp = function(_) {
    if (this.length > _.length)
      return 1;
    if (this.length < _.length)
      return -1;
    for (var b = 0, m = this.length - 1; m >= 0; m--) {
      var v = 0 | this.words[m], E = 0 | _.words[m];
      if (v !== E) {
        v < E ? b = -1 : v > E && (b = 1);
        break;
      }
    }
    return b;
  }, c.prototype.gtn = function(_) {
    return this.cmpn(_) === 1;
  }, c.prototype.gt = function(_) {
    return this.cmp(_) === 1;
  }, c.prototype.gten = function(_) {
    return this.cmpn(_) >= 0;
  }, c.prototype.gte = function(_) {
    return this.cmp(_) >= 0;
  }, c.prototype.ltn = function(_) {
    return this.cmpn(_) === -1;
  }, c.prototype.lt = function(_) {
    return this.cmp(_) === -1;
  }, c.prototype.lten = function(_) {
    return this.cmpn(_) <= 0;
  }, c.prototype.lte = function(_) {
    return this.cmp(_) <= 0;
  }, c.prototype.eqn = function(_) {
    return this.cmpn(_) === 0;
  }, c.prototype.eq = function(_) {
    return this.cmp(_) === 0;
  }, c.red = function(_) {
    return new g(_);
  }, c.prototype.toRed = function(_) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), _.convertTo(this)._forceRed(_);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(_) {
    return this.red = _, this;
  }, c.prototype.forceRed = function(_) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(_);
  }, c.prototype.redAdd = function(_) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, _);
  }, c.prototype.redIAdd = function(_) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, _);
  }, c.prototype.redSub = function(_) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, _);
  }, c.prototype.redISub = function(_) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, _);
  }, c.prototype.redShl = function(_) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, _);
  }, c.prototype.redMul = function(_) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.mul(this, _);
  }, c.prototype.redIMul = function(_) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, _), this.red.imul(this, _);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(_) {
    return a(this.red && !_.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, _);
  };
  var V = { k256: null, p224: null, p192: null, p25519: null };
  function Z(_, b) {
    this.name = _, this.p = new c(b, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function N() {
    Z.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function W() {
    Z.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function H() {
    Z.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function te() {
    Z.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function g(_) {
    if (typeof _ == "string") {
      var b = c._prime(_);
      this.m = b.p, this.prime = b;
    } else
      a(_.gtn(1), "modulus must be greater than 1"), this.m = _, this.prime = null;
  }
  function $(_) {
    g.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  Z.prototype._tmp = function() {
    var _ = new c(null);
    return _.words = new Array(Math.ceil(this.n / 13)), _;
  }, Z.prototype.ireduce = function(_) {
    var b, m = _;
    do
      this.split(m, this.tmp), b = (m = (m = this.imulK(m)).iadd(this.tmp)).bitLength();
    while (b > this.n);
    var v = b < this.n ? -1 : m.ucmp(this.p);
    return v === 0 ? (m.words[0] = 0, m.length = 1) : v > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
  }, Z.prototype.split = function(_, b) {
    _.iushrn(this.n, 0, b);
  }, Z.prototype.imulK = function(_) {
    return _.imul(this.k);
  }, u(N, Z), N.prototype.split = function(_, b) {
    for (var m = 4194303, v = Math.min(_.length, 9), E = 0; E < v; E++)
      b.words[E] = _.words[E];
    if (b.length = v, _.length <= 9)
      return _.words[0] = 0, void (_.length = 1);
    var T = _.words[9];
    for (b.words[b.length++] = T & m, E = 10; E < _.length; E++) {
      var j = 0 | _.words[E];
      _.words[E - 10] = (j & m) << 4 | T >>> 22, T = j;
    }
    T >>>= 22, _.words[E - 10] = T, T === 0 && _.length > 10 ? _.length -= 10 : _.length -= 9;
  }, N.prototype.imulK = function(_) {
    _.words[_.length] = 0, _.words[_.length + 1] = 0, _.length += 2;
    for (var b = 0, m = 0; m < _.length; m++) {
      var v = 0 | _.words[m];
      b += 977 * v, _.words[m] = 67108863 & b, b = 64 * v + (b / 67108864 | 0);
    }
    return _.words[_.length - 1] === 0 && (_.length--, _.words[_.length - 1] === 0 && _.length--), _;
  }, u(W, Z), u(H, Z), u(te, Z), te.prototype.imulK = function(_) {
    for (var b = 0, m = 0; m < _.length; m++) {
      var v = 19 * (0 | _.words[m]) + b, E = 67108863 & v;
      v >>>= 26, _.words[m] = E, b = v;
    }
    return b !== 0 && (_.words[_.length++] = b), _;
  }, c._prime = function(_) {
    if (V[_])
      return V[_];
    var b;
    if (_ === "k256")
      b = new N();
    else if (_ === "p224")
      b = new W();
    else if (_ === "p192")
      b = new H();
    else {
      if (_ !== "p25519")
        throw new Error("Unknown prime " + _);
      b = new te();
    }
    return V[_] = b, b;
  }, g.prototype._verify1 = function(_) {
    a(_.negative === 0, "red works only with positives"), a(_.red, "red works only with red numbers");
  }, g.prototype._verify2 = function(_, b) {
    a((_.negative | b.negative) == 0, "red works only with positives"), a(_.red && _.red === b.red, "red works only with red numbers");
  }, g.prototype.imod = function(_) {
    return this.prime ? this.prime.ireduce(_)._forceRed(this) : (k(_, _.umod(this.m)._forceRed(this)), _);
  }, g.prototype.neg = function(_) {
    return _.isZero() ? _.clone() : this.m.sub(_)._forceRed(this);
  }, g.prototype.add = function(_, b) {
    this._verify2(_, b);
    var m = _.add(b);
    return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this);
  }, g.prototype.iadd = function(_, b) {
    this._verify2(_, b);
    var m = _.iadd(b);
    return m.cmp(this.m) >= 0 && m.isub(this.m), m;
  }, g.prototype.sub = function(_, b) {
    this._verify2(_, b);
    var m = _.sub(b);
    return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this);
  }, g.prototype.isub = function(_, b) {
    this._verify2(_, b);
    var m = _.isub(b);
    return m.cmpn(0) < 0 && m.iadd(this.m), m;
  }, g.prototype.shl = function(_, b) {
    return this._verify1(_), this.imod(_.ushln(b));
  }, g.prototype.imul = function(_, b) {
    return this._verify2(_, b), this.imod(_.imul(b));
  }, g.prototype.mul = function(_, b) {
    return this._verify2(_, b), this.imod(_.mul(b));
  }, g.prototype.isqr = function(_) {
    return this.imul(_, _.clone());
  }, g.prototype.sqr = function(_) {
    return this.mul(_, _);
  }, g.prototype.sqrt = function(_) {
    if (_.isZero())
      return _.clone();
    var b = this.m.andln(3);
    if (a(b % 2 == 1), b === 3) {
      var m = this.m.add(new c(1)).iushrn(2);
      return this.pow(_, m);
    }
    for (var v = this.m.subn(1), E = 0; !v.isZero() && v.andln(1) === 0; )
      E++, v.iushrn(1);
    a(!v.isZero());
    var T = new c(1).toRed(this), j = T.redNeg(), L = this.m.subn(1).iushrn(1), J = this.m.bitLength();
    for (J = new c(2 * J * J).toRed(this); this.pow(J, L).cmp(j) !== 0; )
      J.redIAdd(j);
    for (var Y = this.pow(J, v), ne = this.pow(_, v.addn(1).iushrn(1)), Q = this.pow(_, v), oe = E; Q.cmp(T) !== 0; ) {
      for (var ae = Q, ce = 0; ae.cmp(T) !== 0; ce++)
        ae = ae.redSqr();
      a(ce < oe);
      var ue = this.pow(Y, new c(1).iushln(oe - ce - 1));
      ne = ne.redMul(ue), Y = ue.redSqr(), Q = Q.redMul(Y), oe = ce;
    }
    return ne;
  }, g.prototype.invm = function(_) {
    var b = _._invmp(this.m);
    return b.negative !== 0 ? (b.negative = 0, this.imod(b).redNeg()) : this.imod(b);
  }, g.prototype.pow = function(_, b) {
    if (b.isZero())
      return new c(1).toRed(this);
    if (b.cmpn(1) === 0)
      return _.clone();
    var m = new Array(16);
    m[0] = new c(1).toRed(this), m[1] = _;
    for (var v = 2; v < m.length; v++)
      m[v] = this.mul(m[v - 1], _);
    var E = m[0], T = 0, j = 0, L = b.bitLength() % 26;
    for (L === 0 && (L = 26), v = b.length - 1; v >= 0; v--) {
      for (var J = b.words[v], Y = L - 1; Y >= 0; Y--) {
        var ne = J >> Y & 1;
        E !== m[0] && (E = this.sqr(E)), ne !== 0 || T !== 0 ? (T <<= 1, T |= ne, (++j == 4 || v === 0 && Y === 0) && (E = this.mul(E, m[T]), j = 0, T = 0)) : j = 0;
      }
      L = 26;
    }
    return E;
  }, g.prototype.convertTo = function(_) {
    var b = _.umod(this.m);
    return b === _ ? b.clone() : b;
  }, g.prototype.convertFrom = function(_) {
    var b = _.clone();
    return b.red = null, b;
  }, c.mont = function(_) {
    return new $(_);
  }, u($, g), $.prototype.convertTo = function(_) {
    return this.imod(_.ushln(this.shift));
  }, $.prototype.convertFrom = function(_) {
    var b = this.imod(_.mul(this.rinv));
    return b.red = null, b;
  }, $.prototype.imul = function(_, b) {
    if (_.isZero() || b.isZero())
      return _.words[0] = 0, _.length = 1, _;
    var m = _.imul(b), v = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = m.isub(v).iushrn(this.shift), T = E;
    return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
  }, $.prototype.mul = function(_, b) {
    if (_.isZero() || b.isZero())
      return new c(0)._forceRed(this);
    var m = _.mul(b), v = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = m.isub(v).iushrn(this.shift), T = E;
    return E.cmp(this.m) >= 0 ? T = E.isub(this.m) : E.cmpn(0) < 0 && (T = E.iadd(this.m)), T._forceRed(this);
  }, $.prototype.invm = function(_) {
    return this.imod(_._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    !root.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(n) {
      return Object.prototype.toString.call(n) === "[object Array]";
    }), !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(n) {
      return typeof n == "object" && n.buffer && n.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(n, o) {
      return function(a) {
        return new Sha256(o, !0).update(a)[n]();
      };
    }, createMethod = function(n) {
      var o = createOutputMethod("hex", n);
      NODE_JS && (o = nodeWrap(o, n)), o.create = function() {
        return new Sha256(n);
      }, o.update = function(c) {
        return o.create().update(c);
      };
      for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
        var u = OUTPUT_TYPES[a];
        o[u] = createOutputMethod(u, n);
      }
      return o;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(n) {
        if (typeof n == "string")
          return crypto.createHash(algorithm).update(n, "utf8").digest("hex");
        if (n == null)
          throw new Error(ERROR);
        return n.constructor === ArrayBuffer && (n = new Uint8Array(n)), Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(n)).digest("hex") : method(n);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(n, o) {
      return function(a, u) {
        return new HmacSha256(a, o, !0).update(u)[n]();
      };
    }, createHmacMethod = function(n) {
      var o = createHmacOutputMethod("hex", n);
      o.create = function(c) {
        return new HmacSha256(c, n);
      }, o.update = function(c, p) {
        return o.create(c).update(p);
      };
      for (var a = 0; a < OUTPUT_TYPES.length; ++a) {
        var u = OUTPUT_TYPES[a];
        o[u] = createHmacOutputMethod(u, n);
      }
      return o;
    };
    function Sha256(n, o) {
      o ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = n;
    }
    function HmacSha256(n, o, a) {
      var u, c = typeof n;
      if (c === "string") {
        var p, d = [], w = n.length, S = 0;
        for (u = 0; u < w; ++u)
          (p = n.charCodeAt(u)) < 128 ? d[S++] = p : p < 2048 ? (d[S++] = 192 | p >> 6, d[S++] = 128 | 63 & p) : p < 55296 || p >= 57344 ? (d[S++] = 224 | p >> 12, d[S++] = 128 | p >> 6 & 63, d[S++] = 128 | 63 & p) : (p = 65536 + ((1023 & p) << 10 | 1023 & n.charCodeAt(++u)), d[S++] = 240 | p >> 18, d[S++] = 128 | p >> 12 & 63, d[S++] = 128 | p >> 6 & 63, d[S++] = 128 | 63 & p);
        n = d;
      } else {
        if (c !== "object")
          throw new Error(ERROR);
        if (n === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && n.constructor === ArrayBuffer)
          n = new Uint8Array(n);
        else if (!(Array.isArray(n) || ARRAY_BUFFER && ArrayBuffer.isView(n)))
          throw new Error(ERROR);
      }
      n.length > 64 && (n = new Sha256(o, !0).update(n).array());
      var k = [], B = [];
      for (u = 0; u < 64; ++u) {
        var I = n[u] || 0;
        k[u] = 92 ^ I, B[u] = 54 ^ I;
      }
      Sha256.call(this, o, a), this.update(B), this.oKeyPad = k, this.inner = !0, this.sharedMemory = a;
    }
    Sha256.prototype.update = function(n) {
      if (!this.finalized) {
        var o, a = typeof n;
        if (a !== "string") {
          if (a !== "object")
            throw new Error(ERROR);
          if (n === null)
            throw new Error(ERROR);
          if (ARRAY_BUFFER && n.constructor === ArrayBuffer)
            n = new Uint8Array(n);
          else if (!(Array.isArray(n) || ARRAY_BUFFER && ArrayBuffer.isView(n)))
            throw new Error(ERROR);
          o = !0;
        }
        for (var u, c, p = 0, d = n.length, w = this.blocks; p < d; ) {
          if (this.hashed && (this.hashed = !1, w[0] = this.block, w[16] = w[1] = w[2] = w[3] = w[4] = w[5] = w[6] = w[7] = w[8] = w[9] = w[10] = w[11] = w[12] = w[13] = w[14] = w[15] = 0), o)
            for (c = this.start; p < d && c < 64; ++p)
              w[c >> 2] |= n[p] << SHIFT[3 & c++];
          else
            for (c = this.start; p < d && c < 64; ++p)
              (u = n.charCodeAt(p)) < 128 ? w[c >> 2] |= u << SHIFT[3 & c++] : u < 2048 ? (w[c >> 2] |= (192 | u >> 6) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]) : u < 55296 || u >= 57344 ? (w[c >> 2] |= (224 | u >> 12) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]) : (u = 65536 + ((1023 & u) << 10 | 1023 & n.charCodeAt(++p)), w[c >> 2] |= (240 | u >> 18) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 12 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & c++], w[c >> 2] |= (128 | 63 & u) << SHIFT[3 & c++]);
          this.lastByteIndex = c, this.bytes += c - this.start, c >= 64 ? (this.block = w[16], this.start = c - 64, this.hash(), this.hashed = !0) : this.start = c;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var n = this.blocks, o = this.lastByteIndex;
        n[16] = this.block, n[o >> 2] |= EXTRA[3 & o], this.block = n[16], o >= 56 && (this.hashed || this.hash(), n[0] = this.block, n[16] = n[1] = n[2] = n[3] = n[4] = n[5] = n[6] = n[7] = n[8] = n[9] = n[10] = n[11] = n[12] = n[13] = n[14] = n[15] = 0), n[14] = this.hBytes << 3 | this.bytes >>> 29, n[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var n, o, a, u, c, p, d, w, S, k = this.h0, B = this.h1, I = this.h2, C = this.h3, P = this.h4, q = this.h5, D = this.h6, z = this.h7, F = this.blocks;
      for (n = 16; n < 64; ++n)
        o = ((c = F[n - 15]) >>> 7 | c << 25) ^ (c >>> 18 | c << 14) ^ c >>> 3, a = ((c = F[n - 2]) >>> 17 | c << 15) ^ (c >>> 19 | c << 13) ^ c >>> 10, F[n] = F[n - 16] + o + F[n - 7] + a << 0;
      for (S = B & I, n = 0; n < 64; n += 4)
        this.first ? (this.is224 ? (p = 300032, z = (c = F[0] - 1413257819) - 150054599 << 0, C = c + 24177077 << 0) : (p = 704751109, z = (c = F[0] - 210244248) - 1521486534 << 0, C = c + 143694565 << 0), this.first = !1) : (o = (k >>> 2 | k << 30) ^ (k >>> 13 | k << 19) ^ (k >>> 22 | k << 10), u = (p = k & B) ^ k & I ^ S, z = C + (c = z + (a = (P >>> 6 | P << 26) ^ (P >>> 11 | P << 21) ^ (P >>> 25 | P << 7)) + (P & q ^ ~P & D) + K[n] + F[n]) << 0, C = c + (o + u) << 0), o = (C >>> 2 | C << 30) ^ (C >>> 13 | C << 19) ^ (C >>> 22 | C << 10), u = (d = C & k) ^ C & B ^ p, D = I + (c = D + (a = (z >>> 6 | z << 26) ^ (z >>> 11 | z << 21) ^ (z >>> 25 | z << 7)) + (z & P ^ ~z & q) + K[n + 1] + F[n + 1]) << 0, o = ((I = c + (o + u) << 0) >>> 2 | I << 30) ^ (I >>> 13 | I << 19) ^ (I >>> 22 | I << 10), u = (w = I & C) ^ I & k ^ d, q = B + (c = q + (a = (D >>> 6 | D << 26) ^ (D >>> 11 | D << 21) ^ (D >>> 25 | D << 7)) + (D & z ^ ~D & P) + K[n + 2] + F[n + 2]) << 0, o = ((B = c + (o + u) << 0) >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10), u = (S = B & I) ^ B & C ^ w, P = k + (c = P + (a = (q >>> 6 | q << 26) ^ (q >>> 11 | q << 21) ^ (q >>> 25 | q << 7)) + (q & D ^ ~q & z) + K[n + 3] + F[n + 3]) << 0, k = c + (o + u) << 0;
      this.h0 = this.h0 + k << 0, this.h1 = this.h1 + B << 0, this.h2 = this.h2 + I << 0, this.h3 = this.h3 + C << 0, this.h4 = this.h4 + P << 0, this.h5 = this.h5 + q << 0, this.h6 = this.h6 + D << 0, this.h7 = this.h7 + z << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var n = this.h0, o = this.h1, a = this.h2, u = this.h3, c = this.h4, p = this.h5, d = this.h6, w = this.h7, S = HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[15 & o] + HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[15 & a] + HEX_CHARS[u >> 28 & 15] + HEX_CHARS[u >> 24 & 15] + HEX_CHARS[u >> 20 & 15] + HEX_CHARS[u >> 16 & 15] + HEX_CHARS[u >> 12 & 15] + HEX_CHARS[u >> 8 & 15] + HEX_CHARS[u >> 4 & 15] + HEX_CHARS[15 & u] + HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[15 & c] + HEX_CHARS[p >> 28 & 15] + HEX_CHARS[p >> 24 & 15] + HEX_CHARS[p >> 20 & 15] + HEX_CHARS[p >> 16 & 15] + HEX_CHARS[p >> 12 & 15] + HEX_CHARS[p >> 8 & 15] + HEX_CHARS[p >> 4 & 15] + HEX_CHARS[15 & p] + HEX_CHARS[d >> 28 & 15] + HEX_CHARS[d >> 24 & 15] + HEX_CHARS[d >> 20 & 15] + HEX_CHARS[d >> 16 & 15] + HEX_CHARS[d >> 12 & 15] + HEX_CHARS[d >> 8 & 15] + HEX_CHARS[d >> 4 & 15] + HEX_CHARS[15 & d];
      return this.is224 || (S += HEX_CHARS[w >> 28 & 15] + HEX_CHARS[w >> 24 & 15] + HEX_CHARS[w >> 20 & 15] + HEX_CHARS[w >> 16 & 15] + HEX_CHARS[w >> 12 & 15] + HEX_CHARS[w >> 8 & 15] + HEX_CHARS[w >> 4 & 15] + HEX_CHARS[15 & w]), S;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var n = this.h0, o = this.h1, a = this.h2, u = this.h3, c = this.h4, p = this.h5, d = this.h6, w = this.h7, S = [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, 255 & p, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d];
      return this.is224 || S.push(w >> 24 & 255, w >> 16 & 255, w >> 8 & 255, 255 & w), S;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var n = new ArrayBuffer(this.is224 ? 28 : 32), o = new DataView(n);
      return o.setUint32(0, this.h0), o.setUint32(4, this.h1), o.setUint32(8, this.h2), o.setUint32(12, this.h3), o.setUint32(16, this.h4), o.setUint32(20, this.h5), o.setUint32(24, this.h6), this.is224 || o.setUint32(28, this.h7), n;
    }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var n = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(n), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$1);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(n) {
  (function() {
    var o = "input is invalid type", a = typeof window == "object", u = a ? window : {};
    u.JS_SHA512_NO_WINDOW && (a = !1);
    var c = !a && typeof self == "object";
    !u.JS_SHA512_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node ? u = commonjsGlobal : c && (u = self);
    var p = !u.JS_SHA512_NO_COMMON_JS && n.exports, d = !u.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", w = "0123456789abcdef".split(""), S = [-2147483648, 8388608, 32768, 128], k = [24, 16, 8, 0], B = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], I = ["hex", "array", "digest", "arrayBuffer"], C = [];
    !u.JS_SHA512_NO_NODE_JS && Array.isArray || (Array.isArray = function(N) {
      return Object.prototype.toString.call(N) === "[object Array]";
    }), !d || !u.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(N) {
      return typeof N == "object" && N.buffer && N.buffer.constructor === ArrayBuffer;
    });
    var P = function(N, W) {
      return function(H) {
        return new F(W, !0).update(H)[N]();
      };
    }, q = function(N) {
      var W = P("hex", N);
      W.create = function() {
        return new F(N);
      }, W.update = function(g) {
        return W.create().update(g);
      };
      for (var H = 0; H < I.length; ++H) {
        var te = I[H];
        W[te] = P(te, N);
      }
      return W;
    }, D = function(N, W) {
      return function(H, te) {
        return new V(H, W, !0).update(te)[N]();
      };
    }, z = function(N) {
      var W = D("hex", N);
      W.create = function(g) {
        return new V(g, N);
      }, W.update = function(g, $) {
        return W.create(g).update($);
      };
      for (var H = 0; H < I.length; ++H) {
        var te = I[H];
        W[te] = D(te, N);
      }
      return W;
    };
    function F(N, W) {
      W ? (C[0] = C[1] = C[2] = C[3] = C[4] = C[5] = C[6] = C[7] = C[8] = C[9] = C[10] = C[11] = C[12] = C[13] = C[14] = C[15] = C[16] = C[17] = C[18] = C[19] = C[20] = C[21] = C[22] = C[23] = C[24] = C[25] = C[26] = C[27] = C[28] = C[29] = C[30] = C[31] = C[32] = 0, this.blocks = C) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], N == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : N == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : N == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = N, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1;
    }
    function V(N, W, H) {
      var te, g = typeof N;
      if (g !== "string") {
        if (g !== "object")
          throw new Error(o);
        if (N === null)
          throw new Error(o);
        if (d && N.constructor === ArrayBuffer)
          N = new Uint8Array(N);
        else if (!(Array.isArray(N) || d && ArrayBuffer.isView(N)))
          throw new Error(o);
        te = !0;
      }
      var $ = N.length;
      if (!te) {
        for (var _, b = [], m = ($ = N.length, 0), v = 0; v < $; ++v)
          (_ = N.charCodeAt(v)) < 128 ? b[m++] = _ : _ < 2048 ? (b[m++] = 192 | _ >> 6, b[m++] = 128 | 63 & _) : _ < 55296 || _ >= 57344 ? (b[m++] = 224 | _ >> 12, b[m++] = 128 | _ >> 6 & 63, b[m++] = 128 | 63 & _) : (_ = 65536 + ((1023 & _) << 10 | 1023 & N.charCodeAt(++v)), b[m++] = 240 | _ >> 18, b[m++] = 128 | _ >> 12 & 63, b[m++] = 128 | _ >> 6 & 63, b[m++] = 128 | 63 & _);
        N = b;
      }
      N.length > 128 && (N = new F(W, !0).update(N).array());
      var E = [], T = [];
      for (v = 0; v < 128; ++v) {
        var j = N[v] || 0;
        E[v] = 92 ^ j, T[v] = 54 ^ j;
      }
      F.call(this, W, H), this.update(T), this.oKeyPad = E, this.inner = !0, this.sharedMemory = H;
    }
    F.prototype.update = function(N) {
      if (this.finalized)
        throw new Error("finalize already called");
      var W, H = typeof N;
      if (H !== "string") {
        if (H !== "object")
          throw new Error(o);
        if (N === null)
          throw new Error(o);
        if (d && N.constructor === ArrayBuffer)
          N = new Uint8Array(N);
        else if (!(Array.isArray(N) || d && ArrayBuffer.isView(N)))
          throw new Error(o);
        W = !0;
      }
      for (var te, g, $ = 0, _ = N.length, b = this.blocks; $ < _; ) {
        if (this.hashed && (this.hashed = !1, b[0] = this.block, b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = b[7] = b[8] = b[9] = b[10] = b[11] = b[12] = b[13] = b[14] = b[15] = b[16] = b[17] = b[18] = b[19] = b[20] = b[21] = b[22] = b[23] = b[24] = b[25] = b[26] = b[27] = b[28] = b[29] = b[30] = b[31] = b[32] = 0), W)
          for (g = this.start; $ < _ && g < 128; ++$)
            b[g >> 2] |= N[$] << k[3 & g++];
        else
          for (g = this.start; $ < _ && g < 128; ++$)
            (te = N.charCodeAt($)) < 128 ? b[g >> 2] |= te << k[3 & g++] : te < 2048 ? (b[g >> 2] |= (192 | te >> 6) << k[3 & g++], b[g >> 2] |= (128 | 63 & te) << k[3 & g++]) : te < 55296 || te >= 57344 ? (b[g >> 2] |= (224 | te >> 12) << k[3 & g++], b[g >> 2] |= (128 | te >> 6 & 63) << k[3 & g++], b[g >> 2] |= (128 | 63 & te) << k[3 & g++]) : (te = 65536 + ((1023 & te) << 10 | 1023 & N.charCodeAt(++$)), b[g >> 2] |= (240 | te >> 18) << k[3 & g++], b[g >> 2] |= (128 | te >> 12 & 63) << k[3 & g++], b[g >> 2] |= (128 | te >> 6 & 63) << k[3 & g++], b[g >> 2] |= (128 | 63 & te) << k[3 & g++]);
        this.lastByteIndex = g, this.bytes += g - this.start, g >= 128 ? (this.block = b[32], this.start = g - 128, this.hash(), this.hashed = !0) : this.start = g;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, F.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var N = this.blocks, W = this.lastByteIndex;
        N[32] = this.block, N[W >> 2] |= S[3 & W], this.block = N[32], W >= 112 && (this.hashed || this.hash(), N[0] = this.block, N[1] = N[2] = N[3] = N[4] = N[5] = N[6] = N[7] = N[8] = N[9] = N[10] = N[11] = N[12] = N[13] = N[14] = N[15] = N[16] = N[17] = N[18] = N[19] = N[20] = N[21] = N[22] = N[23] = N[24] = N[25] = N[26] = N[27] = N[28] = N[29] = N[30] = N[31] = N[32] = 0), N[30] = this.hBytes << 3 | this.bytes >>> 29, N[31] = this.bytes << 3, this.hash();
      }
    }, F.prototype.hash = function() {
      var N, W, H, te, g, $, _, b, m, v, E, T, j, L, J, Y, ne, Q, oe, ae, ce, ue, le, Se, he, _e = this.h0h, Le = this.h0l, se = this.h1h, we = this.h1l, We = this.h2h, de = this.h2l, ke = this.h3h, l = this.h3l, h = this.h4h, y = this.h4l, A = this.h5h, M = this.h5l, x = this.h6h, O = this.h6l, G = this.h7h, X = this.h7l, ie = this.blocks;
      for (N = 32; N < 160; N += 2)
        W = ((ae = ie[N - 30]) >>> 1 | (ce = ie[N - 29]) << 31) ^ (ae >>> 8 | ce << 24) ^ ae >>> 7, H = (ce >>> 1 | ae << 31) ^ (ce >>> 8 | ae << 24) ^ (ce >>> 7 | ae << 25), te = ((ae = ie[N - 4]) >>> 19 | (ce = ie[N - 3]) << 13) ^ (ce >>> 29 | ae << 3) ^ ae >>> 6, g = (ce >>> 19 | ae << 13) ^ (ae >>> 29 | ce << 3) ^ (ce >>> 6 | ae << 26), ae = ie[N - 32], ce = ie[N - 31], m = ((ue = ie[N - 14]) >>> 16) + (ae >>> 16) + (W >>> 16) + (te >>> 16) + ((b = (65535 & ue) + (65535 & ae) + (65535 & W) + (65535 & te) + ((_ = ((le = ie[N - 13]) >>> 16) + (ce >>> 16) + (H >>> 16) + (g >>> 16) + (($ = (65535 & le) + (65535 & ce) + (65535 & H) + (65535 & g)) >>> 16)) >>> 16)) >>> 16), ie[N] = m << 16 | 65535 & b, ie[N + 1] = _ << 16 | 65535 & $;
      var ee = _e, re = Le, ye = se, fe = we, pe = We, Re = de, me = ke, Ee = l, Ce = h, ge = y, Ae = A, Fe = M, $e = x, Me = O, qe = G, ve = X;
      for (Y = ye & pe, ne = fe & Re, N = 0; N < 160; N += 8)
        W = (ee >>> 28 | re << 4) ^ (re >>> 2 | ee << 30) ^ (re >>> 7 | ee << 25), H = (re >>> 28 | ee << 4) ^ (ee >>> 2 | re << 30) ^ (ee >>> 7 | re << 25), te = (Ce >>> 14 | ge << 18) ^ (Ce >>> 18 | ge << 14) ^ (ge >>> 9 | Ce << 23), g = (ge >>> 14 | Ce << 18) ^ (ge >>> 18 | Ce << 14) ^ (Ce >>> 9 | ge << 23), Q = (v = ee & ye) ^ ee & pe ^ Y, oe = (E = re & fe) ^ re & Re ^ ne, Se = Ce & Ae ^ ~Ce & $e, he = ge & Fe ^ ~ge & Me, ae = ie[N], ce = ie[N + 1], ae = (m = ((ue = B[N]) >>> 16) + (ae >>> 16) + (Se >>> 16) + (te >>> 16) + (qe >>> 16) + ((b = (65535 & ue) + (65535 & ae) + (65535 & Se) + (65535 & te) + (65535 & qe) + ((_ = ((le = B[N + 1]) >>> 16) + (ce >>> 16) + (he >>> 16) + (g >>> 16) + (ve >>> 16) + (($ = (65535 & le) + (65535 & ce) + (65535 & he) + (65535 & g) + (65535 & ve)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ce = _ << 16 | 65535 & $, ue = (m = (Q >>> 16) + (W >>> 16) + ((b = (65535 & Q) + (65535 & W) + ((_ = (oe >>> 16) + (H >>> 16) + (($ = (65535 & oe) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, le = _ << 16 | 65535 & $, qe = (m = (me >>> 16) + (ae >>> 16) + ((b = (65535 & me) + (65535 & ae) + ((_ = (Ee >>> 16) + (ce >>> 16) + (($ = (65535 & Ee) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ve = _ << 16 | 65535 & $, W = ((me = (m = (ue >>> 16) + (ae >>> 16) + ((b = (65535 & ue) + (65535 & ae) + ((_ = (le >>> 16) + (ce >>> 16) + (($ = (65535 & le) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b) >>> 28 | (Ee = _ << 16 | 65535 & $) << 4) ^ (Ee >>> 2 | me << 30) ^ (Ee >>> 7 | me << 25), H = (Ee >>> 28 | me << 4) ^ (me >>> 2 | Ee << 30) ^ (me >>> 7 | Ee << 25), te = (qe >>> 14 | ve << 18) ^ (qe >>> 18 | ve << 14) ^ (ve >>> 9 | qe << 23), g = (ve >>> 14 | qe << 18) ^ (ve >>> 18 | qe << 14) ^ (qe >>> 9 | ve << 23), Q = (T = me & ee) ^ me & ye ^ v, oe = (j = Ee & re) ^ Ee & fe ^ E, Se = qe & Ce ^ ~qe & Ae, he = ve & ge ^ ~ve & Fe, ae = ie[N + 2], ce = ie[N + 3], ae = (m = ((ue = B[N + 2]) >>> 16) + (ae >>> 16) + (Se >>> 16) + (te >>> 16) + ($e >>> 16) + ((b = (65535 & ue) + (65535 & ae) + (65535 & Se) + (65535 & te) + (65535 & $e) + ((_ = ((le = B[N + 3]) >>> 16) + (ce >>> 16) + (he >>> 16) + (g >>> 16) + (Me >>> 16) + (($ = (65535 & le) + (65535 & ce) + (65535 & he) + (65535 & g) + (65535 & Me)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ce = _ << 16 | 65535 & $, ue = (m = (Q >>> 16) + (W >>> 16) + ((b = (65535 & Q) + (65535 & W) + ((_ = (oe >>> 16) + (H >>> 16) + (($ = (65535 & oe) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, le = _ << 16 | 65535 & $, $e = (m = (pe >>> 16) + (ae >>> 16) + ((b = (65535 & pe) + (65535 & ae) + ((_ = (Re >>> 16) + (ce >>> 16) + (($ = (65535 & Re) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, Me = _ << 16 | 65535 & $, W = ((pe = (m = (ue >>> 16) + (ae >>> 16) + ((b = (65535 & ue) + (65535 & ae) + ((_ = (le >>> 16) + (ce >>> 16) + (($ = (65535 & le) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b) >>> 28 | (Re = _ << 16 | 65535 & $) << 4) ^ (Re >>> 2 | pe << 30) ^ (Re >>> 7 | pe << 25), H = (Re >>> 28 | pe << 4) ^ (pe >>> 2 | Re << 30) ^ (pe >>> 7 | Re << 25), te = ($e >>> 14 | Me << 18) ^ ($e >>> 18 | Me << 14) ^ (Me >>> 9 | $e << 23), g = (Me >>> 14 | $e << 18) ^ (Me >>> 18 | $e << 14) ^ ($e >>> 9 | Me << 23), Q = (L = pe & me) ^ pe & ee ^ T, oe = (J = Re & Ee) ^ Re & re ^ j, Se = $e & qe ^ ~$e & Ce, he = Me & ve ^ ~Me & ge, ae = ie[N + 4], ce = ie[N + 5], ae = (m = ((ue = B[N + 4]) >>> 16) + (ae >>> 16) + (Se >>> 16) + (te >>> 16) + (Ae >>> 16) + ((b = (65535 & ue) + (65535 & ae) + (65535 & Se) + (65535 & te) + (65535 & Ae) + ((_ = ((le = B[N + 5]) >>> 16) + (ce >>> 16) + (he >>> 16) + (g >>> 16) + (Fe >>> 16) + (($ = (65535 & le) + (65535 & ce) + (65535 & he) + (65535 & g) + (65535 & Fe)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ce = _ << 16 | 65535 & $, ue = (m = (Q >>> 16) + (W >>> 16) + ((b = (65535 & Q) + (65535 & W) + ((_ = (oe >>> 16) + (H >>> 16) + (($ = (65535 & oe) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, le = _ << 16 | 65535 & $, Ae = (m = (ye >>> 16) + (ae >>> 16) + ((b = (65535 & ye) + (65535 & ae) + ((_ = (fe >>> 16) + (ce >>> 16) + (($ = (65535 & fe) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, Fe = _ << 16 | 65535 & $, W = ((ye = (m = (ue >>> 16) + (ae >>> 16) + ((b = (65535 & ue) + (65535 & ae) + ((_ = (le >>> 16) + (ce >>> 16) + (($ = (65535 & le) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b) >>> 28 | (fe = _ << 16 | 65535 & $) << 4) ^ (fe >>> 2 | ye << 30) ^ (fe >>> 7 | ye << 25), H = (fe >>> 28 | ye << 4) ^ (ye >>> 2 | fe << 30) ^ (ye >>> 7 | fe << 25), te = (Ae >>> 14 | Fe << 18) ^ (Ae >>> 18 | Fe << 14) ^ (Fe >>> 9 | Ae << 23), g = (Fe >>> 14 | Ae << 18) ^ (Fe >>> 18 | Ae << 14) ^ (Ae >>> 9 | Fe << 23), Q = (Y = ye & pe) ^ ye & me ^ L, oe = (ne = fe & Re) ^ fe & Ee ^ J, Se = Ae & $e ^ ~Ae & qe, he = Fe & Me ^ ~Fe & ve, ae = ie[N + 6], ce = ie[N + 7], ae = (m = ((ue = B[N + 6]) >>> 16) + (ae >>> 16) + (Se >>> 16) + (te >>> 16) + (Ce >>> 16) + ((b = (65535 & ue) + (65535 & ae) + (65535 & Se) + (65535 & te) + (65535 & Ce) + ((_ = ((le = B[N + 7]) >>> 16) + (ce >>> 16) + (he >>> 16) + (g >>> 16) + (ge >>> 16) + (($ = (65535 & le) + (65535 & ce) + (65535 & he) + (65535 & g) + (65535 & ge)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ce = _ << 16 | 65535 & $, ue = (m = (Q >>> 16) + (W >>> 16) + ((b = (65535 & Q) + (65535 & W) + ((_ = (oe >>> 16) + (H >>> 16) + (($ = (65535 & oe) + (65535 & H)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, le = _ << 16 | 65535 & $, Ce = (m = (ee >>> 16) + (ae >>> 16) + ((b = (65535 & ee) + (65535 & ae) + ((_ = (re >>> 16) + (ce >>> 16) + (($ = (65535 & re) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, ge = _ << 16 | 65535 & $, ee = (m = (ue >>> 16) + (ae >>> 16) + ((b = (65535 & ue) + (65535 & ae) + ((_ = (le >>> 16) + (ce >>> 16) + (($ = (65535 & le) + (65535 & ce)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & b, re = _ << 16 | 65535 & $;
      m = (_e >>> 16) + (ee >>> 16) + ((b = (65535 & _e) + (65535 & ee) + ((_ = (Le >>> 16) + (re >>> 16) + (($ = (65535 & Le) + (65535 & re)) >>> 16)) >>> 16)) >>> 16), this.h0h = m << 16 | 65535 & b, this.h0l = _ << 16 | 65535 & $, m = (se >>> 16) + (ye >>> 16) + ((b = (65535 & se) + (65535 & ye) + ((_ = (we >>> 16) + (fe >>> 16) + (($ = (65535 & we) + (65535 & fe)) >>> 16)) >>> 16)) >>> 16), this.h1h = m << 16 | 65535 & b, this.h1l = _ << 16 | 65535 & $, m = (We >>> 16) + (pe >>> 16) + ((b = (65535 & We) + (65535 & pe) + ((_ = (de >>> 16) + (Re >>> 16) + (($ = (65535 & de) + (65535 & Re)) >>> 16)) >>> 16)) >>> 16), this.h2h = m << 16 | 65535 & b, this.h2l = _ << 16 | 65535 & $, m = (ke >>> 16) + (me >>> 16) + ((b = (65535 & ke) + (65535 & me) + ((_ = (l >>> 16) + (Ee >>> 16) + (($ = (65535 & l) + (65535 & Ee)) >>> 16)) >>> 16)) >>> 16), this.h3h = m << 16 | 65535 & b, this.h3l = _ << 16 | 65535 & $, m = (h >>> 16) + (Ce >>> 16) + ((b = (65535 & h) + (65535 & Ce) + ((_ = (y >>> 16) + (ge >>> 16) + (($ = (65535 & y) + (65535 & ge)) >>> 16)) >>> 16)) >>> 16), this.h4h = m << 16 | 65535 & b, this.h4l = _ << 16 | 65535 & $, m = (A >>> 16) + (Ae >>> 16) + ((b = (65535 & A) + (65535 & Ae) + ((_ = (M >>> 16) + (Fe >>> 16) + (($ = (65535 & M) + (65535 & Fe)) >>> 16)) >>> 16)) >>> 16), this.h5h = m << 16 | 65535 & b, this.h5l = _ << 16 | 65535 & $, m = (x >>> 16) + ($e >>> 16) + ((b = (65535 & x) + (65535 & $e) + ((_ = (O >>> 16) + (Me >>> 16) + (($ = (65535 & O) + (65535 & Me)) >>> 16)) >>> 16)) >>> 16), this.h6h = m << 16 | 65535 & b, this.h6l = _ << 16 | 65535 & $, m = (G >>> 16) + (qe >>> 16) + ((b = (65535 & G) + (65535 & qe) + ((_ = (X >>> 16) + (ve >>> 16) + (($ = (65535 & X) + (65535 & ve)) >>> 16)) >>> 16)) >>> 16), this.h7h = m << 16 | 65535 & b, this.h7l = _ << 16 | 65535 & $;
    }, F.prototype.hex = function() {
      this.finalize();
      var N = this.h0h, W = this.h0l, H = this.h1h, te = this.h1l, g = this.h2h, $ = this.h2l, _ = this.h3h, b = this.h3l, m = this.h4h, v = this.h4l, E = this.h5h, T = this.h5l, j = this.h6h, L = this.h6l, J = this.h7h, Y = this.h7l, ne = this.bits, Q = w[N >> 28 & 15] + w[N >> 24 & 15] + w[N >> 20 & 15] + w[N >> 16 & 15] + w[N >> 12 & 15] + w[N >> 8 & 15] + w[N >> 4 & 15] + w[15 & N] + w[W >> 28 & 15] + w[W >> 24 & 15] + w[W >> 20 & 15] + w[W >> 16 & 15] + w[W >> 12 & 15] + w[W >> 8 & 15] + w[W >> 4 & 15] + w[15 & W] + w[H >> 28 & 15] + w[H >> 24 & 15] + w[H >> 20 & 15] + w[H >> 16 & 15] + w[H >> 12 & 15] + w[H >> 8 & 15] + w[H >> 4 & 15] + w[15 & H] + w[te >> 28 & 15] + w[te >> 24 & 15] + w[te >> 20 & 15] + w[te >> 16 & 15] + w[te >> 12 & 15] + w[te >> 8 & 15] + w[te >> 4 & 15] + w[15 & te] + w[g >> 28 & 15] + w[g >> 24 & 15] + w[g >> 20 & 15] + w[g >> 16 & 15] + w[g >> 12 & 15] + w[g >> 8 & 15] + w[g >> 4 & 15] + w[15 & g] + w[$ >> 28 & 15] + w[$ >> 24 & 15] + w[$ >> 20 & 15] + w[$ >> 16 & 15] + w[$ >> 12 & 15] + w[$ >> 8 & 15] + w[$ >> 4 & 15] + w[15 & $] + w[_ >> 28 & 15] + w[_ >> 24 & 15] + w[_ >> 20 & 15] + w[_ >> 16 & 15] + w[_ >> 12 & 15] + w[_ >> 8 & 15] + w[_ >> 4 & 15] + w[15 & _];
      return ne >= 256 && (Q += w[b >> 28 & 15] + w[b >> 24 & 15] + w[b >> 20 & 15] + w[b >> 16 & 15] + w[b >> 12 & 15] + w[b >> 8 & 15] + w[b >> 4 & 15] + w[15 & b]), ne >= 384 && (Q += w[m >> 28 & 15] + w[m >> 24 & 15] + w[m >> 20 & 15] + w[m >> 16 & 15] + w[m >> 12 & 15] + w[m >> 8 & 15] + w[m >> 4 & 15] + w[15 & m] + w[v >> 28 & 15] + w[v >> 24 & 15] + w[v >> 20 & 15] + w[v >> 16 & 15] + w[v >> 12 & 15] + w[v >> 8 & 15] + w[v >> 4 & 15] + w[15 & v] + w[E >> 28 & 15] + w[E >> 24 & 15] + w[E >> 20 & 15] + w[E >> 16 & 15] + w[E >> 12 & 15] + w[E >> 8 & 15] + w[E >> 4 & 15] + w[15 & E] + w[T >> 28 & 15] + w[T >> 24 & 15] + w[T >> 20 & 15] + w[T >> 16 & 15] + w[T >> 12 & 15] + w[T >> 8 & 15] + w[T >> 4 & 15] + w[15 & T]), ne == 512 && (Q += w[j >> 28 & 15] + w[j >> 24 & 15] + w[j >> 20 & 15] + w[j >> 16 & 15] + w[j >> 12 & 15] + w[j >> 8 & 15] + w[j >> 4 & 15] + w[15 & j] + w[L >> 28 & 15] + w[L >> 24 & 15] + w[L >> 20 & 15] + w[L >> 16 & 15] + w[L >> 12 & 15] + w[L >> 8 & 15] + w[L >> 4 & 15] + w[15 & L] + w[J >> 28 & 15] + w[J >> 24 & 15] + w[J >> 20 & 15] + w[J >> 16 & 15] + w[J >> 12 & 15] + w[J >> 8 & 15] + w[J >> 4 & 15] + w[15 & J] + w[Y >> 28 & 15] + w[Y >> 24 & 15] + w[Y >> 20 & 15] + w[Y >> 16 & 15] + w[Y >> 12 & 15] + w[Y >> 8 & 15] + w[Y >> 4 & 15] + w[15 & Y]), Q;
    }, F.prototype.toString = F.prototype.hex, F.prototype.digest = function() {
      this.finalize();
      var N = this.h0h, W = this.h0l, H = this.h1h, te = this.h1l, g = this.h2h, $ = this.h2l, _ = this.h3h, b = this.h3l, m = this.h4h, v = this.h4l, E = this.h5h, T = this.h5l, j = this.h6h, L = this.h6l, J = this.h7h, Y = this.h7l, ne = this.bits, Q = [N >> 24 & 255, N >> 16 & 255, N >> 8 & 255, 255 & N, W >> 24 & 255, W >> 16 & 255, W >> 8 & 255, 255 & W, H >> 24 & 255, H >> 16 & 255, H >> 8 & 255, 255 & H, te >> 24 & 255, te >> 16 & 255, te >> 8 & 255, 255 & te, g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, 255 & g, $ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, 255 & $, _ >> 24 & 255, _ >> 16 & 255, _ >> 8 & 255, 255 & _];
      return ne >= 256 && Q.push(b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b), ne >= 384 && Q.push(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, 255 & m, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, 255 & v, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, 255 & T), ne == 512 && Q.push(j >> 24 & 255, j >> 16 & 255, j >> 8 & 255, 255 & j, L >> 24 & 255, L >> 16 & 255, L >> 8 & 255, 255 & L, J >> 24 & 255, J >> 16 & 255, J >> 8 & 255, 255 & J, Y >> 24 & 255, Y >> 16 & 255, Y >> 8 & 255, 255 & Y), Q;
    }, F.prototype.array = F.prototype.digest, F.prototype.arrayBuffer = function() {
      this.finalize();
      var N = this.bits, W = new ArrayBuffer(N / 8), H = new DataView(W);
      return H.setUint32(0, this.h0h), H.setUint32(4, this.h0l), H.setUint32(8, this.h1h), H.setUint32(12, this.h1l), H.setUint32(16, this.h2h), H.setUint32(20, this.h2l), H.setUint32(24, this.h3h), N >= 256 && H.setUint32(28, this.h3l), N >= 384 && (H.setUint32(32, this.h4h), H.setUint32(36, this.h4l), H.setUint32(40, this.h5h), H.setUint32(44, this.h5l)), N == 512 && (H.setUint32(48, this.h6h), H.setUint32(52, this.h6l), H.setUint32(56, this.h7h), H.setUint32(60, this.h7l)), W;
    }, F.prototype.clone = function() {
      var N = new F(this.bits, !1);
      return this.copyTo(N), N;
    }, F.prototype.copyTo = function(N) {
      var W = 0, H = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (W = 0; W < H.length; ++W)
        N[H[W]] = this[H[W]];
      for (W = 0; W < this.blocks.length; ++W)
        N.blocks[W] = this.blocks[W];
    }, V.prototype = new F(), V.prototype.finalize = function() {
      if (F.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var N = this.array();
        F.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(N), F.prototype.finalize.call(this);
      }
    }, V.prototype.clone = function() {
      var N = new V([], this.bits, !1);
      this.copyTo(N), N.inner = this.inner;
      for (var W = 0; W < this.oKeyPad.length; ++W)
        N.oKeyPad[W] = this.oKeyPad[W];
      return N;
    };
    var Z = q(512);
    Z.sha512 = Z, Z.sha384 = q(384), Z.sha512_256 = q(256), Z.sha512_224 = q(224), Z.sha512.hmac = z(512), Z.sha384.hmac = z(384), Z.sha512_256.hmac = z(256), Z.sha512_224.hmac = z(224), p ? n.exports = Z : (u.sha512 = Z.sha512, u.sha384 = Z.sha384, u.sha512_256 = Z.sha512_256, u.sha512_224 = Z.sha512_224);
  })();
})(sha512$1);
const elliptic = elliptic$1, BN = bn$1.exports, { sha256 } = sha256$1.exports, { sha512 } = sha512$1.exports, EC$2 = new elliptic.ec("secp256k1");
function toBytesInt32(n) {
  return new Uint8Array([(4278190080 & n) >> 24, (16711680 & n) >> 16, (65280 & n) >> 8, 255 & n]);
}
const one = new BN(1);
function Unmarshal(n) {
  const o = EC$2.n.bitLength() + 7 >> 3;
  if (EC$2.g.mul(10), (-2 & n[0]) != 2)
    return [null, null];
  if (n.length != 1 + o)
    return [null, null];
  const a = new BN(n.slice(1, 1 + o));
  try {
    const u = EC$2.curve.pointFromX(a);
    return [u.x, u.y];
  } catch {
    return [null, null];
  }
}
function H1(n) {
  let o = null, a = null;
  const u = EC$2.n.bitLength() + 7 >> 3;
  let c = 0;
  for (; o == null && c < 100; ) {
    const p = [2, ...sha512.array(new Uint8Array([...toBytesInt32(c), ...n]))];
    [o, a] = Unmarshal(p.slice(0, u + 1)), c++;
  }
  return EC$2.curve.point(o, a);
}
function H2(n) {
  const o = EC$2.n.bitLength() + 7 >> 3;
  let a = 0;
  for (; ; ) {
    const u = sha512.array(new Uint8Array([...toBytesInt32(a), ...n])), c = new BN(u.slice(0, o));
    if (c.cmp(EC$2.curve.n.sub(one)) == -1)
      return c.add(one);
    a++;
  }
}
function Evaluate(n, o) {
  const a = EC$2.keyFromPrivate(n), u = EC$2.genKeyPair().getPrivate(), c = H1(o), p = c.mul(n).encode(), d = EC$2.curve.g.mul(u), w = c.mul(u), S = H2([...EC$2.curve.g.encode(), ...c.encode(), ...a.getPublic().encode(), ...p, ...d.encode(), ...w.encode()]), k = u.sub(S.mul(a.getPrivate())).umod(EC$2.curve.n);
  return [sha256.array(new Uint8Array(p)), [...new Array(32 - S.byteLength()).fill(0), ...S.toArray(), ...new Array(32 - k.byteLength()).fill(0), ...k.toArray(), ...p]];
}
function ProofHoHash(n, o, a) {
  const u = EC$2.keyFromPublic(n);
  if (a.length !== 129)
    throw new Error("invalid vrf");
  const c = a.slice(0, 32), p = a.slice(32, 64), d = a.slice(64, 129), w = decodePoint(d);
  if (!w)
    throw new Error("invalid vrf");
  const S = EC$2.curve.g.mul(p), k = u.getPublic().mul(c), B = S.add(k), I = H1(o), C = I.mul(p), P = w.mul(c), q = C.add(P), D = H2([...EC$2.curve.g.encode(), ...I.encode(), ...u.getPublic().encode(), ...d, ...B.encode(), ...q.encode()]), z = [...new Array(32 - D.byteLength()).fill(0), ...D.toArray()];
  let F = !0;
  for (let V = 0; V < z.length; V++)
    c[V] !== z[V] && (F = !1);
  if (!F)
    throw new Error("invalid vrf");
  return sha256.array(new Uint8Array(d));
}
function decodePoint(n) {
  try {
    return EC$2.curve.decodePoint(n);
  } catch {
    return null;
  }
}
var vrfJs = { Evaluate, ProofHoHash }, StateCache = {};
function canBeCached(n) {
  return n.confirmationStatus === void 0 || n.confirmationStatus === "confirmed";
}
Object.defineProperty(StateCache, "__esModule", { value: !0 }), StateCache.canBeCached = void 0, StateCache.canBeCached = canBeCached;
var TagsParser$1 = {};
Object.defineProperty(TagsParser$1, "__esModule", { value: !0 }), TagsParser$1.TagsParser = void 0;
const SmartWeaveTags_1$2 = SmartWeaveTags, LoggerFactory_1$b = LoggerFactory$1;
class TagsParser {
  constructor() {
    this.logger = LoggerFactory_1$b.LoggerFactory.INST.create("TagsParser");
  }
  getInputTag(o, a) {
    if (TagsParser.hasMultipleInteractions(o)) {
      this.logger.debug("Interaction transaction is using multiple input tx tag format.");
      const u = o.tags.findIndex((p) => p.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID && p.value === a);
      if (o.tags.length - 1 === u)
        return void this.logger.warn("Wrong tags format: 'Contract' is the last tag");
      const c = o.tags[u + 1];
      return c.name !== SmartWeaveTags_1$2.SmartWeaveTags.INPUT ? void this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${c.name} was found`) : c;
    }
    return o.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INPUT);
  }
  isInteractWrite(o, a) {
    return o.tags.some((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE && u.value === a);
  }
  getInteractWritesContracts(o) {
    return o.tags.filter((a) => a.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE).map((a) => a.value);
  }
  getContractTag(o) {
    var a;
    return (a = o.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID)) === null || a === void 0 ? void 0 : a.value;
  }
  getContractsWithInputs(o) {
    const a = /* @__PURE__ */ new Map();
    return o.tags.filter((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).forEach((u) => {
      a.set(u.value, this.getInputTag(o, u.value));
    }), a;
  }
  static hasMultipleInteractions(o) {
    return o.tags.filter((a) => a.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).length > 1;
  }
}
TagsParser$1.TagsParser = TagsParser;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(DefaultStateEvaluator$1, "__esModule", { value: !0 }), DefaultStateEvaluator$1.DefaultStateEvaluator = void 0;
const vrf_js_1$1 = vrfJs, elliptic_1$1 = __importDefault$5(elliptic$1), SortKeyCache_1$1 = SortKeyCache, Benchmark_1$1 = Benchmark$1, LoggerFactory_1$a = LoggerFactory$1, utils_1$5 = utils$n, StateEvaluator_1$2 = StateEvaluator, StateCache_1 = StateCache, TagsParser_1 = TagsParser$1, EC$1 = new elliptic_1$1.default.ec("secp256k1");
class DefaultStateEvaluator {
  constructor(o, a = []) {
    this.arweave = o, this.executionContextModifiers = a, this.logger = LoggerFactory_1$a.LoggerFactory.INST.create("DefaultStateEvaluator"), this.tagsParser = new TagsParser_1.TagsParser();
  }
  async eval(o, a) {
    return this.doReadState(o.sortedInteractions, new StateEvaluator_1$2.EvalStateResult(o.contractDefinition.initState, {}, {}), o, a);
  }
  async doReadState(o, a, u, c) {
    var p;
    const { ignoreExceptions: d, stackTrace: w, internalWrites: S } = u.evaluationOptions, { contract: k, contractDefinition: B, sortedInteractions: I } = u;
    let C = a.state, P = null;
    const q = a.validity, D = a.errorMessages;
    u == null || u.handler.initState(C);
    const z = u.contract.callDepth();
    this.logger.info(`${(0, utils_1$5.indent)(z)}Evaluating state for ${B.txId} [${o.length} non-cached of ${I.length} all]`);
    let F = null, V = null;
    const Z = o.length;
    u.handler.initState(C);
    for (let W = 0; W < Z; W++) {
      const H = o[W], te = Benchmark_1$1.Benchmark.measure();
      if (P = H.sortKey, H.vrf && !this.verifyVrf(H.vrf, H.sortKey, this.arweave))
        throw new Error("Vrf verification failed.");
      if (this.logger.debug(`${(0, utils_1$5.indent)(z)}[${B.txId}][${H.id}][${H.block.height}]: ${o.indexOf(H) + 1}/${o.length} [of all:${I.length}]`), this.tagsParser.isInteractWrite(H, B.txId) && S) {
        const g = this.tagsParser.getContractTag(H);
        this.logger.debug(`${(0, utils_1$5.indent)(z)}Internal Write - Loading writing contract`, g);
        const $ = k.getCallStack().addInteractionData({ interaction: null, interactionTx: H, currentTx: c }), _ = u.warp.contract(g, u.contract, { callingInteraction: H, callType: "read" });
        await this.onContractCall(H, u, new StateEvaluator_1$2.EvalStateResult(C, q, D)), this.logger.debug(`${(0, utils_1$5.indent)(z)}Reading state of the calling contract at`, H.sortKey), await _.readState(H.sortKey, [...c || [], { contractTxId: B.txId, interactionTxId: H.id }]);
        const b = await this.internalWriteState(B.txId, H.sortKey);
        if (b !== null) {
          C = b.cachedValue.state, u == null || u.handler.initState(C), q[H.id] = b.cachedValue.validity[H.id], !((p = b.cachedValue.errorMessages) === null || p === void 0) && p[H.id] && (D[H.id] = b.cachedValue.errorMessages[H.id]);
          const m = new StateEvaluator_1$2.EvalStateResult(C, q, D);
          await this.onStateUpdate(H, u, m), (0, StateCache_1.canBeCached)(H) && (V = { tx: H, state: m });
        } else
          q[H.id] = !1;
        $.update({ cacheHit: !1, outputState: w.saveState ? C : void 0, executionTime: te.elapsed(!0), valid: q[H.id], errorMessage: F, gasUsed: 0 });
      } else {
        const g = this.tagsParser.getInputTag(H, u.contractDefinition.txId);
        if (!g) {
          this.logger.error(`${(0, utils_1$5.indent)(z)}Skipping tx - Input tag not found for ${H.id}`);
          continue;
        }
        const $ = this.parseInput(g);
        if (!$) {
          this.logger.error(`${(0, utils_1$5.indent)(z)}Skipping tx - invalid Input tag - ${H.id}`);
          continue;
        }
        const _ = { input: $, caller: H.owner.address }, b = { interaction: _, interactionTx: H, currentTx: c };
        this.logger.debug(`${(0, utils_1$5.indent)(z)}Interaction:`, _);
        const m = k.getCallStack().addInteractionData(b), v = await u.handler.handle(u, new StateEvaluator_1$2.EvalStateResult(C, q, D), b);
        if (F = v.errorMessage, v.type !== "ok" && (D[H.id] = F), this.logResult(v, H, u), this.logger.debug(`${(0, utils_1$5.indent)(z)}Interaction evaluation`, te.elapsed()), m.update({ cacheHit: !1, outputState: w.saveState ? C : void 0, executionTime: te.elapsed(!0), valid: q[H.id], errorMessage: F, gasUsed: v.gasUsed }), v.type === "exception" && d !== !0)
          throw new Error(`Exception while processing ${JSON.stringify(_)}:
${v.errorMessage}`);
        q[H.id] = v.type === "ok", C = v.state;
        const E = new StateEvaluator_1$2.EvalStateResult(C, q, D);
        (0, StateCache_1.canBeCached)(H) && (V = { tx: H, state: E }), await this.onStateUpdate(H, u, E);
      }
      for (const { modify: g } of this.executionContextModifiers)
        u = await g(C, u);
    }
    const N = new StateEvaluator_1$2.EvalStateResult(C, q, D);
    return V !== null && await this.onStateEvaluated(V.tx, u, V.state), new SortKeyCache_1$1.SortKeyCacheResult(P, N);
  }
  verifyVrf(o, a, u) {
    const c = EC$1.keyFromPublic(o.pubkey, "hex");
    let p;
    try {
      p = (0, vrf_js_1$1.ProofHoHash)(c.getPublic(), u.utils.stringToBuffer(a), u.utils.b64UrlToBuffer(o.proof));
    } catch {
      return !1;
    }
    return u.utils.bufferTob64Url(p) == o.index;
  }
  logResult(o, a, u) {
    o.type === "exception" && this.logger.error(`Executing of interaction: [${u.contractDefinition.txId} -> ${a.id}] threw exception:`, `${o.errorMessage}`), o.type === "error" && this.logger.warn(`Executing of interaction: [${u.contractDefinition.txId} -> ${a.id}] returned error:`, o.errorMessage);
  }
  parseInput(o) {
    try {
      return JSON.parse(o.value);
    } catch (a) {
      return this.logger.error(a), null;
    }
  }
}
DefaultStateEvaluator$1.DefaultStateEvaluator = DefaultStateEvaluator;
var LexicographicalInteractionsSorter = {}, WarpGatewayInteractionsLoader = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.WarpGatewayInteractionsLoader = n.SourceType = void 0;
  const o = Benchmark$1, a = LoggerFactory$1, u = utils$n;
  var c;
  (c = n.SourceType || (n.SourceType = {})).ARWEAVE = "arweave", c.WARP_SEQUENCER = "redstone-sequencer", n.WarpGatewayInteractionsLoader = class {
    constructor(p, d = null, w = null) {
      this.baseUrl = p, this.confirmationStatus = d, this.source = w, this.logger = a.LoggerFactory.INST.create("WarpGatewayInteractionsLoader"), this.baseUrl = (0, u.stripTrailingSlash)(p), Object.assign(this, d), this.source = w;
    }
    async load(p, d, w, S) {
      this.logger.debug("Loading interactions: for ", { contractId: p, fromSortKey: d, toSortKey: w });
      const k = [];
      let B = 0, I = 0, C = 0;
      const P = o.Benchmark.measure();
      do {
        const q = o.Benchmark.measure(), D = `${this.baseUrl}/gateway/v2/interactions-sort-key`, z = await fetch(`${D}?${new URLSearchParams({ contractId: p, ...d ? { from: d } : "", ...w ? { to: w } : "", page: (++B).toString(), fromSdk: "true", ...this.confirmationStatus && this.confirmationStatus.confirmed ? { confirmationStatus: "confirmed" } : "", ...this.confirmationStatus && this.confirmationStatus.notCorrupted ? { confirmationStatus: "not_corrupted" } : "", ...this.source ? { source: this.source } : "" })}`).then((F) => F.ok ? F.json() : Promise.reject(F)).catch((F) => {
          var V;
          throw !((V = F.body) === null || V === void 0) && V.message && this.logger.error(F.body.message), new Error(`Unable to retrieve transactions. Warp gateway responded with status ${F.status}.`);
        });
        this.logger.debug(`Loading interactions: page ${B} loaded in ${q.elapsed()}`), k.push(...z.interactions), I = z.paging.limit, C = z.paging.items, this.logger.debug(`Loaded interactions length: ${k.length}, from: ${d}, to: ${w}`);
      } while (C == I);
      return this.logger.debug("All loaded interactions:", { from: d, to: w, loaded: k.length, time: P.elapsed() }), k;
    }
    type() {
      return "warp";
    }
    clearCache() {
    }
  };
})(WarpGatewayInteractionsLoader), function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 }), n.LexicographicalInteractionsSorter = n.genesisSortKey = n.sortingLast = n.sortingFirst = void 0;
  const o = utils$C, a = LoggerFactory$1, u = WarpGatewayInteractionsLoader, c = "".padEnd(13, "0"), p = "".padEnd(13, "9"), d = "".padEnd(13, "0");
  n.sortingFirst = "".padEnd(64, "0"), n.sortingLast = "".padEnd(64, "z"), n.genesisSortKey = `${"".padStart(12, "0")},${c},${n.sortingFirst}`, n.LexicographicalInteractionsSorter = class {
    constructor(w) {
      this.arweave = w, this.logger = a.LoggerFactory.INST.create("LexicographicalInteractionsSorter");
    }
    async sort(w) {
      const S = [...w], k = S.map((B) => this.addSortKey(B));
      return await Promise.all(k), S.sort((B, I) => B.node.sortKey.localeCompare(I.node.sortKey));
    }
    async createSortKey(w, S, k, B = !1) {
      const I = this.arweave.utils.b64UrlToBuffer(w), C = this.arweave.utils.b64UrlToBuffer(S), P = this.arweave.utils.concatBuffers([I, C]), q = (0, o.arrayToHex)(await this.arweave.crypto.hash(P));
      return `${`${k}`.padStart(12, "0")},${B ? p : d},${q}`;
    }
    extractBlockHeight(w) {
      return w ? parseInt(w.split(",")[0]) : null;
    }
    async addSortKey(w) {
      const { node: S } = w;
      w.node.sortKey !== void 0 && w.node.source == u.SourceType.WARP_SEQUENCER ? this.logger.debug("Using sortKey from sequencer", w.node.sortKey) : w.node.sortKey = await this.createSortKey(S.block.id, S.id, S.block.height);
    }
    generateLastSortKey(w) {
      return `${`${w}`.padStart(12, "0")},${p},${n.sortingLast}`;
    }
  };
}(LexicographicalInteractionsSorter), Object.defineProperty(CacheableStateEvaluator$1, "__esModule", { value: !0 }), CacheableStateEvaluator$1.CacheableStateEvaluator = void 0;
const SortKeyCache_1 = SortKeyCache, LoggerFactory_1$9 = LoggerFactory$1, utils_1$4 = utils$n, StateEvaluator_1$1 = StateEvaluator, DefaultStateEvaluator_1 = DefaultStateEvaluator$1, LexicographicalInteractionsSorter_1$1 = LexicographicalInteractionsSorter;
class CacheableStateEvaluator extends DefaultStateEvaluator_1.DefaultStateEvaluator {
  constructor(o, a, u = []) {
    super(o, u), this.cache = a, this.cLogger = LoggerFactory_1$9.LoggerFactory.INST.create("CacheableStateEvaluator");
  }
  async eval(o, a) {
    var u, c, p, d;
    const w = o.cachedState;
    if (w && w.sortKey == o.requestedSortKey)
      return this.cLogger.info(`Exact cache hit for sortKey ${(u = o == null ? void 0 : o.contractDefinition) === null || u === void 0 ? void 0 : u.txId}:${w.sortKey}`), (c = o.handler) === null || c === void 0 || c.initState(w.cachedValue.state), w;
    const S = o.sortedInteractions, k = o.contractDefinition.txId;
    if (!k)
      throw new Error("Contract tx id not set in the execution context");
    for (const P of a || [])
      if (P.contractTxId === o.contractDefinition.txId) {
        const q = S.findIndex((D) => D.id === P.interactionTxId);
        q !== -1 && (this.cLogger.debug("Inf. Loop fix - removing interaction", { height: S[q].block.height, contractTxId: P.contractTxId, interactionTxId: P.interactionTxId, sortKey: S[q].sortKey }), S.splice(q));
      }
    if (S.length == 0) {
      if (this.cLogger.info(`No missing interactions ${k}`), w)
        return (p = o.handler) === null || p === void 0 || p.initState(w.cachedValue.state), w;
      {
        (d = o.handler) === null || d === void 0 || d.initState(o.contractDefinition.initState), this.cLogger.debug("Inserting initial state into cache");
        const P = new StateEvaluator_1$1.EvalStateResult(o.contractDefinition.initState, {}, {});
        return await this.cache.put(new SortKeyCache_1.CacheKey(k, LexicographicalInteractionsSorter_1$1.genesisSortKey), P), new SortKeyCache_1.SortKeyCacheResult(LexicographicalInteractionsSorter_1$1.genesisSortKey, P);
      }
    }
    const B = w == null ? o.contractDefinition.initState : w.cachedValue.state, I = w == null ? {} : w.cachedValue.validity, C = w == null ? {} : w.cachedValue.errorMessages;
    return this.cLogger.debug("Base state", B), await this.doReadState(S, new StateEvaluator_1$1.EvalStateResult(B, I, C || {}), o, a);
  }
  async onStateEvaluated(o, a, u) {
    const c = a.contractDefinition.txId;
    this.cLogger.debug(`${(0, utils_1$4.indent)(a.contract.callDepth())}onStateEvaluated: cache update for contract ${c} [${o.sortKey}]`), await this.putInCache(c, o, u);
  }
  async onStateUpdate(o, a, u, c = !1) {
    (a.evaluationOptions.updateCacheForEachInteraction || c) && (this.cLogger.debug(`onStateUpdate: cache update for contract ${a.contractDefinition.txId} [${o.sortKey}]`, { contract: a.contractDefinition.txId, state: u.state, sortKey: o.sortKey }), await this.putInCache(a.contractDefinition.txId, o, u));
  }
  async latestAvailableState(o, a) {
    if (this.cLogger.debug("Searching for", { contractTxId: o, sortKey: a }), a) {
      const u = await this.cache.getLessOrEqual(o, a);
      return u && this.cLogger.debug(`Latest available state at ${o}: ${u.sortKey}`), u;
    }
    return await this.cache.getLast(o);
  }
  async onInternalWriteStateUpdate(o, a, u) {
    this.cLogger.debug("Internal write state update:", { sortKey: o.sortKey, dry: o.dry, contractTxId: a, state: u.state }), await this.putInCache(a, o, u);
  }
  async onContractCall(o, a, u) {
    var c;
    if (((c = a.sortedInteractions) === null || c === void 0 ? void 0 : c.length) == 0)
      return;
    const p = a.sortedInteractions.indexOf(o);
    p < 1 || await this.putInCache(a.contractDefinition.txId, a.sortedInteractions[p - 1], u);
  }
  async putInCache(o, a, u) {
    if (a.dry || a.confirmationStatus !== void 0 && a.confirmationStatus !== "confirmed")
      return;
    const c = new StateEvaluator_1$1.EvalStateResult(u.state, u.validity, u.errorMessages || {});
    this.cLogger.debug("Putting into cache", { contractTxId: o, transaction: a.id, sortKey: a.sortKey, dry: a.dry, state: c.state, validity: c.validity }), await this.cache.put(new SortKeyCache_1.CacheKey(o, a.sortKey), c);
  }
  async syncState(o, a, u, c) {
    const p = new StateEvaluator_1$1.EvalStateResult(u, c, {});
    await this.cache.put(new SortKeyCache_1.CacheKey(o, a), p);
  }
  async dumpCache() {
    return await this.cache.dump();
  }
  async internalWriteState(o, a) {
    return await this.cache.get(o, a);
  }
  async hasContractCached(o) {
    return await this.cache.getLast(o) != null;
  }
  async lastCachedSortKey() {
    return await this.cache.getLastSortKey();
  }
  async allCachedContracts() {
    return await this.cache.allContracts();
  }
}
CacheableStateEvaluator$1.CacheableStateEvaluator = CacheableStateEvaluator;
var HandlerExecutorFactory$1 = {}, umd = { exports: {} };
(function(n, o) {
  var a = function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.default = void 0, u.demangle = z, u.instantiate = P, u.instantiateStreaming = D, u.instantiateSync = q;
    const c = () => {
      throw Error("Operation requires compiling with --exportRuntime");
    }, p = typeof BigUint64Array < "u", d = Symbol(), w = new TextDecoder("utf-16le", { fatal: !0 });
    function S(V, Z) {
      let N = new Uint32Array(V)[Z + -4 >>> 2] >>> 1;
      const W = new Uint16Array(V, Z, N);
      if (N <= 192)
        return String.fromCharCode(...W);
      try {
        return w.decode(W);
      } catch {
        let H = "", te = 0;
        for (; N - te > 1024; )
          H += String.fromCharCode(...W.subarray(te, te += 1024));
        return H + String.fromCharCode(...W.subarray(te));
      }
    }
    function k(V) {
      const Z = {};
      function N(H, te) {
        return H ? S(H.buffer, te) : "<yet unknown>";
      }
      const W = V.env = V.env || {};
      return W.abort = W.abort || function(H, te, g, $) {
        const _ = Z.memory || W.memory;
        throw Error(`abort: ${N(_, H)} at ${N(_, te)}:${g}:${$}`);
      }, W.trace = W.trace || function(H, te, ...g) {
        const $ = Z.memory || W.memory;
        console.log(`trace: ${N($, H)}${te ? " " : ""}${g.slice(0, te).join(", ")}`);
      }, W.seed = W.seed || Date.now, V.Math = V.Math || Math, V.Date = V.Date || Date, Z;
    }
    function B(V, Z) {
      const N = Z.exports, W = N.memory, H = N.table, te = N.__new || c, g = N.__pin || c, $ = N.__unpin || c, _ = N.__collect || c, b = N.__rtti_base, m = b ? (Q) => Q[b >>> 2] : c;
      function v(Q) {
        const oe = new Uint32Array(W.buffer);
        if ((Q >>>= 0) >= m(oe))
          throw Error(`invalid id: ${Q}`);
        return oe[(b + 4 >>> 2) + (Q << 1) + 1];
      }
      function E(Q) {
        const oe = function(ae) {
          const ce = new Uint32Array(W.buffer);
          if ((ae >>>= 0) >= m(ce))
            throw Error(`invalid id: ${ae}`);
          return ce[(b + 4 >>> 2) + (ae << 1)];
        }(Q);
        if (!(7 & oe))
          throw Error(`not an array: ${Q}, flags=${oe}`);
        return oe;
      }
      function T(Q) {
        return 31 - Math.clz32(Q >>> 6 & 31);
      }
      function j(Q, oe, ae) {
        const ce = W.buffer;
        if (ae)
          switch (Q) {
            case 2:
              return new Float32Array(ce);
            case 3:
              return new Float64Array(ce);
          }
        else
          switch (Q) {
            case 0:
              return new (oe ? Int8Array : Uint8Array)(ce);
            case 1:
              return new (oe ? Int16Array : Uint16Array)(ce);
            case 2:
              return new (oe ? Int32Array : Uint32Array)(ce);
            case 3:
              return new (oe ? BigInt64Array : BigUint64Array)(ce);
          }
        throw Error(`unsupported align: ${Q}`);
      }
      function L(Q) {
        const oe = new Uint32Array(W.buffer), ae = E(oe[Q + -8 >>> 2]), ce = T(ae);
        let ue = 4 & ae ? Q : oe[Q + 4 >>> 2];
        const le = 2 & ae ? oe[Q + 12 >>> 2] : oe[ue + -4 >>> 2] >>> ce;
        return j(ce, 2048 & ae, 4096 & ae).subarray(ue >>>= ce, ue + le);
      }
      function J(Q, oe, ae) {
        return new Q(Y(Q, oe, ae));
      }
      function Y(Q, oe, ae) {
        const ce = W.buffer, ue = new Uint32Array(ce);
        return new Q(ce, ue[ae + 4 >>> 2], ue[ae + 8 >>> 2] >>> oe);
      }
      function ne(Q, oe, ae) {
        V[`__get${oe}`] = J.bind(null, Q, ae), V[`__get${oe}View`] = Y.bind(null, Q, ae);
      }
      return V.__new = te, V.__pin = g, V.__unpin = $, V.__collect = _, V.__newString = function(Q) {
        if (Q == null)
          return 0;
        const oe = Q.length, ae = te(oe << 1, 1), ce = new Uint16Array(W.buffer);
        for (var ue = 0, le = ae >>> 1; ue < oe; ++ue)
          ce[le + ue] = Q.charCodeAt(ue);
        return ae;
      }, V.__newArrayBuffer = function(Q) {
        if (Q == null)
          return 0;
        const oe = new Uint8Array(Q), ae = te(oe.length, 0);
        return new Uint8Array(W.buffer).set(oe, ae), ae;
      }, V.__getString = function(Q) {
        if (!Q)
          return null;
        const oe = W.buffer;
        if (new Uint32Array(oe)[Q + -8 >>> 2] !== 1)
          throw Error(`not a string: ${Q}`);
        return S(oe, Q);
      }, V.__newArray = function(Q, oe = 0) {
        const ae = oe, ce = E(Q), ue = T(ce), le = typeof ae != "number", Se = le ? ae.length : ae, he = te(Se << ue, 4 & ce ? Q : 0);
        let _e;
        if (4 & ce)
          _e = he;
        else {
          g(he);
          const Le = te(2 & ce ? 16 : 12, Q);
          $(he);
          const se = new Uint32Array(W.buffer);
          se[Le + 0 >>> 2] = he, se[Le + 4 >>> 2] = he, se[Le + 8 >>> 2] = Se << ue, 2 & ce && (se[Le + 12 >>> 2] = Se), _e = Le;
        }
        if (le) {
          const Le = j(ue, 2048 & ce, 4096 & ce), se = he >>> ue;
          if (16384 & ce)
            for (let we = 0; we < Se; ++we)
              Le[se + we] = ae[we];
          else
            Le.set(ae, se);
        }
        return _e;
      }, V.__getArrayView = L, V.__getArray = function(Q) {
        const oe = L(Q), ae = oe.length, ce = new Array(ae);
        for (let ue = 0; ue < ae; ue++)
          ce[ue] = oe[ue];
        return ce;
      }, V.__getArrayBuffer = function(Q) {
        const oe = W.buffer, ae = new Uint32Array(oe)[Q + -4 >>> 2];
        return oe.slice(Q, Q + ae);
      }, V.__getFunction = function(Q) {
        if (!H)
          throw Error("Operation requires compiling with --exportTable");
        const oe = new Uint32Array(W.buffer)[Q >>> 2];
        return H.get(oe);
      }, [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].forEach((Q) => {
        ne(Q, Q.name, 31 - Math.clz32(Q.BYTES_PER_ELEMENT));
      }), p && [BigUint64Array, BigInt64Array].forEach((Q) => {
        ne(Q, Q.name.slice(3), 3);
      }), V.__instanceof = function(Q, oe) {
        const ae = new Uint32Array(W.buffer);
        let ce = ae[Q + -8 >>> 2];
        if (ce <= m(ae))
          do {
            if (ce == oe)
              return !0;
            ce = v(ce);
          } while (ce);
        return !1;
      }, V.memory = V.memory || W, V.table = V.table || H, z(N, V);
    }
    function I(V) {
      return typeof Response < "u" && V instanceof Response;
    }
    function C(V) {
      return V instanceof WebAssembly.Module;
    }
    async function P(V, Z = {}) {
      if (I(V = await V))
        return D(V, Z);
      const N = C(V) ? V : await WebAssembly.compile(V), W = k(Z), H = await WebAssembly.instantiate(N, Z);
      return { module: N, instance: H, exports: B(W, H) };
    }
    function q(V, Z = {}) {
      const N = C(V) ? V : new WebAssembly.Module(V), W = k(Z), H = new WebAssembly.Instance(N, Z);
      return { module: N, instance: H, exports: B(W, H) };
    }
    async function D(V, Z = {}) {
      if (!WebAssembly.instantiateStreaming)
        return P(I(V = await V) ? V.arrayBuffer() : V, Z);
      const N = k(Z), W = await WebAssembly.instantiateStreaming(V, Z), H = B(N, W.instance);
      return { ...W, exports: H };
    }
    function z(V, Z = {}) {
      const N = V.__argumentsLength ? (W) => {
        V.__argumentsLength.value = W;
      } : V.__setArgumentsLength || V.__setargc || (() => {
      });
      for (let W of Object.keys(V)) {
        const H = V[W];
        let te = W.split("."), g = Z;
        for (; te.length > 1; ) {
          let b = te.shift();
          Object.hasOwn(g, b) || (g[b] = {}), g = g[b];
        }
        let $ = te[0], _ = $.indexOf("#");
        if (_ >= 0) {
          const b = $.substring(0, _), m = g[b];
          if (m === void 0 || !m.prototype) {
            const v = function(...E) {
              return v.wrap(v.prototype.constructor(0, ...E));
            };
            v.prototype = { valueOf() {
              return this[d];
            } }, v.wrap = function(E) {
              return Object.create(v.prototype, { [d]: { value: E, writable: !1 } });
            }, m && Object.getOwnPropertyNames(m).forEach((E) => Object.defineProperty(v, E, Object.getOwnPropertyDescriptor(m, E))), g[b] = v;
          }
          if ($ = $.substring(_ + 1), g = g[b].prototype, /^(get|set):/.test($)) {
            if (!Object.hasOwn(g, $ = $.substring(4))) {
              let v = V[W.replace("set:", "get:")], E = V[W.replace("get:", "set:")];
              Object.defineProperty(g, $, { get() {
                return v(this[d]);
              }, set(T) {
                E(this[d], T);
              }, enumerable: !0 });
            }
          } else
            $ === "constructor" ? (g[$] = function(...v) {
              return N(v.length), H(...v);
            }).original = H : (g[$] = function(...v) {
              return N(v.length), H(this[d], ...v);
            }).original = H;
        } else
          /^(get|set):/.test($) ? Object.hasOwn(g, $ = $.substring(4)) || Object.defineProperty(g, $, { get: V[W.replace("set:", "get:")], set: V[W.replace("get:", "set:")], enumerable: !0 }) : typeof H == "function" && H !== N ? (g[$] = (...b) => (N(b.length), H(...b))).original = H : g[$] = H;
      }
      return Z;
    }
    Object.hasOwn = Object.hasOwn || function(V, Z) {
      return Object.prototype.hasOwnProperty.call(V, Z);
    };
    var F = { instantiate: P, instantiateSync: q, instantiateStreaming: D, demangle: z };
    return u.default = F, "default" in u ? u.default : u;
  }({});
  n.exports = a;
})(umd);
var asWasmImports$1 = {};
Object.defineProperty(asWasmImports$1, "__esModule", { value: !0 }), asWasmImports$1.asWasmImports = void 0;
const LoggerFactory_1$8 = LoggerFactory$1, asWasmImports = (n, o) => {
  const a = LoggerFactory_1$8.LoggerFactory.INST.create("WASM:AS");
  return { metering: { usegas: n.useGas }, console: { "console.log": function(u) {
    a.debug(`${n.contract.id}: ${o.exports.__getString(u)}`);
  }, "console.logO": function(u, c) {
    a.debug(`${n.contract.id}: ${o.exports.__getString(u)}`, JSON.parse(o.exports.__getString(c)));
  } }, block: { "Block.height": function() {
    return n.block.height;
  }, "Block.indep_hash": function() {
    return o.exports.__newString(n.block.indep_hash);
  }, "Block.timestamp": function() {
    return n.block.timestamp;
  } }, transaction: { "Transaction.id": function() {
    return o.exports.__newString(n.transaction.id);
  }, "Transaction.owner": function() {
    return o.exports.__newString(n.transaction.owner);
  }, "Transaction.target": function() {
    return o.exports.__newString(n.transaction.target);
  } }, contract: { "Contract.id": function() {
    return o.exports.__newString(n.contract.id);
  }, "Contract.owner": function() {
    return o.exports.__newString(n.contract.owner);
  } }, api: { _readContractState: (u, c) => {
    const p = o.exports.__getString(c), d = (w = u, o.exports.table.get(w));
    var w;
    return console.log("Simulating read state of", p), setTimeout(() => {
      console.log("calling callback"), d(o.exports.__newString(JSON.stringify({ contractTxId: p })));
    }, 1e3);
  }, clearTimeout }, env: { abort(u, c, p, d) {
    const w = o.exports.__getString(u);
    throw a.error(`--------------------- Error message from AssemblyScript ----------------------
`), a.error("  " + w), a.error('    In file "' + o.exports.__getString(c) + '"'), a.error(`    on line ${p}, column ${d}.`), a.error(`------------------------------------------------------------------------------
`), new Error(w);
  } } };
};
asWasmImports$1.asWasmImports = asWasmImports;
var rustWasmImports$1 = {};
Object.defineProperty(rustWasmImports$1, "__esModule", { value: !0 }), rustWasmImports$1.rustWasmImports = void 0;
const LoggerFactory_1$7 = LoggerFactory$1, rustWasmImports = (n, o, a, u) => {
  const c = LoggerFactory_1$7.LoggerFactory.INST.create("WASM:Rust"), p = { metering: { usegas: n.useGas }, console: { log: function(v) {
    c.debug(`${n.contract.id}: ${v}`);
  } }, Block: { height: function() {
    return n.block.height;
  }, indep_hash: function() {
    return n.block.indep_hash;
  }, timestamp: function() {
    return n.block.timestamp;
  } }, Transaction: { id: function() {
    return n.transaction.id;
  }, owner: function() {
    return n.transaction.owner;
  }, target: function() {
    return n.transaction.target;
  } }, Contract: { id: function() {
    return n.contract.id;
  }, owner: function() {
    return n.contract.owner;
  } }, SmartWeave: { caller: function() {
    return n.caller;
  }, readContractState: async function(v) {
    return await n.contracts.readContractState(v);
  }, write: async function(v, E) {
    return await n.contracts.write(v, E);
  } }, Vrf: { value: function() {
    return n.vrf.value;
  }, randomInt: function(v) {
    return n.vrf.randomInt(v);
  } } }, d = { __wbg_log_: function(v, E) {
    p.console.log(P(v, E));
  }, __wbindgen_json_parse: function(v, E) {
    return z(JSON.parse(P(v, E)));
  }, __wbindgen_json_serialize: function(v, E) {
    const T = F(E);
    var j = W(JSON.stringify(T === void 0 ? null : T), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), L = V;
    te()[v / 4 + 1] = L, te()[v / 4 + 0] = j;
  }, __wbindgen_object_drop_ref: function(v) {
    g(v);
  }, __wbindgen_cb_drop: function(v) {
    const E = g(v).original;
    return E.cnt-- == 1 && (E.a = 0, !0);
  }, __wbg_readContractState: function(v, E) {
    return z(p.SmartWeave.readContractState(P(v, E)));
  }, __wbg_viewContractState: function(v, E) {
  }, __wbg_caller: function(v) {
    var E = W(p.SmartWeave.caller(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_write: function(v, E, T) {
    return z(p.SmartWeave.write(P(v, E), g(T)));
  }, __wbg_refreshState: function(v, E) {
  }, __wbg_indephash: function(v) {
    var E = W(p.Block.indep_hash(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_height: function() {
    return p.Block.height();
  }, __wbg_timestamp: function() {
    return p.Block.timestamp();
  }, __wbg_id: function(v) {
    var E = W(p.Transaction.id(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_contractOwner: function(v) {
    var E = W(p.Contract.owner(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_contractId: function(v) {
    var E = W(p.Contract.id(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_owner: function(v) {
    var E = W(p.Transaction.owner(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_target: function(v) {
    var E = W(p.Transaction.target(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_call: function() {
    return m(function(v, E, T) {
      return z(F(v).call(F(E), F(T)));
    }, arguments);
  }, __wbg_new: function(v, E) {
    try {
      var T = { a: v, b: E }, j = new Promise((L, J) => {
        const Y = T.a;
        T.a = 0;
        try {
          return function(ne, Q, oe, ae) {
            a.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(ne, Q, z(oe), z(ae));
          }(Y, T.b, L, J);
        } finally {
          T.a = Y;
        }
      });
      return z(j);
    } finally {
      T.a = T.b = 0;
    }
  }, __wbg_resolve: function(v) {
    return z(Promise.resolve(F(v)));
  }, __wbg_then_a: function(v, E) {
    return z(F(v).then(F(E)));
  }, __wbg_then_5: function(v, E, T) {
    return z(F(v).then(F(E), F(T)));
  }, __wbindgen_debug_string: function(v, E) {
    var T = W($(F(E)), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), j = V;
    te()[v / 4 + 1] = j, te()[v / 4 + 0] = T;
  }, __wbindgen_throw: function(v, E) {
    throw new Error(P(v, E));
  }, __wbindgen_closure_wrapper: function(v, E, T) {
    var j = function(L, J, Y, ne) {
      const Q = { a: L, b: J, cnt: 1, dtor: Y }, oe = (...ae) => {
        Q.cnt++;
        const ce = Q.a;
        Q.a = 0;
        try {
          return ne(ce, Q.b, ...ae);
        } finally {
          --Q.cnt == 0 ? a.exports.__wbindgen_export_2.get(Q.dtor)(ce, Q.b) : Q.a = ce;
        }
      };
      return oe.original = Q, oe;
    }(v, E, u, _);
    return z(j);
  }, __wbindgen_string_new: function(v, E) {
    return z(P(v, E));
  }, __wbg_value: function(v) {
    var E = W(p.Vrf.value(), a.exports.__wbindgen_malloc, a.exports.__wbindgen_realloc), T = V;
    te()[v / 4 + 1] = T, te()[v / 4 + 0] = E;
  }, __wbg_randomInt: function(v, E) {
    return p.Vrf.randomInt(E);
  } }, w = Object.keys(d);
  let S = o.reduce((v, E) => {
    const T = w.find((j) => E.startsWith(j));
    if (T === void 0)
      throw new Error(`Cannot find import mapping for ${E}`);
    return v[E] = d[T], v;
  }, {}), k = {};
  k.__wbindgen_placeholder__ = S;
  let B = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 });
  B.decode();
  let I = null;
  function C() {
    return I !== null && I.buffer === a.exports.memory.buffer || (I = new Uint8Array(a.exports.memory.buffer)), I;
  }
  function P(v, E) {
    return B.decode(C().subarray(v, v + E));
  }
  const q = new Array(32).fill(void 0);
  q.push(void 0, null, !0, !1);
  let D = q.length;
  function z(v) {
    D === q.length && q.push(q.length + 1);
    const E = D;
    return D = q[E], q[E] = v, E;
  }
  function F(v) {
    return q[v];
  }
  let V = 0, Z = new TextEncoder("utf-8");
  const N = typeof Z.encodeInto == "function" ? function(v, E) {
    return Z.encodeInto(v, E);
  } : function(v, E) {
    const T = Z.encode(v);
    return E.set(T), { read: v.length, written: T.length };
  };
  function W(v, E, T) {
    if (T === void 0) {
      const ne = Z.encode(v), Q = E(ne.length);
      return C().subarray(Q, Q + ne.length).set(ne), V = ne.length, Q;
    }
    let j = v.length, L = E(j);
    const J = C();
    let Y = 0;
    for (; Y < j; Y++) {
      const ne = v.charCodeAt(Y);
      if (ne > 127)
        break;
      J[L + Y] = ne;
    }
    if (Y !== j) {
      Y !== 0 && (v = v.slice(Y)), L = T(L, j, j = Y + 3 * v.length);
      const ne = C().subarray(L + Y, L + j);
      Y += N(v, ne).written;
    }
    return V = Y, L;
  }
  let H = null;
  function te() {
    return H !== null && H.buffer === a.exports.memory.buffer || (H = new Int32Array(a.exports.memory.buffer)), H;
  }
  function g(v) {
    const E = F(v);
    return function(T) {
      T < 36 || (q[T] = D, D = T);
    }(v), E;
  }
  function $(v) {
    const E = typeof v;
    if (E == "number" || E == "boolean" || v == null)
      return `${v}`;
    if (E == "string")
      return `"${v}"`;
    if (E == "symbol") {
      const L = v.description;
      return L == null ? "Symbol" : `Symbol(${L})`;
    }
    if (E == "function") {
      const L = v.name;
      return typeof L == "string" && L.length > 0 ? `Function(${L})` : "Function";
    }
    if (Array.isArray(v)) {
      const L = v.length;
      let J = "[";
      L > 0 && (J += $(v[0]));
      for (let Y = 1; Y < L; Y++)
        J += ", " + $(v[Y]);
      return J += "]", J;
    }
    const T = /\[object ([^\]]+)\]/.exec(toString.call(v));
    let j;
    if (!(T.length > 1))
      return toString.call(v);
    if (j = T[1], j == "Object")
      try {
        return "Object(" + JSON.stringify(v) + ")";
      } catch {
        return "Object";
      }
    return v instanceof Error ? `${v.name}: ${v.message}
${v.stack}` : j;
  }
  function _(v, E, T) {
    a.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(v, E, z(T));
  }
  S.handle = function(v) {
    return g(a.exports.handle(z(v)));
  };
  let b = 32;
  function m(v, E) {
    try {
      return v.apply(this, E);
    } catch (T) {
      a.exports.__wbindgen_exn_store(z(T));
    }
  }
  return S.initState = function(v) {
    try {
      a.exports.initState(function(E) {
        if (b == 1)
          throw new Error("out of js stack");
        return q[--b] = E, b;
      }(v));
    } finally {
      q[b++] = void 0;
    }
  }, S.currentState = function() {
    return g(a.exports.currentState());
  }, S.lang = function() {
    try {
      const T = a.exports.__wbindgen_add_to_stack_pointer(-16);
      a.exports.lang(T);
      var v = te()[T / 4 + 0], E = te()[T / 4 + 1];
      return P(v, E);
    } finally {
      a.exports.__wbindgen_add_to_stack_pointer(16), a.exports.__wbindgen_free(v, E);
    }
  }, S.type = function() {
    return a.exports.type();
  }, S.StateWrapper = class {
    __destroy_into_raw() {
      const v = this.ptr;
      return this.ptr = 0, v;
    }
    free() {
      const v = this.__destroy_into_raw();
      a.exports.__wbg_statewrapper_free(v);
    }
  }, k.metering = p.metering, { imports: k, exports: S };
};
rustWasmImports$1.rustWasmImports = rustWasmImports;
var goWasmImports = {};
Object.defineProperty(goWasmImports, "__esModule", { value: !0 }), goWasmImports.Go = void 0;
const LoggerFactory_1$6 = LoggerFactory$1, encoder = new TextEncoder(), decoder = new TextDecoder("utf-8");
let logLine = [], globalJsModule;
(function(n) {
  globalJsModule = n, globalJsModule.redstone = { go: {} };
}).call(commonjsGlobal, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
class Go {
  constructor(o) {
    this._callbackTimeouts = /* @__PURE__ */ new Map(), this._nextCallbackTimeoutID = 1;
    const a = LoggerFactory_1$6.LoggerFactory.INST.create("WASM:Go");
    let u = this;
    globalJsModule.redstone.go = { WasmModule: { registerWasmModule: function(C) {
      u._id = C, u.exports = globalJsModule[C], delete globalJsModule[C], globalJsModule.redstone.go[C] = {}, globalJsModule.redstone.go[C].imports = { console: { log: function(...P) {
        a.debug(P[0], ...P.slice(1));
      } }, Transaction: { id: function() {
        return o.transaction.id;
      }, owner: function() {
        return o.transaction.owner;
      }, target: function() {
        return o.transaction.target;
      } }, Block: { indep_hash: function() {
        return o.block.indep_hash;
      }, height: function() {
        return o.block.height;
      }, timestamp: function() {
        return o.block.timestamp;
      } }, Contract: { id: function() {
        return o.contract.id;
      }, owner: function() {
        return o.contract.owner;
      } }, SmartWeave: { readContractState: async function(P) {
        return await o.contracts.readContractState(P);
      } } };
    } } };
    const c = () => new DataView(this._inst.exports.memory.buffer), p = (C, P) => {
      c().setUint32(C + 0, P, !0), c().setUint32(C + 4, Math.floor(P / 4294967296), !0);
    }, d = (C) => {
      const P = c().getFloat64(C, !0);
      if (P === 0)
        return;
      if (!isNaN(P))
        return P;
      const q = c().getUint32(C, !0);
      return this._values[q];
    }, w = (C, P) => {
      if (typeof P == "number")
        return isNaN(P) ? (c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 0, !0)) : P === 0 ? (c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 1, !0)) : void c().setFloat64(C, P, !0);
      switch (P) {
        case void 0:
          return void c().setFloat64(C, 0, !0);
        case null:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 2, !0);
        case !0:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 3, !0);
        case !1:
          return c().setUint32(C + 4, 2146959360, !0), void c().setUint32(C, 4, !0);
      }
      let D = this._ids.get(P);
      D === void 0 && (D = this._idPool.pop(), D === void 0 && (D = this._values.length), this._values[D] = P, this._goRefCounts[D] = 0, this._ids.set(P, D)), this._goRefCounts[D]++;
      let z = 1;
      switch (typeof P) {
        case "string":
          z = 2;
          break;
        case "symbol":
          z = 3;
          break;
        case "function":
          z = 4;
      }
      c().setUint32(C + 4, 2146959360 | z, !0), c().setUint32(C, D, !0);
    }, S = (C, P, q = null) => new Uint8Array(this._inst.exports.memory.buffer, C, P), k = (C, P, q) => {
      const D = new Array(P);
      for (let z = 0; z < P; z++)
        D[z] = d(C + 8 * z);
      return D;
    }, B = (C, P) => decoder.decode(new DataView(this._inst.exports.memory.buffer, C, P)), I = Date.now() - performance.now();
    this.importObject = { wasi_snapshot_preview1: { fd_write: function(C, P, q, D) {
      let z = 0;
      if (C == 1)
        for (let F = 0; F < q; F++) {
          let V = P + 8 * F, Z = c().getUint32(V + 0, !0), N = c().getUint32(V + 4, !0);
          z += N;
          for (let W = 0; W < N; W++) {
            let H = c().getUint8(Z + W);
            if (H != 13)
              if (H == 10) {
                let te = decoder.decode(new Uint8Array(logLine));
                logLine = [], console.log(te);
              } else
                logLine.push(H);
          }
        }
      else
        console.error("invalid file descriptor:", C);
      return c().setUint32(D, z, !0), 0;
    }, fd_close: () => 0, fd_fdstat_get: () => 0, fd_seek: () => 0, proc_exit: (C) => {
      if (!commonjsGlobal.process)
        throw "trying to exit with code " + C;
      process.exit(C);
    }, random_get: (C, P) => (crypto.getRandomValues(S(C, P, null)), 0) }, env: { "runtime.ticks": () => I + performance.now(), "runtime.sleepTicks": (C) => {
      setTimeout(this._inst.exports.go_scheduler, C);
    }, "syscall/js.finalizeRef": (C) => {
      const P = c().getUint32(C, !0);
      if (this._goRefCounts[P]--, this._goRefCounts[P] === 0) {
        const q = this._values[P];
        this._values[P] = null, this._ids.delete(q), this._idPool.push(P);
      }
    }, "syscall/js.stringVal": (C, P, q) => {
      const D = B(P, q);
      w(C, D);
    }, "syscall/js.valueGet": (C, P, q, D) => {
      let z = B(q, D), F = d(P), V = Reflect.get(F, z);
      w(C, V);
    }, "syscall/js.valueSet": (C, P, q, D) => {
      const z = d(C), F = B(P, q), V = d(D);
      Reflect.set(z, F, V);
    }, "syscall/js.valueDelete": (C, P, q) => {
      const D = d(C), z = B(P, q);
      Reflect.deleteProperty(D, z);
    }, "syscall/js.valueIndex": (C, P, q) => {
      w(C, Reflect.get(d(P), q));
    }, "syscall/js.valueSetIndex": (C, P, q) => {
      Reflect.set(d(C), P, d(q));
    }, "syscall/js.valueCall": (C, P, q, D, z, F, V) => {
      const Z = d(P), N = B(q, D), W = k(z, F);
      try {
        const H = Reflect.get(Z, N);
        w(C, Reflect.apply(H, Z, W)), c().setUint8(C + 8, 1);
      } catch (H) {
        w(C, H), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueInvoke": (C, P, q, D, z) => {
      try {
        const F = d(P), V = k(q, D);
        w(C, Reflect.apply(F, void 0, V)), c().setUint8(C + 8, 1);
      } catch (F) {
        w(C, F), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueNew": (C, P, q, D, z) => {
      const F = d(P), V = k(q, D);
      try {
        w(C, Reflect.construct(F, V)), c().setUint8(C + 8, 1);
      } catch (Z) {
        w(C, Z), c().setUint8(C + 8, 0);
      }
    }, "syscall/js.valueLength": (C) => d(C).length, "syscall/js.valuePrepareString": (C, P) => {
      const q = String(d(P)), D = encoder.encode(q);
      w(C, D), p(C + 8, D.length);
    }, "syscall/js.valueLoadString": (C, P, q, D) => {
      const z = d(C);
      S(P, q, D).set(z);
    }, "syscall/js.valueInstanceOf": (C, P) => d(C) instanceof d(P), "syscall/js.copyBytesToGo": (C, P, q, D, z) => {
      let F = C, V = C + 4;
      const Z = S(P, q), N = d(z);
      if (!(N instanceof Uint8Array))
        return void c().setUint8(V, 0);
      const W = N.subarray(0, Z.length);
      Z.set(W), p(F, W.length), c().setUint8(V, 1);
    }, "syscall/js.copyBytesToJS": (C, P, q, D, z) => {
      let F = C, V = C + 4;
      const Z = d(P), N = S(q, D);
      if (!(Z instanceof Uint8Array))
        return void c().setUint8(V, 0);
      const W = N.subarray(0, Z.length);
      Z.set(W), p(F, W.length), c().setUint8(V, 1);
    } } };
  }
  async run(o) {
    for (this._inst = o, this._values = [NaN, 0, null, !0, !1, commonjsGlobal, this], this._goRefCounts = [], this._ids = /* @__PURE__ */ new Map(), this._idPool = [], this.exited = !1, new DataView(this._inst.exports.memory.buffer); ; ) {
      const a = new Promise((u) => {
        this._resolveCallbackPromise = () => {
          if (this.exited)
            throw new Error("bad callback: Go program has already exited");
          setTimeout(u, 0);
        };
      });
      if (this._inst.exports._start(), this.exited)
        break;
      await a;
    }
  }
  _resume() {
    if (this.exited)
      throw new Error("Go program has already exited");
    this._inst.exports.resume(), this.exited && this._resolveExitPromise();
  }
  _makeFuncWrapper(o) {
    const a = this;
    return function() {
      const u = { id: o, this: this, args: arguments };
      return a._pendingEvent = u, a._resume(), u.result;
    };
  }
  _resolveExitPromise() {
  }
}
goWasmImports.Go = Go;
var smartweaveGlobal = {};
Object.defineProperty(smartweaveGlobal, "__esModule", { value: !0 }), smartweaveGlobal.SmartWeaveGlobal = void 0;
class SmartWeaveGlobal {
  constructor(o, a, u) {
    this.gasUsed = 0, this.gasLimit = Number.MAX_SAFE_INTEGER, this.unsafeClient = o, this.arweave = { ar: o.ar, utils: o.utils, wallets: o.wallets, crypto: o.crypto }, this.evaluationOptions = u, this.contract = a, this.transaction = new Transaction(this), this.block = new Block(this), this.contracts = { readContractState: (c, p, d) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, viewContractState: (c, p) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, write: (c, p, d) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, refreshState: () => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    } }, this.vrf = new Vrf(this), this.useGas = this.useGas.bind(this), this.getBalance = this.getBalance.bind(this);
  }
  useGas(o) {
    if (o < 0)
      throw new Error("[RE:GNE] Gas number exception - gas < 0.");
    if (this.gasUsed += o, this.gasUsed > this.gasLimit)
      throw new Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
  }
  async getBalance(o, a) {
    if (!this._activeTx)
      throw new Error("Cannot read balance - active tx is not set.");
    if (!this.block.height)
      throw new Error("Cannot read balance - block height not set.");
    const u = a || this.block.height;
    return await fetch(`${this.evaluationOptions.walletBalanceUrl}block/height/${u}/wallet/${o}/balance`).then((c) => c.ok ? c.text() : Promise.reject(c)).catch((c) => {
      var p;
      throw new Error(`Unable to read wallet balance. ${c.status}. ${(p = c.body) === null || p === void 0 ? void 0 : p.message}`);
    });
  }
}
smartweaveGlobal.SmartWeaveGlobal = SmartWeaveGlobal;
class Transaction {
  constructor(o) {
    this.smartWeaveGlobal = o;
  }
  get id() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.id;
  }
  get owner() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.owner.address;
  }
  get target() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.recipient;
  }
  get tags() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.tags;
  }
  get quantity() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.quantity.winston;
  }
  get reward() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.fee.winston;
  }
}
class Block {
  constructor(o) {
    this.smartWeaveGlobal = o;
  }
  get height() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.height;
  }
  get indep_hash() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.id;
  }
  get timestamp() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current tx");
    return this.smartWeaveGlobal._activeTx.block.timestamp;
  }
}
class Vrf {
  constructor(o) {
    this.smartWeaveGlobal = o;
  }
  get data() {
    return this.smartWeaveGlobal._activeTx.vrf;
  }
  get value() {
    return this.smartWeaveGlobal._activeTx.vrf.bigint;
  }
  randomInt(o) {
    if (!Number.isInteger(o))
      throw new Error("Integer max value required for random integer generation");
    const a = BigInt(this.smartWeaveGlobal._activeTx.vrf.bigint) % BigInt(o) + BigInt(1);
    if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER)
      throw new Error("Random int cannot be cast to number");
    return Number(a);
  }
}
var JsHandlerApi$1 = {}, AbstractContractHandler$1 = {}, Contract = {};
Object.defineProperty(Contract, "__esModule", { value: !0 }), Contract.ContractError = void 0;
class ContractError$1 extends Error {
  constructor(o) {
    super(o), this.name = "ContractError";
  }
}
Contract.ContractError = ContractError$1, Object.defineProperty(AbstractContractHandler$1, "__esModule", { value: !0 }), AbstractContractHandler$1.AbstractContractHandler = void 0;
const Contract_1 = Contract, LoggerFactory_1$5 = LoggerFactory$1, utils_1$3 = utils$n;
class AbstractContractHandler {
  constructor(o, a) {
    this.swGlobal = o, this.contractDefinition = a, this.logger = LoggerFactory_1$5.LoggerFactory.INST.create("ContractHandler"), this.assignReadContractState = this.assignReadContractState.bind(this), this.assignViewContractState = this.assignViewContractState.bind(this), this.assignWrite = this.assignWrite.bind(this), this.assignRefreshState = this.assignRefreshState.bind(this);
  }
  async dispose() {
  }
  assignWrite(o, a) {
    this.swGlobal.contracts.write = async (u, c, p) => {
      if (!o.evaluationOptions.internalWrites)
        throw new Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
      const d = p == null ? o.evaluationOptions.throwOnInternalWriteError : p, w = { from: this.contractDefinition.txId, to: u, input: c };
      this.logger.debug("swGlobal.write call:", w);
      const S = o.warp.contract(u, o.contract, { callingInteraction: this.swGlobal._activeTx, callType: "write" }), k = await S.dryWriteFromTx(c, this.swGlobal._activeTx, [...a || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      this.logger.debug("Cache result?:", !this.swGlobal._activeTx.dry);
      const B = k.type !== "ok" && d && (!this.swGlobal._activeTx.dry || this.swGlobal._activeTx.dry && this.swGlobal._activeTx.strict), I = B ? `Internal write auto error for call [${JSON.stringify(w)}]: ${k.errorMessage}` : k.errorMessage;
      if (await o.warp.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, u, { state: k.state, validity: { ...k.originalValidity, [this.swGlobal._activeTx.id]: k.type == "ok" }, errorMessages: { ...k.originalErrorMessages, [this.swGlobal._activeTx.id]: I } }), B)
        throw new Contract_1.ContractError(I);
      return k;
    };
  }
  assignViewContractState(o) {
    this.swGlobal.contracts.viewContractState = async (a, u) => (this.logger.debug("swGlobal.viewContractState call:", { from: this.contractDefinition.txId, to: a, input: u }), await o.warp.contract(a, o.contract, { callingInteraction: this.swGlobal._activeTx, callType: "view" }).viewStateForTx(u, this.swGlobal._activeTx));
  }
  assignReadContractState(o, a, u, c) {
    this.swGlobal.contracts.readContractState = async (p, d) => {
      this.logger.debug("swGlobal.readContractState call:", { from: this.contractDefinition.txId, to: p, sortKey: c.sortKey, transaction: this.swGlobal.transaction.id });
      const { stateEvaluator: w } = o.warp, S = o.warp.contract(p, o.contract, { callingInteraction: c, callType: "read" });
      await w.onContractCall(c, o, u);
      const k = await S.readState(c.sortKey, [...a || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      return d ? (0, utils_1$3.deepCopy)(k) : (0, utils_1$3.deepCopy)(k.cachedValue.state);
    };
  }
  assignRefreshState(o) {
    this.swGlobal.contracts.refreshState = async () => {
      const a = o.warp.stateEvaluator, u = await a.latestAvailableState(this.swGlobal.contract.id, this.swGlobal._activeTx.sortKey);
      return u == null ? void 0 : u.cachedValue.state;
    };
  }
}
AbstractContractHandler$1.AbstractContractHandler = AbstractContractHandler, Object.defineProperty(JsHandlerApi$1, "__esModule", { value: !0 }), JsHandlerApi$1.JsHandlerApi = void 0;
const utils_1$2 = utils$n, AbstractContractHandler_1$1 = AbstractContractHandler$1;
class JsHandlerApi extends AbstractContractHandler_1$1.AbstractContractHandler {
  constructor(o, a, u) {
    super(o, a), this.contractFunction = u;
  }
  async handle(o, a, u) {
    const { timeoutId: c, timeoutPromise: p } = (0, utils_1$2.timeout)(o.evaluationOptions.maxInteractionEvaluationTimeSeconds);
    try {
      const { interaction: d, interactionTx: w, currentTx: S } = u, k = (0, utils_1$2.deepCopy)(a.state, o.evaluationOptions.useFastCopy);
      this.swGlobal._activeTx = w, this.swGlobal.caller = d.caller, this.assignReadContractState(o, S, a, w), this.assignViewContractState(o), this.assignWrite(o, S), this.assignRefreshState(o);
      const B = await Promise.race([p, this.contractFunction(k, d)]);
      if (B && (B.state !== void 0 || B.result !== void 0))
        return { type: "ok", result: B.result, state: B.state || a.state };
      throw new Error(`Unexpected result from contract: ${JSON.stringify(B)}`);
    } catch (d) {
      return d.name === "ContractError" ? { type: "error", errorMessage: d.message, state: a.state, result: null } : { type: "exception", errorMessage: `${d && d.stack || d && d.message || d}`, state: a.state, result: null };
    } finally {
      c !== null && clearTimeout(c);
    }
  }
  initState(o) {
  }
}
JsHandlerApi$1.JsHandlerApi = JsHandlerApi;
var WasmHandlerApi$1 = {}, safeStableStringify = { exports: {} };
(function(n, o) {
  const a = z();
  a.configure = z, a.stringify = a, a.default = a, o.stringify = a, o.configure = z, n.exports = a;
  const u = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/, c = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g, p = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "\\t", "\\n", "\\u000b", "\\f", "\\r", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f", "", "", '\\"', "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\"];
  function d(F) {
    if (F.length === 2) {
      const Z = F.charCodeAt(1);
      return `${F[0]}\\u${Z.toString(16)}`;
    }
    const V = F.charCodeAt(0);
    return p.length > V ? p[V] : `\\u${V.toString(16)}`;
  }
  function w(F) {
    if (F.length < 5e3 && !u.test(F))
      return F;
    if (F.length > 100)
      return F.replace(c, d);
    let V = "", Z = 0;
    for (let N = 0; N < F.length; N++) {
      const W = F.charCodeAt(N);
      if (W === 34 || W === 92 || W < 32)
        V += `${F.slice(Z, N)}${p[W]}`, Z = N + 1;
      else if (W >= 55296 && W <= 57343) {
        if (W <= 56319 && N + 1 < F.length) {
          const H = F.charCodeAt(N + 1);
          if (H >= 56320 && H <= 57343) {
            N++;
            continue;
          }
        }
        V += `${F.slice(Z, N)}\\u${W.toString(16)}`, Z = N + 1;
      }
    }
    return V += F.slice(Z), V;
  }
  function S(F) {
    if (F.length > 200)
      return F.sort();
    for (let V = 1; V < F.length; V++) {
      const Z = F[V];
      let N = V;
      for (; N !== 0 && F[N - 1] > Z; )
        F[N] = F[N - 1], N--;
      F[N] = Z;
    }
    return F;
  }
  const k = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
  function B(F) {
    return k.call(F) !== void 0 && F.length !== 0;
  }
  function I(F, V, Z) {
    F.length < Z && (Z = F.length);
    const N = V === "," ? "" : " ";
    let W = `"0":${N}${F[0]}`;
    for (let H = 1; H < Z; H++)
      W += `${V}"${H}":${N}${F[H]}`;
    return W;
  }
  function C(F, V) {
    if (F && Object.prototype.hasOwnProperty.call(F, V)) {
      var Z = F[V];
      if (typeof Z != "boolean")
        throw new TypeError(`The "${V}" argument must be of type boolean`);
    }
    return Z === void 0 || Z;
  }
  function P(F, V) {
    if (F && Object.prototype.hasOwnProperty.call(F, V)) {
      var Z = F[V];
      if (typeof Z != "number")
        throw new TypeError(`The "${V}" argument must be of type number`);
      if (!Number.isInteger(Z))
        throw new TypeError(`The "${V}" argument must be an integer`);
      if (Z < 1)
        throw new RangeError(`The "${V}" argument must be >= 1`);
    }
    return Z === void 0 ? 1 / 0 : Z;
  }
  function q(F) {
    return F === 1 ? "1 item" : `${F} items`;
  }
  function D(F) {
    const V = /* @__PURE__ */ new Set();
    for (const Z of F)
      typeof Z == "string" ? V.add(Z) : typeof Z == "number" && V.add(String(Z));
    return V;
  }
  function z(F) {
    const V = function(b) {
      if (b && Object.prototype.hasOwnProperty.call(b, "circularValue")) {
        var m = b.circularValue;
        if (typeof m == "string")
          return `"${m}"`;
        if (m == null)
          return m;
        if (m === Error || m === TypeError)
          return { toString() {
            throw new TypeError("Converting circular structure to JSON");
          } };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }(F), Z = C(F, "bigint"), N = C(F, "deterministic"), W = P(F, "maximumDepth"), H = P(F, "maximumBreadth");
    function te(b, m, v, E, T, j) {
      let L = m[b];
      switch (typeof L == "object" && L !== null && typeof L.toJSON == "function" && (L = L.toJSON(b)), L = E.call(m, b, L), typeof L) {
        case "string":
          return `"${w(L)}"`;
        case "object": {
          if (L === null)
            return "null";
          if (v.indexOf(L) !== -1)
            return V;
          let J = "", Y = ",";
          const ne = j;
          if (Array.isArray(L)) {
            if (L.length === 0)
              return "[]";
            if (W < v.length + 1)
              return '"[Array]"';
            v.push(L), T !== "" && (J += `
${j += T}`, Y = `,
${j}`);
            const le = Math.min(L.length, H);
            let Se = 0;
            for (; Se < le - 1; Se++) {
              const _e = te(Se, L, v, E, T, j);
              J += _e !== void 0 ? _e : "null", J += Y;
            }
            const he = te(Se, L, v, E, T, j);
            return J += he !== void 0 ? he : "null", L.length - 1 > H && (J += `${Y}"... ${q(L.length - H - 1)} not stringified"`), T !== "" && (J += `
${ne}`), v.pop(), `[${J}]`;
          }
          let Q = Object.keys(L);
          const oe = Q.length;
          if (oe === 0)
            return "{}";
          if (W < v.length + 1)
            return '"[Object]"';
          let ae = "", ce = "";
          T !== "" && (Y = `,
${j += T}`, ae = " ");
          let ue = Math.min(oe, H);
          B(L) && (J += I(L, Y, H), Q = Q.slice(L.length), ue -= L.length, ce = Y), N && (Q = S(Q)), v.push(L);
          for (let le = 0; le < ue; le++) {
            const Se = Q[le], he = te(Se, L, v, E, T, j);
            he !== void 0 && (J += `${ce}"${w(Se)}":${ae}${he}`, ce = Y);
          }
          return oe > H && (J += `${ce}"...":${ae}"${q(oe - H)} not stringified"`, ce = Y), T !== "" && ce.length > 1 && (J = `
${j}${J}
${ne}`), v.pop(), `{${J}}`;
        }
        case "number":
          return isFinite(L) ? String(L) : "null";
        case "boolean":
          return L === !0 ? "true" : "false";
        case "bigint":
          return Z ? String(L) : void 0;
      }
    }
    function g(b, m, v, E, T, j) {
      switch (typeof m == "object" && m !== null && typeof m.toJSON == "function" && (m = m.toJSON(b)), typeof m) {
        case "string":
          return `"${w(m)}"`;
        case "object": {
          if (m === null)
            return "null";
          if (v.indexOf(m) !== -1)
            return V;
          const L = j;
          let J = "", Y = ",";
          if (Array.isArray(m)) {
            if (m.length === 0)
              return "[]";
            if (W < v.length + 1)
              return '"[Array]"';
            v.push(m), T !== "" && (J += `
${j += T}`, Y = `,
${j}`);
            const oe = Math.min(m.length, H);
            let ae = 0;
            for (; ae < oe - 1; ae++) {
              const ue = g(ae, m[ae], v, E, T, j);
              J += ue !== void 0 ? ue : "null", J += Y;
            }
            const ce = g(ae, m[ae], v, E, T, j);
            return J += ce !== void 0 ? ce : "null", m.length - 1 > H && (J += `${Y}"... ${q(m.length - H - 1)} not stringified"`), T !== "" && (J += `
${L}`), v.pop(), `[${J}]`;
          }
          if (E.size === 0)
            return "{}";
          v.push(m);
          let ne = "";
          T !== "" && (Y = `,
${j += T}`, ne = " ");
          let Q = "";
          for (const oe of E) {
            const ae = g(oe, m[oe], v, E, T, j);
            ae !== void 0 && (J += `${Q}"${w(oe)}":${ne}${ae}`, Q = Y);
          }
          return T !== "" && Q.length > 1 && (J = `
${j}${J}
${L}`), v.pop(), `{${J}}`;
        }
        case "number":
          return isFinite(m) ? String(m) : "null";
        case "boolean":
          return m === !0 ? "true" : "false";
        case "bigint":
          return Z ? String(m) : void 0;
      }
    }
    function $(b, m, v, E, T) {
      switch (typeof m) {
        case "string":
          return `"${w(m)}"`;
        case "object": {
          if (m === null)
            return "null";
          if (typeof m.toJSON == "function") {
            if (typeof (m = m.toJSON(b)) != "object")
              return $(b, m, v, E, T);
            if (m === null)
              return "null";
          }
          if (v.indexOf(m) !== -1)
            return V;
          const j = T;
          if (Array.isArray(m)) {
            if (m.length === 0)
              return "[]";
            if (W < v.length + 1)
              return '"[Array]"';
            v.push(m);
            let ae = `
${T += E}`;
            const ce = `,
${T}`, ue = Math.min(m.length, H);
            let le = 0;
            for (; le < ue - 1; le++) {
              const he = $(le, m[le], v, E, T);
              ae += he !== void 0 ? he : "null", ae += ce;
            }
            const Se = $(le, m[le], v, E, T);
            return ae += Se !== void 0 ? Se : "null", m.length - 1 > H && (ae += `${ce}"... ${q(m.length - H - 1)} not stringified"`), ae += `
${j}`, v.pop(), `[${ae}]`;
          }
          let L = Object.keys(m);
          const J = L.length;
          if (J === 0)
            return "{}";
          if (W < v.length + 1)
            return '"[Object]"';
          const Y = `,
${T += E}`;
          let ne = "", Q = "", oe = Math.min(J, H);
          B(m) && (ne += I(m, Y, H), L = L.slice(m.length), oe -= m.length, Q = Y), N && (L = S(L)), v.push(m);
          for (let ae = 0; ae < oe; ae++) {
            const ce = L[ae], ue = $(ce, m[ce], v, E, T);
            ue !== void 0 && (ne += `${Q}"${w(ce)}": ${ue}`, Q = Y);
          }
          return J > H && (ne += `${Q}"...": "${q(J - H)} not stringified"`, Q = Y), Q !== "" && (ne = `
${T}${ne}
${j}`), v.pop(), `{${ne}}`;
        }
        case "number":
          return isFinite(m) ? String(m) : "null";
        case "boolean":
          return m === !0 ? "true" : "false";
        case "bigint":
          return Z ? String(m) : void 0;
      }
    }
    function _(b, m, v) {
      switch (typeof m) {
        case "string":
          return `"${w(m)}"`;
        case "object": {
          if (m === null)
            return "null";
          if (typeof m.toJSON == "function") {
            if (typeof (m = m.toJSON(b)) != "object")
              return _(b, m, v);
            if (m === null)
              return "null";
          }
          if (v.indexOf(m) !== -1)
            return V;
          let E = "";
          if (Array.isArray(m)) {
            if (m.length === 0)
              return "[]";
            if (W < v.length + 1)
              return '"[Array]"';
            v.push(m);
            const Y = Math.min(m.length, H);
            let ne = 0;
            for (; ne < Y - 1; ne++) {
              const oe = _(ne, m[ne], v);
              E += oe !== void 0 ? oe : "null", E += ",";
            }
            const Q = _(ne, m[ne], v);
            return E += Q !== void 0 ? Q : "null", m.length - 1 > H && (E += `,"... ${q(m.length - H - 1)} not stringified"`), v.pop(), `[${E}]`;
          }
          let T = Object.keys(m);
          const j = T.length;
          if (j === 0)
            return "{}";
          if (W < v.length + 1)
            return '"[Object]"';
          let L = "", J = Math.min(j, H);
          B(m) && (E += I(m, ",", H), T = T.slice(m.length), J -= m.length, L = ","), N && (T = S(T)), v.push(m);
          for (let Y = 0; Y < J; Y++) {
            const ne = T[Y], Q = _(ne, m[ne], v);
            Q !== void 0 && (E += `${L}"${w(ne)}":${Q}`, L = ",");
          }
          return j > H && (E += `${L}"...":"${q(j - H)} not stringified"`), v.pop(), `{${E}}`;
        }
        case "number":
          return isFinite(m) ? String(m) : "null";
        case "boolean":
          return m === !0 ? "true" : "false";
        case "bigint":
          return Z ? String(m) : void 0;
      }
    }
    return function(b, m, v) {
      if (arguments.length > 1) {
        let E = "";
        if (typeof v == "number" ? E = " ".repeat(Math.min(v, 10)) : typeof v == "string" && (E = v.slice(0, 10)), m != null) {
          if (typeof m == "function")
            return te("", { "": b }, [], m, E, "");
          if (Array.isArray(m))
            return g("", b, [], D(m), E, "");
        }
        if (E.length !== 0)
          return $("", b, [], E, "");
      }
      return _("", b, []);
    };
  }
})(safeStableStringify, safeStableStringify.exports);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(WasmHandlerApi$1, "__esModule", { value: !0 }), WasmHandlerApi$1.WasmHandlerApi = void 0;
const safe_stable_stringify_1 = __importDefault$4(safeStableStringify.exports), AbstractContractHandler_1 = AbstractContractHandler$1;
class WasmHandlerApi extends AbstractContractHandler_1.AbstractContractHandler {
  constructor(o, a, u) {
    super(o, a), this.wasmExports = u;
  }
  async handle(o, a, u) {
    try {
      const { interaction: c, interactionTx: p, currentTx: d } = u;
      return this.swGlobal._activeTx = p, this.swGlobal.caller = c.caller, this.swGlobal.gasLimit = o.evaluationOptions.gasLimit, this.swGlobal.gasUsed = 0, this.assignReadContractState(o, d, a, p), this.assignWrite(o, d), { type: "ok", result: await this.doHandle(c), state: this.doGetCurrentState(), gasUsed: this.swGlobal.gasUsed };
    } catch (c) {
      const p = { errorMessage: c.message, state: a.state, result: null };
      return c.message.startsWith("[RE:") ? (this.logger.fatal(c), { ...p, type: "exception" }) : { ...p, type: "error" };
    }
  }
  initState(o) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const a = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(o));
        this.wasmExports.initState(a);
        break;
      }
      case "rust":
        this.wasmExports.initState(o);
        break;
      case "go":
        this.wasmExports.initState((0, safe_stable_stringify_1.default)(o));
        break;
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  async doHandle(o) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const a = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(o.input)), u = this.wasmExports.handle(a), c = this.wasmExports.__getString(u);
        return JSON.parse(c);
      }
      case "rust": {
        let a = await this.wasmExports.handle(o.input);
        if (!a)
          return;
        if (Object.prototype.hasOwnProperty.call(a, "Ok"))
          return a.Ok;
        {
          let u;
          this.logger.debug("Error from rust", a.Err);
          let c = "";
          throw typeof a.Err == "string" || a.Err instanceof String ? u = a.Err : (u = Object.keys(a.Err)[0], c = " " + a.Err[u]), u == "RuntimeError" ? new Error(`[RE:RE]${c}`) : new Error(`[CE:${u}${c}]`);
        }
      }
      case "go": {
        const a = await this.wasmExports.handle((0, safe_stable_stringify_1.default)(o.input));
        return JSON.parse(a);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  doGetCurrentState() {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const o = this.wasmExports.currentState();
        return JSON.parse(this.wasmExports.__getString(o));
      }
      case "rust":
        return this.wasmExports.currentState();
      case "go": {
        const o = this.wasmExports.currentState();
        return JSON.parse(o);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
}
WasmHandlerApi$1.WasmHandlerApi = WasmHandlerApi;
var normalizeSource = {};
function normalizeContractSource(n, o) {
  const a = n.trim().split(`
`), u = a[0], c = a[a.length - 1];
  return (/\(\s*\(\)\s*=>\s*{/g.test(u) || /\s*\(\s*function\s*\(\)\s*{/g.test(u)) && /}\s*\)\s*\(\)\s*;/g.test(c) && (a.shift(), a.pop(), n = a.join(`
`)), n = n.replace(/export\s+async\s+function\s+handle/gmu, "async function handle").replace(/export\s+function\s+handle/gmu, "function handle"), o ? `
    ${n}
    module.exports = handle;` : `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${n};
    return handle;
  `;
}
Object.defineProperty(normalizeSource, "__esModule", { value: !0 }), normalizeSource.normalizeContractSource = void 0, normalizeSource.normalizeContractSource = normalizeContractSource;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(n, o, a, u) {
  u === void 0 && (u = a);
  var c = Object.getOwnPropertyDescriptor(o, a);
  c && !("get" in c ? !o.__esModule : c.writable || c.configurable) || (c = { enumerable: !0, get: function() {
    return o[a];
  } }), Object.defineProperty(n, u, c);
} : function(n, o, a, u) {
  u === void 0 && (u = a), n[u] = o[a];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(n, o) {
  Object.defineProperty(n, "default", { enumerable: !0, value: o });
} : function(n, o) {
  n.default = o;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var o = {};
  if (n != null)
    for (var a in n)
      a !== "default" && Object.prototype.hasOwnProperty.call(n, a) && __createBinding(o, n, a);
  return __setModuleDefault(o, n), o;
}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(HandlerExecutorFactory$1, "__esModule", { value: !0 }), HandlerExecutorFactory$1.HandlerExecutorFactory = void 0;
const loader_1 = __importDefault$3(umd.exports), as_wasm_imports_1 = asWasmImports$1, rust_wasm_imports_1 = rustWasmImports$1, go_wasm_imports_1$1 = goWasmImports, bignumber_js_1 = __importDefault$3(bignumber.exports), vm2 = __importStar(require$$2$1), smartweave_global_1 = smartweaveGlobal, Benchmark_1 = Benchmark$1, LoggerFactory_1$4 = LoggerFactory$1, JsHandlerApi_1 = JsHandlerApi$1, WasmHandlerApi_1 = WasmHandlerApi$1, normalize_source_1 = normalizeSource, MemCache_1 = MemCache$1;
class ContractError extends Error {
  constructor(o) {
    super(o), this.name = "ContractError";
  }
}
class HandlerExecutorFactory {
  constructor(o) {
    this.arweave = o, this.logger = LoggerFactory_1$4.LoggerFactory.INST.create("HandlerExecutorFactory"), this.cache = new MemCache_1.MemCache();
  }
  async create(o, a) {
    const u = new smartweave_global_1.SmartWeaveGlobal(this.arweave, { id: o.txId, owner: o.owner }, a);
    if (o.contractType == "wasm") {
      this.logger.info("Creating handler for wasm contract", o.txId);
      const c = Benchmark_1.Benchmark.measure();
      let p, d = null;
      const w = generateResponse(o.srcBinary);
      switch (o.srcWasmLang) {
        case "assemblyscript": {
          const S = { exports: null };
          p = await loader_1.default.instantiateStreaming(w, (0, as_wasm_imports_1.asWasmImports)(u, S)), S.exports = p.exports;
          break;
        }
        case "rust": {
          const S = { exports: null, modifiedExports: { wasm_bindgen__convert__closures__invoke2_mut__: null, _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null } }, k = await getWasmModule(w, o.srcBinary), B = WebAssembly.Module.imports(k).filter((P) => P.module === "__wbindgen_placeholder__").map((P) => P.name), { imports: I, exports: C } = (0, rust_wasm_imports_1.rustWasmImports)(u, B, S, o.metadata.dtor);
          d = C, p = await WebAssembly.instantiate(k, I), S.exports = p.exports, Object.keys(p.exports).forEach((P) => {
            P.startsWith("wasm_bindgen__convert__closures__invoke2_mut__") && (S.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = p.exports[P]), P.startsWith("_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__") && (S.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = p.exports[P]);
          });
          break;
        }
        case "go": {
          const S = new go_wasm_imports_1$1.Go(u);
          S.importObject.metering = { usegas: function(B) {
            u.useGas(B);
          } };
          const k = await getWasmModule(w, o.srcBinary);
          p = await WebAssembly.instantiate(k, S.importObject), S.run(p), d = S.exports;
          break;
        }
        default:
          throw new Error(`Support for ${o.srcWasmLang} not implemented yet.`);
      }
      return this.logger.info(`WASM ${o.srcWasmLang} handler created in ${c.elapsed()}`), new WasmHandlerApi_1.WasmHandlerApi(u, o, d || p.exports);
    }
    {
      this.logger.info("Creating handler for js contract", o.txId);
      const c = (0, normalize_source_1.normalizeContractSource)(o.src, a.useVM2);
      if (!a.allowUnsafeClient && c.includes("SmartWeave.unsafeClient"))
        throw new Error("Using unsafeClient is not allowed by default. Use EvaluationOptions.allowUnsafeClient flag.");
      if (!a.allowBigInt && c.includes("BigInt"))
        throw new Error("Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.");
      if (a.useVM2) {
        const p = new vm2.VMScript(c), d = new vm2.NodeVM({ console: "off", sandbox: { SmartWeave: u, BigNumber: bignumber_js_1.default, logger: this.logger, ContractError, ContractAssert: function(w, S) {
          if (!w)
            throw new ContractError(S);
        } }, compiler: "javascript", eval: !1, wasm: !1, allowAsync: !0, wrapper: "commonjs" });
        return new JsHandlerApi_1.JsHandlerApi(u, o, d.run(p));
      }
      {
        const p = new Function(c)(u, bignumber_js_1.default, LoggerFactory_1$4.LoggerFactory.INST.create(u.contract.id));
        return new JsHandlerApi_1.JsHandlerApi(u, o, p);
      }
    }
  }
}
function generateResponse(n) {
  return new Response(n, { status: 200, statusText: "OK", headers: { "Content-Type": "application/wasm" } });
}
async function getWasmModule(n, o) {
  return WebAssembly.compileStreaming ? await WebAssembly.compileStreaming(n) : await WebAssembly.compile(o);
}
HandlerExecutorFactory$1.HandlerExecutorFactory = HandlerExecutorFactory;
var Warp = {}, DefaultCreateContract = {}, SourceImpl$1 = {}, redstoneWasmMetering = {}, redstoneWasmJsonToolkit = {}, wasm2json$1 = { exports: {} }, leb128$1 = {}, bn = { exports: {} };
(function(n, o) {
  function a(g, $) {
    if (!g)
      throw new Error($ || "Assertion failed");
  }
  function u(g, $) {
    g.super_ = $;
    var _ = function() {
    };
    _.prototype = $.prototype, g.prototype = new _(), g.prototype.constructor = g;
  }
  function c(g, $, _) {
    if (c.isBN(g))
      return g;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, g !== null && ($ !== "le" && $ !== "be" || (_ = $, $ = 10), this._init(g || 0, $ || 10, _ || "be"));
  }
  var p;
  typeof bn == "object" ? bn.exports = c : o.BN = c, c.BN = c, c.wordSize = 26;
  try {
    p = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function d(g, $) {
    var _ = g.charCodeAt($);
    return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
  }
  function w(g, $, _) {
    var b = d(g, _);
    return _ - 1 >= $ && (b |= d(g, _ - 1) << 4), b;
  }
  function S(g, $, _, b) {
    for (var m = 0, v = Math.min(g.length, _), E = $; E < v; E++) {
      var T = g.charCodeAt(E) - 48;
      m *= b, m += T >= 49 ? T - 49 + 10 : T >= 17 ? T - 17 + 10 : T;
    }
    return m;
  }
  c.isBN = function(g) {
    return g instanceof c || g !== null && typeof g == "object" && g.constructor.wordSize === c.wordSize && Array.isArray(g.words);
  }, c.max = function(g, $) {
    return g.cmp($) > 0 ? g : $;
  }, c.min = function(g, $) {
    return g.cmp($) < 0 ? g : $;
  }, c.prototype._init = function(g, $, _) {
    if (typeof g == "number")
      return this._initNumber(g, $, _);
    if (typeof g == "object")
      return this._initArray(g, $, _);
    $ === "hex" && ($ = 16), a($ === (0 | $) && $ >= 2 && $ <= 36);
    var b = 0;
    (g = g.toString().replace(/\s+/g, ""))[0] === "-" && (b++, this.negative = 1), b < g.length && ($ === 16 ? this._parseHex(g, b, _) : (this._parseBase(g, $, b), _ === "le" && this._initArray(this.toArray(), $, _)));
  }, c.prototype._initNumber = function(g, $, _) {
    g < 0 && (this.negative = 1, g = -g), g < 67108864 ? (this.words = [67108863 & g], this.length = 1) : g < 4503599627370496 ? (this.words = [67108863 & g, g / 67108864 & 67108863], this.length = 2) : (a(g < 9007199254740992), this.words = [67108863 & g, g / 67108864 & 67108863, 1], this.length = 3), _ === "le" && this._initArray(this.toArray(), $, _);
  }, c.prototype._initArray = function(g, $, _) {
    if (a(typeof g.length == "number"), g.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v, E = 0;
    if (_ === "be")
      for (b = g.length - 1, m = 0; b >= 0; b -= 3)
        v = g[b] | g[b - 1] << 8 | g[b - 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    else if (_ === "le")
      for (b = 0, m = 0; b < g.length; b += 3)
        v = g[b] | g[b + 1] << 8 | g[b + 2] << 16, this.words[m] |= v << E & 67108863, this.words[m + 1] = v >>> 26 - E & 67108863, (E += 24) >= 26 && (E -= 26, m++);
    return this.strip();
  }, c.prototype._parseHex = function(g, $, _) {
    this.length = Math.ceil((g.length - $) / 6), this.words = new Array(this.length);
    for (var b = 0; b < this.length; b++)
      this.words[b] = 0;
    var m, v = 0, E = 0;
    if (_ === "be")
      for (b = g.length - 1; b >= $; b -= 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    else
      for (b = (g.length - $) % 2 == 0 ? $ + 1 : $; b < g.length; b += 2)
        m = w(g, $, b) << v, this.words[E] |= 67108863 & m, v >= 18 ? (v -= 18, E += 1, this.words[E] |= m >>> 26) : v += 8;
    this.strip();
  }, c.prototype._parseBase = function(g, $, _) {
    this.words = [0], this.length = 1;
    for (var b = 0, m = 1; m <= 67108863; m *= $)
      b++;
    b--, m = m / $ | 0;
    for (var v = g.length - _, E = v % b, T = Math.min(v, v - E) + _, j = 0, L = _; L < T; L += b)
      j = S(g, L, L + b, $), this.imuln(m), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    if (E !== 0) {
      var J = 1;
      for (j = S(g, L, g.length, $), L = 0; L < E; L++)
        J *= $;
      this.imuln(J), this.words[0] + j < 67108864 ? this.words[0] += j : this._iaddn(j);
    }
    this.strip();
  }, c.prototype.copy = function(g) {
    g.words = new Array(this.length);
    for (var $ = 0; $ < this.length; $++)
      g.words[$] = this.words[$];
    g.length = this.length, g.negative = this.negative, g.red = this.red;
  }, c.prototype.clone = function() {
    var g = new c(null);
    return this.copy(g), g;
  }, c.prototype._expand = function(g) {
    for (; this.length < g; )
      this.words[this.length++] = 0;
    return this;
  }, c.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, c.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, c.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var k = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function C(g, $, _) {
    _.negative = $.negative ^ g.negative;
    var b = g.length + $.length | 0;
    _.length = b, b = b - 1 | 0;
    var m = 0 | g.words[0], v = 0 | $.words[0], E = m * v, T = 67108863 & E, j = E / 67108864 | 0;
    _.words[0] = T;
    for (var L = 1; L < b; L++) {
      for (var J = j >>> 26, Y = 67108863 & j, ne = Math.min(L, $.length - 1), Q = Math.max(0, L - g.length + 1); Q <= ne; Q++) {
        var oe = L - Q | 0;
        J += (E = (m = 0 | g.words[oe]) * (v = 0 | $.words[Q]) + Y) / 67108864 | 0, Y = 67108863 & E;
      }
      _.words[L] = 0 | Y, j = 0 | J;
    }
    return j !== 0 ? _.words[L] = 0 | j : _.length--, _.strip();
  }
  c.prototype.toString = function(g, $) {
    var _;
    if ($ = 0 | $ || 1, (g = g || 10) === 16 || g === "hex") {
      _ = "";
      for (var b = 0, m = 0, v = 0; v < this.length; v++) {
        var E = this.words[v], T = (16777215 & (E << b | m)).toString(16);
        _ = (m = E >>> 24 - b & 16777215) != 0 || v !== this.length - 1 ? k[6 - T.length] + T + _ : T + _, (b += 2) >= 26 && (b -= 26, v--);
      }
      for (m !== 0 && (_ = m.toString(16) + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    if (g === (0 | g) && g >= 2 && g <= 36) {
      var j = B[g], L = I[g];
      _ = "";
      var J = this.clone();
      for (J.negative = 0; !J.isZero(); ) {
        var Y = J.modn(L).toString(g);
        _ = (J = J.idivn(L)).isZero() ? Y + _ : k[j - Y.length] + Y + _;
      }
      for (this.isZero() && (_ = "0" + _); _.length % $ != 0; )
        _ = "0" + _;
      return this.negative !== 0 && (_ = "-" + _), _;
    }
    a(!1, "Base should be between 2 and 36");
  }, c.prototype.toNumber = function() {
    var g = this.words[0];
    return this.length === 2 ? g += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? g += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -g : g;
  }, c.prototype.toJSON = function() {
    return this.toString(16);
  }, c.prototype.toBuffer = function(g, $) {
    return a(p !== void 0), this.toArrayLike(p, g, $);
  }, c.prototype.toArray = function(g, $) {
    return this.toArrayLike(Array, g, $);
  }, c.prototype.toArrayLike = function(g, $, _) {
    var b = this.byteLength(), m = _ || Math.max(1, b);
    a(b <= m, "byte array longer than desired length"), a(m > 0, "Requested array length <= 0"), this.strip();
    var v, E, T = $ === "le", j = new g(m), L = this.clone();
    if (T) {
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[E] = v;
      for (; E < m; E++)
        j[E] = 0;
    } else {
      for (E = 0; E < m - b; E++)
        j[E] = 0;
      for (E = 0; !L.isZero(); E++)
        v = L.andln(255), L.iushrn(8), j[m - E - 1] = v;
    }
    return j;
  }, Math.clz32 ? c.prototype._countBits = function(g) {
    return 32 - Math.clz32(g);
  } : c.prototype._countBits = function(g) {
    var $ = g, _ = 0;
    return $ >= 4096 && (_ += 13, $ >>>= 13), $ >= 64 && (_ += 7, $ >>>= 7), $ >= 8 && (_ += 4, $ >>>= 4), $ >= 2 && (_ += 2, $ >>>= 2), _ + $;
  }, c.prototype._zeroBits = function(g) {
    if (g === 0)
      return 26;
    var $ = g, _ = 0;
    return (8191 & $) == 0 && (_ += 13, $ >>>= 13), (127 & $) == 0 && (_ += 7, $ >>>= 7), (15 & $) == 0 && (_ += 4, $ >>>= 4), (3 & $) == 0 && (_ += 2, $ >>>= 2), (1 & $) == 0 && _++, _;
  }, c.prototype.bitLength = function() {
    var g = this.words[this.length - 1], $ = this._countBits(g);
    return 26 * (this.length - 1) + $;
  }, c.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var g = 0, $ = 0; $ < this.length; $++) {
      var _ = this._zeroBits(this.words[$]);
      if (g += _, _ !== 26)
        break;
    }
    return g;
  }, c.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, c.prototype.toTwos = function(g) {
    return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();
  }, c.prototype.fromTwos = function(g) {
    return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();
  }, c.prototype.isNeg = function() {
    return this.negative !== 0;
  }, c.prototype.neg = function() {
    return this.clone().ineg();
  }, c.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, c.prototype.iuor = function(g) {
    for (; this.length < g.length; )
      this.words[this.length++] = 0;
    for (var $ = 0; $ < g.length; $++)
      this.words[$] = this.words[$] | g.words[$];
    return this.strip();
  }, c.prototype.ior = function(g) {
    return a((this.negative | g.negative) == 0), this.iuor(g);
  }, c.prototype.or = function(g) {
    return this.length > g.length ? this.clone().ior(g) : g.clone().ior(this);
  }, c.prototype.uor = function(g) {
    return this.length > g.length ? this.clone().iuor(g) : g.clone().iuor(this);
  }, c.prototype.iuand = function(g) {
    var $;
    $ = this.length > g.length ? g : this;
    for (var _ = 0; _ < $.length; _++)
      this.words[_] = this.words[_] & g.words[_];
    return this.length = $.length, this.strip();
  }, c.prototype.iand = function(g) {
    return a((this.negative | g.negative) == 0), this.iuand(g);
  }, c.prototype.and = function(g) {
    return this.length > g.length ? this.clone().iand(g) : g.clone().iand(this);
  }, c.prototype.uand = function(g) {
    return this.length > g.length ? this.clone().iuand(g) : g.clone().iuand(this);
  }, c.prototype.iuxor = function(g) {
    var $, _;
    this.length > g.length ? ($ = this, _ = g) : ($ = g, _ = this);
    for (var b = 0; b < _.length; b++)
      this.words[b] = $.words[b] ^ _.words[b];
    if (this !== $)
      for (; b < $.length; b++)
        this.words[b] = $.words[b];
    return this.length = $.length, this.strip();
  }, c.prototype.ixor = function(g) {
    return a((this.negative | g.negative) == 0), this.iuxor(g);
  }, c.prototype.xor = function(g) {
    return this.length > g.length ? this.clone().ixor(g) : g.clone().ixor(this);
  }, c.prototype.uxor = function(g) {
    return this.length > g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);
  }, c.prototype.inotn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = 0 | Math.ceil(g / 26), _ = g % 26;
    this._expand($), _ > 0 && $--;
    for (var b = 0; b < $; b++)
      this.words[b] = 67108863 & ~this.words[b];
    return _ > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - _), this.strip();
  }, c.prototype.notn = function(g) {
    return this.clone().inotn(g);
  }, c.prototype.setn = function(g, $) {
    a(typeof g == "number" && g >= 0);
    var _ = g / 26 | 0, b = g % 26;
    return this._expand(_ + 1), this.words[_] = $ ? this.words[_] | 1 << b : this.words[_] & ~(1 << b), this.strip();
  }, c.prototype.iadd = function(g) {
    var $, _, b;
    if (this.negative !== 0 && g.negative === 0)
      return this.negative = 0, $ = this.isub(g), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && g.negative !== 0)
      return g.negative = 0, $ = this.isub(g), g.negative = 1, $._normSign();
    this.length > g.length ? (_ = this, b = g) : (_ = g, b = this);
    for (var m = 0, v = 0; v < b.length; v++)
      $ = (0 | _.words[v]) + (0 | b.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    for (; m !== 0 && v < _.length; v++)
      $ = (0 | _.words[v]) + m, this.words[v] = 67108863 & $, m = $ >>> 26;
    if (this.length = _.length, m !== 0)
      this.words[this.length] = m, this.length++;
    else if (_ !== this)
      for (; v < _.length; v++)
        this.words[v] = _.words[v];
    return this;
  }, c.prototype.add = function(g) {
    var $;
    return g.negative !== 0 && this.negative === 0 ? (g.negative = 0, $ = this.sub(g), g.negative ^= 1, $) : g.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = g.sub(this), this.negative = 1, $) : this.length > g.length ? this.clone().iadd(g) : g.clone().iadd(this);
  }, c.prototype.isub = function(g) {
    if (g.negative !== 0) {
      g.negative = 0;
      var $ = this.iadd(g);
      return g.negative = 1, $._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();
    var _, b, m = this.cmp(g);
    if (m === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    m > 0 ? (_ = this, b = g) : (_ = g, b = this);
    for (var v = 0, E = 0; E < b.length; E++)
      v = ($ = (0 | _.words[E]) - (0 | b.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    for (; v !== 0 && E < _.length; E++)
      v = ($ = (0 | _.words[E]) + v) >> 26, this.words[E] = 67108863 & $;
    if (v === 0 && E < _.length && _ !== this)
      for (; E < _.length; E++)
        this.words[E] = _.words[E];
    return this.length = Math.max(this.length, E), _ !== this && (this.negative = 1), this.strip();
  }, c.prototype.sub = function(g) {
    return this.clone().isub(g);
  };
  var P = function(g, $, _) {
    var b, m, v, E = g.words, T = $.words, j = _.words, L = 0, J = 0 | E[0], Y = 8191 & J, ne = J >>> 13, Q = 0 | E[1], oe = 8191 & Q, ae = Q >>> 13, ce = 0 | E[2], ue = 8191 & ce, le = ce >>> 13, Se = 0 | E[3], he = 8191 & Se, _e = Se >>> 13, Le = 0 | E[4], se = 8191 & Le, we = Le >>> 13, We = 0 | E[5], de = 8191 & We, ke = We >>> 13, l = 0 | E[6], h = 8191 & l, y = l >>> 13, A = 0 | E[7], M = 8191 & A, x = A >>> 13, O = 0 | E[8], G = 8191 & O, X = O >>> 13, ie = 0 | E[9], ee = 8191 & ie, re = ie >>> 13, ye = 0 | T[0], fe = 8191 & ye, pe = ye >>> 13, Re = 0 | T[1], me = 8191 & Re, Ee = Re >>> 13, Ce = 0 | T[2], ge = 8191 & Ce, Ae = Ce >>> 13, Fe = 0 | T[3], $e = 8191 & Fe, Me = Fe >>> 13, qe = 0 | T[4], ve = 8191 & qe, Oe = qe >>> 13, He = 0 | T[5], be = 8191 & He, Pe = He >>> 13, ze = 0 | T[6], Te = 8191 & ze, Ne = ze >>> 13, Ve = 0 | T[7], xe = 8191 & Ve, Ue = Ve >>> 13, Je = 0 | T[8], Be = 8191 & Je, je = Je >>> 13, Xe = 0 | T[9], Ie = 8191 & Xe, De = Xe >>> 13;
    _.negative = g.negative ^ $.negative, _.length = 19;
    var Ge = (L + (b = Math.imul(Y, fe)) | 0) + ((8191 & (m = (m = Math.imul(Y, pe)) + Math.imul(ne, fe) | 0)) << 13) | 0;
    L = ((v = Math.imul(ne, pe)) + (m >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, b = Math.imul(oe, fe), m = (m = Math.imul(oe, pe)) + Math.imul(ae, fe) | 0, v = Math.imul(ae, pe);
    var Ke = (L + (b = b + Math.imul(Y, me) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ee) | 0) + Math.imul(ne, me) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ee) | 0) + (m >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, b = Math.imul(ue, fe), m = (m = Math.imul(ue, pe)) + Math.imul(le, fe) | 0, v = Math.imul(le, pe), b = b + Math.imul(oe, me) | 0, m = (m = m + Math.imul(oe, Ee) | 0) + Math.imul(ae, me) | 0, v = v + Math.imul(ae, Ee) | 0;
    var Ye = (L + (b = b + Math.imul(Y, ge) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ae) | 0) + Math.imul(ne, ge) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ae) | 0) + (m >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, b = Math.imul(he, fe), m = (m = Math.imul(he, pe)) + Math.imul(_e, fe) | 0, v = Math.imul(_e, pe), b = b + Math.imul(ue, me) | 0, m = (m = m + Math.imul(ue, Ee) | 0) + Math.imul(le, me) | 0, v = v + Math.imul(le, Ee) | 0, b = b + Math.imul(oe, ge) | 0, m = (m = m + Math.imul(oe, Ae) | 0) + Math.imul(ae, ge) | 0, v = v + Math.imul(ae, Ae) | 0;
    var Ze = (L + (b = b + Math.imul(Y, $e) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Me) | 0) + Math.imul(ne, $e) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Me) | 0) + (m >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, b = Math.imul(se, fe), m = (m = Math.imul(se, pe)) + Math.imul(we, fe) | 0, v = Math.imul(we, pe), b = b + Math.imul(he, me) | 0, m = (m = m + Math.imul(he, Ee) | 0) + Math.imul(_e, me) | 0, v = v + Math.imul(_e, Ee) | 0, b = b + Math.imul(ue, ge) | 0, m = (m = m + Math.imul(ue, Ae) | 0) + Math.imul(le, ge) | 0, v = v + Math.imul(le, Ae) | 0, b = b + Math.imul(oe, $e) | 0, m = (m = m + Math.imul(oe, Me) | 0) + Math.imul(ae, $e) | 0, v = v + Math.imul(ae, Me) | 0;
    var Qe = (L + (b = b + Math.imul(Y, ve) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Oe) | 0) + Math.imul(ne, ve) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Oe) | 0) + (m >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, b = Math.imul(de, fe), m = (m = Math.imul(de, pe)) + Math.imul(ke, fe) | 0, v = Math.imul(ke, pe), b = b + Math.imul(se, me) | 0, m = (m = m + Math.imul(se, Ee) | 0) + Math.imul(we, me) | 0, v = v + Math.imul(we, Ee) | 0, b = b + Math.imul(he, ge) | 0, m = (m = m + Math.imul(he, Ae) | 0) + Math.imul(_e, ge) | 0, v = v + Math.imul(_e, Ae) | 0, b = b + Math.imul(ue, $e) | 0, m = (m = m + Math.imul(ue, Me) | 0) + Math.imul(le, $e) | 0, v = v + Math.imul(le, Me) | 0, b = b + Math.imul(oe, ve) | 0, m = (m = m + Math.imul(oe, Oe) | 0) + Math.imul(ae, ve) | 0, v = v + Math.imul(ae, Oe) | 0;
    var et = (L + (b = b + Math.imul(Y, be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Pe) | 0) + Math.imul(ne, be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Pe) | 0) + (m >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, b = Math.imul(h, fe), m = (m = Math.imul(h, pe)) + Math.imul(y, fe) | 0, v = Math.imul(y, pe), b = b + Math.imul(de, me) | 0, m = (m = m + Math.imul(de, Ee) | 0) + Math.imul(ke, me) | 0, v = v + Math.imul(ke, Ee) | 0, b = b + Math.imul(se, ge) | 0, m = (m = m + Math.imul(se, Ae) | 0) + Math.imul(we, ge) | 0, v = v + Math.imul(we, Ae) | 0, b = b + Math.imul(he, $e) | 0, m = (m = m + Math.imul(he, Me) | 0) + Math.imul(_e, $e) | 0, v = v + Math.imul(_e, Me) | 0, b = b + Math.imul(ue, ve) | 0, m = (m = m + Math.imul(ue, Oe) | 0) + Math.imul(le, ve) | 0, v = v + Math.imul(le, Oe) | 0, b = b + Math.imul(oe, be) | 0, m = (m = m + Math.imul(oe, Pe) | 0) + Math.imul(ae, be) | 0, v = v + Math.imul(ae, Pe) | 0;
    var tt = (L + (b = b + Math.imul(Y, Te) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ne) | 0) + Math.imul(ne, Te) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ne) | 0) + (m >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, b = Math.imul(M, fe), m = (m = Math.imul(M, pe)) + Math.imul(x, fe) | 0, v = Math.imul(x, pe), b = b + Math.imul(h, me) | 0, m = (m = m + Math.imul(h, Ee) | 0) + Math.imul(y, me) | 0, v = v + Math.imul(y, Ee) | 0, b = b + Math.imul(de, ge) | 0, m = (m = m + Math.imul(de, Ae) | 0) + Math.imul(ke, ge) | 0, v = v + Math.imul(ke, Ae) | 0, b = b + Math.imul(se, $e) | 0, m = (m = m + Math.imul(se, Me) | 0) + Math.imul(we, $e) | 0, v = v + Math.imul(we, Me) | 0, b = b + Math.imul(he, ve) | 0, m = (m = m + Math.imul(he, Oe) | 0) + Math.imul(_e, ve) | 0, v = v + Math.imul(_e, Oe) | 0, b = b + Math.imul(ue, be) | 0, m = (m = m + Math.imul(ue, Pe) | 0) + Math.imul(le, be) | 0, v = v + Math.imul(le, Pe) | 0, b = b + Math.imul(oe, Te) | 0, m = (m = m + Math.imul(oe, Ne) | 0) + Math.imul(ae, Te) | 0, v = v + Math.imul(ae, Ne) | 0;
    var rt = (L + (b = b + Math.imul(Y, xe) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, Ue) | 0) + Math.imul(ne, xe) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, Ue) | 0) + (m >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, b = Math.imul(G, fe), m = (m = Math.imul(G, pe)) + Math.imul(X, fe) | 0, v = Math.imul(X, pe), b = b + Math.imul(M, me) | 0, m = (m = m + Math.imul(M, Ee) | 0) + Math.imul(x, me) | 0, v = v + Math.imul(x, Ee) | 0, b = b + Math.imul(h, ge) | 0, m = (m = m + Math.imul(h, Ae) | 0) + Math.imul(y, ge) | 0, v = v + Math.imul(y, Ae) | 0, b = b + Math.imul(de, $e) | 0, m = (m = m + Math.imul(de, Me) | 0) + Math.imul(ke, $e) | 0, v = v + Math.imul(ke, Me) | 0, b = b + Math.imul(se, ve) | 0, m = (m = m + Math.imul(se, Oe) | 0) + Math.imul(we, ve) | 0, v = v + Math.imul(we, Oe) | 0, b = b + Math.imul(he, be) | 0, m = (m = m + Math.imul(he, Pe) | 0) + Math.imul(_e, be) | 0, v = v + Math.imul(_e, Pe) | 0, b = b + Math.imul(ue, Te) | 0, m = (m = m + Math.imul(ue, Ne) | 0) + Math.imul(le, Te) | 0, v = v + Math.imul(le, Ne) | 0, b = b + Math.imul(oe, xe) | 0, m = (m = m + Math.imul(oe, Ue) | 0) + Math.imul(ae, xe) | 0, v = v + Math.imul(ae, Ue) | 0;
    var nt = (L + (b = b + Math.imul(Y, Be) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, je) | 0) + Math.imul(ne, Be) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, je) | 0) + (m >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, b = Math.imul(ee, fe), m = (m = Math.imul(ee, pe)) + Math.imul(re, fe) | 0, v = Math.imul(re, pe), b = b + Math.imul(G, me) | 0, m = (m = m + Math.imul(G, Ee) | 0) + Math.imul(X, me) | 0, v = v + Math.imul(X, Ee) | 0, b = b + Math.imul(M, ge) | 0, m = (m = m + Math.imul(M, Ae) | 0) + Math.imul(x, ge) | 0, v = v + Math.imul(x, Ae) | 0, b = b + Math.imul(h, $e) | 0, m = (m = m + Math.imul(h, Me) | 0) + Math.imul(y, $e) | 0, v = v + Math.imul(y, Me) | 0, b = b + Math.imul(de, ve) | 0, m = (m = m + Math.imul(de, Oe) | 0) + Math.imul(ke, ve) | 0, v = v + Math.imul(ke, Oe) | 0, b = b + Math.imul(se, be) | 0, m = (m = m + Math.imul(se, Pe) | 0) + Math.imul(we, be) | 0, v = v + Math.imul(we, Pe) | 0, b = b + Math.imul(he, Te) | 0, m = (m = m + Math.imul(he, Ne) | 0) + Math.imul(_e, Te) | 0, v = v + Math.imul(_e, Ne) | 0, b = b + Math.imul(ue, xe) | 0, m = (m = m + Math.imul(ue, Ue) | 0) + Math.imul(le, xe) | 0, v = v + Math.imul(le, Ue) | 0, b = b + Math.imul(oe, Be) | 0, m = (m = m + Math.imul(oe, je) | 0) + Math.imul(ae, Be) | 0, v = v + Math.imul(ae, je) | 0;
    var it = (L + (b = b + Math.imul(Y, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(Y, De) | 0) + Math.imul(ne, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ne, De) | 0) + (m >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, b = Math.imul(ee, me), m = (m = Math.imul(ee, Ee)) + Math.imul(re, me) | 0, v = Math.imul(re, Ee), b = b + Math.imul(G, ge) | 0, m = (m = m + Math.imul(G, Ae) | 0) + Math.imul(X, ge) | 0, v = v + Math.imul(X, Ae) | 0, b = b + Math.imul(M, $e) | 0, m = (m = m + Math.imul(M, Me) | 0) + Math.imul(x, $e) | 0, v = v + Math.imul(x, Me) | 0, b = b + Math.imul(h, ve) | 0, m = (m = m + Math.imul(h, Oe) | 0) + Math.imul(y, ve) | 0, v = v + Math.imul(y, Oe) | 0, b = b + Math.imul(de, be) | 0, m = (m = m + Math.imul(de, Pe) | 0) + Math.imul(ke, be) | 0, v = v + Math.imul(ke, Pe) | 0, b = b + Math.imul(se, Te) | 0, m = (m = m + Math.imul(se, Ne) | 0) + Math.imul(we, Te) | 0, v = v + Math.imul(we, Ne) | 0, b = b + Math.imul(he, xe) | 0, m = (m = m + Math.imul(he, Ue) | 0) + Math.imul(_e, xe) | 0, v = v + Math.imul(_e, Ue) | 0, b = b + Math.imul(ue, Be) | 0, m = (m = m + Math.imul(ue, je) | 0) + Math.imul(le, Be) | 0, v = v + Math.imul(le, je) | 0;
    var ot = (L + (b = b + Math.imul(oe, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(oe, De) | 0) + Math.imul(ae, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ae, De) | 0) + (m >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, b = Math.imul(ee, ge), m = (m = Math.imul(ee, Ae)) + Math.imul(re, ge) | 0, v = Math.imul(re, Ae), b = b + Math.imul(G, $e) | 0, m = (m = m + Math.imul(G, Me) | 0) + Math.imul(X, $e) | 0, v = v + Math.imul(X, Me) | 0, b = b + Math.imul(M, ve) | 0, m = (m = m + Math.imul(M, Oe) | 0) + Math.imul(x, ve) | 0, v = v + Math.imul(x, Oe) | 0, b = b + Math.imul(h, be) | 0, m = (m = m + Math.imul(h, Pe) | 0) + Math.imul(y, be) | 0, v = v + Math.imul(y, Pe) | 0, b = b + Math.imul(de, Te) | 0, m = (m = m + Math.imul(de, Ne) | 0) + Math.imul(ke, Te) | 0, v = v + Math.imul(ke, Ne) | 0, b = b + Math.imul(se, xe) | 0, m = (m = m + Math.imul(se, Ue) | 0) + Math.imul(we, xe) | 0, v = v + Math.imul(we, Ue) | 0, b = b + Math.imul(he, Be) | 0, m = (m = m + Math.imul(he, je) | 0) + Math.imul(_e, Be) | 0, v = v + Math.imul(_e, je) | 0;
    var at = (L + (b = b + Math.imul(ue, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(ue, De) | 0) + Math.imul(le, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(le, De) | 0) + (m >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, b = Math.imul(ee, $e), m = (m = Math.imul(ee, Me)) + Math.imul(re, $e) | 0, v = Math.imul(re, Me), b = b + Math.imul(G, ve) | 0, m = (m = m + Math.imul(G, Oe) | 0) + Math.imul(X, ve) | 0, v = v + Math.imul(X, Oe) | 0, b = b + Math.imul(M, be) | 0, m = (m = m + Math.imul(M, Pe) | 0) + Math.imul(x, be) | 0, v = v + Math.imul(x, Pe) | 0, b = b + Math.imul(h, Te) | 0, m = (m = m + Math.imul(h, Ne) | 0) + Math.imul(y, Te) | 0, v = v + Math.imul(y, Ne) | 0, b = b + Math.imul(de, xe) | 0, m = (m = m + Math.imul(de, Ue) | 0) + Math.imul(ke, xe) | 0, v = v + Math.imul(ke, Ue) | 0, b = b + Math.imul(se, Be) | 0, m = (m = m + Math.imul(se, je) | 0) + Math.imul(we, Be) | 0, v = v + Math.imul(we, je) | 0;
    var st = (L + (b = b + Math.imul(he, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(he, De) | 0) + Math.imul(_e, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(_e, De) | 0) + (m >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, b = Math.imul(ee, ve), m = (m = Math.imul(ee, Oe)) + Math.imul(re, ve) | 0, v = Math.imul(re, Oe), b = b + Math.imul(G, be) | 0, m = (m = m + Math.imul(G, Pe) | 0) + Math.imul(X, be) | 0, v = v + Math.imul(X, Pe) | 0, b = b + Math.imul(M, Te) | 0, m = (m = m + Math.imul(M, Ne) | 0) + Math.imul(x, Te) | 0, v = v + Math.imul(x, Ne) | 0, b = b + Math.imul(h, xe) | 0, m = (m = m + Math.imul(h, Ue) | 0) + Math.imul(y, xe) | 0, v = v + Math.imul(y, Ue) | 0, b = b + Math.imul(de, Be) | 0, m = (m = m + Math.imul(de, je) | 0) + Math.imul(ke, Be) | 0, v = v + Math.imul(ke, je) | 0;
    var ut = (L + (b = b + Math.imul(se, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(se, De) | 0) + Math.imul(we, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(we, De) | 0) + (m >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, b = Math.imul(ee, be), m = (m = Math.imul(ee, Pe)) + Math.imul(re, be) | 0, v = Math.imul(re, Pe), b = b + Math.imul(G, Te) | 0, m = (m = m + Math.imul(G, Ne) | 0) + Math.imul(X, Te) | 0, v = v + Math.imul(X, Ne) | 0, b = b + Math.imul(M, xe) | 0, m = (m = m + Math.imul(M, Ue) | 0) + Math.imul(x, xe) | 0, v = v + Math.imul(x, Ue) | 0, b = b + Math.imul(h, Be) | 0, m = (m = m + Math.imul(h, je) | 0) + Math.imul(y, Be) | 0, v = v + Math.imul(y, je) | 0;
    var ct = (L + (b = b + Math.imul(de, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(de, De) | 0) + Math.imul(ke, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(ke, De) | 0) + (m >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, b = Math.imul(ee, Te), m = (m = Math.imul(ee, Ne)) + Math.imul(re, Te) | 0, v = Math.imul(re, Ne), b = b + Math.imul(G, xe) | 0, m = (m = m + Math.imul(G, Ue) | 0) + Math.imul(X, xe) | 0, v = v + Math.imul(X, Ue) | 0, b = b + Math.imul(M, Be) | 0, m = (m = m + Math.imul(M, je) | 0) + Math.imul(x, Be) | 0, v = v + Math.imul(x, je) | 0;
    var ft = (L + (b = b + Math.imul(h, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(h, De) | 0) + Math.imul(y, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(y, De) | 0) + (m >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, b = Math.imul(ee, xe), m = (m = Math.imul(ee, Ue)) + Math.imul(re, xe) | 0, v = Math.imul(re, Ue), b = b + Math.imul(G, Be) | 0, m = (m = m + Math.imul(G, je) | 0) + Math.imul(X, Be) | 0, v = v + Math.imul(X, je) | 0;
    var ht = (L + (b = b + Math.imul(M, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(M, De) | 0) + Math.imul(x, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(x, De) | 0) + (m >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, b = Math.imul(ee, Be), m = (m = Math.imul(ee, je)) + Math.imul(re, Be) | 0, v = Math.imul(re, je);
    var dt = (L + (b = b + Math.imul(G, Ie) | 0) | 0) + ((8191 & (m = (m = m + Math.imul(G, De) | 0) + Math.imul(X, Ie) | 0)) << 13) | 0;
    L = ((v = v + Math.imul(X, De) | 0) + (m >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863;
    var pt = (L + (b = Math.imul(ee, Ie)) | 0) + ((8191 & (m = (m = Math.imul(ee, De)) + Math.imul(re, Ie) | 0)) << 13) | 0;
    return L = ((v = Math.imul(re, De)) + (m >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, j[0] = Ge, j[1] = Ke, j[2] = Ye, j[3] = Ze, j[4] = Qe, j[5] = et, j[6] = tt, j[7] = rt, j[8] = nt, j[9] = it, j[10] = ot, j[11] = at, j[12] = st, j[13] = ut, j[14] = ct, j[15] = ft, j[16] = ht, j[17] = dt, j[18] = pt, L !== 0 && (j[19] = L, _.length++), _;
  };
  function q(g, $, _) {
    return new D().mulp(g, $, _);
  }
  function D(g, $) {
    this.x = g, this.y = $;
  }
  Math.imul || (P = C), c.prototype.mulTo = function(g, $) {
    var _, b = this.length + g.length;
    return _ = this.length === 10 && g.length === 10 ? P(this, g, $) : b < 63 ? C(this, g, $) : b < 1024 ? function(m, v, E) {
      E.negative = v.negative ^ m.negative, E.length = m.length + v.length;
      for (var T = 0, j = 0, L = 0; L < E.length - 1; L++) {
        var J = j;
        j = 0;
        for (var Y = 67108863 & T, ne = Math.min(L, v.length - 1), Q = Math.max(0, L - m.length + 1); Q <= ne; Q++) {
          var oe = L - Q, ae = (0 | m.words[oe]) * (0 | v.words[Q]), ce = 67108863 & ae;
          Y = 67108863 & (ce = ce + Y | 0), j += (J = (J = J + (ae / 67108864 | 0) | 0) + (ce >>> 26) | 0) >>> 26, J &= 67108863;
        }
        E.words[L] = Y, T = J, J = j;
      }
      return T !== 0 ? E.words[L] = T : E.length--, E.strip();
    }(this, g, $) : q(this, g, $), _;
  }, D.prototype.makeRBT = function(g) {
    for (var $ = new Array(g), _ = c.prototype._countBits(g) - 1, b = 0; b < g; b++)
      $[b] = this.revBin(b, _, g);
    return $;
  }, D.prototype.revBin = function(g, $, _) {
    if (g === 0 || g === _ - 1)
      return g;
    for (var b = 0, m = 0; m < $; m++)
      b |= (1 & g) << $ - m - 1, g >>= 1;
    return b;
  }, D.prototype.permute = function(g, $, _, b, m, v) {
    for (var E = 0; E < v; E++)
      b[E] = $[g[E]], m[E] = _[g[E]];
  }, D.prototype.transform = function(g, $, _, b, m, v) {
    this.permute(v, g, $, _, b, m);
    for (var E = 1; E < m; E <<= 1)
      for (var T = E << 1, j = Math.cos(2 * Math.PI / T), L = Math.sin(2 * Math.PI / T), J = 0; J < m; J += T)
        for (var Y = j, ne = L, Q = 0; Q < E; Q++) {
          var oe = _[J + Q], ae = b[J + Q], ce = _[J + Q + E], ue = b[J + Q + E], le = Y * ce - ne * ue;
          ue = Y * ue + ne * ce, ce = le, _[J + Q] = oe + ce, b[J + Q] = ae + ue, _[J + Q + E] = oe - ce, b[J + Q + E] = ae - ue, Q !== T && (le = j * Y - L * ne, ne = j * ne + L * Y, Y = le);
        }
  }, D.prototype.guessLen13b = function(g, $) {
    var _ = 1 | Math.max($, g), b = 1 & _, m = 0;
    for (_ = _ / 2 | 0; _; _ >>>= 1)
      m++;
    return 1 << m + 1 + b;
  }, D.prototype.conjugate = function(g, $, _) {
    if (!(_ <= 1))
      for (var b = 0; b < _ / 2; b++) {
        var m = g[b];
        g[b] = g[_ - b - 1], g[_ - b - 1] = m, m = $[b], $[b] = -$[_ - b - 1], $[_ - b - 1] = -m;
      }
  }, D.prototype.normalize13b = function(g, $) {
    for (var _ = 0, b = 0; b < $ / 2; b++) {
      var m = 8192 * Math.round(g[2 * b + 1] / $) + Math.round(g[2 * b] / $) + _;
      g[b] = 67108863 & m, _ = m < 67108864 ? 0 : m / 67108864 | 0;
    }
    return g;
  }, D.prototype.convert13b = function(g, $, _, b) {
    for (var m = 0, v = 0; v < $; v++)
      m += 0 | g[v], _[2 * v] = 8191 & m, m >>>= 13, _[2 * v + 1] = 8191 & m, m >>>= 13;
    for (v = 2 * $; v < b; ++v)
      _[v] = 0;
    a(m === 0), a((-8192 & m) == 0);
  }, D.prototype.stub = function(g) {
    for (var $ = new Array(g), _ = 0; _ < g; _++)
      $[_] = 0;
    return $;
  }, D.prototype.mulp = function(g, $, _) {
    var b = 2 * this.guessLen13b(g.length, $.length), m = this.makeRBT(b), v = this.stub(b), E = new Array(b), T = new Array(b), j = new Array(b), L = new Array(b), J = new Array(b), Y = new Array(b), ne = _.words;
    ne.length = b, this.convert13b(g.words, g.length, E, b), this.convert13b($.words, $.length, L, b), this.transform(E, v, T, j, b, m), this.transform(L, v, J, Y, b, m);
    for (var Q = 0; Q < b; Q++) {
      var oe = T[Q] * J[Q] - j[Q] * Y[Q];
      j[Q] = T[Q] * Y[Q] + j[Q] * J[Q], T[Q] = oe;
    }
    return this.conjugate(T, j, b), this.transform(T, j, ne, v, b, m), this.conjugate(ne, v, b), this.normalize13b(ne, b), _.negative = g.negative ^ $.negative, _.length = g.length + $.length, _.strip();
  }, c.prototype.mul = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), this.mulTo(g, $);
  }, c.prototype.mulf = function(g) {
    var $ = new c(null);
    return $.words = new Array(this.length + g.length), q(this, g, $);
  }, c.prototype.imul = function(g) {
    return this.clone().mulTo(g, this);
  }, c.prototype.imuln = function(g) {
    a(typeof g == "number"), a(g < 67108864);
    for (var $ = 0, _ = 0; _ < this.length; _++) {
      var b = (0 | this.words[_]) * g, m = (67108863 & b) + (67108863 & $);
      $ >>= 26, $ += b / 67108864 | 0, $ += m >>> 26, this.words[_] = 67108863 & m;
    }
    return $ !== 0 && (this.words[_] = $, this.length++), this;
  }, c.prototype.muln = function(g) {
    return this.clone().imuln(g);
  }, c.prototype.sqr = function() {
    return this.mul(this);
  }, c.prototype.isqr = function() {
    return this.imul(this.clone());
  }, c.prototype.pow = function(g) {
    var $ = function(v) {
      for (var E = new Array(v.bitLength()), T = 0; T < E.length; T++) {
        var j = T / 26 | 0, L = T % 26;
        E[T] = (v.words[j] & 1 << L) >>> L;
      }
      return E;
    }(g);
    if ($.length === 0)
      return new c(1);
    for (var _ = this, b = 0; b < $.length && $[b] === 0; b++, _ = _.sqr())
      ;
    if (++b < $.length)
      for (var m = _.sqr(); b < $.length; b++, m = m.sqr())
        $[b] !== 0 && (_ = _.mul(m));
    return _;
  }, c.prototype.iushln = function(g) {
    a(typeof g == "number" && g >= 0);
    var $, _ = g % 26, b = (g - _) / 26, m = 67108863 >>> 26 - _ << 26 - _;
    if (_ !== 0) {
      var v = 0;
      for ($ = 0; $ < this.length; $++) {
        var E = this.words[$] & m, T = (0 | this.words[$]) - E << _;
        this.words[$] = T | v, v = E >>> 26 - _;
      }
      v && (this.words[$] = v, this.length++);
    }
    if (b !== 0) {
      for ($ = this.length - 1; $ >= 0; $--)
        this.words[$ + b] = this.words[$];
      for ($ = 0; $ < b; $++)
        this.words[$] = 0;
      this.length += b;
    }
    return this.strip();
  }, c.prototype.ishln = function(g) {
    return a(this.negative === 0), this.iushln(g);
  }, c.prototype.iushrn = function(g, $, _) {
    var b;
    a(typeof g == "number" && g >= 0), b = $ ? ($ - $ % 26) / 26 : 0;
    var m = g % 26, v = Math.min((g - m) / 26, this.length), E = 67108863 ^ 67108863 >>> m << m, T = _;
    if (b -= v, b = Math.max(0, b), T) {
      for (var j = 0; j < v; j++)
        T.words[j] = this.words[j];
      T.length = v;
    }
    if (v !== 0)
      if (this.length > v)
        for (this.length -= v, j = 0; j < this.length; j++)
          this.words[j] = this.words[j + v];
      else
        this.words[0] = 0, this.length = 1;
    var L = 0;
    for (j = this.length - 1; j >= 0 && (L !== 0 || j >= b); j--) {
      var J = 0 | this.words[j];
      this.words[j] = L << 26 - m | J >>> m, L = J & E;
    }
    return T && L !== 0 && (T.words[T.length++] = L), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, c.prototype.ishrn = function(g, $, _) {
    return a(this.negative === 0), this.iushrn(g, $, _);
  }, c.prototype.shln = function(g) {
    return this.clone().ishln(g);
  }, c.prototype.ushln = function(g) {
    return this.clone().iushln(g);
  }, c.prototype.shrn = function(g) {
    return this.clone().ishrn(g);
  }, c.prototype.ushrn = function(g) {
    return this.clone().iushrn(g);
  }, c.prototype.testn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    return !(this.length <= _ || !(this.words[_] & b));
  }, c.prototype.imaskn = function(g) {
    a(typeof g == "number" && g >= 0);
    var $ = g % 26, _ = (g - $) / 26;
    if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= _)
      return this;
    if ($ !== 0 && _++, this.length = Math.min(_, this.length), $ !== 0) {
      var b = 67108863 ^ 67108863 >>> $ << $;
      this.words[this.length - 1] &= b;
    }
    return this.strip();
  }, c.prototype.maskn = function(g) {
    return this.clone().imaskn(g);
  }, c.prototype.iaddn = function(g) {
    return a(typeof g == "number"), a(g < 67108864), g < 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < g ? (this.words[0] = g - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);
  }, c.prototype._iaddn = function(g) {
    this.words[0] += g;
    for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
      this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
    return this.length = Math.max(this.length, $ + 1), this;
  }, c.prototype.isubn = function(g) {
    if (a(typeof g == "number"), a(g < 67108864), g < 0)
      return this.iaddn(-g);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(g), this.negative = 1, this;
    if (this.words[0] -= g, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
        this.words[$] += 67108864, this.words[$ + 1] -= 1;
    return this.strip();
  }, c.prototype.addn = function(g) {
    return this.clone().iaddn(g);
  }, c.prototype.subn = function(g) {
    return this.clone().isubn(g);
  }, c.prototype.iabs = function() {
    return this.negative = 0, this;
  }, c.prototype.abs = function() {
    return this.clone().iabs();
  }, c.prototype._ishlnsubmul = function(g, $, _) {
    var b, m, v = g.length + _;
    this._expand(v);
    var E = 0;
    for (b = 0; b < g.length; b++) {
      m = (0 | this.words[b + _]) + E;
      var T = (0 | g.words[b]) * $;
      E = ((m -= 67108863 & T) >> 26) - (T / 67108864 | 0), this.words[b + _] = 67108863 & m;
    }
    for (; b < this.length - _; b++)
      E = (m = (0 | this.words[b + _]) + E) >> 26, this.words[b + _] = 67108863 & m;
    if (E === 0)
      return this.strip();
    for (a(E === -1), E = 0, b = 0; b < this.length; b++)
      E = (m = -(0 | this.words[b]) + E) >> 26, this.words[b] = 67108863 & m;
    return this.negative = 1, this.strip();
  }, c.prototype._wordDiv = function(g, $) {
    var _ = (this.length, g.length), b = this.clone(), m = g, v = 0 | m.words[m.length - 1];
    (_ = 26 - this._countBits(v)) != 0 && (m = m.ushln(_), b.iushln(_), v = 0 | m.words[m.length - 1]);
    var E, T = b.length - m.length;
    if ($ !== "mod") {
      (E = new c(null)).length = T + 1, E.words = new Array(E.length);
      for (var j = 0; j < E.length; j++)
        E.words[j] = 0;
    }
    var L = b.clone()._ishlnsubmul(m, 1, T);
    L.negative === 0 && (b = L, E && (E.words[T] = 1));
    for (var J = T - 1; J >= 0; J--) {
      var Y = 67108864 * (0 | b.words[m.length + J]) + (0 | b.words[m.length + J - 1]);
      for (Y = Math.min(Y / v | 0, 67108863), b._ishlnsubmul(m, Y, J); b.negative !== 0; )
        Y--, b.negative = 0, b._ishlnsubmul(m, 1, J), b.isZero() || (b.negative ^= 1);
      E && (E.words[J] = Y);
    }
    return E && E.strip(), b.strip(), $ !== "div" && _ !== 0 && b.iushrn(_), { div: E || null, mod: b };
  }, c.prototype.divmod = function(g, $, _) {
    return a(!g.isZero()), this.isZero() ? { div: new c(0), mod: new c(0) } : this.negative !== 0 && g.negative === 0 ? (v = this.neg().divmod(g, $), $ !== "mod" && (b = v.div.neg()), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.iadd(g)), { div: b, mod: m }) : this.negative === 0 && g.negative !== 0 ? (v = this.divmod(g.neg(), $), $ !== "mod" && (b = v.div.neg()), { div: b, mod: v.mod }) : (this.negative & g.negative) != 0 ? (v = this.neg().divmod(g.neg(), $), $ !== "div" && (m = v.mod.neg(), _ && m.negative !== 0 && m.isub(g)), { div: v.div, mod: m }) : g.length > this.length || this.cmp(g) < 0 ? { div: new c(0), mod: this } : g.length === 1 ? $ === "div" ? { div: this.divn(g.words[0]), mod: null } : $ === "mod" ? { div: null, mod: new c(this.modn(g.words[0])) } : { div: this.divn(g.words[0]), mod: new c(this.modn(g.words[0])) } : this._wordDiv(g, $);
    var b, m, v;
  }, c.prototype.div = function(g) {
    return this.divmod(g, "div", !1).div;
  }, c.prototype.mod = function(g) {
    return this.divmod(g, "mod", !1).mod;
  }, c.prototype.umod = function(g) {
    return this.divmod(g, "mod", !0).mod;
  }, c.prototype.divRound = function(g) {
    var $ = this.divmod(g);
    if ($.mod.isZero())
      return $.div;
    var _ = $.div.negative !== 0 ? $.mod.isub(g) : $.mod, b = g.ushrn(1), m = g.andln(1), v = _.cmp(b);
    return v < 0 || m === 1 && v === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
  }, c.prototype.modn = function(g) {
    a(g <= 67108863);
    for (var $ = (1 << 26) % g, _ = 0, b = this.length - 1; b >= 0; b--)
      _ = ($ * _ + (0 | this.words[b])) % g;
    return _;
  }, c.prototype.idivn = function(g) {
    a(g <= 67108863);
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = (0 | this.words[_]) + 67108864 * $;
      this.words[_] = b / g | 0, $ = b % g;
    }
    return this.strip();
  }, c.prototype.divn = function(g) {
    return this.clone().idivn(g);
  }, c.prototype.egcd = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b = new c(1), m = new c(0), v = new c(0), E = new c(1), T = 0; $.isEven() && _.isEven(); )
      $.iushrn(1), _.iushrn(1), ++T;
    for (var j = _.clone(), L = $.clone(); !$.isZero(); ) {
      for (var J = 0, Y = 1; ($.words[0] & Y) == 0 && J < 26; ++J, Y <<= 1)
        ;
      if (J > 0)
        for ($.iushrn(J); J-- > 0; )
          (b.isOdd() || m.isOdd()) && (b.iadd(j), m.isub(L)), b.iushrn(1), m.iushrn(1);
      for (var ne = 0, Q = 1; (_.words[0] & Q) == 0 && ne < 26; ++ne, Q <<= 1)
        ;
      if (ne > 0)
        for (_.iushrn(ne); ne-- > 0; )
          (v.isOdd() || E.isOdd()) && (v.iadd(j), E.isub(L)), v.iushrn(1), E.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), b.isub(v), m.isub(E)) : (_.isub($), v.isub(b), E.isub(m));
    }
    return { a: v, b: E, gcd: _.iushln(T) };
  }, c.prototype._invmp = function(g) {
    a(g.negative === 0), a(!g.isZero());
    var $ = this, _ = g.clone();
    $ = $.negative !== 0 ? $.umod(g) : $.clone();
    for (var b, m = new c(1), v = new c(0), E = _.clone(); $.cmpn(1) > 0 && _.cmpn(1) > 0; ) {
      for (var T = 0, j = 1; ($.words[0] & j) == 0 && T < 26; ++T, j <<= 1)
        ;
      if (T > 0)
        for ($.iushrn(T); T-- > 0; )
          m.isOdd() && m.iadd(E), m.iushrn(1);
      for (var L = 0, J = 1; (_.words[0] & J) == 0 && L < 26; ++L, J <<= 1)
        ;
      if (L > 0)
        for (_.iushrn(L); L-- > 0; )
          v.isOdd() && v.iadd(E), v.iushrn(1);
      $.cmp(_) >= 0 ? ($.isub(_), m.isub(v)) : (_.isub($), v.isub(m));
    }
    return (b = $.cmpn(1) === 0 ? m : v).cmpn(0) < 0 && b.iadd(g), b;
  }, c.prototype.gcd = function(g) {
    if (this.isZero())
      return g.abs();
    if (g.isZero())
      return this.abs();
    var $ = this.clone(), _ = g.clone();
    $.negative = 0, _.negative = 0;
    for (var b = 0; $.isEven() && _.isEven(); b++)
      $.iushrn(1), _.iushrn(1);
    for (; ; ) {
      for (; $.isEven(); )
        $.iushrn(1);
      for (; _.isEven(); )
        _.iushrn(1);
      var m = $.cmp(_);
      if (m < 0) {
        var v = $;
        $ = _, _ = v;
      } else if (m === 0 || _.cmpn(1) === 0)
        break;
      $.isub(_);
    }
    return _.iushln(b);
  }, c.prototype.invm = function(g) {
    return this.egcd(g).a.umod(g);
  }, c.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, c.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, c.prototype.andln = function(g) {
    return this.words[0] & g;
  }, c.prototype.bincn = function(g) {
    a(typeof g == "number");
    var $ = g % 26, _ = (g - $) / 26, b = 1 << $;
    if (this.length <= _)
      return this._expand(_ + 1), this.words[_] |= b, this;
    for (var m = b, v = _; m !== 0 && v < this.length; v++) {
      var E = 0 | this.words[v];
      m = (E += m) >>> 26, E &= 67108863, this.words[v] = E;
    }
    return m !== 0 && (this.words[v] = m, this.length++), this;
  }, c.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, c.prototype.cmpn = function(g) {
    var $, _ = g < 0;
    if (this.negative !== 0 && !_)
      return -1;
    if (this.negative === 0 && _)
      return 1;
    if (this.strip(), this.length > 1)
      $ = 1;
    else {
      _ && (g = -g), a(g <= 67108863, "Number is too big");
      var b = 0 | this.words[0];
      $ = b === g ? 0 : b < g ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.cmp = function(g) {
    if (this.negative !== 0 && g.negative === 0)
      return -1;
    if (this.negative === 0 && g.negative !== 0)
      return 1;
    var $ = this.ucmp(g);
    return this.negative !== 0 ? 0 | -$ : $;
  }, c.prototype.ucmp = function(g) {
    if (this.length > g.length)
      return 1;
    if (this.length < g.length)
      return -1;
    for (var $ = 0, _ = this.length - 1; _ >= 0; _--) {
      var b = 0 | this.words[_], m = 0 | g.words[_];
      if (b !== m) {
        b < m ? $ = -1 : b > m && ($ = 1);
        break;
      }
    }
    return $;
  }, c.prototype.gtn = function(g) {
    return this.cmpn(g) === 1;
  }, c.prototype.gt = function(g) {
    return this.cmp(g) === 1;
  }, c.prototype.gten = function(g) {
    return this.cmpn(g) >= 0;
  }, c.prototype.gte = function(g) {
    return this.cmp(g) >= 0;
  }, c.prototype.ltn = function(g) {
    return this.cmpn(g) === -1;
  }, c.prototype.lt = function(g) {
    return this.cmp(g) === -1;
  }, c.prototype.lten = function(g) {
    return this.cmpn(g) <= 0;
  }, c.prototype.lte = function(g) {
    return this.cmp(g) <= 0;
  }, c.prototype.eqn = function(g) {
    return this.cmpn(g) === 0;
  }, c.prototype.eq = function(g) {
    return this.cmp(g) === 0;
  }, c.red = function(g) {
    return new H(g);
  }, c.prototype.toRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), g.convertTo(this)._forceRed(g);
  }, c.prototype.fromRed = function() {
    return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, c.prototype._forceRed = function(g) {
    return this.red = g, this;
  }, c.prototype.forceRed = function(g) {
    return a(!this.red, "Already a number in reduction context"), this._forceRed(g);
  }, c.prototype.redAdd = function(g) {
    return a(this.red, "redAdd works only with red numbers"), this.red.add(this, g);
  }, c.prototype.redIAdd = function(g) {
    return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, g);
  }, c.prototype.redSub = function(g) {
    return a(this.red, "redSub works only with red numbers"), this.red.sub(this, g);
  }, c.prototype.redISub = function(g) {
    return a(this.red, "redISub works only with red numbers"), this.red.isub(this, g);
  }, c.prototype.redShl = function(g) {
    return a(this.red, "redShl works only with red numbers"), this.red.shl(this, g);
  }, c.prototype.redMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.mul(this, g);
  }, c.prototype.redIMul = function(g) {
    return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, g), this.red.imul(this, g);
  }, c.prototype.redSqr = function() {
    return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, c.prototype.redISqr = function() {
    return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, c.prototype.redSqrt = function() {
    return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, c.prototype.redInvm = function() {
    return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, c.prototype.redNeg = function() {
    return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, c.prototype.redPow = function(g) {
    return a(this.red && !g.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, g);
  };
  var z = { k256: null, p224: null, p192: null, p25519: null };
  function F(g, $) {
    this.name = g, this.p = new c($, 16), this.n = this.p.bitLength(), this.k = new c(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function V() {
    F.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Z() {
    F.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function N() {
    F.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function W() {
    F.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function H(g) {
    if (typeof g == "string") {
      var $ = c._prime(g);
      this.m = $.p, this.prime = $;
    } else
      a(g.gtn(1), "modulus must be greater than 1"), this.m = g, this.prime = null;
  }
  function te(g) {
    H.call(this, g), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new c(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  F.prototype._tmp = function() {
    var g = new c(null);
    return g.words = new Array(Math.ceil(this.n / 13)), g;
  }, F.prototype.ireduce = function(g) {
    var $, _ = g;
    do
      this.split(_, this.tmp), $ = (_ = (_ = this.imulK(_)).iadd(this.tmp)).bitLength();
    while ($ > this.n);
    var b = $ < this.n ? -1 : _.ucmp(this.p);
    return b === 0 ? (_.words[0] = 0, _.length = 1) : b > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
  }, F.prototype.split = function(g, $) {
    g.iushrn(this.n, 0, $);
  }, F.prototype.imulK = function(g) {
    return g.imul(this.k);
  }, u(V, F), V.prototype.split = function(g, $) {
    for (var _ = 4194303, b = Math.min(g.length, 9), m = 0; m < b; m++)
      $.words[m] = g.words[m];
    if ($.length = b, g.length <= 9)
      return g.words[0] = 0, void (g.length = 1);
    var v = g.words[9];
    for ($.words[$.length++] = v & _, m = 10; m < g.length; m++) {
      var E = 0 | g.words[m];
      g.words[m - 10] = (E & _) << 4 | v >>> 22, v = E;
    }
    v >>>= 22, g.words[m - 10] = v, v === 0 && g.length > 10 ? g.length -= 10 : g.length -= 9;
  }, V.prototype.imulK = function(g) {
    g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 0 | g.words[_];
      $ += 977 * b, g.words[_] = 67108863 & $, $ = 64 * b + ($ / 67108864 | 0);
    }
    return g.words[g.length - 1] === 0 && (g.length--, g.words[g.length - 1] === 0 && g.length--), g;
  }, u(Z, F), u(N, F), u(W, F), W.prototype.imulK = function(g) {
    for (var $ = 0, _ = 0; _ < g.length; _++) {
      var b = 19 * (0 | g.words[_]) + $, m = 67108863 & b;
      b >>>= 26, g.words[_] = m, $ = b;
    }
    return $ !== 0 && (g.words[g.length++] = $), g;
  }, c._prime = function(g) {
    if (z[g])
      return z[g];
    var $;
    if (g === "k256")
      $ = new V();
    else if (g === "p224")
      $ = new Z();
    else if (g === "p192")
      $ = new N();
    else {
      if (g !== "p25519")
        throw new Error("Unknown prime " + g);
      $ = new W();
    }
    return z[g] = $, $;
  }, H.prototype._verify1 = function(g) {
    a(g.negative === 0, "red works only with positives"), a(g.red, "red works only with red numbers");
  }, H.prototype._verify2 = function(g, $) {
    a((g.negative | $.negative) == 0, "red works only with positives"), a(g.red && g.red === $.red, "red works only with red numbers");
  }, H.prototype.imod = function(g) {
    return this.prime ? this.prime.ireduce(g)._forceRed(this) : g.umod(this.m)._forceRed(this);
  }, H.prototype.neg = function(g) {
    return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);
  }, H.prototype.add = function(g, $) {
    this._verify2(g, $);
    var _ = g.add($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _._forceRed(this);
  }, H.prototype.iadd = function(g, $) {
    this._verify2(g, $);
    var _ = g.iadd($);
    return _.cmp(this.m) >= 0 && _.isub(this.m), _;
  }, H.prototype.sub = function(g, $) {
    this._verify2(g, $);
    var _ = g.sub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _._forceRed(this);
  }, H.prototype.isub = function(g, $) {
    this._verify2(g, $);
    var _ = g.isub($);
    return _.cmpn(0) < 0 && _.iadd(this.m), _;
  }, H.prototype.shl = function(g, $) {
    return this._verify1(g), this.imod(g.ushln($));
  }, H.prototype.imul = function(g, $) {
    return this._verify2(g, $), this.imod(g.imul($));
  }, H.prototype.mul = function(g, $) {
    return this._verify2(g, $), this.imod(g.mul($));
  }, H.prototype.isqr = function(g) {
    return this.imul(g, g.clone());
  }, H.prototype.sqr = function(g) {
    return this.mul(g, g);
  }, H.prototype.sqrt = function(g) {
    if (g.isZero())
      return g.clone();
    var $ = this.m.andln(3);
    if (a($ % 2 == 1), $ === 3) {
      var _ = this.m.add(new c(1)).iushrn(2);
      return this.pow(g, _);
    }
    for (var b = this.m.subn(1), m = 0; !b.isZero() && b.andln(1) === 0; )
      m++, b.iushrn(1);
    a(!b.isZero());
    var v = new c(1).toRed(this), E = v.redNeg(), T = this.m.subn(1).iushrn(1), j = this.m.bitLength();
    for (j = new c(2 * j * j).toRed(this); this.pow(j, T).cmp(E) !== 0; )
      j.redIAdd(E);
    for (var L = this.pow(j, b), J = this.pow(g, b.addn(1).iushrn(1)), Y = this.pow(g, b), ne = m; Y.cmp(v) !== 0; ) {
      for (var Q = Y, oe = 0; Q.cmp(v) !== 0; oe++)
        Q = Q.redSqr();
      a(oe < ne);
      var ae = this.pow(L, new c(1).iushln(ne - oe - 1));
      J = J.redMul(ae), L = ae.redSqr(), Y = Y.redMul(L), ne = oe;
    }
    return J;
  }, H.prototype.invm = function(g) {
    var $ = g._invmp(this.m);
    return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
  }, H.prototype.pow = function(g, $) {
    if ($.isZero())
      return new c(1).toRed(this);
    if ($.cmpn(1) === 0)
      return g.clone();
    var _ = new Array(16);
    _[0] = new c(1).toRed(this), _[1] = g;
    for (var b = 2; b < _.length; b++)
      _[b] = this.mul(_[b - 1], g);
    var m = _[0], v = 0, E = 0, T = $.bitLength() % 26;
    for (T === 0 && (T = 26), b = $.length - 1; b >= 0; b--) {
      for (var j = $.words[b], L = T - 1; L >= 0; L--) {
        var J = j >> L & 1;
        m !== _[0] && (m = this.sqr(m)), J !== 0 || v !== 0 ? (v <<= 1, v |= J, (++E == 4 || b === 0 && L === 0) && (m = this.mul(m, _[v]), E = 0, v = 0)) : E = 0;
      }
      T = 26;
    }
    return m;
  }, H.prototype.convertTo = function(g) {
    var $ = g.umod(this.m);
    return $ === g ? $.clone() : $;
  }, H.prototype.convertFrom = function(g) {
    var $ = g.clone();
    return $.red = null, $;
  }, c.mont = function(g) {
    return new te(g);
  }, u(te, H), te.prototype.convertTo = function(g) {
    return this.imod(g.ushln(this.shift));
  }, te.prototype.convertFrom = function(g) {
    var $ = this.imod(g.mul(this.rinv));
    return $.red = null, $;
  }, te.prototype.imul = function(g, $) {
    if (g.isZero() || $.isZero())
      return g.words[0] = 0, g.length = 1, g;
    var _ = g.imul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.mul = function(g, $) {
    if (g.isZero() || $.isZero())
      return new c(0)._forceRed(this);
    var _ = g.mul($), b = _.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m = _.isub(b).iushrn(this.shift), v = m;
    return m.cmp(this.m) >= 0 ? v = m.isub(this.m) : m.cmpn(0) < 0 && (v = m.iadd(this.m)), v._forceRed(this);
  }, te.prototype.invm = function(g) {
    return this.imod(g._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(n, o) {
  var a = buffer$6, u = a.Buffer;
  function c(d, w) {
    for (var S in d)
      w[S] = d[S];
  }
  function p(d, w, S) {
    return u(d, w, S);
  }
  u.from && u.alloc && u.allocUnsafe && u.allocUnsafeSlow ? n.exports = a : (c(a, o), o.Buffer = p), p.prototype = Object.create(u.prototype), c(u, p), p.from = function(d, w, S) {
    if (typeof d == "number")
      throw new TypeError("Argument must not be a number");
    return u(d, w, S);
  }, p.alloc = function(d, w, S) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    var k = u(d);
    return w !== void 0 ? typeof S == "string" ? k.fill(w, S) : k.fill(w) : k.fill(0), k;
  }, p.allocUnsafe = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return u(d);
  }, p.allocUnsafeSlow = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return a.SlowBuffer(d);
  };
})(safeBuffer, safeBuffer.exports);
const Buffer$4 = safeBuffer.exports.Buffer;
var bufferPipe$1 = class {
  constructor(n = Buffer$4.from([])) {
    this.buffer = n;
  }
  read(n) {
    const o = this.buffer.subarray(0, n);
    return this.buffer = this.buffer.subarray(n), o;
  }
  write(n) {
    n = Buffer$4.from(n), this.buffer = Buffer$4.concat([this.buffer, n]);
  }
};
const Bn$1 = bn.exports, Pipe$2 = bufferPipe$1;
var unsigned = { encode: encode$1, decode: decode$1, read: read$1, readBn: readBn$1, write: write$1 };
function read$1(n) {
  return readBn$1(n).toString();
}
function readBn$1(n) {
  const o = new Bn$1(0);
  let a, u = 0;
  for (; a = n.read(1)[0], o.ior(new Bn$1(127 & a).shln(u)), a >> 7 != 0; )
    u += 7;
  return o;
}
function write$1(n, o) {
  const a = new Bn$1(n);
  for (; ; ) {
    const u = a.maskn(7).toNumber();
    if (a.ishrn(7), a.isZero()) {
      o.write([u]);
      break;
    }
    o.write([128 | u]);
  }
}
function encode$1(n) {
  const o = new Pipe$2();
  return write$1(n, o), o.buffer;
}
function decode$1(n) {
  return read$1(new Pipe$2(n));
}
const Bn = bn.exports, Pipe$1 = bufferPipe$1;
var signed = { encode, decode, write, read, readBn };
function read(n) {
  return readBn(n).toString();
}
function readBn(n) {
  const o = new Bn(0);
  let a, u = 0;
  for (; a = n.read(1)[0], o.ior(new Bn(127 & a).shln(u)), u += 7, a >> 7 != 0; )
    ;
  return 64 & a && o.setn(u), o.fromTwos(u);
}
function write(n, o) {
  let a = new Bn(n);
  const u = a.isNeg();
  for (u && (a = a.toTwos(a.bitLength() + 8)); ; ) {
    const p = a.maskn(7).toNumber();
    if (a.ishrn(7), c(a) && (64 & p) != 0 || a.isZero() && (64 & p) == 0) {
      o.write([p]);
      break;
    }
    o.write([128 | p]);
  }
  function c(p) {
    return u && p.toString(2).indexOf("0") < 0;
  }
}
function encode(n) {
  const o = new Pipe$1();
  return write(n, o), o.buffer;
}
function decode(n) {
  return read(new Pipe$1(n));
}
leb128$1.unsigned = unsigned, leb128$1.signed = signed;
const Buffer$3 = safeBuffer.exports.Buffer;
var bufferPipe = class {
  constructor(n = Buffer$3.from([])) {
    this.buffer = n, this._bytesRead = 0, this._bytesWrote = 0;
  }
  read(n) {
    this._bytesRead += n;
    const o = this.buffer.slice(0, n);
    return this.buffer = this.buffer.slice(n), o;
  }
  write(n) {
    n = Buffer$3.from(n), this._bytesWrote += n.length, this.buffer = Buffer$3.concat([this.buffer, n]);
  }
  get end() {
    return !this.buffer.length;
  }
  get bytesRead() {
    return this._bytesRead;
  }
  get bytesWrote() {
    return this._bytesWrote;
  }
};
const block = "block_type", loop = "block_type", br = "varuint32", br_if = "varuint32", br_table = "br_table", call = "varuint32", call_indirect = "call_indirect", get_local = "varuint32", set_local = "varuint32", tee_local = "varuint32", get_global = "varuint32", set_global = "varuint32", load = "memory_immediate", load8_s = "memory_immediate", load8_u = "memory_immediate", load16_s = "memory_immediate", load16_u = "memory_immediate", load32_s = "memory_immediate", load32_u = "memory_immediate", store = "memory_immediate", store8 = "memory_immediate", store16 = "memory_immediate", store32 = "memory_immediate", current_memory = "varuint1", grow_memory = "varuint1", i32 = "varint32", i64 = "varint64", f32 = "uint32", f64 = "uint64", require$$0$1 = { block, loop, if: "block_type", br, br_if, br_table, call, call_indirect, get_local, set_local, tee_local, get_global, set_global, load, load8_s, load8_u, load16_s, load16_u, load32_s, load32_u, store, store8, store16, store32, current_memory, grow_memory, i32, i64, f32, f64 }, leb$1 = leb128$1, Stream$1 = bufferPipe, OP_IMMEDIATES$1 = require$$0$1, _exports$1 = wasm2json$1.exports = (n, o) => {
  const a = new Stream$1(n);
  return _exports$1.parse(a, o);
}, LANGUAGE_TYPES$1 = _exports$1.LANGUAGE_TYPES = { 127: "i32", 126: "i64", 125: "f32", 124: "f64", 112: "anyFunc", 96: "func", 64: "block_type" }, EXTERNAL_KIND$1 = _exports$1.EXTERNAL_KIND = { 0: "function", 1: "table", 2: "memory", 3: "global" };
_exports$1.parsePreramble = (n) => {
  const o = { name: "preramble" };
  return o.magic = [...n.read(4)], o.version = [...n.read(4)], o;
}, _exports$1.parseSectionHeader = (n) => {
  const o = n.read(1)[0], a = leb$1.unsigned.readBn(n).toNumber();
  return { id: o, name: SECTION_IDS$1[o], size: a };
};
const OPCODES$1 = _exports$1.OPCODES = { 0: "unreachable", 1: "nop", 2: "block", 3: "loop", 4: "if", 5: "else", 11: "end", 12: "br", 13: "br_if", 14: "br_table", 15: "return", 16: "call", 17: "call_indirect", 26: "drop", 27: "select", 32: "get_local", 33: "set_local", 34: "tee_local", 35: "get_global", 36: "set_global", 40: "i32.load", 41: "i64.load", 42: "f32.load", 43: "f64.load", 44: "i32.load8_s", 45: "i32.load8_u", 46: "i32.load16_s", 47: "i32.load16_u", 48: "i64.load8_s", 49: "i64.load8_u", 50: "i64.load16_s", 51: "i64.load16_u", 52: "i64.load32_s", 53: "i64.load32_u", 54: "i32.store", 55: "i64.store", 56: "f32.store", 57: "f64.store", 58: "i32.store8", 59: "i32.store16", 60: "i64.store8", 61: "i64.store16", 62: "i64.store32", 63: "current_memory", 64: "grow_memory", 65: "i32.const", 66: "i64.const", 67: "f32.const", 68: "f64.const", 69: "i32.eqz", 70: "i32.eq", 71: "i32.ne", 72: "i32.lt_s", 73: "i32.lt_u", 74: "i32.gt_s", 75: "i32.gt_u", 76: "i32.le_s", 77: "i32.le_u", 78: "i32.ge_s", 79: "i32.ge_u", 80: "i64.eqz", 81: "i64.eq", 82: "i64.ne", 83: "i64.lt_s", 84: "i64.lt_u", 85: "i64.gt_s", 86: "i64.gt_u", 87: "i64.le_s", 88: "i64.le_u", 89: "i64.ge_s", 90: "i64.ge_u", 91: "f32.eq", 92: "f32.ne", 93: "f32.lt", 94: "f32.gt", 95: "f32.le", 96: "f32.ge", 97: "f64.eq", 98: "f64.ne", 99: "f64.lt", 100: "f64.gt", 101: "f64.le", 102: "f64.ge", 103: "i32.clz", 104: "i32.ctz", 105: "i32.popcnt", 106: "i32.add", 107: "i32.sub", 108: "i32.mul", 109: "i32.div_s", 110: "i32.div_u", 111: "i32.rem_s", 112: "i32.rem_u", 113: "i32.and", 114: "i32.or", 115: "i32.xor", 116: "i32.shl", 117: "i32.shr_s", 118: "i32.shr_u", 119: "i32.rotl", 120: "i32.rotr", 121: "i64.clz", 122: "i64.ctz", 123: "i64.popcnt", 124: "i64.add", 125: "i64.sub", 126: "i64.mul", 127: "i64.div_s", 128: "i64.div_u", 129: "i64.rem_s", 130: "i64.rem_u", 131: "i64.and", 132: "i64.or", 133: "i64.xor", 134: "i64.shl", 135: "i64.shr_s", 136: "i64.shr_u", 137: "i64.rotl", 138: "i64.rotr", 139: "f32.abs", 140: "f32.neg", 141: "f32.ceil", 142: "f32.floor", 143: "f32.trunc", 144: "f32.nearest", 145: "f32.sqrt", 146: "f32.add", 147: "f32.sub", 148: "f32.mul", 149: "f32.div", 150: "f32.min", 151: "f32.max", 152: "f32.copysign", 153: "f64.abs", 154: "f64.neg", 155: "f64.ceil", 156: "f64.floor", 157: "f64.trunc", 158: "f64.nearest", 159: "f64.sqrt", 160: "f64.add", 161: "f64.sub", 162: "f64.mul", 163: "f64.div", 164: "f64.min", 165: "f64.max", 166: "f64.copysign", 167: "i32.wrap/i64", 168: "i32.trunc_s/f32", 169: "i32.trunc_u/f32", 170: "i32.trunc_s/f64", 171: "i32.trunc_u/f64", 172: "i64.extend_s/i32", 173: "i64.extend_u/i32", 174: "i64.trunc_s/f32", 175: "i64.trunc_u/f32", 176: "i64.trunc_s/f64", 177: "i64.trunc_u/f64", 178: "f32.convert_s/i32", 179: "f32.convert_u/i32", 180: "f32.convert_s/i64", 181: "f32.convert_u/i64", 182: "f32.demote/f64", 183: "f64.convert_s/i32", 184: "f64.convert_u/i32", 185: "f64.convert_s/i64", 186: "f64.convert_u/i64", 187: "f64.promote/f32", 188: "i32.reinterpret/f32", 189: "i64.reinterpret/f64", 190: "f32.reinterpret/i32", 191: "f64.reinterpret/i64" }, SECTION_IDS$1 = _exports$1.SECTION_IDS = { 0: "custom", 1: "type", 2: "import", 3: "function", 4: "table", 5: "memory", 6: "global", 7: "export", 8: "start", 9: "element", 10: "code", 11: "data" };
_exports$1.immediataryParsers = { varuint1: (n) => n.read(1)[0], varuint32: (n) => leb$1.unsigned.read(n), varint32: (n) => leb$1.signed.read(n), varint64: (n) => leb$1.signed.read(n), uint32: (n) => [...n.read(4)], uint64: (n) => [...n.read(8)], block_type: (n) => {
  const o = n.read(1)[0];
  return LANGUAGE_TYPES$1[o];
}, br_table: (n) => {
  const o = { targets: [] }, a = leb$1.unsigned.readBn(n).toNumber();
  for (let u = 0; u < a; u++) {
    const c = leb$1.unsigned.readBn(n).toNumber();
    o.targets.push(c);
  }
  return o.defaultTarget = leb$1.unsigned.readBn(n).toNumber(), o;
}, call_indirect: (n) => {
  const o = {};
  return o.index = leb$1.unsigned.readBn(n).toNumber(), o.reserved = n.read(1)[0], o;
}, memory_immediate: (n) => {
  const o = {};
  return o.flags = leb$1.unsigned.readBn(n).toNumber(), o.offset = leb$1.unsigned.readBn(n).toNumber(), o;
} }, _exports$1.typeParsers = { function: (n) => leb$1.unsigned.readBn(n).toNumber(), table: (n) => {
  const o = {}, a = n.read(1)[0];
  return o.elementType = LANGUAGE_TYPES$1[a], o.limits = _exports$1.typeParsers.memory(n), o;
}, global: (n) => {
  const o = {};
  let a = n.read(1)[0];
  return o.contentType = LANGUAGE_TYPES$1[a], o.mutability = n.read(1)[0], o;
}, memory: (n) => {
  const o = {};
  return o.flags = leb$1.unsigned.readBn(n).toNumber(), o.intial = leb$1.unsigned.readBn(n).toNumber(), o.flags === 1 && (o.maximum = leb$1.unsigned.readBn(n).toNumber()), o;
}, initExpr: (n) => {
  const o = _exports$1.parseOp(n);
  return n.read(1), o;
} };
const sectionParsers = _exports$1.sectionParsers = { custom: (n, o) => {
  const a = { name: "custom" }, u = new Stream$1(n.read(o.size)), c = leb$1.unsigned.readBn(u).toNumber(), p = u.read(c);
  return a.sectionName = Buffer.from(p).toString(), a.payload = [...u.buffer], a;
}, type: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "type", entries: [] };
  for (let u = 0; u < o; u++) {
    let c = n.read(1)[0];
    const p = { form: LANGUAGE_TYPES$1[c], params: [] }, d = leb$1.unsigned.readBn(n).toNumber();
    for (let w = 0; w < d; w++) {
      const S = n.read(1)[0];
      p.params.push(LANGUAGE_TYPES$1[S]);
    }
    leb$1.unsigned.readBn(n).toNumber() && (c = n.read(1)[0], p.return_type = LANGUAGE_TYPES$1[c]), a.entries.push(p);
  }
  return a;
}, import: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "import", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = {}, p = leb$1.unsigned.readBn(n).toNumber();
    c.moduleStr = Buffer.from(n.read(p)).toString();
    const d = leb$1.unsigned.readBn(n).toNumber();
    c.fieldStr = Buffer.from(n.read(d)).toString();
    const w = n.read(1)[0];
    c.kind = EXTERNAL_KIND$1[w], c.type = _exports$1.typeParsers[c.kind](n), a.entries.push(c);
  }
  return a;
}, function: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "function", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = leb$1.unsigned.readBn(n).toNumber();
    a.entries.push(c);
  }
  return a;
}, table: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "table", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = _exports$1.typeParsers.table(n);
    a.entries.push(c);
  }
  return a;
}, memory: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "memory", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = _exports$1.typeParsers.memory(n);
    a.entries.push(c);
  }
  return a;
}, global: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "global", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = {};
    c.type = _exports$1.typeParsers.global(n), c.init = _exports$1.typeParsers.initExpr(n), a.entries.push(c);
  }
  return a;
}, export: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "export", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = leb$1.unsigned.readBn(n).toNumber(), p = {};
    p.field_str = Buffer.from(n.read(c)).toString();
    const d = n.read(1)[0];
    p.kind = EXTERNAL_KIND$1[d], p.index = leb$1.unsigned.readBn(n).toNumber(), a.entries.push(p);
  }
  return a;
}, start: (n) => {
  const o = { name: "start" };
  return o.index = leb$1.unsigned.readBn(n).toNumber(), o;
}, element: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "element", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = { elements: [] };
    c.index = leb$1.unsigned.readBn(n).toNumber(), c.offset = _exports$1.typeParsers.initExpr(n);
    const p = leb$1.unsigned.readBn(n).toNumber();
    for (let d = 0; d < p; d++) {
      const w = leb$1.unsigned.readBn(n).toNumber();
      c.elements.push(w);
    }
    a.entries.push(c);
  }
  return a;
}, code: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "code", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = { locals: [], code: [] };
    let p = leb$1.unsigned.readBn(n).toNumber();
    const d = n.bytesRead + p, w = leb$1.unsigned.readBn(n).toNumber();
    for (let S = 0; S < w; S++) {
      const k = {};
      k.count = leb$1.unsigned.readBn(n).toNumber();
      const B = n.read(1)[0];
      k.type = LANGUAGE_TYPES$1[B], c.locals.push(k);
    }
    for (; n.bytesRead < d; ) {
      const S = _exports$1.parseOp(n);
      c.code.push(S);
    }
    a.entries.push(c);
  }
  return a;
}, data: (n) => {
  const o = leb$1.unsigned.readBn(n).toNumber(), a = { name: "data", entries: [] };
  for (let u = 0; u < o; u++) {
    const c = {};
    c.index = leb$1.unsigned.readBn(n).toNumber(), c.offset = _exports$1.typeParsers.initExpr(n);
    const p = leb$1.unsigned.readBn(n).toNumber();
    c.data = [...n.read(p)], a.entries.push(c);
  }
  return a;
} };
_exports$1.parseOp = (n) => {
  const o = {}, a = n.read(1)[0], u = OPCODES$1[a];
  let [c, p] = u.split(".");
  p === void 0 ? p = c : o.return_type = c, o.name = p;
  const d = OP_IMMEDIATES$1[p === "const" ? c : p];
  return d && (o.immediates = _exports$1.immediataryParsers[d](n)), o;
}, _exports$1.parse = (n, o) => {
  const a = [_exports$1.parsePreramble(n)];
  for (; !n.end; ) {
    const u = _exports$1.parseSectionHeader(n);
    a.push(sectionParsers[u.name](n, u));
  }
  return a;
};
var json2wasm = { exports: {} }, npmBrowser = {}, buffer = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  const o = base64Js, a = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = d, n.SlowBuffer = function(l) {
    return +l != l && (l = 0), d.alloc(+l);
  }, n.INSPECT_MAX_BYTES = 50;
  const c = 2147483647;
  function p(l) {
    if (l > c)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
    const h = new Uint8Array(l);
    return Object.setPrototypeOf(h, d.prototype), h;
  }
  function d(l, h, y) {
    if (typeof l == "number") {
      if (typeof h == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return k(l);
    }
    return w(l, h, y);
  }
  function w(l, h, y) {
    if (typeof l == "string")
      return function(x, O) {
        if (typeof O == "string" && O !== "" || (O = "utf8"), !d.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        const G = 0 | P(x, O);
        let X = p(G);
        const ie = X.write(x, O);
        return ie !== G && (X = X.slice(0, ie)), X;
      }(l, h);
    if (ArrayBuffer.isView(l))
      return function(x) {
        if (se(x, Uint8Array)) {
          const O = new Uint8Array(x);
          return I(O.buffer, O.byteOffset, O.byteLength);
        }
        return B(x);
      }(l);
    if (l == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
    if (se(l, ArrayBuffer) || l && se(l.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (se(l, SharedArrayBuffer) || l && se(l.buffer, SharedArrayBuffer)))
      return I(l, h, y);
    if (typeof l == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const A = l.valueOf && l.valueOf();
    if (A != null && A !== l)
      return d.from(A, h, y);
    const M = function(x) {
      if (d.isBuffer(x)) {
        const O = 0 | C(x.length), G = p(O);
        return G.length === 0 || x.copy(G, 0, 0, O), G;
      }
      return x.length !== void 0 ? typeof x.length != "number" || we(x.length) ? p(0) : B(x) : x.type === "Buffer" && Array.isArray(x.data) ? B(x.data) : void 0;
    }(l);
    if (M)
      return M;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof l[Symbol.toPrimitive] == "function")
      return d.from(l[Symbol.toPrimitive]("string"), h, y);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
  }
  function S(l) {
    if (typeof l != "number")
      throw new TypeError('"size" argument must be of type number');
    if (l < 0)
      throw new RangeError('The value "' + l + '" is invalid for option "size"');
  }
  function k(l) {
    return S(l), p(l < 0 ? 0 : 0 | C(l));
  }
  function B(l) {
    const h = l.length < 0 ? 0 : 0 | C(l.length), y = p(h);
    for (let A = 0; A < h; A += 1)
      y[A] = 255 & l[A];
    return y;
  }
  function I(l, h, y) {
    if (h < 0 || l.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (l.byteLength < h + (y || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return A = h === void 0 && y === void 0 ? new Uint8Array(l) : y === void 0 ? new Uint8Array(l, h) : new Uint8Array(l, h, y), Object.setPrototypeOf(A, d.prototype), A;
  }
  function C(l) {
    if (l >= c)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
    return 0 | l;
  }
  function P(l, h) {
    if (d.isBuffer(l))
      return l.length;
    if (ArrayBuffer.isView(l) || se(l, ArrayBuffer))
      return l.byteLength;
    if (typeof l != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
    const y = l.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && y === 0)
      return 0;
    let M = !1;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return y;
        case "utf8":
        case "utf-8":
          return he(l).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * y;
        case "hex":
          return y >>> 1;
        case "base64":
          return _e(l).length;
        default:
          if (M)
            return A ? -1 : he(l).length;
          h = ("" + h).toLowerCase(), M = !0;
      }
  }
  function q(l, h, y) {
    let A = !1;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((y === void 0 || y > this.length) && (y = this.length), y <= 0) || (y >>>= 0) <= (h >>>= 0))
      return "";
    for (l || (l = "utf8"); ; )
      switch (l) {
        case "hex":
          return m(this, h, y);
        case "utf8":
        case "utf-8":
          return g(this, h, y);
        case "ascii":
          return _(this, h, y);
        case "latin1":
        case "binary":
          return b(this, h, y);
        case "base64":
          return te(this, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, h, y);
        default:
          if (A)
            throw new TypeError("Unknown encoding: " + l);
          l = (l + "").toLowerCase(), A = !0;
      }
  }
  function D(l, h, y) {
    const A = l[h];
    l[h] = l[y], l[y] = A;
  }
  function z(l, h, y, A, M) {
    if (l.length === 0)
      return -1;
    if (typeof y == "string" ? (A = y, y = 0) : y > 2147483647 ? y = 2147483647 : y < -2147483648 && (y = -2147483648), we(y = +y) && (y = M ? 0 : l.length - 1), y < 0 && (y = l.length + y), y >= l.length) {
      if (M)
        return -1;
      y = l.length - 1;
    } else if (y < 0) {
      if (!M)
        return -1;
      y = 0;
    }
    if (typeof h == "string" && (h = d.from(h, A)), d.isBuffer(h))
      return h.length === 0 ? -1 : F(l, h, y, A, M);
    if (typeof h == "number")
      return h &= 255, typeof Uint8Array.prototype.indexOf == "function" ? M ? Uint8Array.prototype.indexOf.call(l, h, y) : Uint8Array.prototype.lastIndexOf.call(l, h, y) : F(l, [h], y, A, M);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(l, h, y, A, M) {
    let x, O = 1, G = l.length, X = h.length;
    if (A !== void 0 && ((A = String(A).toLowerCase()) === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (l.length < 2 || h.length < 2)
        return -1;
      O = 2, G /= 2, X /= 2, y /= 2;
    }
    function ie(ee, re) {
      return O === 1 ? ee[re] : ee.readUInt16BE(re * O);
    }
    if (M) {
      let ee = -1;
      for (x = y; x < G; x++)
        if (ie(l, x) === ie(h, ee === -1 ? 0 : x - ee)) {
          if (ee === -1 && (ee = x), x - ee + 1 === X)
            return ee * O;
        } else
          ee !== -1 && (x -= x - ee), ee = -1;
    } else
      for (y + X > G && (y = G - X), x = y; x >= 0; x--) {
        let ee = !0;
        for (let re = 0; re < X; re++)
          if (ie(l, x + re) !== ie(h, re)) {
            ee = !1;
            break;
          }
        if (ee)
          return x;
      }
    return -1;
  }
  function V(l, h, y, A) {
    y = Number(y) || 0;
    const M = l.length - y;
    A ? (A = Number(A)) > M && (A = M) : A = M;
    const x = h.length;
    let O;
    for (A > x / 2 && (A = x / 2), O = 0; O < A; ++O) {
      const G = parseInt(h.substr(2 * O, 2), 16);
      if (we(G))
        return O;
      l[y + O] = G;
    }
    return O;
  }
  function Z(l, h, y, A) {
    return Le(he(h, l.length - y), l, y, A);
  }
  function N(l, h, y, A) {
    return Le(function(M) {
      const x = [];
      for (let O = 0; O < M.length; ++O)
        x.push(255 & M.charCodeAt(O));
      return x;
    }(h), l, y, A);
  }
  function W(l, h, y, A) {
    return Le(_e(h), l, y, A);
  }
  function H(l, h, y, A) {
    return Le(function(M, x) {
      let O, G, X;
      const ie = [];
      for (let ee = 0; ee < M.length && !((x -= 2) < 0); ++ee)
        O = M.charCodeAt(ee), G = O >> 8, X = O % 256, ie.push(X), ie.push(G);
      return ie;
    }(h, l.length - y), l, y, A);
  }
  function te(l, h, y) {
    return h === 0 && y === l.length ? o.fromByteArray(l) : o.fromByteArray(l.slice(h, y));
  }
  function g(l, h, y) {
    y = Math.min(l.length, y);
    const A = [];
    let M = h;
    for (; M < y; ) {
      const x = l[M];
      let O = null, G = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (M + G <= y) {
        let X, ie, ee, re;
        switch (G) {
          case 1:
            x < 128 && (O = x);
            break;
          case 2:
            X = l[M + 1], (192 & X) == 128 && (re = (31 & x) << 6 | 63 & X, re > 127 && (O = re));
            break;
          case 3:
            X = l[M + 1], ie = l[M + 2], (192 & X) == 128 && (192 & ie) == 128 && (re = (15 & x) << 12 | (63 & X) << 6 | 63 & ie, re > 2047 && (re < 55296 || re > 57343) && (O = re));
            break;
          case 4:
            X = l[M + 1], ie = l[M + 2], ee = l[M + 3], (192 & X) == 128 && (192 & ie) == 128 && (192 & ee) == 128 && (re = (15 & x) << 18 | (63 & X) << 12 | (63 & ie) << 6 | 63 & ee, re > 65535 && re < 1114112 && (O = re));
        }
      }
      O === null ? (O = 65533, G = 1) : O > 65535 && (O -= 65536, A.push(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), A.push(O), M += G;
    }
    return function(x) {
      const O = x.length;
      if (O <= $)
        return String.fromCharCode.apply(String, x);
      let G = "", X = 0;
      for (; X < O; )
        G += String.fromCharCode.apply(String, x.slice(X, X += $));
      return G;
    }(A);
  }
  n.kMaxLength = c, d.TYPED_ARRAY_SUPPORT = function() {
    try {
      const l = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(l, h), l.foo() === 42;
    } catch {
      return !1;
    }
  }(), d.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(d.prototype, "offset", { enumerable: !0, get: function() {
    if (d.isBuffer(this))
      return this.byteOffset;
  } }), d.poolSize = 8192, d.from = function(l, h, y) {
    return w(l, h, y);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(l, h, y) {
    return function(A, M, x) {
      return S(A), A <= 0 ? p(A) : M !== void 0 ? typeof x == "string" ? p(A).fill(M, x) : p(A).fill(M) : p(A);
    }(l, h, y);
  }, d.allocUnsafe = function(l) {
    return k(l);
  }, d.allocUnsafeSlow = function(l) {
    return k(l);
  }, d.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== d.prototype;
  }, d.compare = function(l, h) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), se(h, Uint8Array) && (h = d.from(h, h.offset, h.byteLength)), !d.isBuffer(l) || !d.isBuffer(h))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (l === h)
      return 0;
    let y = l.length, A = h.length;
    for (let M = 0, x = Math.min(y, A); M < x; ++M)
      if (l[M] !== h[M]) {
        y = l[M], A = h[M];
        break;
      }
    return y < A ? -1 : A < y ? 1 : 0;
  }, d.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(l, h) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return d.alloc(0);
    let y;
    if (h === void 0)
      for (h = 0, y = 0; y < l.length; ++y)
        h += l[y].length;
    const A = d.allocUnsafe(h);
    let M = 0;
    for (y = 0; y < l.length; ++y) {
      let x = l[y];
      if (se(x, Uint8Array))
        M + x.length > A.length ? (d.isBuffer(x) || (x = d.from(x)), x.copy(A, M)) : Uint8Array.prototype.set.call(A, x, M);
      else {
        if (!d.isBuffer(x))
          throw new TypeError('"list" argument must be an Array of Buffers');
        x.copy(A, M);
      }
      M += x.length;
    }
    return A;
  }, d.byteLength = P, d.prototype._isBuffer = !0, d.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < l; h += 2)
      D(this, h, h + 1);
    return this;
  }, d.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < l; h += 4)
      D(this, h, h + 3), D(this, h + 1, h + 2);
    return this;
  }, d.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < l; h += 8)
      D(this, h, h + 7), D(this, h + 1, h + 6), D(this, h + 2, h + 5), D(this, h + 3, h + 4);
    return this;
  }, d.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? g(this, 0, l) : q.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(l) {
    if (!d.isBuffer(l))
      throw new TypeError("Argument must be a Buffer");
    return this === l || d.compare(this, l) === 0;
  }, d.prototype.inspect = function() {
    let l = "";
    const h = n.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (l += " ... "), "<Buffer " + l + ">";
  }, u && (d.prototype[u] = d.prototype.inspect), d.prototype.compare = function(l, h, y, A, M) {
    if (se(l, Uint8Array) && (l = d.from(l, l.offset, l.byteLength)), !d.isBuffer(l))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
    if (h === void 0 && (h = 0), y === void 0 && (y = l ? l.length : 0), A === void 0 && (A = 0), M === void 0 && (M = this.length), h < 0 || y > l.length || A < 0 || M > this.length)
      throw new RangeError("out of range index");
    if (A >= M && h >= y)
      return 0;
    if (A >= M)
      return -1;
    if (h >= y)
      return 1;
    if (this === l)
      return 0;
    let x = (M >>>= 0) - (A >>>= 0), O = (y >>>= 0) - (h >>>= 0);
    const G = Math.min(x, O), X = this.slice(A, M), ie = l.slice(h, y);
    for (let ee = 0; ee < G; ++ee)
      if (X[ee] !== ie[ee]) {
        x = X[ee], O = ie[ee];
        break;
      }
    return x < O ? -1 : O < x ? 1 : 0;
  }, d.prototype.includes = function(l, h, y) {
    return this.indexOf(l, h, y) !== -1;
  }, d.prototype.indexOf = function(l, h, y) {
    return z(this, l, h, y, !0);
  }, d.prototype.lastIndexOf = function(l, h, y) {
    return z(this, l, h, y, !1);
  }, d.prototype.write = function(l, h, y, A) {
    if (h === void 0)
      A = "utf8", y = this.length, h = 0;
    else if (y === void 0 && typeof h == "string")
      A = h, y = this.length, h = 0;
    else {
      if (!isFinite(h))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      h >>>= 0, isFinite(y) ? (y >>>= 0, A === void 0 && (A = "utf8")) : (A = y, y = void 0);
    }
    const M = this.length - h;
    if ((y === void 0 || y > M) && (y = M), l.length > 0 && (y < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    A || (A = "utf8");
    let x = !1;
    for (; ; )
      switch (A) {
        case "hex":
          return V(this, l, h, y);
        case "utf8":
        case "utf-8":
          return Z(this, l, h, y);
        case "ascii":
        case "latin1":
        case "binary":
          return N(this, l, h, y);
        case "base64":
          return W(this, l, h, y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, l, h, y);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + A);
          A = ("" + A).toLowerCase(), x = !0;
      }
  }, d.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const $ = 4096;
  function _(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(127 & l[M]);
    return A;
  }
  function b(l, h, y) {
    let A = "";
    y = Math.min(l.length, y);
    for (let M = h; M < y; ++M)
      A += String.fromCharCode(l[M]);
    return A;
  }
  function m(l, h, y) {
    const A = l.length;
    (!h || h < 0) && (h = 0), (!y || y < 0 || y > A) && (y = A);
    let M = "";
    for (let x = h; x < y; ++x)
      M += We[l[x]];
    return M;
  }
  function v(l, h, y) {
    const A = l.slice(h, y);
    let M = "";
    for (let x = 0; x < A.length - 1; x += 2)
      M += String.fromCharCode(A[x] + 256 * A[x + 1]);
    return M;
  }
  function E(l, h, y) {
    if (l % 1 != 0 || l < 0)
      throw new RangeError("offset is not uint");
    if (l + h > y)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function T(l, h, y, A, M, x) {
    if (!d.isBuffer(l))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > M || h < x)
      throw new RangeError('"value" argument is out of bounds');
    if (y + A > l.length)
      throw new RangeError("Index out of range");
  }
  function j(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x, x >>= 8, l[y++] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, O >>= 8, l[y++] = O, y;
  }
  function L(l, h, y, A, M) {
    ce(h, A, M, l, y, 7);
    let x = Number(h & BigInt(4294967295));
    l[y + 7] = x, x >>= 8, l[y + 6] = x, x >>= 8, l[y + 5] = x, x >>= 8, l[y + 4] = x;
    let O = Number(h >> BigInt(32) & BigInt(4294967295));
    return l[y + 3] = O, O >>= 8, l[y + 2] = O, O >>= 8, l[y + 1] = O, O >>= 8, l[y] = O, y + 8;
  }
  function J(l, h, y, A, M, x) {
    if (y + A > l.length)
      throw new RangeError("Index out of range");
    if (y < 0)
      throw new RangeError("Index out of range");
  }
  function Y(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 4), a.write(l, h, y, A, 23, 4), y + 4;
  }
  function ne(l, h, y, A, M) {
    return h = +h, y >>>= 0, M || J(l, 0, y, 8), a.write(l, h, y, A, 52, 8), y + 8;
  }
  d.prototype.slice = function(l, h) {
    const y = this.length;
    (l = ~~l) < 0 ? (l += y) < 0 && (l = 0) : l > y && (l = y), (h = h === void 0 ? y : ~~h) < 0 ? (h += y) < 0 && (h = 0) : h > y && (h = y), h < l && (h = l);
    const A = this.subarray(l, h);
    return Object.setPrototypeOf(A, d.prototype), A;
  }, d.prototype.readUintLE = d.prototype.readUIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return A;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l + --h], M = 1;
    for (; h > 0 && (M *= 256); )
      A += this[l + --h] * M;
    return A;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), this[l];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(l, h) {
    return l >>>= 0, h || E(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, d.prototype.readBigUInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, M = this[++l] + 256 * this[++l] + 65536 * this[++l] + y * 2 ** 24;
    return BigInt(A) + (BigInt(M) << BigInt(32));
  }), d.prototype.readBigUInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = h * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], M = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y;
    return (BigInt(A) << BigInt(32)) + BigInt(M);
  }), d.prototype.readIntLE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = this[l], M = 1, x = 0;
    for (; ++x < h && (M *= 256); )
      A += this[l + x] * M;
    return M *= 128, A >= M && (A -= Math.pow(2, 8 * h)), A;
  }, d.prototype.readIntBE = function(l, h, y) {
    l >>>= 0, h >>>= 0, y || E(l, h, this.length);
    let A = h, M = 1, x = this[l + --A];
    for (; A > 0 && (M *= 256); )
      x += this[l + --A] * M;
    return M *= 128, x >= M && (x -= Math.pow(2, 8 * h)), x;
  }, d.prototype.readInt8 = function(l, h) {
    return l >>>= 0, h || E(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
  }, d.prototype.readInt16LE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l] | this[l + 1] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt16BE = function(l, h) {
    l >>>= 0, h || E(l, 2, this.length);
    const y = this[l + 1] | this[l] << 8;
    return 32768 & y ? 4294901760 | y : y;
  }, d.prototype.readInt32LE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, d.prototype.readInt32BE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, d.prototype.readBigInt64LE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (y << 24);
    return (BigInt(A) << BigInt(32)) + BigInt(h + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
  }), d.prototype.readBigInt64BE = de(function(l) {
    ue(l >>>= 0, "offset");
    const h = this[l], y = this[l + 7];
    h !== void 0 && y !== void 0 || le(l, this.length - 8);
    const A = (h << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
    return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + y);
  }), d.prototype.readFloatLE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !0, 23, 4);
  }, d.prototype.readFloatBE = function(l, h) {
    return l >>>= 0, h || E(l, 4, this.length), a.read(this, l, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(l, h) {
    return l >>>= 0, h || E(l, 8, this.length), a.read(this, l, !1, 52, 8);
  }, d.prototype.writeUintLE = d.prototype.writeUIntLE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = 1, x = 0;
    for (this[h] = 255 & l; ++x < y && (M *= 256); )
      this[h + x] = l / M & 255;
    return h + y;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(l, h, y, A) {
    l = +l, h >>>= 0, y >>>= 0, A || T(this, l, h, y, Math.pow(2, 8 * y) - 1, 0);
    let M = y - 1, x = 1;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      this[h + M] = l / x & 255;
    return h + y;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 255, 0), this[h] = 255 & l, h + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 65535, 0), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h + 3] = l >>> 24, this[h + 2] = l >>> 16, this[h + 1] = l >>> 8, this[h] = 255 & l, h + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 4294967295, 0), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigUInt64LE = de(function(l, h = 0) {
    return j(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeBigUInt64BE = de(function(l, h = 0) {
    return L(this, l, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), d.prototype.writeIntLE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = 0, x = 1, O = 0;
    for (this[h] = 255 & l; ++M < y && (x *= 256); )
      l < 0 && O === 0 && this[h + M - 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeIntBE = function(l, h, y, A) {
    if (l = +l, h >>>= 0, !A) {
      const G = Math.pow(2, 8 * y - 1);
      T(this, l, h, y, G - 1, -G);
    }
    let M = y - 1, x = 1, O = 0;
    for (this[h + M] = 255 & l; --M >= 0 && (x *= 256); )
      l < 0 && O === 0 && this[h + M + 1] !== 0 && (O = 1), this[h + M] = (l / x >> 0) - O & 255;
    return h + y;
  }, d.prototype.writeInt8 = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[h] = 255 & l, h + 1;
  }, d.prototype.writeInt16LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = 255 & l, this[h + 1] = l >>> 8, h + 2;
  }, d.prototype.writeInt16BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 2, 32767, -32768), this[h] = l >>> 8, this[h + 1] = 255 & l, h + 2;
  }, d.prototype.writeInt32LE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), this[h] = 255 & l, this[h + 1] = l >>> 8, this[h + 2] = l >>> 16, this[h + 3] = l >>> 24, h + 4;
  }, d.prototype.writeInt32BE = function(l, h, y) {
    return l = +l, h >>>= 0, y || T(this, l, h, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[h] = l >>> 24, this[h + 1] = l >>> 16, this[h + 2] = l >>> 8, this[h + 3] = 255 & l, h + 4;
  }, d.prototype.writeBigInt64LE = de(function(l, h = 0) {
    return j(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeBigInt64BE = de(function(l, h = 0) {
    return L(this, l, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), d.prototype.writeFloatLE = function(l, h, y) {
    return Y(this, l, h, !0, y);
  }, d.prototype.writeFloatBE = function(l, h, y) {
    return Y(this, l, h, !1, y);
  }, d.prototype.writeDoubleLE = function(l, h, y) {
    return ne(this, l, h, !0, y);
  }, d.prototype.writeDoubleBE = function(l, h, y) {
    return ne(this, l, h, !1, y);
  }, d.prototype.copy = function(l, h, y, A) {
    if (!d.isBuffer(l))
      throw new TypeError("argument should be a Buffer");
    if (y || (y = 0), A || A === 0 || (A = this.length), h >= l.length && (h = l.length), h || (h = 0), A > 0 && A < y && (A = y), A === y || l.length === 0 || this.length === 0)
      return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (y < 0 || y >= this.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("sourceEnd out of bounds");
    A > this.length && (A = this.length), l.length - h < A - y && (A = l.length - h + y);
    const M = A - y;
    return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, y, A) : Uint8Array.prototype.set.call(l, this.subarray(y, A), h), M;
  }, d.prototype.fill = function(l, h, y, A) {
    if (typeof l == "string") {
      if (typeof h == "string" ? (A = h, h = 0, y = this.length) : typeof y == "string" && (A = y, y = this.length), A !== void 0 && typeof A != "string")
        throw new TypeError("encoding must be a string");
      if (typeof A == "string" && !d.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      if (l.length === 1) {
        const x = l.charCodeAt(0);
        (A === "utf8" && x < 128 || A === "latin1") && (l = x);
      }
    } else
      typeof l == "number" ? l &= 255 : typeof l == "boolean" && (l = Number(l));
    if (h < 0 || this.length < h || this.length < y)
      throw new RangeError("Out of range index");
    if (y <= h)
      return this;
    let M;
    if (h >>>= 0, y = y === void 0 ? this.length : y >>> 0, l || (l = 0), typeof l == "number")
      for (M = h; M < y; ++M)
        this[M] = l;
    else {
      const x = d.isBuffer(l) ? l : d.from(l, A), O = x.length;
      if (O === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (M = 0; M < y - h; ++M)
        this[M + h] = x[M % O];
    }
    return this;
  };
  const Q = {};
  function oe(l, h, y) {
    Q[l] = class extends y {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: h.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${l}]`, this.stack, delete this.name;
      }
      get code() {
        return l;
      }
      set code(A) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: A, writable: !0 });
      }
      toString() {
        return `${this.name} [${l}]: ${this.message}`;
      }
    };
  }
  function ae(l) {
    let h = "", y = l.length;
    const A = l[0] === "-" ? 1 : 0;
    for (; y >= A + 4; y -= 3)
      h = `_${l.slice(y - 3, y)}${h}`;
    return `${l.slice(0, y)}${h}`;
  }
  function ce(l, h, y, A, M, x) {
    if (l > y || l < h) {
      const O = typeof h == "bigint" ? "n" : "";
      let G;
      throw G = x > 3 ? h === 0 || h === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (x + 1)}${O}` : `>= -(2${O} ** ${8 * (x + 1) - 1}${O}) and < 2 ** ${8 * (x + 1) - 1}${O}` : `>= ${h}${O} and <= ${y}${O}`, new Q.ERR_OUT_OF_RANGE("value", G, l);
    }
    (function(O, G, X) {
      ue(G, "offset"), O[G] !== void 0 && O[G + X] !== void 0 || le(G, O.length - (X + 1));
    })(A, M, x);
  }
  function ue(l, h) {
    if (typeof l != "number")
      throw new Q.ERR_INVALID_ARG_TYPE(h, "number", l);
  }
  function le(l, h, y) {
    throw Math.floor(l) !== l ? (ue(l, y), new Q.ERR_OUT_OF_RANGE(y || "offset", "an integer", l)) : h < 0 ? new Q.ERR_BUFFER_OUT_OF_BOUNDS() : new Q.ERR_OUT_OF_RANGE(y || "offset", `>= ${y ? 1 : 0} and <= ${h}`, l);
  }
  oe("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
    return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), oe("ERR_INVALID_ARG_TYPE", function(l, h) {
    return `The "${l}" argument must be of type number. Received type ${typeof h}`;
  }, TypeError), oe("ERR_OUT_OF_RANGE", function(l, h, y) {
    let A = `The value of "${l}" is out of range.`, M = y;
    return Number.isInteger(y) && Math.abs(y) > 2 ** 32 ? M = ae(String(y)) : typeof y == "bigint" && (M = String(y), (y > BigInt(2) ** BigInt(32) || y < -(BigInt(2) ** BigInt(32))) && (M = ae(M)), M += "n"), A += ` It must be ${h}. Received ${M}`, A;
  }, RangeError);
  const Se = /[^+/0-9A-Za-z-_]/g;
  function he(l, h) {
    let y;
    h = h || 1 / 0;
    const A = l.length;
    let M = null;
    const x = [];
    for (let O = 0; O < A; ++O) {
      if (y = l.charCodeAt(O), y > 55295 && y < 57344) {
        if (!M) {
          if (y > 56319) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          if (O + 1 === A) {
            (h -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          M = y;
          continue;
        }
        if (y < 56320) {
          (h -= 3) > -1 && x.push(239, 191, 189), M = y;
          continue;
        }
        y = 65536 + (M - 55296 << 10 | y - 56320);
      } else
        M && (h -= 3) > -1 && x.push(239, 191, 189);
      if (M = null, y < 128) {
        if ((h -= 1) < 0)
          break;
        x.push(y);
      } else if (y < 2048) {
        if ((h -= 2) < 0)
          break;
        x.push(y >> 6 | 192, 63 & y | 128);
      } else if (y < 65536) {
        if ((h -= 3) < 0)
          break;
        x.push(y >> 12 | 224, y >> 6 & 63 | 128, 63 & y | 128);
      } else {
        if (!(y < 1114112))
          throw new Error("Invalid code point");
        if ((h -= 4) < 0)
          break;
        x.push(y >> 18 | 240, y >> 12 & 63 | 128, y >> 6 & 63 | 128, 63 & y | 128);
      }
    }
    return x;
  }
  function _e(l) {
    return o.toByteArray(function(h) {
      if ((h = (h = h.split("=")[0]).trim().replace(Se, "")).length < 2)
        return "";
      for (; h.length % 4 != 0; )
        h += "=";
      return h;
    }(l));
  }
  function Le(l, h, y, A) {
    let M;
    for (M = 0; M < A && !(M + y >= h.length || M >= l.length); ++M)
      h[M + y] = l[M];
    return M;
  }
  function se(l, h) {
    return l instanceof h || l != null && l.constructor != null && l.constructor.name != null && l.constructor.name === h.name;
  }
  function we(l) {
    return l != l;
  }
  const We = function() {
    const l = "0123456789abcdef", h = new Array(256);
    for (let y = 0; y < 16; ++y) {
      const A = 16 * y;
      for (let M = 0; M < 16; ++M)
        h[A + M] = l[y] + l[M];
    }
    return h;
  }();
  function de(l) {
    return typeof BigInt > "u" ? ke : l;
  }
  function ke() {
    throw new Error("BigInt not supported");
  }
})(buffer), commonjsGlobal.fetch = window.fetch, npmBrowser.buffer = buffer.Buffer;
const Buffer$2 = npmBrowser.Buffer, leb = leb128$1, Stream = bufferPipe, OP_IMMEDIATES = require$$0$1, _exports = json2wasm.exports = (n) => _exports.generate(n).buffer, LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = { i32: 127, i64: 126, f32: 125, f64: 124, anyFunc: 112, func: 96, block_type: 64 }, EXTERNAL_KIND = _exports.EXTERNAL_KIND = { function: 0, table: 1, memory: 2, global: 3 }, SECTION_IDS = _exports.SECTION_IDS = { custom: 0, type: 1, import: 2, function: 3, table: 4, memory: 5, global: 6, export: 7, start: 8, element: 9, code: 10, data: 11 }, OPCODES = _exports.OPCODES = { unreachable: 0, nop: 1, block: 2, loop: 3, if: 4, else: 5, end: 11, br: 12, br_if: 13, br_table: 14, return: 15, call: 16, call_indirect: 17, drop: 26, select: 27, get_local: 32, set_local: 33, tee_local: 34, get_global: 35, set_global: 36, "i32.load": 40, "i64.load": 41, "f32.load": 42, "f64.load": 43, "i32.load8_s": 44, "i32.load8_u": 45, "i32.load16_s": 46, "i32.load16_u": 47, "i64.load8_s": 48, "i64.load8_u": 49, "i64.load16_s": 50, "i64.load16_u": 51, "i64.load32_s": 52, "i64.load32_u": 53, "i32.store": 54, "i64.store": 55, "f32.store": 56, "f64.store": 57, "i32.store8": 58, "i32.store16": 59, "i64.store8": 60, "i64.store16": 61, "i64.store32": 62, current_memory: 63, grow_memory: 64, "i32.const": 65, "i64.const": 66, "f32.const": 67, "f64.const": 68, "i32.eqz": 69, "i32.eq": 70, "i32.ne": 71, "i32.lt_s": 72, "i32.lt_u": 73, "i32.gt_s": 74, "i32.gt_u": 75, "i32.le_s": 76, "i32.le_u": 77, "i32.ge_s": 78, "i32.ge_u": 79, "i64.eqz": 80, "i64.eq": 81, "i64.ne": 82, "i64.lt_s": 83, "i64.lt_u": 84, "i64.gt_s": 85, "i64.gt_u": 86, "i64.le_s": 87, "i64.le_u": 88, "i64.ge_s": 89, "i64.ge_u": 90, "f32.eq": 91, "f32.ne": 92, "f32.lt": 93, "f32.gt": 94, "f32.le": 95, "f32.ge": 96, "f64.eq": 97, "f64.ne": 98, "f64.lt": 99, "f64.gt": 100, "f64.le": 101, "f64.ge": 102, "i32.clz": 103, "i32.ctz": 104, "i32.popcnt": 105, "i32.add": 106, "i32.sub": 107, "i32.mul": 108, "i32.div_s": 109, "i32.div_u": 110, "i32.rem_s": 111, "i32.rem_u": 112, "i32.and": 113, "i32.or": 114, "i32.xor": 115, "i32.shl": 116, "i32.shr_s": 117, "i32.shr_u": 118, "i32.rotl": 119, "i32.rotr": 120, "i64.clz": 121, "i64.ctz": 122, "i64.popcnt": 123, "i64.add": 124, "i64.sub": 125, "i64.mul": 126, "i64.div_s": 127, "i64.div_u": 128, "i64.rem_s": 129, "i64.rem_u": 130, "i64.and": 131, "i64.or": 132, "i64.xor": 133, "i64.shl": 134, "i64.shr_s": 135, "i64.shr_u": 136, "i64.rotl": 137, "i64.rotr": 138, "f32.abs": 139, "f32.neg": 140, "f32.ceil": 141, "f32.floor": 142, "f32.trunc": 143, "f32.nearest": 144, "f32.sqrt": 145, "f32.add": 146, "f32.sub": 147, "f32.mul": 148, "f32.div": 149, "f32.min": 150, "f32.max": 151, "f32.copysign": 152, "f64.abs": 153, "f64.neg": 154, "f64.ceil": 155, "f64.floor": 156, "f64.trunc": 157, "f64.nearest": 158, "f64.sqrt": 159, "f64.add": 160, "f64.sub": 161, "f64.mul": 162, "f64.div": 163, "f64.min": 164, "f64.max": 165, "f64.copysign": 166, "i32.wrap/i64": 167, "i32.trunc_s/f32": 168, "i32.trunc_u/f32": 169, "i32.trunc_s/f64": 170, "i32.trunc_u/f64": 171, "i64.extend_s/i32": 172, "i64.extend_u/i32": 173, "i64.trunc_s/f32": 174, "i64.trunc_u/f32": 175, "i64.trunc_s/f64": 176, "i64.trunc_u/f64": 177, "f32.convert_s/i32": 178, "f32.convert_u/i32": 179, "f32.convert_s/i64": 180, "f32.convert_u/i64": 181, "f32.demote/f64": 182, "f64.convert_s/i32": 183, "f64.convert_u/i32": 184, "f64.convert_s/i64": 185, "f64.convert_u/i64": 186, "f64.promote/f32": 187, "i32.reinterpret/f32": 188, "i64.reinterpret/f64": 189, "f32.reinterpret/i32": 190, "f64.reinterpret/i64": 191 };
_exports.typeGenerators = { function: (n, o) => {
  leb.unsigned.write(n, o);
}, table: (n, o) => {
  o.write([LANGUAGE_TYPES[n.elementType]]), _exports.typeGenerators.memory(n.limits, o);
}, global: (n, o) => {
  o.write([LANGUAGE_TYPES[n.contentType]]), o.write([n.mutability]);
}, memory: (n, o) => {
  leb.unsigned.write(Number(n.maximum !== void 0), o), leb.unsigned.write(n.intial, o), n.maximum !== void 0 && leb.unsigned.write(n.maximum, o);
}, initExpr: (n, o) => {
  _exports.generateOp(n, o), _exports.generateOp({ name: "end", type: "void" }, o);
} }, _exports.immediataryGenerators = { varuint1: (n, o) => (o.write([n]), o), varuint32: (n, o) => (leb.unsigned.write(n, o), o), varint32: (n, o) => (leb.signed.write(n, o), o), varint64: (n, o) => (leb.signed.write(n, o), o), uint32: (n, o) => (o.write(n), o), uint64: (n, o) => (o.write(n), o), block_type: (n, o) => (o.write([LANGUAGE_TYPES[n]]), o), br_table: (n, o) => {
  leb.unsigned.write(n.targets.length, o);
  for (let a of n.targets)
    leb.unsigned.write(a, o);
  return leb.unsigned.write(n.defaultTarget, o), o;
}, call_indirect: (n, o) => (leb.unsigned.write(n.index, o), o.write([n.reserved]), o), memory_immediate: (n, o) => (leb.unsigned.write(n.flags, o), leb.unsigned.write(n.offset, o), o) };
const entryGenerators = { type: (n, o = new Stream()) => {
  o.write([LANGUAGE_TYPES[n.form]]);
  const a = n.params.length;
  return leb.unsigned.write(a, o), a !== 0 && o.write(n.params.map((u) => LANGUAGE_TYPES[u])), o.write([n.return_type ? 1 : 0]), n.return_type && o.write([LANGUAGE_TYPES[n.return_type]]), o.buffer;
}, import: (n, o = new Stream()) => {
  leb.unsigned.write(n.moduleStr.length, o), o.write(n.moduleStr), leb.unsigned.write(n.fieldStr.length, o), o.write(n.fieldStr), o.write([EXTERNAL_KIND[n.kind]]), _exports.typeGenerators[n.kind](n.type, o);
}, function: (n, o = new Stream()) => (leb.unsigned.write(n, o), o.buffer), table: _exports.typeGenerators.table, global: (n, o = new Stream()) => (_exports.typeGenerators.global(n.type, o), _exports.typeGenerators.initExpr(n.init, o), o), memory: _exports.typeGenerators.memory, export: (n, o = new Stream()) => {
  const a = Buffer$2.from(n.field_str), u = a.length;
  return leb.unsigned.write(u, o), o.write(a), o.write([EXTERNAL_KIND[n.kind]]), leb.unsigned.write(n.index, o), o;
}, element: (n, o = new Stream()) => {
  leb.unsigned.write(n.index, o), _exports.typeGenerators.initExpr(n.offset, o), leb.unsigned.write(n.elements.length, o);
  for (let a of n.elements)
    leb.unsigned.write(a, o);
  return o;
}, code: (n, o = new Stream()) => {
  let a = new Stream();
  leb.unsigned.write(n.locals.length, a);
  for (let u of n.locals)
    leb.unsigned.write(u.count, a), a.write([LANGUAGE_TYPES[u.type]]);
  for (let u of n.code)
    _exports.generateOp(u, a);
  return leb.unsigned.write(a.bytesWrote, o), o.write(a.buffer), o;
}, data: (n, o = new Stream()) => (leb.unsigned.write(n.index, o), _exports.typeGenerators.initExpr(n.offset, o), leb.unsigned.write(n.data.length, o), o.write(n.data), o) };
_exports.entryGenerators = entryGenerators, _exports.generateSection = function(n, o = new Stream()) {
  const a = n.name, u = new Stream();
  if (o.write([SECTION_IDS[a]]), a === "custom")
    leb.unsigned.write(n.sectionName.length, u), u.write(n.sectionName), u.write(n.payload);
  else if (a === "start")
    leb.unsigned.write(n.index, u);
  else {
    leb.unsigned.write(n.entries.length, u);
    for (let c of n.entries)
      entryGenerators[a](c, u);
  }
  return leb.unsigned.write(u.bytesWrote, o), o.write(u.buffer), o;
}, _exports.generate = (n, o = new Stream()) => {
  const [a, ...u] = n;
  _exports.generatePreramble(a, o);
  for (let c of u)
    _exports.generateSection(c, o);
  return o;
}, _exports.generatePreramble = (n, o = new Stream()) => (o.write(n.magic), o.write(n.version), o), _exports.generateOp = (n, o = new Stream()) => {
  let a = n.name;
  n.return_type !== void 0 && (a = n.return_type + "." + a), o.write([OPCODES[a]]);
  const u = OP_IMMEDIATES[n.name === "const" ? n.return_type : n.name];
  return u && _exports.immediataryGenerators[u](n.immediates, o), o;
};
const immediates = require$$0$1;
var text2json = (n) => {
  const o = [], a = n.split(/\s|\n/);
  for (; a.length; ) {
    const u = a.shift(), c = {};
    let [p, d] = u.split(".");
    d === void 0 ? d = p : c.return_type = p, c.name = d;
    const w = immediates[c.name === "const" ? c.return_type : c.name];
    w && (c.immediates = immediataryParser(w, a)), o.push(c);
  }
  return o;
};
function immediataryParser(n, o) {
  const a = {};
  switch (n) {
    case "br_table":
      const u = [];
      for (; ; ) {
        let c = o[0];
        if (isNaN(c))
          break;
        o.shift(), u.push(c);
      }
      return u;
    case "call_indirect":
      return a.index = o.shift(), a.reserved = 0, a;
    case "memory_immediate":
      return a.flags = o.shift(), a.offset = o.shift(), a;
    default:
      return o.shift();
  }
}
const Buffer$1 = npmBrowser.Buffer, leb128 = leb128$1.unsigned, wasm2json = wasm2json$1.exports, Pipe = bufferPipe, SECTIONS = ["custom", "type", "import", "function", "table", "memory", "global", "export", "start", "element", "code", "data"];
var iterator = class {
  constructor(n) {
    this._wasm = n, this._sections = [], this._modified = !1;
  }
  get wasm() {
    return this._modified && (this._wasm = Buffer$1.concat(this._sections.concat(this._pipe.buffer)), this._modified = !1), this._wasm;
  }
  *[Symbol.iterator]() {
    for (this._pipe = new Pipe(this._wasm), this._sections = [this._pipe.read(8)]; !this._pipe.end; ) {
      const n = this._pipe.bytesRead, o = this._pipe.read(1)[0], a = Number(leb128.read(this._pipe)), u = this._pipe.read(a), c = this._pipe.bytesRead, p = this._wasm.slice(n, c), d = this._sections.push(p) - 1;
      yield new Section(o, u, this, d);
    }
  }
  _update(n, o) {
    this._modified = !0, this._sections[n] = o;
  }
};
class Section {
  constructor(o, a, u, c) {
    this._it = u, this._index = c, this.type = SECTIONS[o], this._type = o, this._section = a;
    const p = new Pipe(a);
    this.type !== "custom" && (this.count = Number(leb128.read(p))), this._body = p.buffer;
  }
  toJSON() {
    return wasm2json.sectionParsers[this.type](new Pipe(this._section));
  }
  appendEntries(o) {
    this.count += o.length, this._body = Buffer$1.concat([this._body].concat(o));
    const a = Buffer$1.concat([leb128.encode(this.count), this._body]);
    this._it._update(this._index, Buffer$1.concat([Buffer$1.from([this._type]), leb128.encode(a.length), a]));
  }
}
redstoneWasmJsonToolkit.wasm2json = wasm2json$1.exports, redstoneWasmJsonToolkit.json2wasm = json2wasm.exports, redstoneWasmJsonToolkit.text2json = text2json, redstoneWasmJsonToolkit.Iterator = iterator;
const start = 0, type = { params: { DEFAULT: 0 }, return_type: { DEFAULT: 0 } }, code = { locals: { DEFAULT: 1 }, code: { get_local: 120, set_local: 120, tee_local: 120, get_global: 120, set_global: 120, load8_s: 120, load8_u: 120, load16_s: 120, load16_u: 120, load32_s: 120, load32_u: 120, load: 120, store8: 120, store16: 120, store32: 120, store: 120, grow_memory: 1e4, current_memory: 100, nop: 1, block: 1, loop: 1, if: 1, then: 90, else: 90, br: 90, br_if: 90, br_table: 120, return: 90, call: 90, call_indirect: 1e4, const: 1, add: 45, sub: 45, mul: 45, div_s: 36e3, div_u: 36e3, rem_s: 36e3, rem_u: 36e3, and: 45, or: 45, xor: 45, shl: 67, shr_u: 67, shr_s: 67, rotl: 90, rotr: 90, eq: 45, eqz: 45, ne: 45, lt_s: 45, lt_u: 45, le_s: 45, le_u: 45, gt_s: 45, gt_u: 45, ge_s: 45, ge_u: 45, clz: 45, ctz: 45, popcnt: 45, drop: 120, select: 120, unreachable: 1 } }, data = 0, require$$2 = { start, type, import: 0, code, data };
(function(n) {
  const o = redstoneWasmJsonToolkit, a = o.text2json, u = json2wasm.exports.SECTION_IDS, c = require$$2;
  function p(w, S = {}, k = 0) {
    let B = 0;
    if (k = S.DEFAULT !== void 0 ? S.DEFAULT : 0, Array.isArray(w))
      w.forEach((I) => {
        B += p(I, S);
      });
    else if (typeof w == "object")
      for (const I in w) {
        const C = S[I];
        C && (B += p(w[I], C, k));
      }
    else
      B = S[w] === void 0 ? k : S[w];
    return B;
  }
  function d(w, S, k, B, I) {
    function C(V, Z) {
      return a(`${B}.const ${V} call ${Z}`);
    }
    function P(V, Z) {
      V.name === "call" && V.immediates >= Z && (V.immediates = (++V.immediates).toString());
    }
    const q = /* @__PURE__ */ new Set(["grow_memory", "end", "br", "br_table", "br_if", "if", "else", "return", "loop"]), D = C(0, 0).reduce((V, Z) => V + p(Z.name, S.code), 0);
    let z = w.code.slice(), F = [];
    for (I += p(w.locals, S.local); z.length; ) {
      let V = 0;
      for (; ; ) {
        const Z = z[V++];
        if (P(Z, k), I += p(Z.name, S.code), q.has(Z.name))
          break;
      }
      I !== 0 && (I += D, F = F.concat(C(I, k))), F = F.concat(z.slice(0, V)), z = z.slice(V), I = 0;
    }
    return w.code = F, w;
  }
  n.meterJSON = (w, S) => {
    function k(N, W) {
      return N.find((H) => H.name === W);
    }
    function B(N, W) {
      const H = u[W];
      for (let te in N) {
        const g = N[te], $ = u[g.name];
        if ($ && H < $)
          return void N.splice(te, 0, { name: W, entries: [] });
      }
    }
    let I, C, P = 0, { costTable: q, moduleStr: D, fieldStr: z, meterType: F } = S;
    q || (q = c), D || (D = "metering"), z || (z = "usegas"), F || (F = "i32"), k(w, "type") || B(w, "type"), k(w, "import") || B(w, "import");
    const V = { moduleStr: D, fieldStr: z, kind: "function" }, Z = { form: "func", params: [F] };
    w = w.slice(0);
    for (let N of w)
      switch (N = Object.assign(N), N.name) {
        case "type":
          V.type = N.entries.push(Z) - 1, C = N;
          break;
        case "function":
          I = N;
          break;
        case "import":
          for (const W of N.entries) {
            if (W.moduleStr === D && W.fieldStr === z)
              throw new Error("importing metering function is not allowed");
            W.kind === "function" && P++;
          }
          N.entries.push(V);
          break;
        case "export":
          for (const W of N.entries)
            W.kind === "function" && W.index >= P && W.index++;
          break;
        case "element":
          for (const W of N.entries)
            W.elements = W.elements.map((H) => H >= P ? ++H : H);
          break;
        case "start":
          N.index >= P && N.index++;
          break;
        case "code":
          for (const W in N.entries) {
            const H = N.entries[W], te = I.entries[W], g = p(C.entries[te], q.type);
            d(H, q.code, P, F, g);
          }
      }
    return w;
  }, n.meterWASM = (w, S = {}) => {
    let k = o.wasm2json(w);
    return k = n.meterJSON(k, S), o.json2wasm(k);
  };
})(redstoneWasmMetering);
var wasmBindgenTools = {};
function matchMutClosureDtor(n) {
  return n.match(/(const|var) ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/)[2];
}
Object.defineProperty(wasmBindgenTools, "__esModule", { value: !0 }), wasmBindgenTools.matchMutClosureDtor = void 0, wasmBindgenTools.matchMutClosureDtor = matchMutClosureDtor;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(SourceImpl$1, "__esModule", { value: !0 }), SourceImpl$1.SourceImpl = void 0;
const redstone_wasm_metering_1 = __importDefault$2(redstoneWasmMetering), go_wasm_imports_1 = goWasmImports, fs_1 = __importDefault$2(require$$2$1), wasm_bindgen_tools_1 = wasmBindgenTools, SmartWeaveTags_1$1 = SmartWeaveTags, LoggerFactory_1$3 = LoggerFactory$1, redstone_isomorphic_1$1 = npmBrowser$1, wasmTypeMapping = /* @__PURE__ */ new Map([[1, "assemblyscript"], [2, "rust"], [3, "go"]]);
class SourceImpl {
  constructor(o) {
    this.arweave = o, this.logger = LoggerFactory_1$3.LoggerFactory.INST.create("Source");
  }
  async save(o, a, u = !1) {
    this.logger.debug("Creating new contract source");
    const { src: c, wasmSrcCodeDir: p, wasmGlueCode: d } = o, w = c instanceof redstone_isomorphic_1$1.Buffer ? "wasm" : "js";
    let S, k = null, B = null;
    const I = {}, C = [];
    if (w == "wasm") {
      const z = redstone_wasm_metering_1.default.meterWASM(c, { meterType: "i32" });
      C.push(z);
      const F = await WebAssembly.compile(c), V = WebAssembly.Module.imports(F);
      let Z;
      if (this.isGoModule(V)) {
        const W = new go_wasm_imports_1.Go(null), H = new WebAssembly.Instance(F, W.importObject);
        W.run(H), Z = W.exports.lang(), B = W.exports.version();
      } else {
        const W = await WebAssembly.instantiate(c, dummyImports(V));
        if (!W.instance.exports.lang)
          throw new Error('No info about source type in wasm binary. Did you forget to export "lang" function?');
        if (Z = W.instance.exports.lang(), B = W.instance.exports.version(), !wasmTypeMapping.has(Z))
          throw new Error(`Unknown wasm source type ${Z}`);
      }
      if (k = wasmTypeMapping.get(Z), p == null)
        throw new Error("No path to original wasm contract source code");
      const N = await this.zipContents(p);
      if (C.push(N), k == "rust") {
        if (!d)
          throw new Error("No path to generated wasm-bindgen js code");
        const W = fs_1.default.readFileSync(d, "utf-8"), H = (0, wasm_bindgen_tools_1.matchMutClosureDtor)(W);
        I.dtor = parseInt(H), C.push(redstone_isomorphic_1$1.Buffer.from(W));
      }
    }
    const P = w == "wasm" ? this.joinBuffers(C) : c;
    S = typeof a == "function" ? await this.arweave.createTransaction({ data: P }) : await this.arweave.createTransaction({ data: P }, a), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_NAME, "SmartWeaveContractSource"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_VERSION, "0.3.0"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.SDK, "Warp"), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.CONTENT_TYPE, w == "js" ? "application/javascript" : "application/wasm"), w == "wasm" && (S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG, k), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG_VERSION, B), S.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_META, JSON.stringify(I))), typeof a == "function" ? await a(S) : await this.arweave.transactions.sign(S, a), this.logger.debug("Posting transaction with source");
    let q, D = !0;
    if (u || (q = await this.arweave.transactions.post(S), D = q.status === 200 || q.status === 208), D)
      return S;
    throw new Error(`Unable to write Contract Source. Arweave responded with status ${q.status}: ${q.statusText}`);
  }
  isGoModule(o) {
    return o.some((a) => a.module == "env" && a.name.startsWith("syscall/js"));
  }
  joinBuffers(o) {
    const a = o.length, u = [];
    return u.push(redstone_isomorphic_1$1.Buffer.from(a.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|")), o.forEach((c) => {
      u.push(redstone_isomorphic_1$1.Buffer.from(c.length.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|"));
    }), u.push(...o), u.reduce((c, p) => redstone_isomorphic_1$1.Buffer.concat([c, p]));
  }
  async zipContents(o) {
    const a = require$$2$1, u = new require$$2$1.WritableStreamBuffer({ initialSize: 1024e3, incrementAmount: 1024e3 }), c = a("zip", { zlib: { level: 9 } });
    return c.on("error", function(p) {
      throw p;
    }), c.pipe(u), c.directory(o.toString(), o.toString()), await c.finalize(), u.end(), u.getContents();
  }
}
function dummyImports(n) {
  const o = {};
  return n.forEach((a) => {
    Object.prototype.hasOwnProperty.call(o, a.module) || (o[a.module] = {}), o[a.module][a.name] = function() {
    };
  }), o;
}
var hasRequiredDefaultCreateContract;
function requireDefaultCreateContract() {
  if (hasRequiredDefaultCreateContract)
    return DefaultCreateContract;
  hasRequiredDefaultCreateContract = 1, Object.defineProperty(DefaultCreateContract, "__esModule", { value: !0 }), DefaultCreateContract.DefaultCreateContract = void 0;
  const n = SmartWeaveTags, o = requireWarpFactory(), a = LoggerFactory$1, u = SourceImpl$1;
  return DefaultCreateContract.DefaultCreateContract = class {
    constructor(c, p) {
      this.arweave = c, this.warp = p, this.logger = a.LoggerFactory.INST.create("DefaultCreateContract"), this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
    }
    async deploy(c, p) {
      const { wallet: d, initState: w, tags: S, transfer: k, data: B } = c, I = p == null ? this.warp.definitionLoader.type() == "warp" : !p, C = new u.SourceImpl(this.arweave), P = await C.save(c, d, I);
      return this.logger.debug("Creating new contract"), await this.deployFromSourceTx({ srcTxId: P.id, wallet: d, initState: w, tags: S, transfer: k, data: B }, !I, P);
    }
    async deployFromSourceTx(c, p, d = null) {
      this.logger.debug("Creating new contract from src tx");
      const { wallet: w, srcTxId: S, initState: k, tags: B, transfer: I, data: C } = c, P = p == null ? this.warp.definitionLoader.type() == "warp" : !p;
      let q, D, z = await this.arweave.createTransaction({ data: (C == null ? void 0 : C.body) || k }, w);
      if (+(I == null ? void 0 : I.winstonQty) > 0 && I.target.length && (this.logger.debug("Creating additional transaction with AR transfer", I), z = await this.arweave.createTransaction({ data: (C == null ? void 0 : C.body) || k, target: I.target, quantity: I.winstonQty }, w)), B == null ? void 0 : B.length)
        for (const F of B)
          z.addTag(F.name.toString(), F.value.toString());
      if (z.addTag(n.SmartWeaveTags.APP_NAME, "SmartWeaveContract"), z.addTag(n.SmartWeaveTags.APP_VERSION, "0.3.0"), z.addTag(n.SmartWeaveTags.CONTRACT_SRC_TX_ID, S), z.addTag(n.SmartWeaveTags.SDK, "RedStone"), C ? (z.addTag(n.SmartWeaveTags.CONTENT_TYPE, C["Content-Type"]), z.addTag(n.SmartWeaveTags.INIT_STATE, k)) : z.addTag(n.SmartWeaveTags.CONTENT_TYPE, "application/json"), await this.arweave.transactions.sign(z, w), P) {
        const F = await this.post(z, d);
        this.logger.debug(F), q = !0;
      } else
        D = await this.arweave.transactions.post(z), q = D.status === 200 || D.status === 208;
      if (q)
        return { contractTxId: z.id, srcTxId: S };
      throw new Error(`Unable to write Contract. Arweave responded with status ${D.status}: ${D.statusText}`);
    }
    async post(c, p = null) {
      let d = { contractTx: c };
      p && (d = { ...d, srcTx: p });
      const w = await fetch(`${o.WARP_GW_URL}/gateway/contracts/deploy`, { method: "POST", body: JSON.stringify(d), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } });
      if (w.ok)
        return w.json();
      throw new Error(`Error while posting contract. Sequencer responded with status ${w.status} ${w.statusText}`);
    }
  }, DefaultCreateContract;
}
SourceImpl$1.SourceImpl = SourceImpl;
var HandlerBasedContract = {}, ContractCallRecord$1 = {};
Object.defineProperty(ContractCallRecord$1, "__esModule", { value: !0 }), ContractCallRecord$1.InteractionOutput = ContractCallRecord$1.InteractionInput = ContractCallRecord$1.InteractionCall = ContractCallRecord$1.ContractCallRecord = void 0;
const utils_1$1 = utils$n;
class ContractCallRecord {
  constructor(o, a, u = null) {
    this.contractTxId = o, this.depth = a, this.innerCallType = u, this.interactions = {}, this.id = (0, utils_1$1.isomorphicRandomUUID)();
  }
  addInteractionData(o) {
    const { interaction: a, interactionTx: u } = o, c = InteractionCall.create(new InteractionInput(u.id, u.sortKey, u.block.height, u.block.timestamp, a == null ? void 0 : a.caller, a == null ? void 0 : a.input.function, a == null ? void 0 : a.input, u.dry, {}));
    return this.interactions[u.id] = c, c;
  }
  getInteraction(o) {
    return this.interactions[o];
  }
  print() {
    return JSON.stringify(this, null, 2);
  }
}
ContractCallRecord$1.ContractCallRecord = ContractCallRecord;
class InteractionCall {
  constructor(o) {
    this.interactionInput = o;
  }
  static create(o) {
    return new InteractionCall(o);
  }
  update(o) {
    this.interactionOutput = o;
  }
}
ContractCallRecord$1.InteractionCall = InteractionCall;
class InteractionInput {
  constructor(o, a, u, c, p, d, w, S, k = {}) {
    this.txId = o, this.sortKey = a, this.blockHeight = u, this.blockTimestamp = c, this.caller = p, this.functionName = d, this.functionArguments = w, this.dryWrite = S, this.foreignContractCalls = k;
  }
}
ContractCallRecord$1.InteractionInput = InteractionInput;
class InteractionOutput {
  constructor(o, a, u, c, p = "", d) {
    this.cacheHit = o, this.outputState = a, this.executionTime = u, this.valid = c, this.errorMessage = p, this.gasUsed = d;
  }
}
ContractCallRecord$1.InteractionOutput = InteractionOutput;
var createInteractionTx$1 = {};
Object.defineProperty(createInteractionTx$1, "__esModule", { value: !0 }), createInteractionTx$1.unpackTags = createInteractionTx$1.createDummyTx = createInteractionTx$1.createInteractionTx = void 0;
const SmartWeaveTags_1 = SmartWeaveTags;
async function createInteractionTx(n, o, a, u, c, p = "", d = "0", w = !1, S) {
  const k = { data: Math.random().toString().slice(-4) };
  p && p.length && (k.target = p.toString(), d && +d > 0 && (k.quantity = d.toString())), w && (k.reward = "72600854", k.last_tx = "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO"), S && S.length && (k.reward = S);
  const B = await n.createTransaction(k);
  if (!u)
    throw new Error(`Input should be a truthy value: ${JSON.stringify(u)}`);
  if (c && c.length)
    for (const I of c)
      B.addTag(I.name.toString(), I.value.toString());
  return B.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, "SmartWeaveAction"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, "0.3.0"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, "Warp"), B.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID, a), B.addTag(SmartWeaveTags_1.SmartWeaveTags.INPUT, JSON.stringify(u)), o && await o(B), B;
}
function createDummyTx(n, o, a) {
  const u = unpackTags(n);
  return { id: n.id, owner: { address: o, key: "" }, recipient: n.target, tags: u, fee: { winston: n.reward, ar: "" }, quantity: { winston: n.quantity, ar: "" }, block: { id: a.indep_hash, height: a.height, timestamp: a.timestamp, previous: null }, dry: !0, anchor: null, signature: null, data: null, parent: null, bundledIn: null };
}
function unpackTags(n) {
  const o = n.get("tags"), a = [];
  for (const u of o)
    try {
      const c = u.get("name", { decode: !0, string: !0 }), p = u.get("value", { decode: !0, string: !0 });
      a.push({ name: c, value: p });
    } catch {
    }
  return a;
}
createInteractionTx$1.createInteractionTx = createInteractionTx, createInteractionTx$1.createDummyTx = createDummyTx, createInteractionTx$1.unpackTags = unpackTags;
var CreateContract = {};
Object.defineProperty(CreateContract, "__esModule", { value: !0 }), CreateContract.emptyTransfer = void 0, CreateContract.emptyTransfer = { target: "", winstonQty: "0" };
var InnerWritesEvaluator$1 = {};
Object.defineProperty(InnerWritesEvaluator$1, "__esModule", { value: !0 }), InnerWritesEvaluator$1.InnerWritesEvaluator = void 0;
class InnerWritesEvaluator {
  eval(o) {
    const a = [];
    return Object.keys(o.interactions).forEach((u) => {
      const c = o.interactions[u];
      this.evalForeignCalls(o.contractTxId, c, a);
    }), a;
  }
  evalForeignCalls(o, a, u) {
    Object.keys(a.interactionInput.foreignContractCalls).forEach((c) => {
      const p = a.interactionInput.foreignContractCalls[c];
      Object.keys(p.interactions).forEach((d) => {
        const w = p.interactions[d];
        w.interactionInput.dryWrite && !u.includes(p.contractTxId) && o !== p.contractTxId && u.push(p.contractTxId), this.evalForeignCalls(o, w, u);
      });
    });
  }
}
InnerWritesEvaluator$1.InnerWritesEvaluator = InnerWritesEvaluator;
var vrf = {}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(vrf, "__esModule", { value: !0 }), vrf.generateMockVrf = void 0;
const elliptic_1 = __importDefault$1(elliptic$1), vrf_js_1 = vrfJs, utils_1 = utils$n, EC = new elliptic_1.default.ec("secp256k1"), key = EC.genKeyPair(), pubKeyS = key.getPublic(!0, "hex");
function generateMockVrf(n, o) {
  const a = o.utils.stringToBuffer(n), [u, c] = (0, vrf_js_1.Evaluate)(key.getPrivate().toArray(), a);
  return { index: o.utils.bufferTob64Url(u), proof: o.utils.bufferTob64Url(c), bigint: (0, utils_1.bufToBn)(u).toString(), pubkey: pubKeyS };
}
var hasRequiredHandlerBasedContract;
function requireHandlerBasedContract() {
  if (hasRequiredHandlerBasedContract)
    return HandlerBasedContract;
  hasRequiredHandlerBasedContract = 1;
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(N, W, H, te) {
    te === void 0 && (te = H);
    var g = Object.getOwnPropertyDescriptor(W, H);
    g && !("get" in g ? !W.__esModule : g.writable || g.configurable) || (g = { enumerable: !0, get: function() {
      return W[H];
    } }), Object.defineProperty(N, te, g);
  } : function(N, W, H, te) {
    te === void 0 && (te = H), N[te] = W[H];
  }), o = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(N, W) {
    Object.defineProperty(N, "default", { enumerable: !0, value: W });
  } : function(N, W) {
    N.default = W;
  }), a = commonjsGlobal && commonjsGlobal.__importStar || function(N) {
    if (N && N.__esModule)
      return N;
    var W = {};
    if (N != null)
      for (var H in N)
        H !== "default" && Object.prototype.hasOwnProperty.call(N, H) && n(W, N, H);
    return o(W, N), W;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(HandlerBasedContract, "__esModule", { value: !0 }), HandlerBasedContract.HandlerBasedContract = void 0;
  const c = u(safeStableStringify.exports), p = a(require$$2$1), d = ContractCallRecord$1, w = LexicographicalInteractionsSorter, S = StateEvaluator, k = SmartWeaveTags, B = createInteractionTx$1, I = Benchmark$1, C = LoggerFactory$1, P = Evolve$1, q = requireArweaveWrapper(), D = utils$n, z = CreateContract, F = SourceImpl$1, V = InnerWritesEvaluator$1, Z = vrf;
  return HandlerBasedContract.HandlerBasedContract = class {
    constructor(N, W, H = null, te = null) {
      var g, $;
      if (this._contractTxId = N, this.warp = W, this._parentContract = H, this._innerCallData = te, this.logger = C.LoggerFactory.INST.create("HandlerBasedContract"), this._evaluationOptions = new S.DefaultEvaluationOptions(), this._innerWritesEvaluator = new V.InnerWritesEvaluator(), this._benchmarkStats = null, this.waitForConfirmation = this.waitForConfirmation.bind(this), this._arweaveWrapper = new q.ArweaveWrapper(W.arweave), this._sorter = new w.LexicographicalInteractionsSorter(W.arweave), H != null) {
        this._evaluationOptions = H.evaluationOptions(), this._callDepth = H.callDepth() + 1;
        const _ = H.getCallStack().getInteraction(te.callingInteraction.id);
        if (this._callDepth > this._evaluationOptions.maxCallDepth)
          throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(_.interactionInput)}`);
        if (this.logger.debug("Calling interaction", { id: te.callingInteraction.id, sortKey: te.callingInteraction.sortKey, type: te.callType }), (($ = (g = _.interactionInput) === null || g === void 0 ? void 0 : g.foreignContractCalls[N]) === null || $ === void 0 ? void 0 : $.innerCallType) === "write" && te.callType === "read")
          throw new Error("Calling a readContractState after performing an inner write is wrong - instead use a state from the result of an internal write.");
        const b = new d.ContractCallRecord(N, this._callDepth, te == null ? void 0 : te.callType);
        _.interactionInput.foreignContractCalls[N] = b, this._callStack = b, this._rootSortKey = H.rootSortKey;
      } else
        this._callDepth = 0, this._callStack = new d.ContractCallRecord(N, 0), this._rootSortKey = null;
      this.getCallStack = this.getCallStack.bind(this);
    }
    async readState(N, W, H) {
      var te, g, $;
      this.logger.info("Read state for", { contractTxId: this._contractTxId, currentTx: W, sortKeyOrBlockHeight: N });
      const _ = I.Benchmark.measure();
      if (this.maybeResetRootContract(), this._parentContract != null && N == null)
        throw new Error("SortKey MUST be always set for non-root contract calls");
      const { stateEvaluator: b } = this.warp, m = typeof N == "number" ? this._sorter.generateLastSortKey(N) : N, v = await this.createExecutionContext(this._contractTxId, m, !1, H);
      this.logger.info("Execution Context", { srcTxId: (te = v.contractDefinition) === null || te === void 0 ? void 0 : te.srcTxId, missingInteractions: (g = v.sortedInteractions) === null || g === void 0 ? void 0 : g.length, cachedSortKey: ($ = v.cachedState) === null || $ === void 0 ? void 0 : $.sortKey }), _.stop();
      const E = I.Benchmark.measure(), T = await b.eval(v, W || []);
      E.stop();
      const j = _.elapsed(!0) + E.elapsed(!0);
      return this._benchmarkStats = { gatewayCommunication: _.elapsed(!0), stateEvaluation: E.elapsed(!0), total: j }, this.logger.info("Benchmark", { "Gateway communication  ": _.elapsed(), "Contract evaluation    ": E.elapsed(), "Total:                 ": `${j.toFixed(0)}ms` }), T;
    }
    async viewState(N, W = [], H = z.emptyTransfer) {
      return this.logger.info("View state for", this._contractTxId), await this.callContract(N, void 0, void 0, W, H);
    }
    async viewStateForTx(N, W) {
      return this.logger.info(`View state for ${this._contractTxId}`, W), await this.callContractForTx(N, W);
    }
    async dryWrite(N, W, H, te) {
      return this.logger.info("Dry-write for", this._contractTxId), await this.callContract(N, W, void 0, H, te);
    }
    async dryWriteFromTx(N, W, H) {
      return this.logger.info(`Dry-write from transaction ${W.id} for ${this._contractTxId}`), await this.callContractForTx(N, W, H || []);
    }
    async writeInteraction(N, W) {
      if (this.logger.info("Write interaction", { input: N, options: W }), !this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: H, interactionsLoader: te, environment: g } = this.warp, $ = (W == null ? void 0 : W.tags) || [], _ = (W == null ? void 0 : W.transfer) || z.emptyTransfer, b = (W == null ? void 0 : W.strict) === !0, m = (W == null ? void 0 : W.vrf) === !0, v = (W == null ? void 0 : W.disableBundling) === !0, E = W == null ? void 0 : W.reward, T = te.type() == "warp" && !v;
      if (T && _.target != z.emptyTransfer.target && _.winstonQty != z.emptyTransfer.winstonQty)
        throw new Error("Ar Transfers are not allowed for bundled interactions");
      if (m && !T && g === "mainnet")
        throw new Error("Vrf generation is only available for bundle interaction");
      if (T)
        return await this.bundleInteraction(N, { tags: $, strict: b, vrf: m });
      {
        const j = await this.createInteraction(N, $, _, b, !1, m && g !== "mainnet", E), L = await H.transactions.post(j);
        if (L.status !== 200)
          return this.logger.error("Error while posting transaction", L), null;
        if (this._evaluationOptions.waitForConfirmation) {
          this.logger.info("Waiting for confirmation of", j.id);
          const J = I.Benchmark.measure();
          await this.waitForConfirmation(j.id), this.logger.info("Transaction confirmed after", J.elapsed());
        }
        return this.warp.environment == "local" && this._evaluationOptions.mineArLocalBlocks && await this.warp.testing.mineBlock(), { originalTxId: j.id };
      }
    }
    async bundleInteraction(N, W) {
      this.logger.info("Bundle interaction input", N);
      const H = await this.createInteraction(N, W.tags, z.emptyTransfer, W.strict, !0, W.vrf);
      return { bundlrResponse: await fetch(`${this._evaluationOptions.bundlerUrl}gateway/sequencer/register`, { method: "POST", body: JSON.stringify(H), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((g) => (this.logger.debug(g), g.ok ? g.json() : Promise.reject(g))).catch((g) => {
        var $;
        throw this.logger.error(g), !(($ = g.body) === null || $ === void 0) && $.message && this.logger.error(g.body.message), new Error(`Unable to bundle interaction: ${JSON.stringify(g)}`);
      }), originalTxId: H.id };
    }
    async createInteraction(N, W, H, te, g = !1, $ = !1, _) {
      if (this._evaluationOptions.internalWrites) {
        const b = await this.callContract(N, void 0, void 0, W, H, te, $);
        if (te && b.type !== "ok")
          throw Error(`Cannot create interaction: ${b.errorMessage}`);
        const m = this.getCallStack(), v = this._innerWritesEvaluator.eval(m);
        this.logger.debug("Input", N), this.logger.debug("Callstack", m.print()), v.forEach((E) => {
          W.push({ name: k.SmartWeaveTags.INTERACT_WRITE, value: E });
        }), this.logger.debug("Tags with inner calls", W);
      } else if (te) {
        const b = await this.callContract(N, void 0, void 0, W, H, te, $);
        if (b.type !== "ok")
          throw Error(`Cannot create interaction: ${b.errorMessage}`);
      }
      return $ && W.push({ name: k.SmartWeaveTags.REQUEST_VRF, value: "true" }), await (0, B.createInteractionTx)(this.warp.arweave, this.signer, this._contractTxId, N, W, H.target, H.winstonQty, g, _);
    }
    txId() {
      return this._contractTxId;
    }
    getCallStack() {
      return this._callStack;
    }
    connect(N) {
      return this.signer = typeof N == "function" ? N : async (W) => {
        await this.warp.arweave.transactions.sign(W, N);
      }, this;
    }
    setEvaluationOptions(N) {
      return this._evaluationOptions = { ...this._evaluationOptions, ...N }, this;
    }
    async waitForConfirmation(N) {
      const { arweave: W } = this.warp, H = await W.transactions.getStatus(N);
      if (H.confirmed !== null)
        return this.logger.info(`Transaction ${N} confirmed`, H), H;
      this.logger.info(`Transaction ${N} not yet confirmed. Waiting another 20 seconds before next check.`), await (0, D.sleep)(2e4), await this.waitForConfirmation(N);
    }
    async createExecutionContext(N, W, H = !1, te) {
      var g;
      const { definitionLoader: $, interactionsLoader: _, executorFactory: b, stateEvaluator: m } = this.warp, v = I.Benchmark.measure(), E = await m.latestAvailableState(N, W);
      this.logger.debug("cache lookup", v.elapsed()), v.reset();
      const T = P.Evolve.evolvedSrcTxId((g = E == null ? void 0 : E.cachedValue) === null || g === void 0 ? void 0 : g.state);
      let j, L, J;
      return this.logger.debug("Cached state", E, W), E && E.sortKey == W ? (this.logger.debug("State fully cached, not loading interactions."), (H || T) && (L = await $.load(N, T), j = await b.create(L, this._evaluationOptions))) : ([L, J] = await Promise.all([$.load(N, T), te ? Promise.resolve(te) : await _.load(N, E == null ? void 0 : E.sortKey, this.getToSortKey(W), this._evaluationOptions)]), E != null && E.sortKey && (J = J.filter((Y) => Y.sortKey.localeCompare(E == null ? void 0 : E.sortKey) > 0)), W && (J = J.filter((Y) => Y.sortKey.localeCompare(W) <= 0)), this.logger.debug("contract and interactions load", v.elapsed()), this._parentContract == null && J.length && (this._rootSortKey = J[J.length - 1].sortKey), j = await b.create(L, this._evaluationOptions)), { warp: this.warp, contract: this, contractDefinition: L, sortedInteractions: J, evaluationOptions: this._evaluationOptions, handler: j, cachedState: E, requestedSortKey: W };
    }
    getToSortKey(N) {
      var W;
      return !((W = this._parentContract) === null || W === void 0) && W.rootSortKey ? N ? this._parentContract.rootSortKey.localeCompare(N) > 0 ? this._parentContract.rootSortKey : N : this._parentContract.rootSortKey : N;
    }
    async createExecutionContextFromTx(N, W) {
      const H = W.owner.address, te = W.sortKey;
      return { ...await this.createExecutionContext(N, te, !0), caller: H };
    }
    maybeResetRootContract() {
      this._parentContract == null && (this.logger.debug("Clearing call stack for the root contract"), this._callStack = new d.ContractCallRecord(this.txId(), 0), this._rootSortKey = null, this.warp.interactionsLoader.clearCache());
    }
    async callContract(N, W, H, te = [], g = z.emptyTransfer, $ = !1, _ = !1) {
      this.logger.info("Call contract input", N), this.maybeResetRootContract(), this.signer || this.logger.warn("Wallet not set.");
      const { arweave: b, stateEvaluator: m } = this.warp;
      let v = await this.createExecutionContext(this._contractTxId, H, !0);
      const E = this.warp.environment == "mainnet" ? await this._arweaveWrapper.warpGwBlock() : await b.blocks.getCurrent();
      let T;
      if (W)
        T = W;
      else if (this.signer) {
        const Q = await b.createTransaction({ data: Math.random().toString().slice(-4), reward: "72600854", last_tx: "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO" });
        await this.signer(Q), T = await b.wallets.ownerToAddress(Q.owner);
      } else
        T = "";
      this.logger.info("effectiveCaller", T), v = { ...v, caller: T };
      const j = await m.eval(v, []);
      this.logger.info("Current state", j.cachedValue.state);
      const L = { input: N, caller: v.caller };
      this.logger.debug("interaction", L);
      const J = await (0, B.createInteractionTx)(b, this.signer, this._contractTxId, N, te, g.target, g.winstonQty, !0), Y = (0, B.createDummyTx)(J, v.caller, E);
      this.logger.debug("Creating sortKey for", { blockId: Y.block.id, id: Y.id, height: Y.block.height }), Y.sortKey = await this._sorter.createSortKey(Y.block.id, Y.id, Y.block.height, !0), Y.strict = $, _ && (Y.vrf = (0, Z.generateMockVrf)(Y.sortKey, b));
      const ne = await this.evalInteraction({ interaction: L, interactionTx: Y, currentTx: [] }, v, j.cachedValue);
      return ne.type !== "ok" && this.logger.fatal("Error while interacting with contract", { type: ne.type, error: ne.errorMessage }), ne;
    }
    async callContractForTx(N, W, H) {
      this.maybeResetRootContract();
      const te = await this.createExecutionContextFromTx(this._contractTxId, W), g = await this.warp.stateEvaluator.eval(te, H);
      this.logger.debug("callContractForTx - evalStateResult", { result: g.cachedValue.state, txId: this._contractTxId });
      const $ = { interaction: { input: N, caller: this._parentContract.txId() }, interactionTx: W, currentTx: H }, _ = await this.evalInteraction($, te, g.cachedValue);
      return _.originalValidity = g.cachedValue.validity, _.originalErrorMessages = g.cachedValue.errorMessages, _;
    }
    async evalInteraction(N, W, H) {
      const te = this.getCallStack().addInteractionData(N), g = I.Benchmark.measure(), $ = await W.handler.handle(W, H, N);
      return te.update({ cacheHit: !1, outputState: this._evaluationOptions.stackTrace.saveState ? $.state : void 0, executionTime: g.elapsed(!0), valid: $.type === "ok", errorMessage: $.errorMessage, gasUsed: $.gasUsed }), $;
    }
    parent() {
      return this._parentContract;
    }
    callDepth() {
      return this._callDepth;
    }
    evaluationOptions() {
      return this._evaluationOptions;
    }
    lastReadStateStats() {
      return this._benchmarkStats;
    }
    stateHash(N) {
      const W = (0, c.default)(N), H = p.createHash("sha256");
      return H.update(W), H.digest("hex");
    }
    async syncState(N, W) {
      const { stateEvaluator: H } = this.warp, te = await fetch(`${N}?${new URLSearchParams({ id: this._contractTxId, ...W })}`).then((g) => g.ok ? g.json() : Promise.reject(g)).catch((g) => {
        var $, _;
        throw !(($ = g.body) === null || $ === void 0) && $.message && this.logger.error(g.body.message), new Error(`Unable to retrieve state. ${g.status}: ${(_ = g.body) === null || _ === void 0 ? void 0 : _.message}`);
      });
      return await H.syncState(this._contractTxId, te.sortKey, te.state, te.validity), this;
    }
    async evolve(N, W) {
      return await this.writeInteraction({ function: "evolve", value: N }, W);
    }
    async save(N) {
      if (!this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: W } = this.warp;
      return (await new F.SourceImpl(W).save(N, this.signer)).id;
    }
    get rootSortKey() {
      return this._rootSortKey;
    }
  }, HandlerBasedContract;
}
vrf.generateMockVrf = generateMockVrf;
var PstContractImpl = {}, hasRequiredPstContractImpl;
function requirePstContractImpl() {
  if (hasRequiredPstContractImpl)
    return PstContractImpl;
  hasRequiredPstContractImpl = 1, Object.defineProperty(PstContractImpl, "__esModule", { value: !0 }), PstContractImpl.PstContractImpl = void 0;
  const n = requireHandlerBasedContract();
  class o extends n.HandlerBasedContract {
    async currentBalance(u) {
      const c = await this.viewState({ function: "balance", target: u });
      if (c.type !== "ok")
        throw Error(c.errorMessage);
      return c.result;
    }
    async currentState() {
      return (await super.readState()).cachedValue.state;
    }
    async transfer(u, c) {
      return await this.writeInteraction({ function: "transfer", ...u }, c);
    }
  }
  return PstContractImpl.PstContractImpl = o, PstContractImpl;
}
var MigrationTool$1 = {}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(MigrationTool$1, "__esModule", { value: !0 }), MigrationTool$1.MigrationTool = void 0;
const LexicographicalInteractionsSorter_1 = LexicographicalInteractionsSorter, StateEvaluator_1 = StateEvaluator, knex_1 = __importDefault(require$$2$1), LoggerFactory_1$2 = LoggerFactory$1;
class MigrationTool {
  constructor(o, a) {
    this.arweave = o, this.levelDb = a, this.logger = LoggerFactory_1$2.LoggerFactory.INST.create("MigrationTool"), this.sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(o);
  }
  async migrateSqlite(o) {
    this.logger.info(`Migrating from sqlite ${o} to leveldb.`);
    const a = (0, knex_1.default)({ client: "sqlite3", connection: { filename: o }, useNullAsDefault: !0 }), u = await a.select(["contract_id", "height", "state"]).from("states").max("height").groupBy(["contract_id"]);
    this.logger.info(`Migrating ${u == null ? void 0 : u.length} contracts' state`);
    const c = [];
    for (const p of u) {
      const d = p.contract_id, w = p.height, S = JSON.parse(p.state), k = this.sorter.generateLastSortKey(parseInt(w));
      this.logger.debug(`Migrating ${d} at height ${w}: ${k}`), await this.levelDb.put({ contractTxId: d, sortKey: k }, new StateEvaluator_1.EvalStateResult(S.state, S.validity, {})), c.push({ contractTxId: d, height: w, sortKey: k });
    }
    return this.logger.info("Migration done."), c;
  }
}
MigrationTool$1.MigrationTool = MigrationTool;
var Testing$1 = {};
Object.defineProperty(Testing$1, "__esModule", { value: !0 }), Testing$1.Testing = void 0;
class Testing {
  constructor(o) {
    this.arweave = o;
  }
  async mineBlock() {
    this.validateEnv(), await this.arweave.api.get("mine");
  }
  async generateWallet() {
    this.validateEnv();
    const o = await this.arweave.wallets.generate();
    return await this.addFunds(o), { jwk: o, address: await this.arweave.wallets.jwkToAddress(o) };
  }
  async addFunds(o) {
    const a = await this.arweave.wallets.getAddress(o);
    await this.arweave.api.get(`/mint/${a}/1000000000000000`);
  }
  validateEnv() {
    if (this.arweave.api.getConfig().host.includes("arweave"))
      throw new Error("Testing features are not available in a non testing environment");
  }
}
Testing$1.Testing = Testing;
var WarpBuilder = {}, DebuggableExecutorFactor = {};
Object.defineProperty(DebuggableExecutorFactor, "__esModule", { value: !0 }), DebuggableExecutorFactor.DebuggableExecutorFactory = void 0;
class DebuggableExecutorFactory {
  constructor(o, a) {
    this.baseImplementation = o, this.sourceCode = a;
  }
  async create(o, a) {
    return Object.prototype.hasOwnProperty.call(this.sourceCode, o.txId) && (o = { ...o, src: this.sourceCode[o.txId] }), await this.baseImplementation.create(o, a);
  }
}
DebuggableExecutorFactor.DebuggableExecutorFactory = DebuggableExecutorFactory;
var ArweaveGatewayInteractionsLoader = {}, hasRequiredArweaveGatewayInteractionsLoader;
function requireArweaveGatewayInteractionsLoader() {
  if (hasRequiredArweaveGatewayInteractionsLoader)
    return ArweaveGatewayInteractionsLoader;
  hasRequiredArweaveGatewayInteractionsLoader = 1, Object.defineProperty(ArweaveGatewayInteractionsLoader, "__esModule", { value: !0 }), ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = ArweaveGatewayInteractionsLoader.bundledTxsFilter = void 0;
  const n = SmartWeaveTags, o = Benchmark$1, a = LoggerFactory$1, u = requireArweaveWrapper(), c = utils$n, p = LexicographicalInteractionsSorter, d = vrf;
  function w(k) {
    var B, I;
    return !(!((B = k.node.parent) === null || B === void 0) && B.id) && !(!((I = k.node.bundledIn) === null || I === void 0) && I.id);
  }
  ArweaveGatewayInteractionsLoader.bundledTxsFilter = w;
  class S {
    constructor(B, I) {
      this.arweave = B, this.environment = I, this.logger = a.LoggerFactory.INST.create("ArweaveGatewayInteractionsLoader"), this.arweaveWrapper = new u.ArweaveWrapper(B), this.sorter = new p.LexicographicalInteractionsSorter(B);
    }
    async load(B, I, C, P) {
      this.logger.debug("Loading interactions for", { contractId: B, fromSortKey: I, toSortKey: C });
      const q = this.sorter.extractBlockHeight(I), D = this.sorter.extractBlockHeight(C), z = { tags: [{ name: n.SmartWeaveTags.APP_NAME, values: ["SmartWeaveAction"] }, { name: n.SmartWeaveTags.CONTRACT_TX_ID, values: [B] }], blockFilter: { min: q, max: D }, first: 100 }, F = o.Benchmark.measure();
      let V = await this.loadPages(z);
      if (F.stop(), P.internalWrites) {
        const W = { tags: [{ name: n.SmartWeaveTags.INTERACT_WRITE, values: [B] }], blockFilter: { min: q, max: D }, first: 100 }, H = await this.loadPages(W);
        this.logger.debug("Inner writes interactions length:", H.length), V = V.concat(H);
      }
      V = V.filter((W) => W.node.block && W.node.block.id && W.node.block.height);
      let Z = await this.sorter.sort(V);
      I && C ? Z = Z.filter((W) => W.node.sortKey.localeCompare(I) > 0 && W.node.sortKey.localeCompare(C) <= 0) : I && !C ? Z = Z.filter((W) => W.node.sortKey.localeCompare(I) > 0) : !I && C && (Z = Z.filter((W) => W.node.sortKey.localeCompare(C) <= 0)), this.logger.debug("All loaded interactions:", { from: I, to: C, loaded: Z.length, time: F.elapsed() });
      const N = this.environment === "local" || this.environment === "testnet";
      return Z.map((W) => {
        const H = W.node;
        return N && H.tags.some((te) => te.name == n.SmartWeaveTags.REQUEST_VRF && te.value === "true") && (H.vrf = (0, d.generateMockVrf)(H.sortKey, this.arweave)), H;
      });
    }
    async loadPages(B) {
      let I = await this.getNextPage(B);
      const C = I.edges.filter((P) => w(P));
      for (; I.pageInfo.hasNextPage; ) {
        const P = I.edges[99].cursor;
        B = { ...B, after: P }, I = await this.getNextPage(B), C.push(...I.edges.filter((q) => w(q)));
      }
      return C;
    }
    async getNextPage(B) {
      const I = o.Benchmark.measure();
      let C = await this.arweaveWrapper.gql(S.query, B);
      for (this.logger.debug("GQL page load:", I.elapsed()); C.status === 403; )
        this.logger.warn(`GQL rate limiting, waiting ${S._30seconds}ms before next try.`), await (0, c.sleep)(S._30seconds), C = await this.arweaveWrapper.gql(S.query, B);
      if (C.status !== 200)
        throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${C.status}.`);
      if (C.data.errors)
        throw this.logger.error(C.data.errors), new Error("Error while loading interaction transactions");
      return C.data.data.transactions;
    }
    type() {
      return "arweave";
    }
    clearCache() {
    }
  }
  return ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = S, S.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`, S._30seconds = 3e4, ArweaveGatewayInteractionsLoader;
}
var CacheableInteractionsLoader$1 = {};
Object.defineProperty(CacheableInteractionsLoader$1, "__esModule", { value: !0 }), CacheableInteractionsLoader$1.CacheableInteractionsLoader = void 0;
const LoggerFactory_1$1 = LoggerFactory$1;
class CacheableInteractionsLoader {
  constructor(o) {
    this.delegate = o, this.logger = LoggerFactory_1$1.LoggerFactory.INST.create("CacheableInteractionsLoader"), this.interactionsCache = /* @__PURE__ */ new Map();
  }
  async load(o, a, u, c) {
    if (this.logger.debug("Loading interactions for", { contractTxId: o, fromSortKey: a, toSortKey: u }), this.interactionsCache.has(o)) {
      const p = this.interactionsCache.get(o);
      if (p != null && p.length) {
        const d = p[p.length - 1].sortKey;
        if (d.localeCompare(u) < 0) {
          const w = await this.delegate.load(o, d, u, c), S = p.concat(w);
          return this.interactionsCache.set(o, S), S;
        }
      }
      return p;
    }
    {
      const p = await this.delegate.load(o, a, u, c);
      return p.length && this.interactionsCache.set(o, p), p;
    }
  }
  type() {
    return this.delegate.type();
  }
  clearCache() {
    this.interactionsCache.clear();
  }
}
CacheableInteractionsLoader$1.CacheableInteractionsLoader = CacheableInteractionsLoader;
var WarpGatewayContractDefinitionLoader = {}, WasmSrc$1 = {};
function readBlobAsArrayBuffer(n) {
  return n.arrayBuffer ? n.arrayBuffer() : new Promise((o, a) => {
    const u = new FileReader();
    u.addEventListener("loadend", () => {
      o(u.result);
    }), u.addEventListener("error", a), u.readAsArrayBuffer(n);
  });
}
async function readBlobAsUint8Array(n) {
  const o = await readBlobAsArrayBuffer(n);
  return new Uint8Array(o);
}
function isBlob(n) {
  return typeof Blob < "u" && n instanceof Blob;
}
function isSharedArrayBuffer(n) {
  return typeof SharedArrayBuffer < "u" && n instanceof SharedArrayBuffer;
}
const isNode = typeof process < "u" && process.versions && process.versions.node !== void 0 && process.versions.electron === void 0;
function isTypedArraySameAsArrayBuffer(n) {
  return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength;
}
class ArrayBufferReader {
  constructor(o) {
    this.typedArray = o instanceof ArrayBuffer || isSharedArrayBuffer(o) ? new Uint8Array(o) : new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  async getLength() {
    return this.typedArray.byteLength;
  }
  async read(o, a) {
    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + o, a);
  }
}
class BlobReader {
  constructor(o) {
    this.blob = o;
  }
  async getLength() {
    return this.blob.size;
  }
  async read(o, a) {
    const u = this.blob.slice(o, o + a), c = await readBlobAsArrayBuffer(u);
    return new Uint8Array(c);
  }
  async sliceAsBlob(o, a, u = "") {
    return this.blob.slice(o, o + a, u);
  }
}
class HTTPRangeReader {
  constructor(o) {
    this.url = o;
  }
  async getLength() {
    if (this.length === void 0) {
      const o = await fetch(this.url, { method: "HEAD" });
      if (!o.ok)
        throw new Error(`failed http request ${this.url}, status: ${o.status}: ${o.statusText}`);
      if (this.length = parseInt(o.headers.get("content-length")), Number.isNaN(this.length))
        throw Error("could not get length");
    }
    return this.length;
  }
  async read(o, a) {
    if (a === 0)
      return new Uint8Array(0);
    const u = await fetch(this.url, { headers: { Range: `bytes=${o}-${o + a - 1}` } });
    if (!u.ok)
      throw new Error(`failed http request ${this.url}, status: ${u.status} offset: ${o} size: ${a}: ${u.statusText}`);
    const c = await u.arrayBuffer();
    return new Uint8Array(c);
  }
}
function inflate(n, o) {
  var a = Uint8Array;
  if (n[0] == 3 && n[1] == 0)
    return o || new a(0);
  var u = _bitsF, c = _bitsE, p = _decodeTiny, d = _get17, w = o == null;
  w && (o = new a(n.length >>> 2 << 3));
  for (var S, k, B = 0, I = 0, C = 0, P = 0, q = 0, D = 0, z = 0, F = 0, V = 0; B == 0; )
    if (B = u(n, V, 1), I = u(n, V + 1, 2), V += 3, I != 0) {
      if (w && (o = _check(o, F + (1 << 17))), I == 1 && (S = U.flmap, k = U.fdmap, D = 511, z = 31), I == 2) {
        C = c(n, V, 5) + 257, P = c(n, V + 5, 5) + 1, q = c(n, V + 10, 4) + 4, V += 14;
        for (var Z = 0; Z < 38; Z += 2)
          U.itree[Z] = 0, U.itree[Z + 1] = 0;
        var N = 1;
        for (Z = 0; Z < q; Z++) {
          var W = c(n, V + 3 * Z, 3);
          U.itree[1 + (U.ordr[Z] << 1)] = W, W > N && (N = W);
        }
        V += 3 * q, makeCodes(U.itree, N), codes2map(U.itree, N, U.imap), S = U.lmap, k = U.dmap, V = p(U.imap, (1 << N) - 1, C + P, n, V, U.ttree);
        var H = _copyOut(U.ttree, 0, C, U.ltree);
        D = (1 << H) - 1;
        var te = _copyOut(U.ttree, C, P, U.dtree);
        z = (1 << te) - 1, makeCodes(U.ltree, H), codes2map(U.ltree, H, S), makeCodes(U.dtree, te), codes2map(U.dtree, te, k);
      }
      for (; ; ) {
        var g = S[d(n, V) & D];
        V += 15 & g;
        var $ = g >>> 4;
        if ($ >>> 8 == 0)
          o[F++] = $;
        else {
          if ($ == 256)
            break;
          var _ = F + $ - 254;
          if ($ > 264) {
            var b = U.ldef[$ - 257];
            _ = F + (b >>> 3) + c(n, V, 7 & b), V += 7 & b;
          }
          var m = k[d(n, V) & z];
          V += 15 & m;
          var v = m >>> 4, E = U.ddef[v], T = (E >>> 4) + u(n, V, 15 & E);
          for (V += 15 & E, w && (o = _check(o, F + (1 << 17))); F < _; )
            o[F] = o[F++ - T], o[F] = o[F++ - T], o[F] = o[F++ - T], o[F] = o[F++ - T];
          F = _;
        }
      }
    } else {
      (7 & V) != 0 && (V += 8 - (7 & V));
      var j = 4 + (V >>> 3), L = n[j - 4] | n[j - 3] << 8;
      w && (o = _check(o, F + L)), o.set(new a(n.buffer, n.byteOffset + j, L), F), V = j + L << 3, F += L;
    }
  return o.length == F ? o : o.slice(0, F);
}
function _check(n, o) {
  var a = n.length;
  if (o <= a)
    return n;
  var u = new Uint8Array(Math.max(a << 1, o));
  return u.set(n, 0), u;
}
function _decodeTiny(n, o, a, u, c, p) {
  for (var d = _bitsE, w = _get17, S = 0; S < a; ) {
    var k = n[w(u, c) & o];
    c += 15 & k;
    var B = k >>> 4;
    if (B <= 15)
      p[S] = B, S++;
    else {
      var I = 0, C = 0;
      B == 16 ? (C = 3 + d(u, c, 2), c += 2, I = p[S - 1]) : B == 17 ? (C = 3 + d(u, c, 3), c += 3) : B == 18 && (C = 11 + d(u, c, 7), c += 7);
      for (var P = S + C; S < P; )
        p[S] = I, S++;
    }
  }
  return c;
}
function _copyOut(n, o, a, u) {
  for (var c = 0, p = 0, d = u.length >>> 1; p < a; ) {
    var w = n[p + o];
    u[p << 1] = 0, u[1 + (p << 1)] = w, w > c && (c = w), p++;
  }
  for (; p < d; )
    u[p << 1] = 0, u[1 + (p << 1)] = 0, p++;
  return c;
}
function makeCodes(n, o) {
  for (var a, u, c, p, d = n.length, w = U.bl_count, S = 0; S <= o; S++)
    w[S] = 0;
  for (S = 1; S < d; S += 2)
    w[n[S]]++;
  var k = U.next_code;
  for (a = 0, w[0] = 0, u = 1; u <= o; u++)
    a = a + w[u - 1] << 1, k[u] = a;
  for (c = 0; c < d; c += 2)
    (p = n[c + 1]) != 0 && (n[c] = k[p], k[p]++);
}
function codes2map(n, o, a) {
  for (var u = n.length, c = U.rev15, p = 0; p < u; p += 2)
    if (n[p + 1] != 0)
      for (var d = p >> 1, w = n[p + 1], S = d << 4 | w, k = o - w, B = n[p] << k, I = B + (1 << k); B != I; )
        a[c[B] >>> 15 - o] = S, B++;
}
function revCodes(n, o) {
  for (var a = U.rev15, u = 15 - o, c = 0; c < n.length; c += 2) {
    var p = n[c] << o - n[c + 1];
    n[c] = a[p] >>> u;
  }
}
function _bitsE(n, o, a) {
  return (n[o >>> 3] | n[1 + (o >>> 3)] << 8) >>> (7 & o) & (1 << a) - 1;
}
function _bitsF(n, o, a) {
  return (n[o >>> 3] | n[1 + (o >>> 3)] << 8 | n[2 + (o >>> 3)] << 16) >>> (7 & o) & (1 << a) - 1;
}
function _get17(n, o) {
  return (n[o >>> 3] | n[1 + (o >>> 3)] << 8 | n[2 + (o >>> 3)] << 16) >>> (7 & o);
}
const U = (u16 = Uint16Array, u32 = Uint32Array, { next_code: new u16(16), bl_count: new u16(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new u16(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new u32(32), flmap: new u16(512), fltree: [], fdmap: new u16(32), fdtree: [], lmap: new u16(32768), ltree: [], ttree: [], dmap: new u16(32768), dtree: [], imap: new u16(512), itree: [], rev15: new u16(32768), lhst: new u32(286), dhst: new u32(30), ihst: new u32(19), lits: new u32(15e3), strt: new u16(65536), prev: new u16(32768) });
var u16, u32;
(function() {
  for (var n = 0; n < 32768; n++) {
    var o = n;
    o = (4278255360 & (o = (4042322160 & (o = (3435973836 & (o = (2863311530 & o) >>> 1 | (1431655765 & o) << 1)) >>> 2 | (858993459 & o) << 2)) >>> 4 | (252645135 & o) << 4)) >>> 8 | (16711935 & o) << 8, U.rev15[n] = (o >>> 16 | o << 16) >>> 17;
  }
  function a(u, c, p) {
    for (; c-- != 0; )
      u.push(0, p);
  }
  for (n = 0; n < 32; n++)
    U.ldef[n] = U.of0[n] << 3 | U.exb[n], U.ddef[n] = U.df0[n] << 4 | U.dxb[n];
  a(U.fltree, 144, 8), a(U.fltree, 112, 9), a(U.fltree, 24, 7), a(U.fltree, 8, 8), makeCodes(U.fltree, 9), codes2map(U.fltree, 9, U.flmap), revCodes(U.fltree, 9), a(U.fdtree, 32, 5), makeCodes(U.fdtree, 5), codes2map(U.fdtree, 5, U.fdmap), revCodes(U.fdtree, 5), a(U.itree, 19, 0), a(U.ltree, 286, 0), a(U.dtree, 30, 0), a(U.ttree, 320, 0);
})();
const crc = { table: function() {
  for (var n = new Uint32Array(256), o = 0; o < 256; o++) {
    for (var a = o, u = 0; u < 8; u++)
      1 & a ? a = 3988292384 ^ a >>> 1 : a >>>= 1;
    n[o] = a;
  }
  return n;
}(), update: function(n, o, a, u) {
  for (var c = 0; c < u; c++)
    n = crc.table[255 & (n ^ o[a + c])] ^ n >>> 8;
  return n;
}, crc: function(n, o, a) {
  return 4294967295 ^ crc.update(4294967295, n, o, a);
} };
function inflateRaw(n, o) {
  return inflate(n, o);
}
const config = { numWorkers: 1, workerURL: "", useWorkers: !1 };
let nextId = 0, numWorkers = 0, canUseWorkers = !0;
const workers = [], availableWorkers = [], waitingForWorkerQueue = [], currentlyProcessingIdToRequestMap = /* @__PURE__ */ new Map();
function handleResult(n) {
  makeWorkerAvailable(n.target);
  const { id: o, error: a, data: u } = n.data, c = currentlyProcessingIdToRequestMap.get(o);
  currentlyProcessingIdToRequestMap.delete(o), a ? c.reject(a) : c.resolve(u);
}
function startWorker(n) {
  return new Promise((o, a) => {
    const u = new Worker(n);
    u.onmessage = (c) => {
      c.data === "start" ? (u.onerror = void 0, u.onmessage = void 0, o(u)) : a(new Error(`unexpected message: ${c.data}`));
    }, u.onerror = a;
  });
}
function dynamicRequire(n, o) {
  return n.require(o);
}
const workerHelper = function() {
  if (isNode) {
    const { Worker: n } = dynamicRequire(module, "worker_threads");
    return { createWorker: async (o) => new n(o), addEventListener(o, a) {
      o.on("message", (u) => {
        a({ target: o, data: u });
      });
    }, async terminate(o) {
      await o.terminate();
    } };
  }
  return { async createWorker(n) {
    try {
      return await startWorker(n);
    } catch {
      console.warn("could not load worker:", n);
    }
    let o;
    try {
      const a = await fetch(n, { mode: "cors" });
      if (!a.ok)
        throw new Error(`could not load: ${n}`);
      o = await a.text(), n = URL.createObjectURL(new Blob([o], { type: "application/javascript" }));
      const u = await startWorker(n);
      return config.workerURL = n, u;
    } catch {
      console.warn("could not load worker via fetch:", n);
    }
    if (o !== void 0)
      try {
        n = `data:application/javascript;base64,${btoa(o)}`;
        const a = await startWorker(n);
        return config.workerURL = n, a;
      } catch {
        console.warn("could not load worker via dataURI");
      }
    throw console.warn("workers will not be used"), new Error("can not start workers");
  }, addEventListener(n, o) {
    n.addEventListener("message", o);
  }, async terminate(n) {
    n.terminate();
  } };
}();
function makeWorkerAvailable(n) {
  availableWorkers.push(n), processWaitingForWorkerQueue();
}
async function getAvailableWorker() {
  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {
    ++numWorkers;
    try {
      const n = await workerHelper.createWorker(config.workerURL);
      workers.push(n), availableWorkers.push(n), workerHelper.addEventListener(n, handleResult);
    } catch {
      canUseWorkers = !1;
    }
  }
  return availableWorkers.pop();
}
function inflateRawLocal(n, o, a, u) {
  const c = new Uint8Array(o);
  inflateRaw(n, c), u(a ? new Blob([c], { type: a }) : c.buffer);
}
async function processWaitingForWorkerQueue() {
  if (waitingForWorkerQueue.length !== 0) {
    if (config.useWorkers && canUseWorkers) {
      const n = await getAvailableWorker();
      if (canUseWorkers) {
        if (n) {
          if (waitingForWorkerQueue.length === 0)
            return void makeWorkerAvailable(n);
          const { id: o, src: a, uncompressedSize: u, type: c, resolve: p, reject: d } = waitingForWorkerQueue.shift();
          currentlyProcessingIdToRequestMap.set(o, { id: o, resolve: p, reject: d });
          const w = [];
          n.postMessage({ type: "inflate", data: { id: o, type: c, src: a, uncompressedSize: u } }, w);
        }
        return;
      }
    }
    for (; waitingForWorkerQueue.length; ) {
      const { src: n, uncompressedSize: o, type: a, resolve: u } = waitingForWorkerQueue.shift();
      let c = n;
      isBlob(n) && (c = await readBlobAsUint8Array(n)), inflateRawLocal(c, o, a, u);
    }
  }
}
function setOptions(n) {
  config.workerURL = n.workerURL || config.workerURL, n.workerURL && (config.useWorkers = !0), config.useWorkers = n.useWorkers !== void 0 ? n.useWorkers : config.useWorkers, config.numWorkers = n.numWorkers || config.numWorkers;
}
function inflateRawAsync(n, o, a) {
  return new Promise((u, c) => {
    waitingForWorkerQueue.push({ src: n, uncompressedSize: o, type: a, resolve: u, reject: c, id: nextId++ }), processWaitingForWorkerQueue();
  });
}
function clearArray(n) {
  n.splice(0, n.length);
}
async function cleanup() {
  for (const n of workers)
    await workerHelper.terminate(n);
  clearArray(workers), clearArray(availableWorkers), clearArray(waitingForWorkerQueue), currentlyProcessingIdToRequestMap.clear(), numWorkers = 0, canUseWorkers = !0;
}
function dosDateTimeToDate(n, o) {
  return new Date(1980 + (n >> 9 & 127), (n >> 5 & 15) - 1, 31 & n, o >> 11 & 31, o >> 5 & 63, 2 * (31 & o), 0);
}
class ZipEntry {
  constructor(o, a) {
    this._reader = o, this._rawEntry = a, this.name = a.name, this.nameBytes = a.nameBytes, this.size = a.uncompressedSize, this.compressedSize = a.compressedSize, this.comment = a.comment, this.commentBytes = a.commentBytes, this.compressionMethod = a.compressionMethod, this.lastModDate = dosDateTimeToDate(a.lastModFileDate, a.lastModFileTime), this.isDirectory = a.uncompressedSize === 0 && a.name.endsWith("/"), this.encrypted = !!(1 & a.generalPurposeBitFlag), this.externalFileAttributes = a.externalFileAttributes, this.versionMadeBy = a.versionMadeBy;
  }
  async blob(o = "application/octet-stream") {
    return await readEntryDataAsBlob(this._reader, this._rawEntry, o);
  }
  async arrayBuffer() {
    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);
  }
  async text() {
    const o = await this.arrayBuffer();
    return decodeBuffer(new Uint8Array(o));
  }
  async json() {
    const o = await this.text();
    return JSON.parse(o);
  }
}
const EOCDR_WITHOUT_COMMENT_SIZE = 22, MAX_COMMENT_SIZE = 65535, EOCDR_SIGNATURE = 101010256, ZIP64_EOCDR_SIGNATURE = 101075792;
async function readAs(n, o, a) {
  return await n.read(o, a);
}
async function readAsBlobOrTypedArray(n, o, a, u) {
  return n.sliceAsBlob ? await n.sliceAsBlob(o, a, u) : await n.read(o, a);
}
const crc$1 = { unsigned: () => 0 };
function getUint16LE(n, o) {
  return n[o] + 256 * n[o + 1];
}
function getUint32LE(n, o) {
  return n[o] + 256 * n[o + 1] + 65536 * n[o + 2] + 16777216 * n[o + 3];
}
function getUint64LE(n, o) {
  return getUint32LE(n, o) + 4294967296 * getUint32LE(n, o + 4);
}
const utf8Decoder = new TextDecoder();
function decodeBuffer(n, o) {
  return isSharedArrayBuffer(n.buffer) && (n = new Uint8Array(n)), utf8Decoder.decode(n);
}
async function findEndOfCentralDirector(n, o) {
  const a = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, o), u = o - a, c = await readAs(n, u, a);
  for (let p = a - EOCDR_WITHOUT_COMMENT_SIZE; p >= 0; --p) {
    if (getUint32LE(c, p) !== EOCDR_SIGNATURE)
      continue;
    const d = new Uint8Array(c.buffer, c.byteOffset + p, c.byteLength - p), w = getUint16LE(d, 4);
    if (w !== 0)
      throw new Error(`multi-volume zip files are not supported. This is volume: ${w}`);
    const S = getUint16LE(d, 10), k = getUint32LE(d, 12), B = getUint32LE(d, 16), I = getUint16LE(d, 20), C = d.length - EOCDR_WITHOUT_COMMENT_SIZE;
    if (I !== C)
      throw new Error(`invalid comment length. expected: ${C}, actual: ${I}`);
    const P = new Uint8Array(d.buffer, d.byteOffset + 22, I), q = decodeBuffer(P);
    return S === 65535 || B === 4294967295 ? await readZip64CentralDirectory(n, u + p, q, P) : await readEntries(n, B, k, S, q, P);
  }
  throw new Error("could not find end of central directory. maybe not zip file");
}
const END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 117853008;
async function readZip64CentralDirectory(n, o, a, u) {
  const c = o - 20, p = await readAs(n, c, 20);
  if (getUint32LE(p, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory locator signature");
  const d = getUint64LE(p, 8), w = await readAs(n, d, 56);
  if (getUint32LE(w, 0) !== ZIP64_EOCDR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory record signature");
  const S = getUint64LE(w, 32), k = getUint64LE(w, 40);
  return readEntries(n, getUint64LE(w, 48), k, S, a, u);
}
const CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 33639248;
async function readEntries(n, o, a, u, c, p) {
  let d = 0;
  const w = await readAs(n, o, a), S = [];
  for (let k = 0; k < u; ++k) {
    const B = w.subarray(d, d + 46), I = getUint32LE(B, 0);
    if (I !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE)
      throw new Error(`invalid central directory file header signature: 0x${I.toString(16)}`);
    const C = { versionMadeBy: getUint16LE(B, 4), versionNeededToExtract: getUint16LE(B, 6), generalPurposeBitFlag: getUint16LE(B, 8), compressionMethod: getUint16LE(B, 10), lastModFileTime: getUint16LE(B, 12), lastModFileDate: getUint16LE(B, 14), crc32: getUint32LE(B, 16), compressedSize: getUint32LE(B, 20), uncompressedSize: getUint32LE(B, 24), fileNameLength: getUint16LE(B, 28), extraFieldLength: getUint16LE(B, 30), fileCommentLength: getUint16LE(B, 32), internalFileAttributes: getUint16LE(B, 36), externalFileAttributes: getUint32LE(B, 38), relativeOffsetOfLocalHeader: getUint32LE(B, 42) };
    if (64 & C.generalPurposeBitFlag)
      throw new Error("strong encryption is not supported");
    d += 46;
    const P = w.subarray(d, d + C.fileNameLength + C.extraFieldLength + C.fileCommentLength);
    C.nameBytes = P.slice(0, C.fileNameLength), C.name = decodeBuffer(C.nameBytes);
    const q = C.fileNameLength + C.extraFieldLength, D = P.slice(C.fileNameLength, q);
    C.extraFields = [];
    let z = 0;
    for (; z < D.length - 3; ) {
      const V = getUint16LE(D, z + 0), Z = z + 4, N = Z + getUint16LE(D, z + 2);
      if (N > D.length)
        throw new Error("extra field length exceeds extra field buffer size");
      C.extraFields.push({ id: V, data: D.slice(Z, N) }), z = N;
    }
    if (C.commentBytes = P.slice(q, q + C.fileCommentLength), C.comment = decodeBuffer(C.commentBytes), d += P.length, C.uncompressedSize === 4294967295 || C.compressedSize === 4294967295 || C.relativeOffsetOfLocalHeader === 4294967295) {
      const V = C.extraFields.find((W) => W.id === 1);
      if (!V)
        throw new Error("expected zip64 extended information extra field");
      const Z = V.data;
      let N = 0;
      if (C.uncompressedSize === 4294967295) {
        if (N + 8 > Z.length)
          throw new Error("zip64 extended information extra field does not include uncompressed size");
        C.uncompressedSize = getUint64LE(Z, N), N += 8;
      }
      if (C.compressedSize === 4294967295) {
        if (N + 8 > Z.length)
          throw new Error("zip64 extended information extra field does not include compressed size");
        C.compressedSize = getUint64LE(Z, N), N += 8;
      }
      if (C.relativeOffsetOfLocalHeader === 4294967295) {
        if (N + 8 > Z.length)
          throw new Error("zip64 extended information extra field does not include relative header offset");
        C.relativeOffsetOfLocalHeader = getUint64LE(Z, N), N += 8;
      }
    }
    const F = C.extraFields.find((V) => V.id === 28789 && V.data.length >= 6 && V.data[0] === 1 && getUint32LE(V.data, 1), crc$1.unsigned(C.nameBytes));
    if (F && (C.fileName = decodeBuffer(F.data.slice(5))), C.compressionMethod === 0) {
      let V = C.uncompressedSize;
      if ((1 & C.generalPurposeBitFlag) != 0 && (V += 12), C.compressedSize !== V)
        throw new Error(`compressed size mismatch for stored file: ${C.compressedSize} != ${V}`);
    }
    S.push(C);
  }
  return { zip: { comment: c, commentBytes: p }, entries: S.map((k) => new ZipEntry(n, k)) };
}
async function readEntryDataHeader(n, o) {
  if (1 & o.generalPurposeBitFlag)
    throw new Error("encrypted entries not supported");
  const a = await readAs(n, o.relativeOffsetOfLocalHeader, 30), u = await n.getLength(), c = getUint32LE(a, 0);
  if (c !== 67324752)
    throw new Error(`invalid local file header signature: 0x${c.toString(16)}`);
  const p = getUint16LE(a, 26), d = getUint16LE(a, 28), w = o.relativeOffsetOfLocalHeader + a.length + p + d;
  let S;
  if (o.compressionMethod === 0)
    S = !1;
  else {
    if (o.compressionMethod !== 8)
      throw new Error(`unsupported compression method: ${o.compressionMethod}`);
    S = !0;
  }
  const k = w, B = k + o.compressedSize;
  if (o.compressedSize !== 0 && B > u)
    throw new Error(`file data overflows file bounds: ${k} +  ${o.compressedSize}  > ${u}`);
  return { decompress: S, fileDataStart: k };
}
async function readEntryDataAsArrayBuffer(n, o) {
  const { decompress: a, fileDataStart: u } = await readEntryDataHeader(n, o);
  if (!a) {
    const p = await readAs(n, u, o.compressedSize);
    return isTypedArraySameAsArrayBuffer(p) ? p.buffer : p.slice().buffer;
  }
  const c = await readAsBlobOrTypedArray(n, u, o.compressedSize);
  return await inflateRawAsync(c, o.uncompressedSize);
}
async function readEntryDataAsBlob(n, o, a) {
  const { decompress: u, fileDataStart: c } = await readEntryDataHeader(n, o);
  if (!u) {
    const d = await readAsBlobOrTypedArray(n, c, o.compressedSize, a);
    return isBlob(d) ? d : new Blob([isSharedArrayBuffer(d.buffer) ? new Uint8Array(d) : d], { type: a });
  }
  const p = await readAsBlobOrTypedArray(n, c, o.compressedSize);
  return await inflateRawAsync(p, o.uncompressedSize, a);
}
function setOptions$1(n) {
  setOptions(n);
}
async function unzipRaw(n) {
  let o;
  if (typeof Blob < "u" && n instanceof Blob)
    o = new BlobReader(n);
  else if (n instanceof ArrayBuffer || n && n.buffer && n.buffer instanceof ArrayBuffer)
    o = new ArrayBufferReader(n);
  else if (isSharedArrayBuffer(n) || isSharedArrayBuffer(n.buffer))
    o = new ArrayBufferReader(n);
  else if (typeof n == "string") {
    const u = await fetch(n);
    if (!u.ok)
      throw new Error(`failed http request ${n}, status: ${u.status}: ${u.statusText}`);
    const c = await u.blob();
    o = new BlobReader(c);
  } else {
    if (typeof n.getLength != "function" || typeof n.read != "function")
      throw new Error("unsupported source type");
    o = n;
  }
  const a = await o.getLength();
  if (a > Number.MAX_SAFE_INTEGER)
    throw new Error(`file too large. size: ${a}. Only file sizes up 4503599627370496 bytes are supported`);
  return await findEndOfCentralDirector(o, a);
}
async function unzip(n) {
  const { zip: o, entries: a } = await unzipRaw(n);
  return { zip: o, entries: Object.fromEntries(a.map((u) => [u.name, u])) };
}
function cleanup$1() {
  cleanup();
}
const unzipit_module = Object.freeze(Object.defineProperty({ __proto__: null, HTTPRangeReader, cleanup: cleanup$1, setOptions: setOptions$1, unzip, unzipRaw }, Symbol.toStringTag, { value: "Module" })), require$$0 = getAugmentedNamespace(unzipit_module);
Object.defineProperty(WasmSrc$1, "__esModule", { value: !0 }), WasmSrc$1.WasmSrc = void 0;
const unzipit_1 = require$$0, redstone_isomorphic_1 = npmBrowser$1, LoggerFactory_1 = LoggerFactory$1;
class WasmSrc {
  constructor(o) {
    this.src = o, this.logger = LoggerFactory_1.LoggerFactory.INST.create("WasmSrc"), this.splitted = this.splitBuffer(o), this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
  }
  wasmBinary() {
    return this.splitted[0];
  }
  async sourceCode() {
    const { entries: o } = await (0, unzipit_1.unzip)(this.splitted[1]), a = /* @__PURE__ */ new Map();
    for (const [u, c] of Object.entries(o)) {
      if (c.isDirectory)
        continue;
      const p = await c.text();
      a.set(u, p);
    }
    return a;
  }
  additionalCode() {
    return this.splitted.length == 2 ? null : this.splitted[2].toString();
  }
  splitBuffer(o) {
    let a = "";
    const u = parseInt(o.toString("utf8", 0, 1));
    this.logger.debug(`Number of elements: ${u}`);
    const c = o.length;
    let p = 0, d = 0;
    for (let k = 2; k < c; k++) {
      const B = o.toString("utf8", k, k + 1);
      if (B == "|" && p++, p == u) {
        d = k + 1;
        break;
      }
      a += B;
    }
    this.logger.debug("Parsed:", { header: a, dataStart: d });
    const w = a.split("|").map((k) => parseInt(k));
    this.logger.debug("Lengths", w);
    const S = [];
    for (const k of w) {
      const B = redstone_isomorphic_1.Buffer.alloc(k), I = d + k;
      o.copy(B, 0, d, I), d = I, S.push(B);
    }
    return S;
  }
}
var hasRequiredWarpGatewayContractDefinitionLoader, hasRequiredWarpBuilder, hasRequiredWarp, hasRequiredWarpFactory, hasRequiredArweaveWrapper, hasRequiredContractDefinitionLoader;
function requireWarpGatewayContractDefinitionLoader() {
  if (hasRequiredWarpGatewayContractDefinitionLoader)
    return WarpGatewayContractDefinitionLoader;
  hasRequiredWarpGatewayContractDefinitionLoader = 1;
  var n = commonjsGlobal && commonjsGlobal.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(WarpGatewayContractDefinitionLoader, "__esModule", { value: !0 }), WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = void 0;
  const o = requireContractDefinitionLoader(), a = npmBrowser$1, u = n(requireTransaction()), c = SmartWeaveTags, p = utils$C, d = Benchmark$1, w = LoggerFactory$1, S = requireArweaveWrapper(), k = utils$n, B = WasmSrc$1, I = memoryLevel, C = browser;
  return WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = class {
    constructor(P, q, D) {
      if (this.baseUrl = P, this.rLogger = w.LoggerFactory.INST.create("WarpGatewayContractDefinitionLoader"), this.baseUrl = (0, k.stripTrailingSlash)(P), this.contractDefinitionLoader = new o.ContractDefinitionLoader(q), this.arweaveWrapper = new S.ArweaveWrapper(q), D.inMemory)
        this.db = new I.MemoryLevel({ valueEncoding: "json" });
      else {
        if (!D.dbLocation)
          throw new Error("LevelDb cache configuration error - no db location specified");
        const z = D.dbLocation;
        this.db = new C.Level(`${z}/contracts`, { valueEncoding: "json" });
      }
    }
    async load(P, q) {
      let D = P;
      q && (D += `_${q}`);
      let z = null;
      try {
        z = await this.db.get(D);
      } catch (Z) {
        if (Z.code != "LEVEL_NOT_FOUND")
          throw Z;
        z = null;
      }
      if (z)
        return this.rLogger.debug("WarpGatewayContractDefinitionLoader: Hit from cache!"), z.contractType == "wasm" && (z.srcBinary = a.Buffer.from(z.srcBinary.data)), z;
      const F = d.Benchmark.measure(), V = await this.doLoad(P, q);
      return this.rLogger.info(`Contract definition loaded in: ${F.elapsed()}`), await this.db.put(D, V), V;
    }
    async doLoad(P, q) {
      try {
        const D = await fetch(`${this.baseUrl}/gateway/contract?txId=${P}${q ? `&srcTxId=${q}` : ""}`).then((z) => z.ok ? z.json() : Promise.reject(z)).catch((z) => {
          var F, V;
          throw !((F = z.body) === null || F === void 0) && F.message && this.rLogger.error(z.body.message), new Error(`Unable to retrieve contract data. Warp gateway responded with status ${z.status}:${(V = z.body) === null || V === void 0 ? void 0 : V.message}`);
        });
        if (D.srcBinary == null || D.srcBinary instanceof a.Buffer || (D.srcBinary = a.Buffer.from(D.srcBinary.data)), D.srcBinary) {
          const z = new B.WasmSrc(D.srcBinary);
          let F;
          D.srcBinary = z.wasmBinary(), F = D.srcTx ? new u.default({ ...D.srcTx }) : await this.arweaveWrapper.tx(D.srcTxId);
          const V = JSON.parse((0, p.getTag)(F, c.SmartWeaveTags.WASM_META));
          D.metadata = V;
        }
        return D.contractType = D.src ? "js" : "wasm", D;
      } catch (D) {
        return this.rLogger.warn("Falling back to default contracts loader", D), await this.contractDefinitionLoader.doLoad(P, q);
      }
    }
    async loadContractSource(P) {
      return await this.contractDefinitionLoader.loadContractSource(P);
    }
    type() {
      return "warp";
    }
  }, WarpGatewayContractDefinitionLoader;
}
function requireWarpBuilder() {
  if (hasRequiredWarpBuilder)
    return WarpBuilder;
  hasRequiredWarpBuilder = 1, Object.defineProperty(WarpBuilder, "__esModule", { value: !0 }), WarpBuilder.WarpBuilder = void 0;
  const n = DebuggableExecutorFactor, o = requireArweaveGatewayInteractionsLoader(), a = CacheableInteractionsLoader$1, u = requireContractDefinitionLoader(), c = requireWarpGatewayContractDefinitionLoader(), p = WarpGatewayInteractionsLoader, d = requireWarp();
  return WarpBuilder.WarpBuilder = class {
    constructor(w, S, k = "custom") {
      this._arweave = w, this._cache = S, this._environment = k;
    }
    setDefinitionLoader(w) {
      return this._definitionLoader = w, this;
    }
    setInteractionsLoader(w) {
      return this._interactionsLoader = w, this;
    }
    setExecutorFactory(w) {
      return this._executorFactory = w, this;
    }
    setStateEvaluator(w) {
      return this._stateEvaluator = w, this;
    }
    overwriteSource(w) {
      if (this._executorFactory == null)
        throw new Error("Set base ExecutorFactory first");
      return this._executorFactory = new n.DebuggableExecutorFactory(this._executorFactory, w), this.build();
    }
    useWarpGateway(w, S) {
      return this._interactionsLoader = new a.CacheableInteractionsLoader(new p.WarpGatewayInteractionsLoader(w.address, w.confirmationStatus, w.source)), this._definitionLoader = new c.WarpGatewayContractDefinitionLoader(w.address, this._arweave, S), this;
    }
    useArweaveGateway() {
      return this._definitionLoader = new u.ContractDefinitionLoader(this._arweave), this._interactionsLoader = new a.CacheableInteractionsLoader(new o.ArweaveGatewayInteractionsLoader(this._arweave, this._environment)), this;
    }
    build() {
      return new d.Warp(this._arweave, this._cache, this._definitionLoader, this._interactionsLoader, this._executorFactory, this._stateEvaluator, this._environment);
    }
  }, WarpBuilder;
}
function requireWarp() {
  if (hasRequiredWarp)
    return Warp;
  hasRequiredWarp = 1, Object.defineProperty(Warp, "__esModule", { value: !0 }), Warp.Warp = void 0;
  const n = requireDefaultCreateContract(), o = requireHandlerBasedContract(), a = requirePstContractImpl(), u = MigrationTool$1, c = Testing$1, p = requireWarpBuilder();
  return Warp.Warp = class {
    constructor(d, w, S, k, B, I, C = "custom") {
      this.arweave = d, this.levelDb = w, this.definitionLoader = S, this.interactionsLoader = k, this.executorFactory = B, this.stateEvaluator = I, this.environment = C, this.createContract = new n.DefaultCreateContract(d, this), this.migrationTool = new u.MigrationTool(d, w), this.testing = new c.Testing(d);
    }
    static builder(d, w, S) {
      return new p.WarpBuilder(d, w, S);
    }
    contract(d, w, S) {
      return new o.HandlerBasedContract(d, this, w, S);
    }
    pst(d) {
      return new a.PstContractImpl(d, this);
    }
  }, Warp;
}
function requireWarpFactory() {
  return hasRequiredWarpFactory || (hasRequiredWarpFactory = 1, function(n) {
    var o = commonjsGlobal && commonjsGlobal.__importDefault || function(B) {
      return B && B.__esModule ? B : { default: B };
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), n.WarpFactory = n.defaultCacheOptions = n.DEFAULT_LEVEL_DB_LOCATION = n.defaultWarpGwOptions = n.WARP_GW_URL = void 0;
    const a = o(web), u = LevelDbCache$1, c = MemCache$1, p = CacheableExecutorFactory$1, d = Evolve$1, w = CacheableStateEvaluator$1, S = HandlerExecutorFactory$1, k = requireWarp();
    n.WARP_GW_URL = "https://d1o5nlqr4okus2.cloudfront.net", n.defaultWarpGwOptions = { confirmationStatus: { notCorrupted: !0 }, source: null, address: n.WARP_GW_URL }, n.DEFAULT_LEVEL_DB_LOCATION = "./cache/warp", n.defaultCacheOptions = { inMemory: !1, dbLocation: n.DEFAULT_LEVEL_DB_LOCATION }, n.WarpFactory = class {
      static forLocal(B = 1984, I = a.default.init({ host: "localhost", port: B, protocol: "http" }), C = { ...n.defaultCacheOptions, inMemory: !0 }) {
        return this.customArweaveGw(I, C, "local");
      }
      static forTestnet(B = a.default.init({ host: "testnet.redstone.tools", port: 443, protocol: "https" }), I = n.defaultCacheOptions) {
        return this.customArweaveGw(B, I, "testnet");
      }
      static forMainnet(B = n.defaultCacheOptions, I = !1, C = a.default.init({ host: "arweave.net", port: 443, protocol: "https" })) {
        return I ? this.customArweaveGw(C, B, "mainnet") : this.customWarpGw(C, n.defaultWarpGwOptions, B, "mainnet");
      }
      static custom(B, I, C) {
        const P = new u.LevelDbCache({ ...I, dbLocation: `${I.dbLocation}/state` }), q = new p.CacheableExecutorFactory(B, new S.HandlerExecutorFactory(B), new c.MemCache()), D = new w.CacheableStateEvaluator(B, P, [new d.Evolve()]);
        return k.Warp.builder(B, P, C).setExecutorFactory(q).setStateEvaluator(D);
      }
      static customArweaveGw(B, I = n.defaultCacheOptions, C) {
        return this.custom(B, I, C).useArweaveGateway().build();
      }
      static customWarpGw(B, I = n.defaultWarpGwOptions, C = n.defaultCacheOptions, P) {
        return this.custom(B, C, P).useWarpGateway(I, C).build();
      }
    };
  }(WarpFactory)), WarpFactory;
}
function requireArweaveWrapper() {
  if (hasRequiredArweaveWrapper)
    return ArweaveWrapper;
  hasRequiredArweaveWrapper = 1;
  var n = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(ArweaveWrapper, "__esModule", { value: !0 }), ArweaveWrapper.ArweaveWrapper = void 0;
  const o = n(web), a = n(requireTransaction()), u = npmBrowser$1, c = requireWarpFactory(), p = LoggerFactory$1;
  return ArweaveWrapper.ArweaveWrapper = class {
    constructor(d) {
      this.arweave = d, this.logger = p.LoggerFactory.INST.create("ArweaveWrapper"), this.baseUrl = `${d.api.config.protocol}://${d.api.config.host}:${d.api.config.port}`, this.logger.debug("baseurl", this.baseUrl);
    }
    async warpGwInfo() {
      return await this.doFetchInfo(`${c.WARP_GW_URL}/gateway/arweave/info`);
    }
    async warpGwBlock() {
      return this.logger.debug("Calling warp gw block info"), await this.doFetchInfo(`${c.WARP_GW_URL}/gateway/arweave/block`);
    }
    async info() {
      return await this.doFetchInfo(`${this.baseUrl}/info`);
    }
    async gql(d, w) {
      try {
        const S = JSON.stringify({ query: d, variables: w });
        return { data: await fetch(`${this.baseUrl}/graphql`, { method: "POST", body: S, headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((B) => B.ok ? B.json() : Promise.reject(B)).catch((B) => {
          var I, C;
          throw !((I = B.body) === null || I === void 0) && I.message && this.logger.error(B.body.message), new Error(`Unable to retrieve gql page. ${B.status}: ${(C = B.body) === null || C === void 0 ? void 0 : C.message}`);
        }), status: 200 };
      } catch (S) {
        throw this.logger.error("Error while loading gql", S), S;
      }
    }
    async tx(d) {
      const w = await fetch(`${this.baseUrl}/tx/${d}`).then((S) => S.ok ? S.json() : Promise.reject(S)).catch((S) => {
        var k, B;
        throw !((k = S.body) === null || k === void 0) && k.message && this.logger.error(S.body.message), new Error(`Unable to retrieve tx ${d}. ${S.status}. ${(B = S.body) === null || B === void 0 ? void 0 : B.message}`);
      });
      return new a.default({ ...w });
    }
    async txData(d) {
      const w = await fetch(`${this.baseUrl}/${d}`);
      if (w.ok) {
        const S = await w.arrayBuffer();
        return u.Buffer.from(S);
      }
      {
        this.logger.warn(`Unable to load data from arweave.net/${d} endpoint, falling back to arweave.js`);
        const S = await this.arweave.transactions.getData(d, { decode: !0 });
        return u.Buffer.from(S);
      }
    }
    async txDataString(d) {
      const w = await this.txData(d);
      return o.default.utils.bufferToString(w);
    }
    async doFetchInfo(d) {
      try {
        return await fetch(d).then((S) => S.ok ? S.json() : Promise.reject(S)).catch((S) => {
          var k, B;
          throw !((k = S.body) === null || k === void 0) && k.message && this.logger.error(S.body.message), new Error(`Unable to retrieve info. ${S.status}: ${(B = S.body) === null || B === void 0 ? void 0 : B.message}`);
        });
      } catch (w) {
        throw this.logger.error("Error while loading info", w), w;
      }
    }
  }, ArweaveWrapper;
}
function requireContractDefinitionLoader() {
  if (hasRequiredContractDefinitionLoader)
    return ContractDefinitionLoader;
  hasRequiredContractDefinitionLoader = 1, Object.defineProperty(ContractDefinitionLoader, "__esModule", { value: !0 }), ContractDefinitionLoader.ContractDefinitionLoader = void 0;
  const n = SmartWeaveTags, o = utils$C, a = Benchmark$1, u = LoggerFactory$1, c = requireArweaveWrapper(), p = WasmSrc$1, d = ["application/javascript", "application/wasm"];
  return ContractDefinitionLoader.ContractDefinitionLoader = class {
    constructor(w) {
      this.arweave = w, this.logger = u.LoggerFactory.INST.create("ContractDefinitionLoader"), this.arweaveWrapper = new c.ArweaveWrapper(w);
    }
    async load(w, S) {
      const k = a.Benchmark.measure(), B = await this.doLoad(w, S);
      return this.logger.info(`Contract definition loaded in: ${k.elapsed()}`), B;
    }
    async doLoad(w, S) {
      const k = a.Benchmark.measure(), B = await this.arweaveWrapper.tx(w), I = await this.arweave.wallets.ownerToAddress(B.owner);
      this.logger.debug("Contract tx and owner", k.elapsed()), k.reset();
      const C = S || (0, o.getTag)(B, n.SmartWeaveTags.CONTRACT_SRC_TX_ID), P = (0, o.getTag)(B, n.SmartWeaveTags.MIN_FEE);
      this.logger.debug("Tags decoding", k.elapsed()), k.reset();
      const q = await this.evalInitialState(B);
      this.logger.debug("init state", q);
      const D = JSON.parse(await this.evalInitialState(B));
      this.logger.debug("Parsing src and init state", k.elapsed());
      const { src: z, srcBinary: F, srcWasmLang: V, contractType: Z, metadata: N, srcTx: W } = await this.loadContractSource(C);
      return { txId: w, srcTxId: C, src: z, srcBinary: F, srcWasmLang: V, initState: D, minFee: P, owner: I, contractType: Z, metadata: N, contractTx: B.toJSON(), srcTx: W };
    }
    async loadContractSource(w) {
      const S = a.Benchmark.measure(), k = await this.arweaveWrapper.tx(w), B = (0, o.getTag)(k, n.SmartWeaveTags.CONTENT_TYPE);
      if (!d.includes(B))
        throw new Error(`Contract source content type ${B} not supported`);
      const I = B == "application/javascript" ? "js" : "wasm", C = I == "js" ? await this.arweaveWrapper.txDataString(w) : await this.arweaveWrapper.txData(w);
      let P, q, D;
      if (I == "wasm") {
        if (q = new p.WasmSrc(C), P = (0, o.getTag)(k, n.SmartWeaveTags.WASM_LANG), !P)
          throw new Error(`Wasm lang not set for wasm contract src ${w}`);
        D = JSON.parse((0, o.getTag)(k, n.SmartWeaveTags.WASM_META));
      }
      return this.logger.debug("Contract src tx load", S.elapsed()), S.reset(), { src: I == "js" ? C : null, srcBinary: I == "wasm" ? q.wasmBinary() : null, srcWasmLang: P, contractType: I, metadata: D, srcTx: k.toJSON() };
    }
    async evalInitialState(w) {
      if ((0, o.getTag)(w, n.SmartWeaveTags.INIT_STATE))
        return (0, o.getTag)(w, n.SmartWeaveTags.INIT_STATE);
      if ((0, o.getTag)(w, n.SmartWeaveTags.INIT_STATE_TX)) {
        const S = (0, o.getTag)(w, n.SmartWeaveTags.INIT_STATE_TX);
        return this.arweaveWrapper.txDataString(S);
      }
      return this.arweaveWrapper.txDataString(w.id);
    }
    type() {
      return "arweave";
    }
  }, ContractDefinitionLoader;
}
WasmSrc$1.WasmSrc = WasmSrc;
var ExecutionContextModifier = {};
Object.defineProperty(ExecutionContextModifier, "__esModule", { value: !0 });
var ExecutionContext = {};
Object.defineProperty(ExecutionContext, "__esModule", { value: !0 });
var ContractDefinition = {};
Object.defineProperty(ContractDefinition, "__esModule", { value: !0 }), ContractDefinition.ContractMetadata = void 0;
class ContractMetadata {
}
ContractDefinition.ContractMetadata = ContractMetadata;
var PstContract = {};
Object.defineProperty(PstContract, "__esModule", { value: !0 });
var Source = {};
Object.defineProperty(Source, "__esModule", { value: !0 });
var gqlResult = {};
Object.defineProperty(gqlResult, "__esModule", { value: !0 }), function(n) {
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(u, c, p, d) {
    d === void 0 && (d = p);
    var w = Object.getOwnPropertyDescriptor(c, p);
    w && !("get" in w ? !c.__esModule : w.writable || w.configurable) || (w = { enumerable: !0, get: function() {
      return c[p];
    } }), Object.defineProperty(u, d, w);
  } : function(u, c, p, d) {
    d === void 0 && (d = p), u[d] = c[p];
  }), a = commonjsGlobal && commonjsGlobal.__exportStar || function(u, c) {
    for (var p in u)
      p === "default" || Object.prototype.hasOwnProperty.call(c, p) || o(c, u, p);
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), a(ConsoleLogger$1, n), a(ConsoleLoggerFactory$1, n), a(WarpLogger, n), a(LoggerFactory$1, n), a(LoggerSettings, n), a(Benchmark$1, n), a(DefinitionLoader, n), a(ExecutorFactory, n), a(InteractionsLoader, n), a(InteractionsSorter, n), a(StateEvaluator, n), a(requireContractDefinitionLoader(), n), a(requireWarpGatewayContractDefinitionLoader(), n), a(requireArweaveGatewayInteractionsLoader(), n), a(WarpGatewayInteractionsLoader, n), a(CacheableInteractionsLoader$1, n), a(DefaultStateEvaluator$1, n), a(CacheableStateEvaluator$1, n), a(HandlerExecutorFactory$1, n), a(LexicographicalInteractionsSorter, n), a(TagsParser$1, n), a(normalizeSource, n), a(StateCache, n), a(WasmSrc$1, n), a(AbstractContractHandler$1, n), a(JsHandlerApi$1, n), a(WasmHandlerApi$1, n), a(ExecutionContextModifier, n), a(SmartWeaveTags, n), a(ExecutionContext, n), a(ContractDefinition, n), a(ContractCallRecord$1, n), a(requireWarpFactory(), n), a(requireWarp(), n), a(requireWarpBuilder(), n), a(Contract, n), a(requireHandlerBasedContract(), n), a(PstContract, n), a(requirePstContractImpl(), n), a(InnerWritesEvaluator$1, n), a(Source, n), a(SourceImpl$1, n), a(requireDefaultCreateContract(), n), a(CreateContract, n), a(gqlResult, n), a(smartweaveGlobal, n), a(errors, n), a(utils$C, n), a(createInteractionTx$1, n), a(utils$n, n), a(requireArweaveWrapper(), n);
}(cjs);
const index = getDefaultExportFromCjs(cjs), index$1 = _mergeNamespaces({ __proto__: null, default: index }, [cjs]);
export {
  DIDAr as default
};

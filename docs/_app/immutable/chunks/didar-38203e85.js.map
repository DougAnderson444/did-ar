{"version":3,"file":"didar-38203e85.js","sources":["../../../../../../src/lib/contract/contractSrc.js?raw","../../../../../../src/lib/contractUtils.ts","../../../../../../src/lib/utils.ts","../../../../../../src/lib/didar.ts"],"sourcesContent":["export default \"export async function handle(state, action) {\\r\\n\\tconst input = action.input;\\r\\n\\tconst caller = action.caller;\\r\\n\\r\\n\\tif (caller !== SmartWeave.contract.owner) {\\r\\n\\t\\treturn { state };\\r\\n\\t}\\r\\n\\r\\n\\tif (input.function === 'update') {\\r\\n\\t\\tif (!state.id) {\\r\\n\\t\\t\\tif (!input.id.startsWith('did:ar')) {\\r\\n\\t\\t\\t\\tthrow new ContractError('Invalid ID');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.id = input.id;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (input.verificationMethod) {\\r\\n\\t\\t\\tif (!Array.isArray(input.verificationMethod) || input.verificationMethod.length === 0) {\\r\\n\\t\\t\\t\\tthrow new ContractError('verificationMethod must be an array with at least one method');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.verificationMethod = input.verificationMethod;\\r\\n\\t\\t}\\r\\n\\t\\tstate.authentication = input?.authentication || state.authentication;\\r\\n\\t\\tstate.assertionMethod = input?.assertionMethod || state.assertionMethod;\\r\\n\\t\\tstate.keyAgreement = input?.keyAgreement || state.keyAgreement;\\r\\n\\t\\tstate.capabilityInvocation = input?.capabilityInvocation || state.capabilityInvocation;\\r\\n\\t\\tstate.capabilityDelegation = input?.capabilityDelegation || state.capabilityDelegation;\\r\\n\\t\\tstate.service = input?.service || state.service;\\r\\n\\t}\\r\\n\\r\\n\\treturn { state };\\r\\n}\\r\\n\"","// https://github.com/ArweaveTeam/SmartWeave/blob/4d09c66d832091805f583ba73e8da96cde2c0190/src/contract-interact.ts#L291\r\n// not exported by arweave-js, so re-written here\r\nexport async function createTx(\r\n\tcontractId: string,\r\n\tinput: any,\r\n\ttags?: { name: string; value: string }[] = [],\r\n\ttarget?: string = '',\r\n\twinstonQty?: string = '0',\r\n\treward?: string\r\n): Promise<Transaction> {\r\n\tconst options: Partial<CreateTransactionInterface> = {\r\n\t\tdata: Math.random().toString().slice(-4),\r\n\t\treward\r\n\t};\r\n\r\n\tif (target && target.length) {\r\n\t\toptions.target = target.toString();\r\n\t\tif (winstonQty && +winstonQty > 0) {\r\n\t\t\toptions.quantity = winstonQty.toString();\r\n\t\t}\r\n\t}\r\n\r\n\tconst interactionTx = await this.arweave.createTransaction(options, this.wallet);\r\n\r\n\tif (!input) {\r\n\t\tthrow new Error(`Input should be a truthy value: ${JSON.stringify(input)}`);\r\n\t}\r\n\r\n\tif (tags && tags.length) {\r\n\t\tfor (const tag of tags) {\r\n\t\t\tinteractionTx.addTag(tag.name.toString(), tag.value.toString());\r\n\t\t}\r\n\t}\r\n\tinteractionTx.addTag('App-Name', 'SmartWeaveAction');\r\n\tinteractionTx.addTag('App-Version', '0.3.0');\r\n\tinteractionTx.addTag('Contract', contractId);\r\n\tinteractionTx.addTag('Input', JSON.stringify(input));\r\n\r\n\ttry {\r\n\t\tawait this.arweave.transactions.sign(interactionTx, this.wallet);\r\n\t\tawait this.post(interactionTx);\r\n\t\tconsole.log({ interactionTx });\r\n\t\treturn interactionTx;\r\n\t} catch (error) {\r\n\t\tconsole.error(error);\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Updates an existing Areave Contract with a new state.ardagtxid\r\n */\r\nexport async function updateContract(ardagtxid: string): Promise<void> {\r\n\t// Create, Sign, Post\r\n\tconst tx = await this.createTx(this.contractId, { function: 'ArDagTx', ardagtxid });\r\n\tawait this.arweave.transactions.sign(tx, this.wallet);\r\n\tawait this.post(tx);\r\n}\r\n\r\n// smartweave without the post\r\n/**\r\n * Create a new contract from a contract source file and an initial state.\r\n * Returns the contract id.\r\n *\r\n * @param arweave       an Arweave client instance\r\n * @param wallet        a wallet private or public key\r\n * @param contractSrc   the contract source as string.\r\n * @param initState     the contract initial state, as a JSON string.\r\n */\r\nexport async function createContract(\r\n\tarweave: Arweave,\r\n\twallet: JWKInterface | 'use_wallet',\r\n\tcontractSrc: string,\r\n\tinitState: string,\r\n\treward?: string\r\n): Promise<string> {\r\n\tconst srcTx = await arweave.createTransaction({ data: contractSrc, reward }, wallet);\r\n\r\n\tsrcTx.addTag('App-Name', 'SmartWeaveContractSource');\r\n\tsrcTx.addTag('App-Version', '0.3.0');\r\n\tsrcTx.addTag('Content-Type', 'application/javascript');\r\n\r\n\tawait arweave.transactions.sign(srcTx, wallet);\r\n\r\n\tconst response = await this.post(srcTx);\r\n\r\n\tif (response.status === 200 || response.status === 208) {\r\n\t\tconst contractTxId = await this.createContractFromTx(arweave, wallet, srcTx.id, initState);\r\n\t\treturn { contractTxId, srcTxId: srcTx.id };\r\n\t} else {\r\n\t\tthrow new Error(\r\n\t\t\t`Unable to write Contract Source: ${JSON.stringify(response?.statusText ?? '')}`\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Create a new contract from an existing contract source tx, with an initial state.\r\n * Returns the contract id.\r\n *\r\n * @param arweave   an Arweave client instance\r\n * @param wallet    a wallet private or public key\r\n * @param srcTxId   the contract source Tx id.\r\n * @param state     the initial state, as a JSON string.\r\n * @param tags          an array of tags with name/value as objects.\r\n * @param target        if needed to send AR to an address, this is the target.\r\n * @param winstonQty    amount of winston to send to the target, if needed.\r\n */\r\nexport async function createContractFromTx(\r\n\tarweave: Arweave,\r\n\twallet: JWKInterface | 'use_wallet',\r\n\tsrcTxId: string,\r\n\tstate: string,\r\n\ttags: { name: string; value: string }[] = [],\r\n\ttarget: string = '',\r\n\twinstonQty: string = '',\r\n\treward?: string\r\n): Promise<string> {\r\n\tlet contractTX = await arweave.createTransaction({ data: state, reward }, wallet);\r\n\r\n\tif (target && winstonQty && target.length && +winstonQty > 0) {\r\n\t\tcontractTX = await arweave.createTransaction(\r\n\t\t\t{\r\n\t\t\t\tdata: state,\r\n\t\t\t\ttarget: target.toString(),\r\n\t\t\t\tquantity: winstonQty.toString(),\r\n\t\t\t\treward\r\n\t\t\t},\r\n\t\t\twallet\r\n\t\t);\r\n\t}\r\n\r\n\tif (tags && tags.length) {\r\n\t\tfor (const tag of tags) {\r\n\t\t\tcontractTX.addTag(tag.name.toString(), tag.value.toString());\r\n\t\t}\r\n\t}\r\n\tcontractTX.addTag('App-Name', 'SmartWeaveContract');\r\n\tcontractTX.addTag('App-Version', '0.3.0');\r\n\tcontractTX.addTag('Contract-Src', srcTxId);\r\n\tcontractTX.addTag('Content-Type', 'application/json');\r\n\r\n\tawait arweave.transactions.sign(contractTX, wallet);\r\n\r\n\tconst response = await this.post(contractTX);\r\n\r\n\tif (response.status === 200 || response.status === 208) {\r\n\t\treturn contractTX.id;\r\n\t} else {\r\n\t\tthrow new Error('Unable to write Contract Initial State');\r\n\t}\r\n}\r\n","import Arweave from 'arweave';\r\n\r\nlet arweave;\r\n\r\n// export async function generateWallet() {\r\n// \tlet wallet: {\r\n// \t\taddress: string;\r\n// \t\tjwk: JWKInterface;\r\n// \t} = { address: '', jwk: undefined };\r\n\r\n// \twallet.jwk = await arweave.wallets.generate();\r\n// \twallet.address = await arweave.wallets.getAddress(wallet.jwk);\r\n// \tawait triggerFaucet(wallet.address);\r\n// \treturn wallet;\r\n// }\r\n\r\nasync function triggerFaucet(address) {\r\n\tawait arweave.api.get(`/mint/${address}/1000000000000`);\r\n\tawait mine();\r\n}\r\n\r\nasync function mine() {\r\n\tawait arweave.api.get('mine');\r\n}\r\n\r\nexport async function setup({\r\n\tlocal,\r\n\twallet,\r\n\tserverUrl = null\r\n}: { local: boolean; serverUrl: string; wallet: handlers } = {}) {\r\n\tlet post; // Bundlr or arweave.transactions.post\r\n\r\n\tif (local && !serverUrl) serverUrl = 'http://localhost:1984';\r\n\tif (!local && !serverUrl) serverUrl = 'https://arweave.net:443';\r\n\r\n\tlet { host, port, protocol } = new URL(serverUrl);\r\n\r\n\thost = host.replace(`:${port}`, '') || 'localhost';\r\n\tport = port || 443;\r\n\tprotocol = protocol.replace(':', '');\r\n\r\n\tarweave = Arweave.init({\r\n\t\thost,\r\n\t\tport,\r\n\t\tprotocol,\r\n\t\ttimeout: 20000,\r\n\t\tlogging: false\r\n\t});\r\n\r\n\tconsole.log({ local, serverUrl, arweave });\r\n\r\n\tif (local) {\r\n\t\t// Save this buffer as an Arweave Contract Transaction\r\n\r\n\t\t// use testNet for testing\r\n\t\tconst address = await arweave.wallets.getAddress();\r\n\t\tawait triggerFaucet(address);\r\n\r\n\t\t// need to bind transactions.post to arweave.transactions as *this*\r\n\t\tconst doPost = arweave.transactions.post;\r\n\t\tconst p = doPost.bind(arweave.transactions);\r\n\t\tpost = async (tx) => {\r\n\t\t\tconst resp = await p(tx);\r\n\t\t\tawait mine();\r\n\t\t\t// logger.log(`Mined ${tx.id}`);\r\n\t\t\treturn resp;\r\n\t\t};\r\n\t} else {\r\n\t\t// use Bunldr for production\r\n\t\tpost = wallet.arweaveWalletAPI.dispatch; // need to have browser open to approve confirmation if > 100kb\r\n\t\tconsole.log('using Bundlr');\r\n\t}\r\n\r\n\treturn {\r\n\t\tarweave,\r\n\t\twallet: 'use_wallet',\r\n\t\tpost,\r\n\t\ttesting: {\r\n\t\t\ttriggerFaucet,\r\n\t\t\tmine\r\n\t\t}\r\n\t};\r\n}\r\n","// import type { JWKInterface } from 'arweave/node/lib/wallet';\r\n\r\nimport initialState from './contract/initial-state.json';\r\nimport contractSrc from './contract/contractSrc.js?raw';\r\n// import { base58btc as multibase58btc } from 'multiformats/bases/base58';\r\nimport {\r\n\tencodeURLSafe as base64URLfromBytes\r\n\t// decodeURLSafe as base64URLtoBytes\r\n} from '@stablelib/base64';\r\n\r\nimport { createTx, createContract, createContractFromTx } from './contractUtils';\r\nimport * as utils from './utils';\r\n\r\nexport async function init({ local, wallet }) {\r\n\tconsole.log({ local });\r\n\tconst { arweave, post, testing } = await utils.setup({ local, wallet });\r\n\r\n\treturn {\r\n\t\tarweave,\r\n\t\tpost,\r\n\t\ttesting,\r\n\t\twallet: 'use_wallet', // always use web wallet\r\n\t\tlocal,\r\n\t\tcreateDid,\r\n\t\tupdateDidDoc,\r\n\t\tupdateContract,\r\n\t\tcreateTx,\r\n\t\tcreateContract,\r\n\t\tcreateContractFromTx\r\n\t};\r\n}\r\n\r\nexport async function createDid({ RSAPublicKey, Ed25519PublicKey, options: { srcTx, local } }) {\r\n\t// validate srcTx is actually a valid arweave transaction on this network\r\n\tif (srcTx) {\r\n\t\ttry {\r\n\t\t\tconst { data } = await this.arweave.transactions.get(srcTx);\r\n\t\t} catch (error) {\r\n\t\t\tsrcTx = null;\r\n\t\t}\r\n\t}\r\n\r\n\tconst { contractTxId, srcTxId } = await this.createContract(\r\n\t\tthis.arweave,\r\n\t\tthis.wallet,\r\n\t\tcontractSrc,\r\n\t\tJSON.stringify(initialState)\r\n\t);\r\n\r\n\t// const tags = [{ name: 'DID-AR', value: 'True' }];\r\n\t// const contractTxId = await this.createContractFromTx(\r\n\t// \tthis.arweave,\r\n\t// \tthis.wallet,\r\n\t// \tsrcTxId,\r\n\t// \tJSON.stringify(initialState)\r\n\t// );\r\n\t// console.log('sign x1');\r\n\r\n\tconst did =\r\n\t\tthis.local || process.env.NODE_ENV === 'development'\r\n\t\t\t? `did:arlocal:${contractTxId}`\r\n\t\t\t: `did:ar:${contractTxId}`;\r\n\r\n\tconst verificationMethods = await generateVerificationMethods({\r\n\t\tdid,\r\n\t\tpublicKeys: [RSAPublicKey, Ed25519PublicKey]\r\n\t});\r\n\r\n\t// Update contract\r\n\tconst tx = await this.createTx(contractTxId, {\r\n\t\tfunction: 'update',\r\n\t\tid: did,\r\n\t\tverificationMethod: verificationMethods\r\n\t});\r\n\r\n\tif (!tx) throw new Error('no tx posted');\r\n\r\n\treturn { did, srcTx };\r\n}\r\nexport async function updateContract(contractTxId: string, props: object): Promise<void> {\r\n\tconst tx = await this.createTx(contractTxId, {\r\n\t\tfunction: 'update',\r\n\t\t...props\r\n\t});\r\n\tawait this.arweave.transactions.sign(tx, this.wallet);\r\n\tawait this.post(tx);\r\n}\r\n\r\n// export async function setUpWarp({ local }: { local: boolean } = {}) {\r\n// \tconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\n\r\n// \tconst { WarpFactory } = await import('warp-contracts'); // build process needs node version\r\n\r\n// \tlet warp =\r\n// \t\tlocal || process.env.NODE_ENV == 'development'\r\n// \t\t\t? WarpFactory.forLocal()\r\n// \t\t\t: WarpFactory.forMainnet();\r\n\r\n// \tif (warp.environment == 'local') {\r\n// \t\tconst walletAddress = await warp.arweave.wallets.getAddress();\r\n// \t\tawait warp.arweave.api.get(`/mint/${walletAddress}/1000000000000000`);\r\n// \t}\r\n// \treturn warp;\r\n// }\r\n\r\nexport async function updateDidDoc({\r\n\tdidDoc,\r\n\twarp,\r\n\toptions = { arweaveWallet, walletAddress, local }\r\n}) {\r\n\tconst contractTxId = didDoc.id.replace(/^did:ar(.*?):/, '');\r\n\r\n\treturn await this.updateContract(contractTxId, didDoc);\r\n}\r\n\r\n// export async function deploySrcContract({ warp, wallet = 'use_wallet' }) {\r\n// \tif (!warp) throw new Error('warp instance is required');\r\n\r\n// \tconst { srcTxId } = await warp.createContract.deploy({\r\n// \t\twallet,\r\n// \t\tinitState: JSON.stringify(initialState),\r\n// \t\tsrc: contractSrc\r\n// \t});\r\n\r\n// \tconst { srcTxId } = await ContractUtils.createContract(arweave, wallet, contractSrc, initState);\r\n// \tconsole.log({ srcTxId });\r\n// \treturn srcTxId;\r\n// }\r\n\r\n// export async function createDidAr({ warp, wallet, RSAPublicKey, Ed25519PublicKey, srcTx = null }) {\r\n// \tif (!warp) throw new Error('warp instance is required');\r\n\r\n// \t// validate srcTx is actually a valid arweave transaction on this network\r\n// \tif (srcTx) {\r\n// \t\ttry {\r\n// \t\t\tconst { data } = await warp.arweave.transactions.get(srcTx);\r\n// \t\t} catch (error) {\r\n// \t\t\tsrcTx = null;\r\n// \t\t}\r\n// \t}\r\n\r\n// \tconst srcTxId = srcTx || (await deploySrcContract({ warp, wallet }));\r\n\r\n// \tconst { contractTxId } = await warp.createContract.deployFromSourceTx({\r\n// \t\twallet,\r\n// \t\tinitState: JSON.stringify(initialState),\r\n// \t\tsrcTxId\r\n// \t});\r\n\r\n// \tconst did =\r\n// \t\twarp.environment == 'mainnet' ? `did:ar:${contractTxId}` : `did:arlocal:${contractTxId}`;\r\n\r\n// \t// use warp-contract to update the contract state\r\n// \tconst contract = warp.contract(contractTxId);\r\n// \tcontract.connect(wallet);\r\n\r\n// \tconst verificationMethods = await generateVerificationMethods({\r\n// \t\tdid,\r\n// \t\tpublicKeys: [RSAPublicKey, Ed25519PublicKey]\r\n// \t});\r\n\r\n// \tawait contract.writeInteraction({\r\n// \t\tfunction: 'update',\r\n// \t\tid: did,\r\n// \t\tverificationMethod: verificationMethods\r\n// \t});\r\n\r\n// \treturn { did, srcTx: srcTxId, contractTxId };\r\n// }\r\n\r\nexport async function generateVerificationMethods({ did, publicKeys }) {\r\n\tconst verificationMethods = [];\r\n\r\n\tfor (let i = 0; i < publicKeys.length; i++) {\r\n\t\tconst key = publicKeys[i];\r\n\t\tconst id = `${did}#key-${i}`;\r\n\r\n\t\tconst method = isRSAKey(key)\r\n\t\t\t? generateRSAVerificationMethod({ did, id, key })\r\n\t\t\t: generateEd25519VerificationMethod({ did, id, key });\r\n\t\tverificationMethods.push(method);\r\n\t}\r\n\r\n\treturn verificationMethods;\r\n}\r\n\r\nfunction generateRSAVerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: JWKInterface;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'RSA',\r\n\t\t\te: 'AQAB',\r\n\t\t\tn: key.n\r\n\t\t}\r\n\t};\r\n}\r\n\r\nexport function generateEd25519VerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: Uint8Array;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'OKP',\r\n\t\t\tcrv: 'Ed25519',\r\n\t\t\tx: base64URLfromBytes(new Uint8Array(key))\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// async function generateEd25519MultibaseVerificationMethod({\r\n// \tdid,\r\n// \tid,\r\n// \tkey\r\n// }: {\r\n// \tdid: string;\r\n// \tid: string;\r\n// \tkey: Uint8Array;\r\n// }) {\r\n// \treturn {\r\n// \t\tid,\r\n// \t\ttype: 'Ed25519VerificationKey2020',\r\n// \t\tcontroller: did,\r\n// \t\tpublicKeyMultibase: multibase58btc.encode(key)\r\n// \t};\r\n// }\r\n\r\nfunction isRSAKey(key: any): boolean {\r\n\treturn key.kty === 'RSA';\r\n}\r\n"],"names":["contractSrc","createTx","contractId","input","tags","target","winstonQty","reward","options","interactionTx","tag","error","createContract","arweave","wallet","initState","srcTx","response","_a","createContractFromTx","srcTxId","state","contractTX","triggerFaucet","address","mine","setup","local","serverUrl","post","host","port","protocol","Arweave","p","tx","resp","init","testing","utils.setup","createDid","updateDidDoc","updateContract","RSAPublicKey","Ed25519PublicKey","data","contractTxId","initialState","did","verificationMethods","generateVerificationMethods","props","didDoc","warp","publicKeys","i","key","id","method","isRSAKey","generateRSAVerificationMethod","generateEd25519VerificationMethod","base64URLfromBytes"],"mappings":"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"}
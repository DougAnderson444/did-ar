{"version":3,"mappings":"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","names":["contractSrc","createDid","setUpWarp","options","createDidAr","__vitePreload","local","WarpFactory","walletAddress","warp","wallet","contract","didDoc","deploySrcContract","initialState","srcTxId","srcTx","did","contractTxId","generateVerificationMethods","RSAPublicKey","Ed25519PublicKey","verificationMethods","i","publicKeys","key","id","method","isRSAKey","generateRSAVerificationMethod","generateEd25519VerificationMethod","base64URLfromBytes"],"sources":["../../../../../../src/lib/contract/contractSrc.js","../../../../../../src/lib/didar.ts"],"sourcesContent":["export default \"export async function handle(state, action) {\\r\\n\\tconst input = action.input;\\r\\n\\tconst caller = action.caller;\\r\\n\\r\\n\\tif (caller !== SmartWeave.contract.owner) {\\r\\n\\t\\treturn { state };\\r\\n\\t}\\r\\n\\r\\n\\tif (input.function === 'update') {\\r\\n\\t\\t// prevent people from accidentally updating their id\\r\\n\\t\\tif (!state.id) {\\r\\n\\t\\t\\tif (!input.id.startsWith('did:ar')) {\\r\\n\\t\\t\\t\\tthrow new ContractError('Invalid ID');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.id = input.id;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (action.input.verificationMethod) {\\r\\n\\t\\t\\t// verify that action.input.verificationMethod is an array\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\t!Array.isArray(action.input.verificationMethod) ||\\r\\n\\t\\t\\t\\taction.input.verificationMethod.length == 0\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\tthrow new ContractError('verificationMethod must be an array with at least one method');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.verificationMethod = action.input.verificationMethod;\\r\\n\\t\\t}\\r\\n\\t\\tstate.authentication = action.input?.authentication || state.authentication;\\r\\n\\t\\tstate.assertionMethod = action.input?.assertionMethod || state.assertionMethod;\\r\\n\\t\\tstate.keyAgreement = action.input?.keyAgreement || state.keyAgreement;\\r\\n\\t\\tstate.capabilityInvocation = action.input?.capabilityInvocation || state.capabilityInvocation;\\r\\n\\t\\tstate.capabilityDelegation = action.input?.capabilityDelegation || state.capabilityDelegation;\\r\\n\\t\\tstate.service = action.input?.service || state.service;\\r\\n\\t}\\r\\n\\r\\n\\treturn { state };\\r\\n}\\r\\n\"","// import * as WarpSdk from 'warp-contracts';\r\n// import type { JWKInterface } from 'arweave/node/lib/wallet';\r\n\r\nimport initialState from './contract/initial-state.json';\r\nimport contractSrc from './contract/contractSrc.js?raw';\r\n// import { base58btc as multibase58btc } from 'multiformats/bases/base58';\r\nimport {\r\n\tencodeURLSafe as base64URLfromBytes\r\n\t// decodeURLSafe as base64URLtoBytes\r\n} from '@stablelib/base64';\r\n\r\nexport async function createDid({\r\n\tRSAPublicKey,\r\n\tEd25519PublicKey,\r\n\toptions = { arweaveWallet, walletAddress, srcTx, local }\r\n}) {\r\n\tconst warp = await setUpWarp({ walletAddress: options?.walletAddress, local: options?.local });\r\n\r\n\tconst { did, srcTx, contractTxId } = await createDidAr({\r\n\t\tsrcTx: options?.srcTx,\r\n\t\twarp,\r\n\t\twallet: options?.arweaveWallet || 'use_wallet',\r\n\t\tRSAPublicKey,\r\n\t\tEd25519PublicKey\r\n\t});\r\n\treturn { did, srcTx };\r\n}\r\n\r\nexport async function setUpWarp({ local }: { local: boolean } = {}) {\r\n\t// const { WarpFactory } = await import('warp-contracts/web');\r\n\r\n\tconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\n\r\n\tconst { WarpFactory } = await import('warp-contracts'); // build process needs node version\r\n\r\n\tlet warp =\r\n\t\tlocal || process.env.NODE_ENV == 'development'\r\n\t\t\t? WarpFactory.forLocal()\r\n\t\t\t: WarpFactory.forMainnet();\r\n\r\n\tif (warp.environment == 'local') {\r\n\t\tconst walletAddress = await warp.arweave.wallets.getAddress();\r\n\t\tawait warp.arweave.api.get(`/mint/${walletAddress}/1000000000000000`);\r\n\t}\r\n\treturn warp;\r\n}\r\n\r\nexport async function updateDidDoc({ didDoc, options = { arweaveWallet, walletAddress } }) {\r\n\tconst warp = await setUpWarp({ walletAddress: options?.walletAddress });\r\n\tconst wallet = options?.arweaveWallet || 'use_wallet';\r\n\tconst contract = warp.contract(didDoc.id);\r\n\tcontract.connect(wallet);\r\n\tawait contract.writeInteraction({\r\n\t\tfunction: 'update',\r\n\t\t...didDoc\r\n\t});\r\n}\r\n\r\nexport async function deploySrcContract({ warp, wallet = 'use_wallet' }) {\r\n\tif (!warp) throw new Error('warp instance is required');\r\n\r\n\tconst { srcTxId } = await warp.createContract.deploy({\r\n\t\twallet,\r\n\t\tinitState: JSON.stringify(initialState),\r\n\t\tsrc: contractSrc\r\n\t});\r\n\tconsole.log({ srcTxId });\r\n\treturn srcTxId;\r\n}\r\n\r\nexport async function createDidAr({ warp, wallet, RSAPublicKey, Ed25519PublicKey, srcTx = null }) {\r\n\tif (!warp) throw new Error('warp instance is required');\r\n\r\n\t// validate srcTx is actually a valid arweave transaction on this network\r\n\tif (srcTx) {\r\n\t\ttry {\r\n\t\t\tconst { data } = await warp.arweave.transactions.get(srcTx);\r\n\t\t} catch (error) {\r\n\t\t\tsrcTx = null;\r\n\t\t}\r\n\t}\r\n\r\n\tconst srcTxId = srcTx || (await deploySrcContract({ warp, wallet }));\r\n\r\n\tconst { contractTxId } = await warp.createContract.deployFromSourceTx({\r\n\t\twallet,\r\n\t\tinitState: JSON.stringify(initialState),\r\n\t\tsrcTxId\r\n\t});\r\n\r\n\tconst did =\r\n\t\twarp.environment == 'mainnet' ? `did:ar:${contractTxId}` : `did:arlocal:${contractTxId}`;\r\n\r\n\t// use warp-contract to update the contract state\r\n\tconst contract = warp.contract(contractTxId);\r\n\tcontract.connect(wallet);\r\n\r\n\tconst verificationMethods = await generateVerificationMethods({\r\n\t\tdid,\r\n\t\tpublicKeys: [RSAPublicKey, Ed25519PublicKey]\r\n\t});\r\n\r\n\tawait contract.writeInteraction({\r\n\t\tfunction: 'update',\r\n\t\tid: did,\r\n\t\tverificationMethod: verificationMethods\r\n\t});\r\n\r\n\treturn { did, srcTx: srcTxId, contractTxId };\r\n}\r\n\r\nexport async function generateVerificationMethods({ did, publicKeys }) {\r\n\tconst verificationMethods = [];\r\n\r\n\tfor (let i = 0; i < publicKeys.length; i++) {\r\n\t\tconst key = publicKeys[i];\r\n\t\tconst id = `${did}#key-${i}`;\r\n\r\n\t\tconst method = isRSAKey(key)\r\n\t\t\t? generateRSAVerificationMethod({ did, id, key })\r\n\t\t\t: generateEd25519VerificationMethod({ did, id, key });\r\n\t\tverificationMethods.push(method);\r\n\t}\r\n\r\n\treturn verificationMethods;\r\n}\r\n\r\nfunction generateRSAVerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: JWKInterface;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'RSA',\r\n\t\t\te: 'AQAB',\r\n\t\t\tn: key.n\r\n\t\t}\r\n\t};\r\n}\r\n\r\nexport function generateEd25519VerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: Uint8Array;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'OKP',\r\n\t\t\tcrv: 'Ed25519',\r\n\t\t\tx: base64URLfromBytes(new Uint8Array(key))\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// async function generateEd25519MultibaseVerificationMethod({\r\n// \tdid,\r\n// \tid,\r\n// \tkey\r\n// }: {\r\n// \tdid: string;\r\n// \tid: string;\r\n// \tkey: Uint8Array;\r\n// }) {\r\n// \treturn {\r\n// \t\tid,\r\n// \t\ttype: 'Ed25519VerificationKey2020',\r\n// \t\tcontroller: did,\r\n// \t\tpublicKeyMultibase: multibase58btc.encode(key)\r\n// \t};\r\n// }\r\n\r\nfunction isRSAKey(key: any): boolean {\r\n\treturn key.kty === 'RSA';\r\n}\r\n"],"file":"_app/immutable/chunks/didar-31853a51.js"}
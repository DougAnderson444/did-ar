{"version":3,"mappings":"iDAAA,MAAMA,EAAW,8CAGjB,eAAsBC,EACrBC,EACA,CAAE,cAAa,EAA6C,GAC3D,CACD,MAAMC,EAAe,MAAMC,EAAK,CAAE,cAAc,GAC1CC,EAAgB,MAAMF,EAAa,YAAYD,CAAQ,EACvDI,EAAM,MAAMH,EAAa,WAAWE,CAAa,EAEhD,OADQ,MAAMF,EAAa,WAAWG,CAAG,CAEjD,CAIsB,iBAAK,CAAE,QAAO,cAAa,EAAI,CAAE,MAAO,GAAO,aAAc,IAAM,CAExF,KAAM,CAAE,aAAgB,QAAMC,aAAO,2NAG9B,OACN,KAHYC,EAAQC,EAAY,SAASC,CAAY,EAAID,EAAY,WAAWC,CAAY,EAI5F,cACA,aACA,aAEF,CAEA,eAAsBC,EAAYT,EAAmC,CAM7D,OALW,MAAM,KAAK,KAAK,SAASF,CAAQ,EAAE,UAAU,GAAG,YAAY,MAG/C,QAAQE,EAGxC,CAEA,eAAsBU,EAAWP,EAAwC,CAGjE,MADK,WADM,MAAM,KAAK,KAAK,SAASA,CAAa,EAAE,UAAU,GAAG,YAAY,MACpD,QAAQ,UAAU,eAElD,CAEA,eAAsBQ,EAAWP,EAA8B,CAE9D,MAAMQ,EAAaR,EAAI,QAAQ,UAAW,EAAE,EAErC,OADc,MAAM,KAAK,KAAK,SAASQ,CAAU,EAAE,UAAU,GAAG,YAAY,KAEpF","names":["REGISTRY","arnsResolver","arnsName","arnsInstance","init","antContractId","did","__vitePreload","local","WarpFactory","CacheOptions","resolveARNS","resolveANT","resolveDID","identifier"],"sources":["../../../../../../src/lib/arnsResolver.ts"],"sourcesContent":["const REGISTRY = 'bLAgYxAdX2Ry-nt6aH2ixgvJXbpsEYm28NgJgyqfs-U';\r\n\r\n// if you're only doing a single resolution, use this\r\nexport async function arnsResolver(\r\n\tarnsName: string,\r\n\t{ CacheOptions }: { CacheOptions: { inMemory: boolean } } = {}\r\n) {\r\n\tconst arnsInstance = await init({ CacheOptions });\r\n\tconst antContractId = await arnsInstance.resolveARNS(arnsName);\r\n\tconst did = await arnsInstance.resolveANT(antContractId);\r\n\tconst didDoc = await arnsInstance.resolveDID(did);\r\n\treturn didDoc;\r\n}\r\n\r\n// if resolveing lots of names, use this\r\n// it keeps the warp instance around\r\nexport async function init({ local, CacheOptions } = { local: false, CacheOptions: {} }) {\r\n\t// make warp\r\n\tconst { WarpFactory } = await import('warp-contracts');\r\n\tconst warp = local ? WarpFactory.forLocal(CacheOptions) : WarpFactory.forMainnet(CacheOptions);\r\n\r\n\treturn {\r\n\t\twarp,\r\n\t\tresolveARNS,\r\n\t\tresolveANT,\r\n\t\tresolveDID\r\n\t};\r\n}\r\n\r\nexport async function resolveARNS(arnsName: string): Promise<string> {\r\n\tconst registry = (await this.warp.contract(REGISTRY).readState()).cachedValue.state; // lookup doc\r\n\r\n\t// match arnsName as key in registry and return value\r\n\tconst antContractId = registry.records[arnsName];\r\n\r\n\treturn antContractId;\r\n}\r\n\r\nexport async function resolveANT(antContractId: string): Promise<string> {\r\n\tconst registry = (await this.warp.contract(antContractId).readState()).cachedValue.state; // lookup doc\r\n\tconst did = `did:ar:${registry.records['did-ar'].transactionId}`;\r\n\treturn did;\r\n}\r\n\r\nexport async function resolveDID(did: string): Promise<string> {\r\n\t// split did:ar:identitifier by the part fater did:ar: into \"did:ar\" and \"identitifier\"\r\n\tconst identifier = did.replace('did:ar:', '');\r\n\tconst didDocument = (await this.warp.contract(identifier).readState()).cachedValue.state;\r\n\treturn didDocument;\r\n}\r\n"],"file":"_app/immutable/chunks/arnsResolver-6028f13d.js"}
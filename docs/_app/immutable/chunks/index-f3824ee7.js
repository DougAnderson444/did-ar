var E={exports:{}};/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */(function(s,e){(function(t){var n;if(s.exports=t(),n=!0,!n){var c=window.Cookies,r=window.Cookies=t();r.noConflict=function(){return window.Cookies=c,r}}})(function(){function t(){for(var r=0,o={};r<arguments.length;r++){var d=arguments[r];for(var h in d)o[h]=d[h]}return o}function n(r){return r.replace(/(%[0-9A-Z]{2})+/g,decodeURIComponent)}function c(r){function o(){}function d(a,u,i){if(!(typeof document>"u")){i=t({path:"/"},o.defaults,i),typeof i.expires=="number"&&(i.expires=new Date(new Date*1+i.expires*864e5)),i.expires=i.expires?i.expires.toUTCString():"";try{var l=JSON.stringify(u);/^[\{\[]/.test(l)&&(u=l)}catch{}u=r.write?r.write(u,a):encodeURIComponent(String(u)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent),a=encodeURIComponent(String(a)).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/[\(\)]/g,escape);var p="";for(var w in i)!i[w]||(p+="; "+w,i[w]!==!0&&(p+="="+i[w].split(";")[0]));return document.cookie=a+"="+u+p}}function h(a,u){if(!(typeof document>"u")){for(var i={},l=document.cookie?document.cookie.split("; "):[],p=0;p<l.length;p++){var w=l[p].split("="),f=w.slice(1).join("=");!u&&f.charAt(0)==='"'&&(f=f.slice(1,-1));try{var m=n(w[0]);if(f=(r.read||r)(f,m)||n(f),u)try{f=JSON.parse(f)}catch{}if(i[m]=f,a===m)break}catch{}}return a?i[a]:i}}return o.set=d,o.get=function(a){return h(a,!1)},o.getJSON=function(a){return h(a,!0)},o.remove=function(a,u){d(a,"",t(u,{expires:-1}))},o.defaults={},o.withConverter=c,o}return c(function(){})})})(E);const g=E.exports,U=365,C=L(),T=!!C,F=C?"None":"Lax";function L(){try{return!Boolean(window.top.location.href)}catch{return!0}}class O{constructor({ttl:e=U,secure:t=T,sameSite:n=F}={}){return this.ttl=e,this.secure=t,this.sameSite=n,(async()=>this)()}async get(e){const t=g.get(e);return typeof t=="string"?t:void 0}async set(e,t){g.set(e,t,this._constructCookieParams())}async remove(e){g.remove(e,this._constructCookieParams())}_constructCookieParams(){return{expires:this.ttl,secure:this.secure,sameSite:this.sameSite}}}class A{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbp=new Promise((n,c)=>{const r=indexedDB.open(e,1);r.onerror=()=>c(r.error),r.onsuccess=()=>n(r.result),r.onupgradeneeded=()=>{r.result.createObjectStore(t)}})}_withIDBStore(e,t){return this._dbp.then(n=>new Promise((c,r)=>{const o=n.transaction(this.storeName,e);o.oncomplete=()=>c(),o.onabort=o.onerror=()=>r(o.error),t(o.objectStore(this.storeName))}))}}let y;function _(){return y||(y=new A),y}function P(s,e=_()){let t;return e._withIDBStore("readonly",n=>{t=n.get(s)}).then(()=>t.result)}function N(s,e,t=_()){return t._withIDBStore("readwrite",n=>{n.put(e,s)})}function j(s,e=_()){return e._withIDBStore("readwrite",t=>{t.delete(s)})}const M="ImmortalDB",$="key-value-pairs";class q{constructor(e=M,t=$){return this.store=new A(e,t),(async()=>{try{await this.store._dbp}catch(n){if(n.name==="SecurityError")return null;throw n}return this})()}async get(e){const t=await P(e,this.store);return typeof t=="string"?t:void 0}async set(e,t){await N(e,t,this.store)}async remove(e){await j(e,this.store)}}class x{constructor(e){return this.store=e,(async()=>this)()}async get(e){const t=this.store.getItem(e);return typeof t=="string"?t:void 0}async set(e,t){this.store.setItem(e,t)}async remove(e){this.store.removeItem(e)}}class J extends x{constructor(){super(window.localStorage)}}class G extends x{constructor(){super(window.sessionStorage)}}const S=console.log,I="_immortal|",R=typeof window<"u",v=[O];try{R&&window.indexedDB&&v.push(q)}catch{}try{R&&window.localStorage&&v.push(J)}catch{}function D(s,e,t=null){return e in s?s[e]:t}function K(s){const e=new Map;let t=s.slice();for(const n of t){let c=0;for(const r of t)n===r&&(c+=1);c>0&&(e.set(n,c),t=t.filter(r=>r!==n))}return e}class W{constructor(e=v){this.stores=[],this.onReady=(async()=>{this.stores=(await Promise.all(e.map(async t=>{if(typeof t=="object")return t;try{return await new t}catch{return null}}))).filter(Boolean)})()}async get(e,t=null){await this.onReady;const n=`${I}${e}`,c=await Promise.all(this.stores.map(async i=>{try{return await i.get(n)}catch(l){S(l)}})),r=Array.from(K(c).entries());r.sort((i,l)=>i[1]<=l[1]);let o;const[d,h]=D(r,0,[void 0,0]),[a,u]=D(r,1,[void 0,0]);return h>u||h===u&&d!==void 0?o=d:o=a,o!==void 0?(await this.set(e,o),o):(await this.remove(e),t)}async set(e,t){return await this.onReady,e=`${I}${e}`,await Promise.all(this.stores.map(async n=>{try{await n.set(e,t)}catch(c){S(c)}})),t}async remove(e){await this.onReady,e=`${I}${e}`,await Promise.all(this.stores.map(async t=>{try{await t.remove(e)}catch(n){S(n)}}))}}const V=new W;export{O as CookieStore,I as DEFAULT_KEY_PREFIX,v as DEFAULT_STORES,V as ImmortalDB,W as ImmortalStorage,q as IndexedDbStore,J as LocalStorageStore,G as SessionStorageStore};

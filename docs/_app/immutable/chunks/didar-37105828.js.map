{"version":3,"mappings":"kYAAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECiBf,eAAsBC,EACrB,CAAE,QAAO,SAAS,cAA4D,CAC7E,MAAO,GACP,OAAQ,YACT,EACiB,CACjB,KAAM,CAAE,aAAgB,QAAMC,aAAO,0KAC/BC,EAAOC,EAAQC,EAAY,SAAS,EAAIA,EAAY,aAElD,mBAAI,mBAAoBF,EAAK,WAAW,EAEzC,CACN,OACA,SACA,SACA,OACA,SAEF,CAEA,eAAsBG,EAAO,CAAE,eAAc,mBAAkB,QAAQ,MAAQ,CAC9E,GAAI,CAAC,KAAK,MAAQ,CAAC,KAAK,OAAc,UAAI,MAAM,2CAA2C,EAY3F,MAAMC,EAAO,CAAC,CAAE,KAAM,SAAU,MAAO,OAAQ,EAEzC,CAAE,eAAc,WAAYC,EAC/B,MAAM,KAAK,KAAK,eAAe,mBAAmB,CAClD,OAAQ,KAAK,OACb,UAAW,KAAK,UAAUC,CAAY,EACtC,QAASD,EACT,MACC,GACD,MAAM,KAAK,KAAK,eAAe,OAAO,CACtC,OAAQ,KAAK,OACb,UAAW,KAAK,UAAUC,CAAY,EACtC,IAAKT,EACL,OACC,EAEEU,EACL,KAAK,KAAK,aAAe,UAAY,UAAUC,IAAiB,eAAeA,IAE1EC,EAAsB,MAAMC,EAA4B,CAC7D,MACA,WAAY,CAACC,EAAcC,CAAgB,EAC3C,EAED,aAAM,KAAK,OAAO,CACjB,GAAIL,EACJ,mBAAoBE,EACpB,EAEMF,CACR,CAKA,eAAsBM,EAAO,CAAE,QAAOC,GAAQ,CAC7C,GAAI,CAAC,KAAK,MAAQ,CAAC,KAAK,OAAc,UAAI,MAAM,2CAA2C,EAE3F,MAAMN,EAAeO,EAAG,QAAQ,gBAAiB,EAAE,EAC7CC,EAAW,KAAK,KAAK,SAASR,CAAY,EACvCQ,UAAQ,KAAK,MAAM,EAC5B,MAAMA,EAAS,iBAAiB,CAC/B,GAAGF,EACH,KACA,SAAU,SACV,CACF,CAEA,eAAsBG,EAAKV,EAAK,CAC/B,GAAI,CAAC,KAAK,MAAQ,CAAC,KAAK,OAAc,UAAI,MAAM,2CAA2C,EAE3F,MAAMC,EAAeD,EAAI,QAAQ,gBAAiB,EAAE,EAG7C,OADS,MADC,KAAK,KAAK,SAASC,CAAY,EACjB,aAAa,YAAY,KAEzD,CAEA,eAAsBE,EAA4B,CAAE,MAAK,cAAc,CACtE,MAAMD,EAAsB,GAE5B,QAAS,EAAI,EAAG,EAAIS,EAAW,OAAQ,IAAK,CAC3C,MAAMC,EAAMD,EAAW,GACjBH,EAAK,GAAGR,SAAW,IAEnBa,EAASC,EAASF,CAAG,EACxBG,EAA8B,CAAE,MAAK,KAAI,KAAK,GAC9CC,EAAkC,CAAE,MAAK,KAAI,MAAK,EACrDd,EAAoB,KAAKW,CAAM,CAChC,CAEO,QACR,CAEA,SAASE,EAA8B,CACtC,MACA,KACA,KACD,EAIG,CACK,OACN,KACA,KAAM,iBACN,WAAYf,EACZ,aAAc,CACb,IAAK,MACL,EAAG,OACH,EAAGY,EAAI,CACR,EAEF,CAEO,SAASI,EAAkC,CACjD,MACA,KACA,KACD,EAIG,CACK,OACN,KACA,KAAM,iBACN,WAAYhB,EACZ,aAAc,CACb,IAAK,MACL,IAAK,UACL,EAAGiB,EAAmB,IAAI,WAAWL,CAAG,CAAC,CAC1C,EAEF,CAmBA,SAASE,EAASF,EAAmB,CACpC,OAAOA,EAAI,MAAQ,KACpB","names":["contractSrc","init","__vitePreload","warp","local","WarpFactory","create","tags","srcTx","initialState","did","contractTxId","verificationMethods","generateVerificationMethods","RSAPublicKey","Ed25519PublicKey","update","rest","id","contract","read","publicKeys","key","method","isRSAKey","generateRSAVerificationMethod","generateEd25519VerificationMethod","base64URLfromBytes"],"sources":["../../../../../../src/lib/contract/contractSrc.js","../../../../../../src/lib/didar.ts"],"sourcesContent":["export default \"export async function handle(state, action) {\\r\\n\\tconst input = action.input;\\r\\n\\tconst caller = action.caller;\\r\\n\\r\\n\\tif (caller !== SmartWeave.contract.owner) {\\r\\n\\t\\treturn { state };\\r\\n\\t}\\r\\n\\r\\n\\tif (input.function === 'update') {\\r\\n\\t\\tif (!state.id) {\\r\\n\\t\\t\\tif (!input?.id?.startsWith('did:ar')) {\\r\\n\\t\\t\\t\\tthrow new ContractError('Invalid ID');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.id = input?.id || state.id;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (input.verificationMethod) {\\r\\n\\t\\t\\tif (!Array.isArray(input.verificationMethod) || input.verificationMethod.length === 0) {\\r\\n\\t\\t\\t\\tthrow new ContractError('verificationMethod must be an array with at least one method');\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tstate.verificationMethod = input.verificationMethod;\\r\\n\\t\\t}\\r\\n\\t\\tstate.authentication = input?.authentication || state.authentication;\\r\\n\\t\\tstate.assertionMethod = input?.assertionMethod || state.assertionMethod;\\r\\n\\t\\tstate.keyAgreement = input?.keyAgreement || state.keyAgreement;\\r\\n\\t\\tstate.capabilityInvocation = input?.capabilityInvocation || state.capabilityInvocation;\\r\\n\\t\\tstate.capabilityDelegation = input?.capabilityDelegation || state.capabilityDelegation;\\r\\n\\t\\tstate.service = input?.service || state.service;\\r\\n\\t}\\r\\n\\r\\n\\treturn { state };\\r\\n}\\r\\n\"","import initialState from './contract/initial-state.json';\r\nimport contractSrc from './contract/contractSrc.js?raw';\r\nimport {\r\n\tencodeURLSafe as base64URLfromBytes\r\n\t// decodeURLSafe as base64URLtoBytes\r\n} from '@stablelib/base64';\r\n\r\n// import { base58btc as multibase58btc } from 'multiformats/bases/base58';\r\n\r\nexport interface DIDAr {\r\n\twarp: WarpFactory;\r\n\twallet: JWKInterface | 'use_wallet';\r\n\tcreate: Function;\r\n\tread: Function;\r\n\tupdate: Function;\r\n}\r\n\r\nexport async function init(\r\n\t{ local, wallet = 'use_wallet' }: { local: boolean; wallet?: 'use_wallet' } = {\r\n\t\tlocal: false,\r\n\t\twallet: 'use_wallet'\r\n\t}\r\n): Promise<DIDAr> {\r\n\tconst { WarpFactory } = await import('warp-contracts');\r\n\tconst warp = local ? WarpFactory.forLocal() : WarpFactory.forMainnet();\r\n\r\n\tconsole.log('warp.environment', warp.environment);\r\n\r\n\treturn {\r\n\t\twarp,\r\n\t\twallet,\r\n\t\tcreate,\r\n\t\tread,\r\n\t\tupdate\r\n\t};\r\n}\r\n\r\nexport async function create({ RSAPublicKey, Ed25519PublicKey, srcTx = null }) {\r\n\tif (!this.warp || !this.wallet) throw new Error('warp and wallet required in parent object');\r\n\r\n\t// validate srcTx is actually a valid arweave transaction on this network\r\n\t// can't use with warp contracts, need get search for it using arql/ardb tags\r\n\t// if (srcTx) {\r\n\t// \ttry {\r\n\t// \t\tconst { data } = await this.warp.arweave.transactions.get(srcTx);\r\n\t// \t} catch (error) {\r\n\t// \t\tsrcTx = null;\r\n\t// \t}\r\n\t// }\r\n\r\n\tconst tags = [{ name: 'DID-AR', value: 'true' }];\r\n\r\n\tconst { contractTxId, srcTxId } = srcTx\r\n\t\t? await this.warp.createContract.deployFromSourceTx({\r\n\t\t\t\twallet: this.wallet,\r\n\t\t\t\tinitState: JSON.stringify(initialState),\r\n\t\t\t\tsrcTxId: srcTx,\r\n\t\t\t\ttags\r\n\t\t  })\r\n\t\t: await this.warp.createContract.deploy({\r\n\t\t\t\twallet: this.wallet,\r\n\t\t\t\tinitState: JSON.stringify(initialState),\r\n\t\t\t\tsrc: contractSrc,\r\n\t\t\t\ttags\r\n\t\t  });\r\n\r\n\tconst did =\r\n\t\tthis.warp.environment == 'mainnet' ? `did:ar:${contractTxId}` : `did:arlocal:${contractTxId}`;\r\n\r\n\tconst verificationMethods = await generateVerificationMethods({\r\n\t\tdid,\r\n\t\tpublicKeys: [RSAPublicKey, Ed25519PublicKey]\r\n\t});\r\n\r\n\tawait this.update({\r\n\t\tid: did,\r\n\t\tverificationMethod: verificationMethods\r\n\t});\r\n\r\n\treturn did; // { did, srcTx: srcTxId };\r\n}\r\n\r\n/**\r\n * Pass in a Partial DID Doc with at least an id to get the contractTxId\r\n */\r\nexport async function update({ id, ...rest }) {\r\n\tif (!this.warp || !this.wallet) throw new Error('warp and wallet required in parent object');\r\n\r\n\tconst contractTxId = id.replace(/^did:ar(.*?):/, '');\r\n\tconst contract = this.warp.contract(contractTxId);\r\n\tcontract.connect(this.wallet);\r\n\tawait contract.writeInteraction({\r\n\t\t...rest,\r\n\t\tid,\r\n\t\tfunction: 'update'\r\n\t});\r\n}\r\n\r\nexport async function read(did) {\r\n\tif (!this.warp || !this.wallet) throw new Error('warp and wallet required in parent object');\r\n\r\n\tconst contractTxId = did.replace(/^did:ar(.*?):/, '');\r\n\tconst contract = this.warp.contract(contractTxId);\r\n\tconst didDoc = (await contract.readState()).cachedValue.state;\r\n\treturn didDoc;\r\n}\r\n\r\nexport async function generateVerificationMethods({ did, publicKeys }) {\r\n\tconst verificationMethods = [];\r\n\r\n\tfor (let i = 0; i < publicKeys.length; i++) {\r\n\t\tconst key = publicKeys[i];\r\n\t\tconst id = `${did}#key-${i}`;\r\n\r\n\t\tconst method = isRSAKey(key)\r\n\t\t\t? generateRSAVerificationMethod({ did, id, key })\r\n\t\t\t: generateEd25519VerificationMethod({ did, id, key });\r\n\t\tverificationMethods.push(method);\r\n\t}\r\n\r\n\treturn verificationMethods;\r\n}\r\n\r\nfunction generateRSAVerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: JWKInterface;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'RSA',\r\n\t\t\te: 'AQAB',\r\n\t\t\tn: key.n\r\n\t\t}\r\n\t};\r\n}\r\n\r\nexport function generateEd25519VerificationMethod({\r\n\tdid,\r\n\tid,\r\n\tkey\r\n}: {\r\n\tdid: string;\r\n\tid: string;\r\n\tkey: Uint8Array;\r\n}) {\r\n\treturn {\r\n\t\tid,\r\n\t\ttype: 'JsonWebKey2020',\r\n\t\tcontroller: did,\r\n\t\tpublicKeyJwk: {\r\n\t\t\tkty: 'OKP',\r\n\t\t\tcrv: 'Ed25519',\r\n\t\t\tx: base64URLfromBytes(new Uint8Array(key))\r\n\t\t}\r\n\t};\r\n}\r\n\r\n// async function generateEd25519MultibaseVerificationMethod({\r\n// \tdid,\r\n// \tid,\r\n// \tkey\r\n// }: {\r\n// \tdid: string;\r\n// \tid: string;\r\n// \tkey: Uint8Array;\r\n// }) {\r\n// \treturn {\r\n// \t\tid,\r\n// \t\ttype: 'Ed25519VerificationKey2020',\r\n// \t\tcontroller: did,\r\n// \t\tpublicKeyMultibase: multibase58btc.encode(key)\r\n// \t};\r\n// }\r\n\r\nfunction isRSAKey(key: any): boolean {\r\n\treturn key.kty === 'RSA';\r\n}\r\n"],"file":"_app/immutable/chunks/didar-37105828.js"}